import { createRequire as e } from "module";
var t = {
  44914: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            Object.defineProperty(e, n, {
              enumerable: true,
              get: function () {
                return t[r];
              },
            });
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          }
        : function (e, t) {
            e["default"] = t;
          });
    var s =
      (this && this.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null) for (var r in e) if (r !== "default" && Object.hasOwnProperty.call(e, r)) n(t, e, r);
        o(t, e);
        return t;
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.issue = t.issueCommand = void 0;
    const i = s(r(70857));
    const a = r(30302);
    function issueCommand(e, t, r) {
      const n = new Command(e, t, r);
      process.stdout.write(n.toString() + i.EOL);
    }
    t.issueCommand = issueCommand;
    function issue(e, t = "") {
      issueCommand(e, {}, t);
    }
    t.issue = issue;
    const A = "::";
    class Command {
      constructor(e, t, r) {
        if (!e) {
          e = "missing.command";
        }
        this.command = e;
        this.properties = t;
        this.message = r;
      }
      toString() {
        let e = A + this.command;
        if (this.properties && Object.keys(this.properties).length > 0) {
          e += " ";
          let t = true;
          for (const r in this.properties) {
            if (this.properties.hasOwnProperty(r)) {
              const n = this.properties[r];
              if (n) {
                if (t) {
                  t = false;
                } else {
                  e += ",";
                }
                e += `${r}=${escapeProperty(n)}`;
              }
            }
          }
        }
        e += `${A}${escapeData(this.message)}`;
        return e;
      }
    }
    function escapeData(e) {
      return a.toCommandValue(e).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
    }
    function escapeProperty(e) {
      return a.toCommandValue(e).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
    }
  },
  37484: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            Object.defineProperty(e, n, {
              enumerable: true,
              get: function () {
                return t[r];
              },
            });
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          }
        : function (e, t) {
            e["default"] = t;
          });
    var s =
      (this && this.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null) for (var r in e) if (r !== "default" && Object.hasOwnProperty.call(e, r)) n(t, e, r);
        o(t, e);
        return t;
      };
    var i =
      (this && this.__awaiter) ||
      function (e, t, r, n) {
        function adopt(e) {
          return e instanceof r
            ? e
            : new r(function (t) {
                t(e);
              });
        }
        return new (r || (r = Promise))(function (r, o) {
          function fulfilled(e) {
            try {
              step(n.next(e));
            } catch (e) {
              o(e);
            }
          }
          function rejected(e) {
            try {
              step(n["throw"](e));
            } catch (e) {
              o(e);
            }
          }
          function step(e) {
            e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
          }
          step((n = n.apply(e, t || [])).next());
        });
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.getIDToken =
      t.getState =
      t.saveState =
      t.group =
      t.endGroup =
      t.startGroup =
      t.info =
      t.notice =
      t.warning =
      t.error =
      t.debug =
      t.isDebug =
      t.setFailed =
      t.setCommandEcho =
      t.setOutput =
      t.getBooleanInput =
      t.getMultilineInput =
      t.getInput =
      t.addPath =
      t.setSecret =
      t.exportVariable =
      t.ExitCode =
        void 0;
    const a = r(44914);
    const A = r(24753);
    const c = r(30302);
    const u = s(r(70857));
    const l = s(r(16928));
    const p = r(35306);
    var d;
    (function (e) {
      e[(e["Success"] = 0)] = "Success";
      e[(e["Failure"] = 1)] = "Failure";
    })((d = t.ExitCode || (t.ExitCode = {})));
    function exportVariable(e, t) {
      const r = c.toCommandValue(t);
      process.env[e] = r;
      const n = process.env["GITHUB_ENV"] || "";
      if (n) {
        return A.issueFileCommand("ENV", A.prepareKeyValueMessage(e, t));
      }
      a.issueCommand("set-env", { name: e }, r);
    }
    t.exportVariable = exportVariable;
    function setSecret(e) {
      a.issueCommand("add-mask", {}, e);
    }
    t.setSecret = setSecret;
    function addPath(e) {
      const t = process.env["GITHUB_PATH"] || "";
      if (t) {
        A.issueFileCommand("PATH", e);
      } else {
        a.issueCommand("add-path", {}, e);
      }
      process.env["PATH"] = `${e}${l.delimiter}${process.env["PATH"]}`;
    }
    t.addPath = addPath;
    function getInput(e, t) {
      const r = process.env[`INPUT_${e.replace(/ /g, "_").toUpperCase()}`] || "";
      if (t && t.required && !r) {
        throw new Error(`Input required and not supplied: ${e}`);
      }
      if (t && t.trimWhitespace === false) {
        return r;
      }
      return r.trim();
    }
    t.getInput = getInput;
    function getMultilineInput(e, t) {
      const r = getInput(e, t)
        .split("\n")
        .filter((e) => e !== "");
      if (t && t.trimWhitespace === false) {
        return r;
      }
      return r.map((e) => e.trim());
    }
    t.getMultilineInput = getMultilineInput;
    function getBooleanInput(e, t) {
      const r = ["true", "True", "TRUE"];
      const n = ["false", "False", "FALSE"];
      const o = getInput(e, t);
      if (r.includes(o)) return true;
      if (n.includes(o)) return false;
      throw new TypeError(
        `Input does not meet YAML 1.2 "Core Schema" specification: ${e}\n` + `Support boolean input list: \`true | True | TRUE | false | False | FALSE\``
      );
    }
    t.getBooleanInput = getBooleanInput;
    function setOutput(e, t) {
      const r = process.env["GITHUB_OUTPUT"] || "";
      if (r) {
        return A.issueFileCommand("OUTPUT", A.prepareKeyValueMessage(e, t));
      }
      process.stdout.write(u.EOL);
      a.issueCommand("set-output", { name: e }, c.toCommandValue(t));
    }
    t.setOutput = setOutput;
    function setCommandEcho(e) {
      a.issue("echo", e ? "on" : "off");
    }
    t.setCommandEcho = setCommandEcho;
    function setFailed(e) {
      process.exitCode = d.Failure;
      error(e);
    }
    t.setFailed = setFailed;
    function isDebug() {
      return process.env["RUNNER_DEBUG"] === "1";
    }
    t.isDebug = isDebug;
    function debug(e) {
      a.issueCommand("debug", {}, e);
    }
    t.debug = debug;
    function error(e, t = {}) {
      a.issueCommand("error", c.toCommandProperties(t), e instanceof Error ? e.toString() : e);
    }
    t.error = error;
    function warning(e, t = {}) {
      a.issueCommand("warning", c.toCommandProperties(t), e instanceof Error ? e.toString() : e);
    }
    t.warning = warning;
    function notice(e, t = {}) {
      a.issueCommand("notice", c.toCommandProperties(t), e instanceof Error ? e.toString() : e);
    }
    t.notice = notice;
    function info(e) {
      process.stdout.write(e + u.EOL);
    }
    t.info = info;
    function startGroup(e) {
      a.issue("group", e);
    }
    t.startGroup = startGroup;
    function endGroup() {
      a.issue("endgroup");
    }
    t.endGroup = endGroup;
    function group(e, t) {
      return i(this, void 0, void 0, function* () {
        startGroup(e);
        let r;
        try {
          r = yield t();
        } finally {
          endGroup();
        }
        return r;
      });
    }
    t.group = group;
    function saveState(e, t) {
      const r = process.env["GITHUB_STATE"] || "";
      if (r) {
        return A.issueFileCommand("STATE", A.prepareKeyValueMessage(e, t));
      }
      a.issueCommand("save-state", { name: e }, c.toCommandValue(t));
    }
    t.saveState = saveState;
    function getState(e) {
      return process.env[`STATE_${e}`] || "";
    }
    t.getState = getState;
    function getIDToken(e) {
      return i(this, void 0, void 0, function* () {
        return yield p.OidcClient.getIDToken(e);
      });
    }
    t.getIDToken = getIDToken;
    var g = r(71847);
    Object.defineProperty(t, "summary", {
      enumerable: true,
      get: function () {
        return g.summary;
      },
    });
    var m = r(71847);
    Object.defineProperty(t, "markdownSummary", {
      enumerable: true,
      get: function () {
        return m.markdownSummary;
      },
    });
    var h = r(31976);
    Object.defineProperty(t, "toPosixPath", {
      enumerable: true,
      get: function () {
        return h.toPosixPath;
      },
    });
    Object.defineProperty(t, "toWin32Path", {
      enumerable: true,
      get: function () {
        return h.toWin32Path;
      },
    });
    Object.defineProperty(t, "toPlatformPath", {
      enumerable: true,
      get: function () {
        return h.toPlatformPath;
      },
    });
  },
  24753: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            Object.defineProperty(e, n, {
              enumerable: true,
              get: function () {
                return t[r];
              },
            });
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          }
        : function (e, t) {
            e["default"] = t;
          });
    var s =
      (this && this.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null) for (var r in e) if (r !== "default" && Object.hasOwnProperty.call(e, r)) n(t, e, r);
        o(t, e);
        return t;
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.prepareKeyValueMessage = t.issueFileCommand = void 0;
    const i = s(r(79896));
    const a = s(r(70857));
    const A = r(12048);
    const c = r(30302);
    function issueFileCommand(e, t) {
      const r = process.env[`GITHUB_${e}`];
      if (!r) {
        throw new Error(`Unable to find environment variable for file command ${e}`);
      }
      if (!i.existsSync(r)) {
        throw new Error(`Missing file at path: ${r}`);
      }
      i.appendFileSync(r, `${c.toCommandValue(t)}${a.EOL}`, { encoding: "utf8" });
    }
    t.issueFileCommand = issueFileCommand;
    function prepareKeyValueMessage(e, t) {
      const r = `ghadelimiter_${A.v4()}`;
      const n = c.toCommandValue(t);
      if (e.includes(r)) {
        throw new Error(`Unexpected input: name should not contain the delimiter "${r}"`);
      }
      if (n.includes(r)) {
        throw new Error(`Unexpected input: value should not contain the delimiter "${r}"`);
      }
      return `${e}<<${r}${a.EOL}${n}${a.EOL}${r}`;
    }
    t.prepareKeyValueMessage = prepareKeyValueMessage;
  },
  35306: function (e, t, r) {
    var n =
      (this && this.__awaiter) ||
      function (e, t, r, n) {
        function adopt(e) {
          return e instanceof r
            ? e
            : new r(function (t) {
                t(e);
              });
        }
        return new (r || (r = Promise))(function (r, o) {
          function fulfilled(e) {
            try {
              step(n.next(e));
            } catch (e) {
              o(e);
            }
          }
          function rejected(e) {
            try {
              step(n["throw"](e));
            } catch (e) {
              o(e);
            }
          }
          function step(e) {
            e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
          }
          step((n = n.apply(e, t || [])).next());
        });
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.OidcClient = void 0;
    const o = r(54844);
    const s = r(44552);
    const i = r(37484);
    class OidcClient {
      static createHttpClient(e = true, t = 10) {
        const r = { allowRetries: e, maxRetries: t };
        return new o.HttpClient("actions/oidc-client", [new s.BearerCredentialHandler(OidcClient.getRequestToken())], r);
      }
      static getRequestToken() {
        const e = process.env["ACTIONS_ID_TOKEN_REQUEST_TOKEN"];
        if (!e) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable");
        }
        return e;
      }
      static getIDTokenUrl() {
        const e = process.env["ACTIONS_ID_TOKEN_REQUEST_URL"];
        if (!e) {
          throw new Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
        }
        return e;
      }
      static getCall(e) {
        var t;
        return n(this, void 0, void 0, function* () {
          const r = OidcClient.createHttpClient();
          const n = yield r.getJson(e).catch((e) => {
            throw new Error(`Failed to get ID Token. \n \n        Error Code : ${e.statusCode}\n \n        Error Message: ${e.message}`);
          });
          const o = (t = n.result) === null || t === void 0 ? void 0 : t.value;
          if (!o) {
            throw new Error("Response json body do not have ID Token field");
          }
          return o;
        });
      }
      static getIDToken(e) {
        return n(this, void 0, void 0, function* () {
          try {
            let t = OidcClient.getIDTokenUrl();
            if (e) {
              const r = encodeURIComponent(e);
              t = `${t}&audience=${r}`;
            }
            i.debug(`ID token url is ${t}`);
            const r = yield OidcClient.getCall(t);
            i.setSecret(r);
            return r;
          } catch (e) {
            throw new Error(`Error message: ${e.message}`);
          }
        });
      }
    }
    t.OidcClient = OidcClient;
  },
  31976: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            Object.defineProperty(e, n, {
              enumerable: true,
              get: function () {
                return t[r];
              },
            });
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          }
        : function (e, t) {
            e["default"] = t;
          });
    var s =
      (this && this.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null) for (var r in e) if (r !== "default" && Object.hasOwnProperty.call(e, r)) n(t, e, r);
        o(t, e);
        return t;
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.toPlatformPath = t.toWin32Path = t.toPosixPath = void 0;
    const i = s(r(16928));
    function toPosixPath(e) {
      return e.replace(/[\\]/g, "/");
    }
    t.toPosixPath = toPosixPath;
    function toWin32Path(e) {
      return e.replace(/[/]/g, "\\");
    }
    t.toWin32Path = toWin32Path;
    function toPlatformPath(e) {
      return e.replace(/[/\\]/g, i.sep);
    }
    t.toPlatformPath = toPlatformPath;
  },
  71847: function (e, t, r) {
    var n =
      (this && this.__awaiter) ||
      function (e, t, r, n) {
        function adopt(e) {
          return e instanceof r
            ? e
            : new r(function (t) {
                t(e);
              });
        }
        return new (r || (r = Promise))(function (r, o) {
          function fulfilled(e) {
            try {
              step(n.next(e));
            } catch (e) {
              o(e);
            }
          }
          function rejected(e) {
            try {
              step(n["throw"](e));
            } catch (e) {
              o(e);
            }
          }
          function step(e) {
            e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
          }
          step((n = n.apply(e, t || [])).next());
        });
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.summary = t.markdownSummary = t.SUMMARY_DOCS_URL = t.SUMMARY_ENV_VAR = void 0;
    const o = r(70857);
    const s = r(79896);
    const { access: i, appendFile: a, writeFile: A } = s.promises;
    t.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
    t.SUMMARY_DOCS_URL = "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
    class Summary {
      constructor() {
        this._buffer = "";
      }
      filePath() {
        return n(this, void 0, void 0, function* () {
          if (this._filePath) {
            return this._filePath;
          }
          const e = process.env[t.SUMMARY_ENV_VAR];
          if (!e) {
            throw new Error(`Unable to find environment variable for $${t.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);
          }
          try {
            yield i(e, s.constants.R_OK | s.constants.W_OK);
          } catch (t) {
            throw new Error(`Unable to access summary file: '${e}'. Check if the file has correct read/write permissions.`);
          }
          this._filePath = e;
          return this._filePath;
        });
      }
      wrap(e, t, r = {}) {
        const n = Object.entries(r)
          .map(([e, t]) => ` ${e}="${t}"`)
          .join("");
        if (!t) {
          return `<${e}${n}>`;
        }
        return `<${e}${n}>${t}</${e}>`;
      }
      write(e) {
        return n(this, void 0, void 0, function* () {
          const t = !!(e === null || e === void 0 ? void 0 : e.overwrite);
          const r = yield this.filePath();
          const n = t ? A : a;
          yield n(r, this._buffer, { encoding: "utf8" });
          return this.emptyBuffer();
        });
      }
      clear() {
        return n(this, void 0, void 0, function* () {
          return this.emptyBuffer().write({ overwrite: true });
        });
      }
      stringify() {
        return this._buffer;
      }
      isEmptyBuffer() {
        return this._buffer.length === 0;
      }
      emptyBuffer() {
        this._buffer = "";
        return this;
      }
      addRaw(e, t = false) {
        this._buffer += e;
        return t ? this.addEOL() : this;
      }
      addEOL() {
        return this.addRaw(o.EOL);
      }
      addCodeBlock(e, t) {
        const r = Object.assign({}, t && { lang: t });
        const n = this.wrap("pre", this.wrap("code", e), r);
        return this.addRaw(n).addEOL();
      }
      addList(e, t = false) {
        const r = t ? "ol" : "ul";
        const n = e.map((e) => this.wrap("li", e)).join("");
        const o = this.wrap(r, n);
        return this.addRaw(o).addEOL();
      }
      addTable(e) {
        const t = e
          .map((e) => {
            const t = e
              .map((e) => {
                if (typeof e === "string") {
                  return this.wrap("td", e);
                }
                const { header: t, data: r, colspan: n, rowspan: o } = e;
                const s = t ? "th" : "td";
                const i = Object.assign(Object.assign({}, n && { colspan: n }), o && { rowspan: o });
                return this.wrap(s, r, i);
              })
              .join("");
            return this.wrap("tr", t);
          })
          .join("");
        const r = this.wrap("table", t);
        return this.addRaw(r).addEOL();
      }
      addDetails(e, t) {
        const r = this.wrap("details", this.wrap("summary", e) + t);
        return this.addRaw(r).addEOL();
      }
      addImage(e, t, r) {
        const { width: n, height: o } = r || {};
        const s = Object.assign(Object.assign({}, n && { width: n }), o && { height: o });
        const i = this.wrap("img", null, Object.assign({ src: e, alt: t }, s));
        return this.addRaw(i).addEOL();
      }
      addHeading(e, t) {
        const r = `h${t}`;
        const n = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(r) ? r : "h1";
        const o = this.wrap(n, e);
        return this.addRaw(o).addEOL();
      }
      addSeparator() {
        const e = this.wrap("hr", null);
        return this.addRaw(e).addEOL();
      }
      addBreak() {
        const e = this.wrap("br", null);
        return this.addRaw(e).addEOL();
      }
      addQuote(e, t) {
        const r = Object.assign({}, t && { cite: t });
        const n = this.wrap("blockquote", e, r);
        return this.addRaw(n).addEOL();
      }
      addLink(e, t) {
        const r = this.wrap("a", e, { href: t });
        return this.addRaw(r).addEOL();
      }
    }
    const c = new Summary();
    t.markdownSummary = c;
    t.summary = c;
  },
  30302: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.toCommandProperties = t.toCommandValue = void 0;
    function toCommandValue(e) {
      if (e === null || e === undefined) {
        return "";
      } else if (typeof e === "string" || e instanceof String) {
        return e;
      }
      return JSON.stringify(e);
    }
    t.toCommandValue = toCommandValue;
    function toCommandProperties(e) {
      if (!Object.keys(e).length) {
        return {};
      }
      return { title: e.title, file: e.file, line: e.startLine, endLine: e.endLine, col: e.startColumn, endColumn: e.endColumn };
    }
    t.toCommandProperties = toCommandProperties;
  },
  51648: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Context = void 0;
    const n = r(79896);
    const o = r(70857);
    class Context {
      constructor() {
        var e, t, r;
        this.payload = {};
        if (process.env.GITHUB_EVENT_PATH) {
          if ((0, n.existsSync)(process.env.GITHUB_EVENT_PATH)) {
            this.payload = JSON.parse((0, n.readFileSync)(process.env.GITHUB_EVENT_PATH, { encoding: "utf8" }));
          } else {
            const e = process.env.GITHUB_EVENT_PATH;
            process.stdout.write(`GITHUB_EVENT_PATH ${e} does not exist${o.EOL}`);
          }
        }
        this.eventName = process.env.GITHUB_EVENT_NAME;
        this.sha = process.env.GITHUB_SHA;
        this.ref = process.env.GITHUB_REF;
        this.workflow = process.env.GITHUB_WORKFLOW;
        this.action = process.env.GITHUB_ACTION;
        this.actor = process.env.GITHUB_ACTOR;
        this.job = process.env.GITHUB_JOB;
        this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
        this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
        this.apiUrl = (e = process.env.GITHUB_API_URL) !== null && e !== void 0 ? e : `https://api.github.com`;
        this.serverUrl = (t = process.env.GITHUB_SERVER_URL) !== null && t !== void 0 ? t : `https://github.com`;
        this.graphqlUrl = (r = process.env.GITHUB_GRAPHQL_URL) !== null && r !== void 0 ? r : `https://api.github.com/graphql`;
      }
      get issue() {
        const e = this.payload;
        return Object.assign(Object.assign({}, this.repo), { number: (e.issue || e.pull_request || e).number });
      }
      get repo() {
        if (process.env.GITHUB_REPOSITORY) {
          const [e, t] = process.env.GITHUB_REPOSITORY.split("/");
          return { owner: e, repo: t };
        }
        if (this.payload.repository) {
          return { owner: this.payload.repository.owner.login, repo: this.payload.repository.name };
        }
        throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
      }
    }
    t.Context = Context;
  },
  93228: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          }
        : function (e, t) {
            e["default"] = t;
          });
    var s =
      (this && this.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null) for (var r in e) if (r !== "default" && Object.prototype.hasOwnProperty.call(e, r)) n(t, e, r);
        o(t, e);
        return t;
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.getOctokit = t.context = void 0;
    const i = s(r(51648));
    const a = r(38006);
    t.context = new i.Context();
    function getOctokit(e, t, ...r) {
      const n = a.GitHub.plugin(...r);
      return new n((0, a.getOctokitOptions)(e, t));
    }
    t.getOctokit = getOctokit;
  },
  65156: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          }
        : function (e, t) {
            e["default"] = t;
          });
    var s =
      (this && this.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null) for (var r in e) if (r !== "default" && Object.prototype.hasOwnProperty.call(e, r)) n(t, e, r);
        o(t, e);
        return t;
      };
    var i =
      (this && this.__awaiter) ||
      function (e, t, r, n) {
        function adopt(e) {
          return e instanceof r
            ? e
            : new r(function (t) {
                t(e);
              });
        }
        return new (r || (r = Promise))(function (r, o) {
          function fulfilled(e) {
            try {
              step(n.next(e));
            } catch (e) {
              o(e);
            }
          }
          function rejected(e) {
            try {
              step(n["throw"](e));
            } catch (e) {
              o(e);
            }
          }
          function step(e) {
            e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
          }
          step((n = n.apply(e, t || [])).next());
        });
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.getApiBaseUrl = t.getProxyFetch = t.getProxyAgentDispatcher = t.getProxyAgent = t.getAuthString = void 0;
    const a = s(r(54844));
    const A = r(46752);
    function getAuthString(e, t) {
      if (!e && !t.auth) {
        throw new Error("Parameter token or opts.auth is required");
      } else if (e && t.auth) {
        throw new Error("Parameters token and opts.auth may not both be specified");
      }
      return typeof t.auth === "string" ? t.auth : `token ${e}`;
    }
    t.getAuthString = getAuthString;
    function getProxyAgent(e) {
      const t = new a.HttpClient();
      return t.getAgent(e);
    }
    t.getProxyAgent = getProxyAgent;
    function getProxyAgentDispatcher(e) {
      const t = new a.HttpClient();
      return t.getAgentDispatcher(e);
    }
    t.getProxyAgentDispatcher = getProxyAgentDispatcher;
    function getProxyFetch(e) {
      const t = getProxyAgentDispatcher(e);
      const proxyFetch = (e, r) =>
        i(this, void 0, void 0, function* () {
          return (0, A.fetch)(e, Object.assign(Object.assign({}, r), { dispatcher: t }));
        });
      return proxyFetch;
    }
    t.getProxyFetch = getProxyFetch;
    function getApiBaseUrl() {
      return process.env["GITHUB_API_URL"] || "https://api.github.com";
    }
    t.getApiBaseUrl = getApiBaseUrl;
  },
  38006: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          }
        : function (e, t) {
            e["default"] = t;
          });
    var s =
      (this && this.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null) for (var r in e) if (r !== "default" && Object.prototype.hasOwnProperty.call(e, r)) n(t, e, r);
        o(t, e);
        return t;
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.getOctokitOptions = t.GitHub = t.defaults = t.context = void 0;
    const i = s(r(51648));
    const a = s(r(65156));
    const A = r(61897);
    const c = r(75726);
    const u = r(37731);
    t.context = new i.Context();
    const l = a.getApiBaseUrl();
    t.defaults = { baseUrl: l, request: { agent: a.getProxyAgent(l), fetch: a.getProxyFetch(l) } };
    t.GitHub = A.Octokit.plugin(c.restEndpointMethods, u.paginateRest).defaults(t.defaults);
    function getOctokitOptions(e, t) {
      const r = Object.assign({}, t || {});
      const n = a.getAuthString(e, r);
      if (n) {
        r.auth = n;
      }
      return r;
    }
    t.getOctokitOptions = getOctokitOptions;
  },
  37731: (e) => {
    var t = Object.defineProperty;
    var r = Object.getOwnPropertyDescriptor;
    var n = Object.getOwnPropertyNames;
    var o = Object.prototype.hasOwnProperty;
    var __export = (e, r) => {
      for (var n in r) t(e, n, { get: r[n], enumerable: true });
    };
    var __copyProps = (e, s, i, a) => {
      if ((s && typeof s === "object") || typeof s === "function") {
        for (let A of n(s)) if (!o.call(e, A) && A !== i) t(e, A, { get: () => s[A], enumerable: !(a = r(s, A)) || a.enumerable });
      }
      return e;
    };
    var __toCommonJS = (e) => __copyProps(t({}, "__esModule", { value: true }), e);
    var s = {};
    __export(s, {
      composePaginateRest: () => a,
      isPaginatingEndpoint: () => isPaginatingEndpoint,
      paginateRest: () => paginateRest,
      paginatingEndpoints: () => A,
    });
    e.exports = __toCommonJS(s);
    var i = "9.2.1";
    function normalizePaginatedListResponse(e) {
      if (!e.data) {
        return { ...e, data: [] };
      }
      const t = "total_count" in e.data && !("url" in e.data);
      if (!t) return e;
      const r = e.data.incomplete_results;
      const n = e.data.repository_selection;
      const o = e.data.total_count;
      delete e.data.incomplete_results;
      delete e.data.repository_selection;
      delete e.data.total_count;
      const s = Object.keys(e.data)[0];
      const i = e.data[s];
      e.data = i;
      if (typeof r !== "undefined") {
        e.data.incomplete_results = r;
      }
      if (typeof n !== "undefined") {
        e.data.repository_selection = n;
      }
      e.data.total_count = o;
      return e;
    }
    function iterator(e, t, r) {
      const n = typeof t === "function" ? t.endpoint(r) : e.request.endpoint(t, r);
      const o = typeof t === "function" ? t : e.request;
      const s = n.method;
      const i = n.headers;
      let a = n.url;
      return {
        [Symbol.asyncIterator]: () => ({
          async next() {
            if (!a) return { done: true };
            try {
              const e = await o({ method: s, url: a, headers: i });
              const t = normalizePaginatedListResponse(e);
              a = ((t.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
              return { value: t };
            } catch (e) {
              if (e.status !== 409) throw e;
              a = "";
              return { value: { status: 200, headers: {}, data: [] } };
            }
          },
        }),
      };
    }
    function paginate(e, t, r, n) {
      if (typeof r === "function") {
        n = r;
        r = void 0;
      }
      return gather(e, [], iterator(e, t, r)[Symbol.asyncIterator](), n);
    }
    function gather(e, t, r, n) {
      return r.next().then((o) => {
        if (o.done) {
          return t;
        }
        let s = false;
        function done() {
          s = true;
        }
        t = t.concat(n ? n(o.value, done) : o.value.data);
        if (s) {
          return t;
        }
        return gather(e, t, r, n);
      });
    }
    var a = Object.assign(paginate, { iterator: iterator });
    var A = [
      "GET /advisories",
      "GET /app/hook/deliveries",
      "GET /app/installation-requests",
      "GET /app/installations",
      "GET /assignments/{assignment_id}/accepted_assignments",
      "GET /classrooms",
      "GET /classrooms/{classroom_id}/assignments",
      "GET /enterprises/{enterprise}/dependabot/alerts",
      "GET /enterprises/{enterprise}/secret-scanning/alerts",
      "GET /events",
      "GET /gists",
      "GET /gists/public",
      "GET /gists/starred",
      "GET /gists/{gist_id}/comments",
      "GET /gists/{gist_id}/commits",
      "GET /gists/{gist_id}/forks",
      "GET /installation/repositories",
      "GET /issues",
      "GET /licenses",
      "GET /marketplace_listing/plans",
      "GET /marketplace_listing/plans/{plan_id}/accounts",
      "GET /marketplace_listing/stubbed/plans",
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
      "GET /networks/{owner}/{repo}/events",
      "GET /notifications",
      "GET /organizations",
      "GET /orgs/{org}/actions/cache/usage-by-repository",
      "GET /orgs/{org}/actions/permissions/repositories",
      "GET /orgs/{org}/actions/runners",
      "GET /orgs/{org}/actions/secrets",
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/actions/variables",
      "GET /orgs/{org}/actions/variables/{name}/repositories",
      "GET /orgs/{org}/blocks",
      "GET /orgs/{org}/code-scanning/alerts",
      "GET /orgs/{org}/codespaces",
      "GET /orgs/{org}/codespaces/secrets",
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/copilot/billing/seats",
      "GET /orgs/{org}/dependabot/alerts",
      "GET /orgs/{org}/dependabot/secrets",
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/events",
      "GET /orgs/{org}/failed_invitations",
      "GET /orgs/{org}/hooks",
      "GET /orgs/{org}/hooks/{hook_id}/deliveries",
      "GET /orgs/{org}/installations",
      "GET /orgs/{org}/invitations",
      "GET /orgs/{org}/invitations/{invitation_id}/teams",
      "GET /orgs/{org}/issues",
      "GET /orgs/{org}/members",
      "GET /orgs/{org}/members/{username}/codespaces",
      "GET /orgs/{org}/migrations",
      "GET /orgs/{org}/migrations/{migration_id}/repositories",
      "GET /orgs/{org}/organization-roles/{role_id}/teams",
      "GET /orgs/{org}/organization-roles/{role_id}/users",
      "GET /orgs/{org}/outside_collaborators",
      "GET /orgs/{org}/packages",
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      "GET /orgs/{org}/personal-access-token-requests",
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
      "GET /orgs/{org}/personal-access-tokens",
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
      "GET /orgs/{org}/projects",
      "GET /orgs/{org}/properties/values",
      "GET /orgs/{org}/public_members",
      "GET /orgs/{org}/repos",
      "GET /orgs/{org}/rulesets",
      "GET /orgs/{org}/rulesets/rule-suites",
      "GET /orgs/{org}/secret-scanning/alerts",
      "GET /orgs/{org}/security-advisories",
      "GET /orgs/{org}/teams",
      "GET /orgs/{org}/teams/{team_slug}/discussions",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
      "GET /orgs/{org}/teams/{team_slug}/invitations",
      "GET /orgs/{org}/teams/{team_slug}/members",
      "GET /orgs/{org}/teams/{team_slug}/projects",
      "GET /orgs/{org}/teams/{team_slug}/repos",
      "GET /orgs/{org}/teams/{team_slug}/teams",
      "GET /projects/columns/{column_id}/cards",
      "GET /projects/{project_id}/collaborators",
      "GET /projects/{project_id}/columns",
      "GET /repos/{owner}/{repo}/actions/artifacts",
      "GET /repos/{owner}/{repo}/actions/caches",
      "GET /repos/{owner}/{repo}/actions/organization-secrets",
      "GET /repos/{owner}/{repo}/actions/organization-variables",
      "GET /repos/{owner}/{repo}/actions/runners",
      "GET /repos/{owner}/{repo}/actions/runs",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
      "GET /repos/{owner}/{repo}/actions/secrets",
      "GET /repos/{owner}/{repo}/actions/variables",
      "GET /repos/{owner}/{repo}/actions/workflows",
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
      "GET /repos/{owner}/{repo}/activity",
      "GET /repos/{owner}/{repo}/assignees",
      "GET /repos/{owner}/{repo}/branches",
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
      "GET /repos/{owner}/{repo}/code-scanning/alerts",
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      "GET /repos/{owner}/{repo}/code-scanning/analyses",
      "GET /repos/{owner}/{repo}/codespaces",
      "GET /repos/{owner}/{repo}/codespaces/devcontainers",
      "GET /repos/{owner}/{repo}/codespaces/secrets",
      "GET /repos/{owner}/{repo}/collaborators",
      "GET /repos/{owner}/{repo}/comments",
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/commits",
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
      "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
      "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
      "GET /repos/{owner}/{repo}/commits/{ref}/status",
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
      "GET /repos/{owner}/{repo}/contributors",
      "GET /repos/{owner}/{repo}/dependabot/alerts",
      "GET /repos/{owner}/{repo}/dependabot/secrets",
      "GET /repos/{owner}/{repo}/deployments",
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
      "GET /repos/{owner}/{repo}/environments",
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
      "GET /repos/{owner}/{repo}/events",
      "GET /repos/{owner}/{repo}/forks",
      "GET /repos/{owner}/{repo}/hooks",
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
      "GET /repos/{owner}/{repo}/invitations",
      "GET /repos/{owner}/{repo}/issues",
      "GET /repos/{owner}/{repo}/issues/comments",
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/issues/events",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
      "GET /repos/{owner}/{repo}/keys",
      "GET /repos/{owner}/{repo}/labels",
      "GET /repos/{owner}/{repo}/milestones",
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
      "GET /repos/{owner}/{repo}/notifications",
      "GET /repos/{owner}/{repo}/pages/builds",
      "GET /repos/{owner}/{repo}/projects",
      "GET /repos/{owner}/{repo}/pulls",
      "GET /repos/{owner}/{repo}/pulls/comments",
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
      "GET /repos/{owner}/{repo}/releases",
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
      "GET /repos/{owner}/{repo}/rules/branches/{branch}",
      "GET /repos/{owner}/{repo}/rulesets",
      "GET /repos/{owner}/{repo}/rulesets/rule-suites",
      "GET /repos/{owner}/{repo}/secret-scanning/alerts",
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
      "GET /repos/{owner}/{repo}/security-advisories",
      "GET /repos/{owner}/{repo}/stargazers",
      "GET /repos/{owner}/{repo}/subscribers",
      "GET /repos/{owner}/{repo}/tags",
      "GET /repos/{owner}/{repo}/teams",
      "GET /repos/{owner}/{repo}/topics",
      "GET /repositories",
      "GET /repositories/{repository_id}/environments/{environment_name}/secrets",
      "GET /repositories/{repository_id}/environments/{environment_name}/variables",
      "GET /search/code",
      "GET /search/commits",
      "GET /search/issues",
      "GET /search/labels",
      "GET /search/repositories",
      "GET /search/topics",
      "GET /search/users",
      "GET /teams/{team_id}/discussions",
      "GET /teams/{team_id}/discussions/{discussion_number}/comments",
      "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
      "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
      "GET /teams/{team_id}/invitations",
      "GET /teams/{team_id}/members",
      "GET /teams/{team_id}/projects",
      "GET /teams/{team_id}/repos",
      "GET /teams/{team_id}/teams",
      "GET /user/blocks",
      "GET /user/codespaces",
      "GET /user/codespaces/secrets",
      "GET /user/emails",
      "GET /user/followers",
      "GET /user/following",
      "GET /user/gpg_keys",
      "GET /user/installations",
      "GET /user/installations/{installation_id}/repositories",
      "GET /user/issues",
      "GET /user/keys",
      "GET /user/marketplace_purchases",
      "GET /user/marketplace_purchases/stubbed",
      "GET /user/memberships/orgs",
      "GET /user/migrations",
      "GET /user/migrations/{migration_id}/repositories",
      "GET /user/orgs",
      "GET /user/packages",
      "GET /user/packages/{package_type}/{package_name}/versions",
      "GET /user/public_emails",
      "GET /user/repos",
      "GET /user/repository_invitations",
      "GET /user/social_accounts",
      "GET /user/ssh_signing_keys",
      "GET /user/starred",
      "GET /user/subscriptions",
      "GET /user/teams",
      "GET /users",
      "GET /users/{username}/events",
      "GET /users/{username}/events/orgs/{org}",
      "GET /users/{username}/events/public",
      "GET /users/{username}/followers",
      "GET /users/{username}/following",
      "GET /users/{username}/gists",
      "GET /users/{username}/gpg_keys",
      "GET /users/{username}/keys",
      "GET /users/{username}/orgs",
      "GET /users/{username}/packages",
      "GET /users/{username}/projects",
      "GET /users/{username}/received_events",
      "GET /users/{username}/received_events/public",
      "GET /users/{username}/repos",
      "GET /users/{username}/social_accounts",
      "GET /users/{username}/ssh_signing_keys",
      "GET /users/{username}/starred",
      "GET /users/{username}/subscriptions",
    ];
    function isPaginatingEndpoint(e) {
      if (typeof e === "string") {
        return A.includes(e);
      } else {
        return false;
      }
    }
    function paginateRest(e) {
      return { paginate: Object.assign(paginate.bind(null, e), { iterator: iterator.bind(null, e) }) };
    }
    paginateRest.VERSION = i;
    0 && 0;
  },
  75726: (e) => {
    var t = Object.defineProperty;
    var r = Object.getOwnPropertyDescriptor;
    var n = Object.getOwnPropertyNames;
    var o = Object.prototype.hasOwnProperty;
    var __export = (e, r) => {
      for (var n in r) t(e, n, { get: r[n], enumerable: true });
    };
    var __copyProps = (e, s, i, a) => {
      if ((s && typeof s === "object") || typeof s === "function") {
        for (let A of n(s)) if (!o.call(e, A) && A !== i) t(e, A, { get: () => s[A], enumerable: !(a = r(s, A)) || a.enumerable });
      }
      return e;
    };
    var __toCommonJS = (e) => __copyProps(t({}, "__esModule", { value: true }), e);
    var s = {};
    __export(s, { legacyRestEndpointMethods: () => legacyRestEndpointMethods, restEndpointMethods: () => restEndpointMethods });
    e.exports = __toCommonJS(s);
    var i = "10.4.1";
    var a = {
      actions: {
        addCustomLabelsToSelfHostedRunnerForOrg: ["POST /orgs/{org}/actions/runners/{runner_id}/labels"],
        addCustomLabelsToSelfHostedRunnerForRepo: ["POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
        addSelectedRepoToOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
        approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
        cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
        createEnvironmentVariable: ["POST /repositories/{repository_id}/environments/{environment_name}/variables"],
        createOrUpdateEnvironmentSecret: ["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
        createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        createOrgVariable: ["POST /orgs/{org}/actions/variables"],
        createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
        createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
        createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
        createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
        createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
        createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
        deleteActionsCacheById: ["DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"],
        deleteActionsCacheByKey: ["DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"],
        deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        deleteEnvironmentSecret: ["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
        deleteEnvironmentVariable: ["DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
        deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
        deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
        deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        deleteRepoVariable: ["DELETE /repos/{owner}/{repo}/actions/variables/{name}"],
        deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
        deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
        deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
        deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
        disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
        disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
        downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
        downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
        downloadWorkflowRunAttemptLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],
        downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
        enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
        enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
        forceCancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"],
        generateRunnerJitconfigForOrg: ["POST /orgs/{org}/actions/runners/generate-jitconfig"],
        generateRunnerJitconfigForRepo: ["POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"],
        getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
        getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
        getActionsCacheUsageByRepoForOrg: ["GET /orgs/{org}/actions/cache/usage-by-repository"],
        getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
        getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
        getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
        getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        getCustomOidcSubClaimForRepo: ["GET /repos/{owner}/{repo}/actions/oidc/customization/sub"],
        getEnvironmentPublicKey: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],
        getEnvironmentSecret: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],
        getEnvironmentVariable: ["GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
        getGithubActionsDefaultWorkflowPermissionsOrganization: ["GET /orgs/{org}/actions/permissions/workflow"],
        getGithubActionsDefaultWorkflowPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/workflow"],
        getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
        getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
        getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
        getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
        getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
        getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
        getRepoPermissions: ["GET /repos/{owner}/{repo}/actions/permissions", {}, { renamed: ["actions", "getGithubActionsPermissionsRepository"] }],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
        getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
        getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
        getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
        getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
        getWorkflowAccessToRepository: ["GET /repos/{owner}/{repo}/actions/permissions/access"],
        getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
        getWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],
        getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
        getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
        listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
        listEnvironmentSecrets: ["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],
        listEnvironmentVariables: ["GET /repositories/{repository_id}/environments/{environment_name}/variables"],
        listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
        listJobsForWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],
        listLabelsForSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}/labels"],
        listLabelsForSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
        listOrgVariables: ["GET /orgs/{org}/actions/variables"],
        listRepoOrganizationSecrets: ["GET /repos/{owner}/{repo}/actions/organization-secrets"],
        listRepoOrganizationVariables: ["GET /repos/{owner}/{repo}/actions/organization-variables"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
        listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
        listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
        listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
        listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
        listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
        listSelectedReposForOrgVariable: ["GET /orgs/{org}/actions/variables/{name}/repositories"],
        listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
        listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
        listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
        listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
        listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
        listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
        reRunJobForWorkflowRun: ["POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"],
        reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
        reRunWorkflowFailedJobs: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"],
        removeAllCustomLabelsFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels"],
        removeAllCustomLabelsFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        removeCustomLabelFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"],
        removeCustomLabelFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"],
        removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
        removeSelectedRepoFromOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
        reviewCustomGatesForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"],
        reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
        setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
        setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
        setCustomLabelsForSelfHostedRunnerForOrg: ["PUT /orgs/{org}/actions/runners/{runner_id}/labels"],
        setCustomLabelsForSelfHostedRunnerForRepo: ["PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        setCustomOidcSubClaimForRepo: ["PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"],
        setGithubActionsDefaultWorkflowPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions/workflow"],
        setGithubActionsDefaultWorkflowPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/workflow"],
        setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
        setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
        setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
        setSelectedReposForOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories"],
        setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"],
        setWorkflowAccessToRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/access"],
        updateEnvironmentVariable: ["PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],
        updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
        updateRepoVariable: ["PATCH /repos/{owner}/{repo}/actions/variables/{name}"],
      },
      activity: {
        checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
        deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
        deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
        getFeeds: ["GET /feeds"],
        getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
        getThread: ["GET /notifications/threads/{thread_id}"],
        getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
        listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
        listNotificationsForAuthenticatedUser: ["GET /notifications"],
        listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
        listPublicEvents: ["GET /events"],
        listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
        listPublicEventsForUser: ["GET /users/{username}/events/public"],
        listPublicOrgEvents: ["GET /orgs/{org}/events"],
        listReceivedEventsForUser: ["GET /users/{username}/received_events"],
        listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
        listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
        listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
        listReposStarredByAuthenticatedUser: ["GET /user/starred"],
        listReposStarredByUser: ["GET /users/{username}/starred"],
        listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
        listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
        listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
        listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
        markNotificationsAsRead: ["PUT /notifications"],
        markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
        markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
        markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
        setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
        setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
        starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
        unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"],
      },
      apps: {
        addRepoToInstallation: [
          "PUT /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] },
        ],
        addRepoToInstallationForAuthenticatedUser: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
        checkToken: ["POST /applications/{client_id}/token"],
        createFromManifest: ["POST /app-manifests/{code}/conversions"],
        createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
        deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
        deleteInstallation: ["DELETE /app/installations/{installation_id}"],
        deleteToken: ["DELETE /applications/{client_id}/token"],
        getAuthenticated: ["GET /app"],
        getBySlug: ["GET /apps/{app_slug}"],
        getInstallation: ["GET /app/installations/{installation_id}"],
        getOrgInstallation: ["GET /orgs/{org}/installation"],
        getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
        getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
        getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
        getUserInstallation: ["GET /users/{username}/installation"],
        getWebhookConfigForApp: ["GET /app/hook/config"],
        getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
        listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
        listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
        listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
        listInstallationRequestsForAuthenticatedApp: ["GET /app/installation-requests"],
        listInstallations: ["GET /app/installations"],
        listInstallationsForAuthenticatedUser: ["GET /user/installations"],
        listPlans: ["GET /marketplace_listing/plans"],
        listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
        listReposAccessibleToInstallation: ["GET /installation/repositories"],
        listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
        listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
        listWebhookDeliveries: ["GET /app/hook/deliveries"],
        redeliverWebhookDelivery: ["POST /app/hook/deliveries/{delivery_id}/attempts"],
        removeRepoFromInstallation: [
          "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] },
        ],
        removeRepoFromInstallationForAuthenticatedUser: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
        resetToken: ["PATCH /applications/{client_id}/token"],
        revokeInstallationAccessToken: ["DELETE /installation/token"],
        scopeToken: ["POST /applications/{client_id}/token/scoped"],
        suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
        unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
        updateWebhookConfigForApp: ["PATCH /app/hook/config"],
      },
      billing: {
        getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
        getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
        getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
        getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
        getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
        getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"],
      },
      checks: {
        create: ["POST /repos/{owner}/{repo}/check-runs"],
        createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
        get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
        getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
        listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
        listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
        listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
        listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
        rerequestRun: ["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],
        rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
        setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
        update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"],
      },
      codeScanning: {
        deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
        getAlert: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}", {}, { renamedParameters: { alert_id: "alert_number" } }],
        getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
        getCodeqlDatabase: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"],
        getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
        getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
        listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
        listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
        listAlertsInstances: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
          {},
          { renamed: ["codeScanning", "listAlertInstances"] },
        ],
        listCodeqlDatabases: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases"],
        listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
        updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
        updateDefaultSetup: ["PATCH /repos/{owner}/{repo}/code-scanning/default-setup"],
        uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"],
      },
      codesOfConduct: { getAllCodesOfConduct: ["GET /codes_of_conduct"], getConductCode: ["GET /codes_of_conduct/{key}"] },
      codespaces: {
        addRepositoryForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
        addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
        checkPermissionsForDevcontainer: ["GET /repos/{owner}/{repo}/codespaces/permissions_check"],
        codespaceMachinesForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/machines"],
        createForAuthenticatedUser: ["POST /user/codespaces"],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}"],
        createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
        createOrUpdateSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}"],
        createWithPrForAuthenticatedUser: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"],
        createWithRepoForAuthenticatedUser: ["POST /repos/{owner}/{repo}/codespaces"],
        deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
        deleteFromOrganization: ["DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"],
        deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
        deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
        deleteSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}"],
        exportForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/exports"],
        getCodespacesForUserInOrg: ["GET /orgs/{org}/members/{username}/codespaces"],
        getExportDetailsForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/exports/{export_id}"],
        getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
        getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
        getPublicKeyForAuthenticatedUser: ["GET /user/codespaces/secrets/public-key"],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/codespaces/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
        getSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}"],
        listDevcontainersInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/devcontainers"],
        listForAuthenticatedUser: ["GET /user/codespaces"],
        listInOrganization: ["GET /orgs/{org}/codespaces", {}, { renamedParameters: { org_id: "org" } }],
        listInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces"],
        listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
        listRepositoriesForSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}/repositories"],
        listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
        listSelectedReposForOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
        preFlightWithRepoForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/new"],
        publishForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/publish"],
        removeRepositoryForSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
        removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
        repoMachinesForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/machines"],
        setRepositoriesForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories"],
        setSelectedReposForOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
        startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
        stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
        stopInOrganization: ["POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"],
        updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"],
      },
      copilot: {
        addCopilotSeatsForTeams: ["POST /orgs/{org}/copilot/billing/selected_teams"],
        addCopilotSeatsForUsers: ["POST /orgs/{org}/copilot/billing/selected_users"],
        cancelCopilotSeatAssignmentForTeams: ["DELETE /orgs/{org}/copilot/billing/selected_teams"],
        cancelCopilotSeatAssignmentForUsers: ["DELETE /orgs/{org}/copilot/billing/selected_users"],
        getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
        getCopilotSeatDetailsForUser: ["GET /orgs/{org}/members/{username}/copilot"],
        listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"],
      },
      dependabot: {
        addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}"],
        createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
        deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
        deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
        getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
        getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/dependabot/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
        listAlertsForEnterprise: ["GET /enterprises/{enterprise}/dependabot/alerts"],
        listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
        listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
        listSelectedReposForOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
        removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
        setSelectedReposForOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
        updateAlert: ["PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
      },
      dependencyGraph: {
        createRepositorySnapshot: ["POST /repos/{owner}/{repo}/dependency-graph/snapshots"],
        diffRange: ["GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"],
        exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"],
      },
      emojis: { get: ["GET /emojis"] },
      gists: {
        checkIsStarred: ["GET /gists/{gist_id}/star"],
        create: ["POST /gists"],
        createComment: ["POST /gists/{gist_id}/comments"],
        delete: ["DELETE /gists/{gist_id}"],
        deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
        fork: ["POST /gists/{gist_id}/forks"],
        get: ["GET /gists/{gist_id}"],
        getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
        getRevision: ["GET /gists/{gist_id}/{sha}"],
        list: ["GET /gists"],
        listComments: ["GET /gists/{gist_id}/comments"],
        listCommits: ["GET /gists/{gist_id}/commits"],
        listForUser: ["GET /users/{username}/gists"],
        listForks: ["GET /gists/{gist_id}/forks"],
        listPublic: ["GET /gists/public"],
        listStarred: ["GET /gists/starred"],
        star: ["PUT /gists/{gist_id}/star"],
        unstar: ["DELETE /gists/{gist_id}/star"],
        update: ["PATCH /gists/{gist_id}"],
        updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"],
      },
      git: {
        createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
        createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
        createRef: ["POST /repos/{owner}/{repo}/git/refs"],
        createTag: ["POST /repos/{owner}/{repo}/git/tags"],
        createTree: ["POST /repos/{owner}/{repo}/git/trees"],
        deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
        getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
        getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
        getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
        getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
        getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
        listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
        updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"],
      },
      gitignore: { getAllTemplates: ["GET /gitignore/templates"], getTemplate: ["GET /gitignore/templates/{name}"] },
      interactions: {
        getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
        getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
        getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
        getRestrictionsForYourPublicRepos: ["GET /user/interaction-limits", {}, { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }],
        removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
        removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
        removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
        removeRestrictionsForYourPublicRepos: ["DELETE /user/interaction-limits", {}, { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }],
        setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
        setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
        setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
        setRestrictionsForYourPublicRepos: ["PUT /user/interaction-limits", {}, { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }],
      },
      issues: {
        addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
        addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
        checkUserCanBeAssignedToIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"],
        create: ["POST /repos/{owner}/{repo}/issues"],
        createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        createLabel: ["POST /repos/{owner}/{repo}/labels"],
        createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
        deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
        deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
        get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
        getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
        getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
        getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
        list: ["GET /issues"],
        listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
        listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
        listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
        listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
        listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],
        listForAuthenticatedUser: ["GET /user/issues"],
        listForOrg: ["GET /orgs/{org}/issues"],
        listForRepo: ["GET /repos/{owner}/{repo}/issues"],
        listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
        listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
        listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
        lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
        removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
        setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
        updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
        updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"],
      },
      licenses: { get: ["GET /licenses/{license}"], getAllCommonlyUsed: ["GET /licenses"], getForRepo: ["GET /repos/{owner}/{repo}/license"] },
      markdown: { render: ["POST /markdown"], renderRaw: ["POST /markdown/raw", { headers: { "content-type": "text/plain; charset=utf-8" } }] },
      meta: { get: ["GET /meta"], getAllVersions: ["GET /versions"], getOctocat: ["GET /octocat"], getZen: ["GET /zen"], root: ["GET /"] },
      migrations: {
        cancelImport: [
          "DELETE /repos/{owner}/{repo}/import",
          {},
          { deprecated: "octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import" },
        ],
        deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive"],
        deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive"],
        downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive"],
        getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive"],
        getCommitAuthors: [
          "GET /repos/{owner}/{repo}/import/authors",
          {},
          {
            deprecated:
              "octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors",
          },
        ],
        getImportStatus: [
          "GET /repos/{owner}/{repo}/import",
          {},
          {
            deprecated:
              "octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status",
          },
        ],
        getLargeFiles: [
          "GET /repos/{owner}/{repo}/import/large_files",
          {},
          { deprecated: "octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files" },
        ],
        getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
        getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
        listForAuthenticatedUser: ["GET /user/migrations"],
        listForOrg: ["GET /orgs/{org}/migrations"],
        listReposForAuthenticatedUser: ["GET /user/migrations/{migration_id}/repositories"],
        listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
        listReposForUser: ["GET /user/migrations/{migration_id}/repositories", {}, { renamed: ["migrations", "listReposForAuthenticatedUser"] }],
        mapCommitAuthor: [
          "PATCH /repos/{owner}/{repo}/import/authors/{author_id}",
          {},
          {
            deprecated:
              "octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author",
          },
        ],
        setLfsPreference: [
          "PATCH /repos/{owner}/{repo}/import/lfs",
          {},
          {
            deprecated:
              "octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference",
          },
        ],
        startForAuthenticatedUser: ["POST /user/migrations"],
        startForOrg: ["POST /orgs/{org}/migrations"],
        startImport: [
          "PUT /repos/{owner}/{repo}/import",
          {},
          { deprecated: "octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import" },
        ],
        unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],
        unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"],
        updateImport: [
          "PATCH /repos/{owner}/{repo}/import",
          {},
          { deprecated: "octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import" },
        ],
      },
      oidc: {
        getOidcCustomSubTemplateForOrg: ["GET /orgs/{org}/actions/oidc/customization/sub"],
        updateOidcCustomSubTemplateForOrg: ["PUT /orgs/{org}/actions/oidc/customization/sub"],
      },
      orgs: {
        addSecurityManagerTeam: ["PUT /orgs/{org}/security-managers/teams/{team_slug}"],
        assignTeamToOrgRole: ["PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
        assignUserToOrgRole: ["PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"],
        blockUser: ["PUT /orgs/{org}/blocks/{username}"],
        cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
        checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
        checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
        checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
        convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
        createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
        createInvitation: ["POST /orgs/{org}/invitations"],
        createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
        createOrUpdateCustomPropertiesValuesForRepos: ["PATCH /orgs/{org}/properties/values"],
        createOrUpdateCustomProperty: ["PUT /orgs/{org}/properties/schema/{custom_property_name}"],
        createWebhook: ["POST /orgs/{org}/hooks"],
        delete: ["DELETE /orgs/{org}"],
        deleteCustomOrganizationRole: ["DELETE /orgs/{org}/organization-roles/{role_id}"],
        deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
        enableOrDisableSecurityProductOnAllOrgRepos: ["POST /orgs/{org}/{security_product}/{enablement}"],
        get: ["GET /orgs/{org}"],
        getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
        getCustomProperty: ["GET /orgs/{org}/properties/schema/{custom_property_name}"],
        getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
        getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
        getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
        getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
        getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
        getWebhookDelivery: ["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],
        list: ["GET /organizations"],
        listAppInstallations: ["GET /orgs/{org}/installations"],
        listBlockedUsers: ["GET /orgs/{org}/blocks"],
        listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
        listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
        listForAuthenticatedUser: ["GET /user/orgs"],
        listForUser: ["GET /users/{username}/orgs"],
        listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
        listMembers: ["GET /orgs/{org}/members"],
        listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
        listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
        listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
        listOrgRoles: ["GET /orgs/{org}/organization-roles"],
        listOrganizationFineGrainedPermissions: ["GET /orgs/{org}/organization-fine-grained-permissions"],
        listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
        listPatGrantRepositories: ["GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"],
        listPatGrantRequestRepositories: ["GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"],
        listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
        listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
        listPendingInvitations: ["GET /orgs/{org}/invitations"],
        listPublicMembers: ["GET /orgs/{org}/public_members"],
        listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
        listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /orgs/{org}/hooks"],
        patchCustomOrganizationRole: ["PATCH /orgs/{org}/organization-roles/{role_id}"],
        pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: ["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
        removeCustomProperty: ["DELETE /orgs/{org}/properties/schema/{custom_property_name}"],
        removeMember: ["DELETE /orgs/{org}/members/{username}"],
        removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
        removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
        removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
        removeSecurityManagerTeam: ["DELETE /orgs/{org}/security-managers/teams/{team_slug}"],
        reviewPatGrantRequest: ["POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"],
        reviewPatGrantRequestsInBulk: ["POST /orgs/{org}/personal-access-token-requests"],
        revokeAllOrgRolesTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}"],
        revokeAllOrgRolesUser: ["DELETE /orgs/{org}/organization-roles/users/{username}"],
        revokeOrgRoleTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
        revokeOrgRoleUser: ["DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"],
        setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
        setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
        unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
        update: ["PATCH /orgs/{org}"],
        updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
        updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
        updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
        updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
        updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"],
      },
      packages: {
        deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
        deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
        deletePackageForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}"],
        deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        deletePackageVersionForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        getAllPackageVersionsForAPackageOwnedByAnOrg: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
          {},
          { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] },
        ],
        getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions",
          {},
          { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"] },
        ],
        getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
        getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
        getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
        getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
        getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
        getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
        getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        listDockerMigrationConflictingPackagesForAuthenticatedUser: ["GET /user/docker/conflicts"],
        listDockerMigrationConflictingPackagesForOrganization: ["GET /orgs/{org}/docker/conflicts"],
        listDockerMigrationConflictingPackagesForUser: ["GET /users/{username}/docker/conflicts"],
        listPackagesForAuthenticatedUser: ["GET /user/packages"],
        listPackagesForOrganization: ["GET /orgs/{org}/packages"],
        listPackagesForUser: ["GET /users/{username}/packages"],
        restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
        restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
        restorePackageForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],
        restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
        restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
        restorePackageVersionForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
      },
      projects: {
        addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
        createCard: ["POST /projects/columns/{column_id}/cards"],
        createColumn: ["POST /projects/{project_id}/columns"],
        createForAuthenticatedUser: ["POST /user/projects"],
        createForOrg: ["POST /orgs/{org}/projects"],
        createForRepo: ["POST /repos/{owner}/{repo}/projects"],
        delete: ["DELETE /projects/{project_id}"],
        deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
        deleteColumn: ["DELETE /projects/columns/{column_id}"],
        get: ["GET /projects/{project_id}"],
        getCard: ["GET /projects/columns/cards/{card_id}"],
        getColumn: ["GET /projects/columns/{column_id}"],
        getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission"],
        listCards: ["GET /projects/columns/{column_id}/cards"],
        listCollaborators: ["GET /projects/{project_id}/collaborators"],
        listColumns: ["GET /projects/{project_id}/columns"],
        listForOrg: ["GET /orgs/{org}/projects"],
        listForRepo: ["GET /repos/{owner}/{repo}/projects"],
        listForUser: ["GET /users/{username}/projects"],
        moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
        moveColumn: ["POST /projects/columns/{column_id}/moves"],
        removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}"],
        update: ["PATCH /projects/{project_id}"],
        updateCard: ["PATCH /projects/columns/cards/{card_id}"],
        updateColumn: ["PATCH /projects/columns/{column_id}"],
      },
      pulls: {
        checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        create: ["POST /repos/{owner}/{repo}/pulls"],
        createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
        createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
        deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
        get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
        getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        list: ["GET /repos/{owner}/{repo}/pulls"],
        listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
        listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
        listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
        listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
        listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
        listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
        update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
        updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],
        updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
      },
      rateLimit: { get: ["GET /rate_limit"] },
      reactions: {
        createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
        createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
        createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
        createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],
        createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
        createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
        deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],
        deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],
        deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],
        deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],
        deleteForRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"],
        deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],
        deleteForTeamDiscussionComment: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}",
        ],
        listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
        listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
        listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
        listForRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}/reactions"],
        listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
        listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
      },
      repos: {
        acceptInvitation: ["PATCH /user/repository_invitations/{invitation_id}", {}, { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }],
        acceptInvitationForAuthenticatedUser: ["PATCH /user/repository_invitations/{invitation_id}"],
        addAppAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, { mapToData: "apps" }],
        addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
        addStatusCheckContexts: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, { mapToData: "contexts" }],
        addTeamAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, { mapToData: "teams" }],
        addUserAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, { mapToData: "users" }],
        cancelPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"],
        checkAutomatedSecurityFixes: ["GET /repos/{owner}/{repo}/automated-security-fixes"],
        checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
        checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts"],
        codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
        compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
        compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
        createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
        createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
        createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
        createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
        createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
        createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
        createDeploymentBranchPolicy: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
        createDeploymentProtectionRule: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
        createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
        createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
        createForAuthenticatedUser: ["POST /user/repos"],
        createFork: ["POST /repos/{owner}/{repo}/forks"],
        createInOrg: ["POST /orgs/{org}/repos"],
        createOrUpdateCustomPropertiesValues: ["PATCH /repos/{owner}/{repo}/properties/values"],
        createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
        createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
        createOrgRuleset: ["POST /orgs/{org}/rulesets"],
        createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
        createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
        createRelease: ["POST /repos/{owner}/{repo}/releases"],
        createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
        createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
        createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate"],
        createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
        declineInvitation: ["DELETE /user/repository_invitations/{invitation_id}", {}, { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }],
        declineInvitationForAuthenticatedUser: ["DELETE /user/repository_invitations/{invitation_id}"],
        delete: ["DELETE /repos/{owner}/{repo}"],
        deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
        deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
        deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
        deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
        deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
        deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
        deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
        deleteDeploymentBranchPolicy: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
        deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
        deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
        deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
        deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
        deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
        deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        deleteTagProtection: ["DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"],
        deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
        disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes"],
        disableDeploymentProtectionRule: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
        disablePrivateVulnerabilityReporting: ["DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"],
        disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],
        downloadArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}", {}, { renamed: ["repos", "downloadZipballArchive"] }],
        downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
        downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
        enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes"],
        enablePrivateVulnerabilityReporting: ["PUT /repos/{owner}/{repo}/private-vulnerability-reporting"],
        enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts"],
        generateReleaseNotes: ["POST /repos/{owner}/{repo}/releases/generate-notes"],
        get: ["GET /repos/{owner}/{repo}"],
        getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
        getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        getAllDeploymentProtectionRules: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
        getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
        getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
        getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
        getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
        getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
        getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
        getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
        getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
        getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
        getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
        getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
        getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
        getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
        getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
        getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
        getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
        getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
        getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
        getCustomDeploymentProtectionRule: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
        getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
        getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
        getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
        getDeploymentBranchPolicy: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
        getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
        getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
        getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
        getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
        getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
        getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
        getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
        getOrgRulesets: ["GET /orgs/{org}/rulesets"],
        getPages: ["GET /repos/{owner}/{repo}/pages"],
        getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
        getPagesDeployment: ["GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"],
        getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
        getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
        getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
        getReadme: ["GET /repos/{owner}/{repo}/readme"],
        getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
        getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
        getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
        getRepoRuleSuite: ["GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"],
        getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
        getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
        getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
        getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
        getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
        getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
        getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
        getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
        getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
        getWebhookDelivery: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],
        listActivities: ["GET /repos/{owner}/{repo}/activity"],
        listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
        listBranches: ["GET /repos/{owner}/{repo}/branches"],
        listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],
        listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
        listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
        listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
        listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
        listCommits: ["GET /repos/{owner}/{repo}/commits"],
        listContributors: ["GET /repos/{owner}/{repo}/contributors"],
        listCustomDeploymentRuleIntegrations: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"],
        listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
        listDeploymentBranchPolicies: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
        listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
        listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
        listForAuthenticatedUser: ["GET /user/repos"],
        listForOrg: ["GET /orgs/{org}/repos"],
        listForUser: ["GET /users/{username}/repos"],
        listForks: ["GET /repos/{owner}/{repo}/forks"],
        listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
        listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
        listLanguages: ["GET /repos/{owner}/{repo}/languages"],
        listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
        listPublic: ["GET /repositories"],
        listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],
        listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
        listReleases: ["GET /repos/{owner}/{repo}/releases"],
        listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
        listTags: ["GET /repos/{owner}/{repo}/tags"],
        listTeams: ["GET /repos/{owner}/{repo}/teams"],
        listWebhookDeliveries: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
        merge: ["POST /repos/{owner}/{repo}/merges"],
        mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
        pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
        removeAppAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, { mapToData: "apps" }],
        removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
        removeStatusCheckContexts: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, { mapToData: "contexts" }],
        removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        removeTeamAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, { mapToData: "teams" }],
        removeUserAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, { mapToData: "users" }],
        renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
        replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
        requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
        setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        setAppAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, { mapToData: "apps" }],
        setStatusCheckContexts: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, { mapToData: "contexts" }],
        setTeamAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, { mapToData: "teams" }],
        setUserAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, { mapToData: "users" }],
        testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
        transfer: ["POST /repos/{owner}/{repo}/transfer"],
        update: ["PATCH /repos/{owner}/{repo}"],
        updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
        updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
        updateDeploymentBranchPolicy: ["PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
        updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
        updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
        updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
        updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
        updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        updateStatusCheckPotection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
          {},
          { renamed: ["repos", "updateStatusCheckProtection"] },
        ],
        updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
        updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
        uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", { baseUrl: "https://uploads.github.com" }],
      },
      search: {
        code: ["GET /search/code"],
        commits: ["GET /search/commits"],
        issuesAndPullRequests: ["GET /search/issues"],
        labels: ["GET /search/labels"],
        repos: ["GET /search/repositories"],
        topics: ["GET /search/topics"],
        users: ["GET /search/users"],
      },
      secretScanning: {
        getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
        listAlertsForEnterprise: ["GET /enterprises/{enterprise}/secret-scanning/alerts"],
        listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
        listLocationsForAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"],
        updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
      },
      securityAdvisories: {
        createFork: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"],
        createPrivateVulnerabilityReport: ["POST /repos/{owner}/{repo}/security-advisories/reports"],
        createRepositoryAdvisory: ["POST /repos/{owner}/{repo}/security-advisories"],
        createRepositoryAdvisoryCveRequest: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"],
        getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
        getRepositoryAdvisory: ["GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"],
        listGlobalAdvisories: ["GET /advisories"],
        listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
        listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
        updateRepositoryAdvisory: ["PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"],
      },
      teams: {
        addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
        addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
        checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        create: ["POST /orgs/{org}/teams"],
        createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
        createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
        deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
        getByName: ["GET /orgs/{org}/teams/{team_slug}"],
        getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        list: ["GET /orgs/{org}/teams"],
        listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
        listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
        listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
        listForAuthenticatedUser: ["GET /user/teams"],
        listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
        listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
        listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
        listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
        removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
        removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"],
      },
      users: {
        addEmailForAuthenticated: ["POST /user/emails", {}, { renamed: ["users", "addEmailForAuthenticatedUser"] }],
        addEmailForAuthenticatedUser: ["POST /user/emails"],
        addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
        block: ["PUT /user/blocks/{username}"],
        checkBlocked: ["GET /user/blocks/{username}"],
        checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
        checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
        createGpgKeyForAuthenticated: ["POST /user/gpg_keys", {}, { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }],
        createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
        createPublicSshKeyForAuthenticated: ["POST /user/keys", {}, { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }],
        createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
        createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
        deleteEmailForAuthenticated: ["DELETE /user/emails", {}, { renamed: ["users", "deleteEmailForAuthenticatedUser"] }],
        deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
        deleteGpgKeyForAuthenticated: ["DELETE /user/gpg_keys/{gpg_key_id}", {}, { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }],
        deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
        deletePublicSshKeyForAuthenticated: ["DELETE /user/keys/{key_id}", {}, { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }],
        deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
        deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
        deleteSshSigningKeyForAuthenticatedUser: ["DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"],
        follow: ["PUT /user/following/{username}"],
        getAuthenticated: ["GET /user"],
        getByUsername: ["GET /users/{username}"],
        getContextForUser: ["GET /users/{username}/hovercard"],
        getGpgKeyForAuthenticated: ["GET /user/gpg_keys/{gpg_key_id}", {}, { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }],
        getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
        getPublicSshKeyForAuthenticated: ["GET /user/keys/{key_id}", {}, { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }],
        getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
        getSshSigningKeyForAuthenticatedUser: ["GET /user/ssh_signing_keys/{ssh_signing_key_id}"],
        list: ["GET /users"],
        listBlockedByAuthenticated: ["GET /user/blocks", {}, { renamed: ["users", "listBlockedByAuthenticatedUser"] }],
        listBlockedByAuthenticatedUser: ["GET /user/blocks"],
        listEmailsForAuthenticated: ["GET /user/emails", {}, { renamed: ["users", "listEmailsForAuthenticatedUser"] }],
        listEmailsForAuthenticatedUser: ["GET /user/emails"],
        listFollowedByAuthenticated: ["GET /user/following", {}, { renamed: ["users", "listFollowedByAuthenticatedUser"] }],
        listFollowedByAuthenticatedUser: ["GET /user/following"],
        listFollowersForAuthenticatedUser: ["GET /user/followers"],
        listFollowersForUser: ["GET /users/{username}/followers"],
        listFollowingForUser: ["GET /users/{username}/following"],
        listGpgKeysForAuthenticated: ["GET /user/gpg_keys", {}, { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }],
        listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
        listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
        listPublicEmailsForAuthenticated: ["GET /user/public_emails", {}, { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }],
        listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
        listPublicKeysForUser: ["GET /users/{username}/keys"],
        listPublicSshKeysForAuthenticated: ["GET /user/keys", {}, { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }],
        listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
        listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
        listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
        listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
        listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
        setPrimaryEmailVisibilityForAuthenticated: [
          "PATCH /user/email/visibility",
          {},
          { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] },
        ],
        setPrimaryEmailVisibilityForAuthenticatedUser: ["PATCH /user/email/visibility"],
        unblock: ["DELETE /user/blocks/{username}"],
        unfollow: ["DELETE /user/following/{username}"],
        updateAuthenticated: ["PATCH /user"],
      },
    };
    var A = a;
    var c = new Map();
    for (const [e, t] of Object.entries(A)) {
      for (const [r, n] of Object.entries(t)) {
        const [t, o, s] = n;
        const [i, a] = t.split(/ /);
        const A = Object.assign({ method: i, url: a }, o);
        if (!c.has(e)) {
          c.set(e, new Map());
        }
        c.get(e).set(r, { scope: e, methodName: r, endpointDefaults: A, decorations: s });
      }
    }
    var u = {
      has({ scope: e }, t) {
        return c.get(e).has(t);
      },
      getOwnPropertyDescriptor(e, t) {
        return { value: this.get(e, t), configurable: true, writable: true, enumerable: true };
      },
      defineProperty(e, t, r) {
        Object.defineProperty(e.cache, t, r);
        return true;
      },
      deleteProperty(e, t) {
        delete e.cache[t];
        return true;
      },
      ownKeys({ scope: e }) {
        return [...c.get(e).keys()];
      },
      set(e, t, r) {
        return (e.cache[t] = r);
      },
      get({ octokit: e, scope: t, cache: r }, n) {
        if (r[n]) {
          return r[n];
        }
        const o = c.get(t).get(n);
        if (!o) {
          return void 0;
        }
        const { endpointDefaults: s, decorations: i } = o;
        if (i) {
          r[n] = decorate(e, t, n, s, i);
        } else {
          r[n] = e.request.defaults(s);
        }
        return r[n];
      },
    };
    function endpointsToMethods(e) {
      const t = {};
      for (const r of c.keys()) {
        t[r] = new Proxy({ octokit: e, scope: r, cache: {} }, u);
      }
      return t;
    }
    function decorate(e, t, r, n, o) {
      const s = e.request.defaults(n);
      function withDecorations(...n) {
        let i = s.endpoint.merge(...n);
        if (o.mapToData) {
          i = Object.assign({}, i, { data: i[o.mapToData], [o.mapToData]: void 0 });
          return s(i);
        }
        if (o.renamed) {
          const [n, s] = o.renamed;
          e.log.warn(`octokit.${t}.${r}() has been renamed to octokit.${n}.${s}()`);
        }
        if (o.deprecated) {
          e.log.warn(o.deprecated);
        }
        if (o.renamedParameters) {
          const i = s.endpoint.merge(...n);
          for (const [n, s] of Object.entries(o.renamedParameters)) {
            if (n in i) {
              e.log.warn(`"${n}" parameter is deprecated for "octokit.${t}.${r}()". Use "${s}" instead`);
              if (!(s in i)) {
                i[s] = i[n];
              }
              delete i[n];
            }
          }
          return s(i);
        }
        return s(...n);
      }
      return Object.assign(withDecorations, s);
    }
    function restEndpointMethods(e) {
      const t = endpointsToMethods(e);
      return { rest: t };
    }
    restEndpointMethods.VERSION = i;
    function legacyRestEndpointMethods(e) {
      const t = endpointsToMethods(e);
      return { ...t, rest: t };
    }
    legacyRestEndpointMethods.VERSION = i;
    0 && 0;
  },
  44552: function (e, t) {
    var r =
      (this && this.__awaiter) ||
      function (e, t, r, n) {
        function adopt(e) {
          return e instanceof r
            ? e
            : new r(function (t) {
                t(e);
              });
        }
        return new (r || (r = Promise))(function (r, o) {
          function fulfilled(e) {
            try {
              step(n.next(e));
            } catch (e) {
              o(e);
            }
          }
          function rejected(e) {
            try {
              step(n["throw"](e));
            } catch (e) {
              o(e);
            }
          }
          function step(e) {
            e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
          }
          step((n = n.apply(e, t || [])).next());
        });
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.PersonalAccessTokenCredentialHandler = t.BearerCredentialHandler = t.BasicCredentialHandler = void 0;
    class BasicCredentialHandler {
      constructor(e, t) {
        this.username = e;
        this.password = t;
      }
      prepareRequest(e) {
        if (!e.headers) {
          throw Error("The request has no headers");
        }
        e.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
      }
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return r(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    }
    t.BasicCredentialHandler = BasicCredentialHandler;
    class BearerCredentialHandler {
      constructor(e) {
        this.token = e;
      }
      prepareRequest(e) {
        if (!e.headers) {
          throw Error("The request has no headers");
        }
        e.headers["Authorization"] = `Bearer ${this.token}`;
      }
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return r(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    }
    t.BearerCredentialHandler = BearerCredentialHandler;
    class PersonalAccessTokenCredentialHandler {
      constructor(e) {
        this.token = e;
      }
      prepareRequest(e) {
        if (!e.headers) {
          throw Error("The request has no headers");
        }
        e.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
      }
      canHandleAuthentication() {
        return false;
      }
      handleAuthentication() {
        return r(this, void 0, void 0, function* () {
          throw new Error("not implemented");
        });
      }
    }
    t.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  },
  54844: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__setModuleDefault) ||
      (Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          }
        : function (e, t) {
            e["default"] = t;
          });
    var s =
      (this && this.__importStar) ||
      function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null) for (var r in e) if (r !== "default" && Object.prototype.hasOwnProperty.call(e, r)) n(t, e, r);
        o(t, e);
        return t;
      };
    var i =
      (this && this.__awaiter) ||
      function (e, t, r, n) {
        function adopt(e) {
          return e instanceof r
            ? e
            : new r(function (t) {
                t(e);
              });
        }
        return new (r || (r = Promise))(function (r, o) {
          function fulfilled(e) {
            try {
              step(n.next(e));
            } catch (e) {
              o(e);
            }
          }
          function rejected(e) {
            try {
              step(n["throw"](e));
            } catch (e) {
              o(e);
            }
          }
          function step(e) {
            e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
          }
          step((n = n.apply(e, t || [])).next());
        });
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.HttpClient = t.isHttps = t.HttpClientResponse = t.HttpClientError = t.getProxyUrl = t.MediaTypes = t.Headers = t.HttpCodes = void 0;
    const a = s(r(58611));
    const A = s(r(65692));
    const c = s(r(54988));
    const u = s(r(20770));
    const l = r(46752);
    var p;
    (function (e) {
      e[(e["OK"] = 200)] = "OK";
      e[(e["MultipleChoices"] = 300)] = "MultipleChoices";
      e[(e["MovedPermanently"] = 301)] = "MovedPermanently";
      e[(e["ResourceMoved"] = 302)] = "ResourceMoved";
      e[(e["SeeOther"] = 303)] = "SeeOther";
      e[(e["NotModified"] = 304)] = "NotModified";
      e[(e["UseProxy"] = 305)] = "UseProxy";
      e[(e["SwitchProxy"] = 306)] = "SwitchProxy";
      e[(e["TemporaryRedirect"] = 307)] = "TemporaryRedirect";
      e[(e["PermanentRedirect"] = 308)] = "PermanentRedirect";
      e[(e["BadRequest"] = 400)] = "BadRequest";
      e[(e["Unauthorized"] = 401)] = "Unauthorized";
      e[(e["PaymentRequired"] = 402)] = "PaymentRequired";
      e[(e["Forbidden"] = 403)] = "Forbidden";
      e[(e["NotFound"] = 404)] = "NotFound";
      e[(e["MethodNotAllowed"] = 405)] = "MethodNotAllowed";
      e[(e["NotAcceptable"] = 406)] = "NotAcceptable";
      e[(e["ProxyAuthenticationRequired"] = 407)] = "ProxyAuthenticationRequired";
      e[(e["RequestTimeout"] = 408)] = "RequestTimeout";
      e[(e["Conflict"] = 409)] = "Conflict";
      e[(e["Gone"] = 410)] = "Gone";
      e[(e["TooManyRequests"] = 429)] = "TooManyRequests";
      e[(e["InternalServerError"] = 500)] = "InternalServerError";
      e[(e["NotImplemented"] = 501)] = "NotImplemented";
      e[(e["BadGateway"] = 502)] = "BadGateway";
      e[(e["ServiceUnavailable"] = 503)] = "ServiceUnavailable";
      e[(e["GatewayTimeout"] = 504)] = "GatewayTimeout";
    })(p || (t.HttpCodes = p = {}));
    var d;
    (function (e) {
      e["Accept"] = "accept";
      e["ContentType"] = "content-type";
    })(d || (t.Headers = d = {}));
    var g;
    (function (e) {
      e["ApplicationJson"] = "application/json";
    })(g || (t.MediaTypes = g = {}));
    function getProxyUrl(e) {
      const t = c.getProxyUrl(new URL(e));
      return t ? t.href : "";
    }
    t.getProxyUrl = getProxyUrl;
    const m = [p.MovedPermanently, p.ResourceMoved, p.SeeOther, p.TemporaryRedirect, p.PermanentRedirect];
    const h = [p.BadGateway, p.ServiceUnavailable, p.GatewayTimeout];
    const E = ["OPTIONS", "GET", "DELETE", "HEAD"];
    const I = 10;
    const y = 5;
    class HttpClientError extends Error {
      constructor(e, t) {
        super(e);
        this.name = "HttpClientError";
        this.statusCode = t;
        Object.setPrototypeOf(this, HttpClientError.prototype);
      }
    }
    t.HttpClientError = HttpClientError;
    class HttpClientResponse {
      constructor(e) {
        this.message = e;
      }
      readBody() {
        return i(this, void 0, void 0, function* () {
          return new Promise((e) =>
            i(this, void 0, void 0, function* () {
              let t = Buffer.alloc(0);
              this.message.on("data", (e) => {
                t = Buffer.concat([t, e]);
              });
              this.message.on("end", () => {
                e(t.toString());
              });
            })
          );
        });
      }
      readBodyBuffer() {
        return i(this, void 0, void 0, function* () {
          return new Promise((e) =>
            i(this, void 0, void 0, function* () {
              const t = [];
              this.message.on("data", (e) => {
                t.push(e);
              });
              this.message.on("end", () => {
                e(Buffer.concat(t));
              });
            })
          );
        });
      }
    }
    t.HttpClientResponse = HttpClientResponse;
    function isHttps(e) {
      const t = new URL(e);
      return t.protocol === "https:";
    }
    t.isHttps = isHttps;
    class HttpClient {
      constructor(e, t, r) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = e;
        this.handlers = t || [];
        this.requestOptions = r;
        if (r) {
          if (r.ignoreSslError != null) {
            this._ignoreSslError = r.ignoreSslError;
          }
          this._socketTimeout = r.socketTimeout;
          if (r.allowRedirects != null) {
            this._allowRedirects = r.allowRedirects;
          }
          if (r.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = r.allowRedirectDowngrade;
          }
          if (r.maxRedirects != null) {
            this._maxRedirects = Math.max(r.maxRedirects, 0);
          }
          if (r.keepAlive != null) {
            this._keepAlive = r.keepAlive;
          }
          if (r.allowRetries != null) {
            this._allowRetries = r.allowRetries;
          }
          if (r.maxRetries != null) {
            this._maxRetries = r.maxRetries;
          }
        }
      }
      options(e, t) {
        return i(this, void 0, void 0, function* () {
          return this.request("OPTIONS", e, null, t || {});
        });
      }
      get(e, t) {
        return i(this, void 0, void 0, function* () {
          return this.request("GET", e, null, t || {});
        });
      }
      del(e, t) {
        return i(this, void 0, void 0, function* () {
          return this.request("DELETE", e, null, t || {});
        });
      }
      post(e, t, r) {
        return i(this, void 0, void 0, function* () {
          return this.request("POST", e, t, r || {});
        });
      }
      patch(e, t, r) {
        return i(this, void 0, void 0, function* () {
          return this.request("PATCH", e, t, r || {});
        });
      }
      put(e, t, r) {
        return i(this, void 0, void 0, function* () {
          return this.request("PUT", e, t, r || {});
        });
      }
      head(e, t) {
        return i(this, void 0, void 0, function* () {
          return this.request("HEAD", e, null, t || {});
        });
      }
      sendStream(e, t, r, n) {
        return i(this, void 0, void 0, function* () {
          return this.request(e, t, r, n);
        });
      }
      getJson(e, t = {}) {
        return i(this, void 0, void 0, function* () {
          t[d.Accept] = this._getExistingOrDefaultHeader(t, d.Accept, g.ApplicationJson);
          const r = yield this.get(e, t);
          return this._processResponse(r, this.requestOptions);
        });
      }
      postJson(e, t, r = {}) {
        return i(this, void 0, void 0, function* () {
          const n = JSON.stringify(t, null, 2);
          r[d.Accept] = this._getExistingOrDefaultHeader(r, d.Accept, g.ApplicationJson);
          r[d.ContentType] = this._getExistingOrDefaultHeader(r, d.ContentType, g.ApplicationJson);
          const o = yield this.post(e, n, r);
          return this._processResponse(o, this.requestOptions);
        });
      }
      putJson(e, t, r = {}) {
        return i(this, void 0, void 0, function* () {
          const n = JSON.stringify(t, null, 2);
          r[d.Accept] = this._getExistingOrDefaultHeader(r, d.Accept, g.ApplicationJson);
          r[d.ContentType] = this._getExistingOrDefaultHeader(r, d.ContentType, g.ApplicationJson);
          const o = yield this.put(e, n, r);
          return this._processResponse(o, this.requestOptions);
        });
      }
      patchJson(e, t, r = {}) {
        return i(this, void 0, void 0, function* () {
          const n = JSON.stringify(t, null, 2);
          r[d.Accept] = this._getExistingOrDefaultHeader(r, d.Accept, g.ApplicationJson);
          r[d.ContentType] = this._getExistingOrDefaultHeader(r, d.ContentType, g.ApplicationJson);
          const o = yield this.patch(e, n, r);
          return this._processResponse(o, this.requestOptions);
        });
      }
      request(e, t, r, n) {
        return i(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          const o = new URL(t);
          let s = this._prepareRequest(e, o, n);
          const i = this._allowRetries && E.includes(e) ? this._maxRetries + 1 : 1;
          let a = 0;
          let A;
          do {
            A = yield this.requestRaw(s, r);
            if (A && A.message && A.message.statusCode === p.Unauthorized) {
              let e;
              for (const t of this.handlers) {
                if (t.canHandleAuthentication(A)) {
                  e = t;
                  break;
                }
              }
              if (e) {
                return e.handleAuthentication(this, s, r);
              } else {
                return A;
              }
            }
            let t = this._maxRedirects;
            while (A.message.statusCode && m.includes(A.message.statusCode) && this._allowRedirects && t > 0) {
              const i = A.message.headers["location"];
              if (!i) {
                break;
              }
              const a = new URL(i);
              if (o.protocol === "https:" && o.protocol !== a.protocol && !this._allowRedirectDowngrade) {
                throw new Error(
                  "Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true."
                );
              }
              yield A.readBody();
              if (a.hostname !== o.hostname) {
                for (const e in n) {
                  if (e.toLowerCase() === "authorization") {
                    delete n[e];
                  }
                }
              }
              s = this._prepareRequest(e, a, n);
              A = yield this.requestRaw(s, r);
              t--;
            }
            if (!A.message.statusCode || !h.includes(A.message.statusCode)) {
              return A;
            }
            a += 1;
            if (a < i) {
              yield A.readBody();
              yield this._performExponentialBackoff(a);
            }
          } while (a < i);
          return A;
        });
      }
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      requestRaw(e, t) {
        return i(this, void 0, void 0, function* () {
          return new Promise((r, n) => {
            function callbackForResult(e, t) {
              if (e) {
                n(e);
              } else if (!t) {
                n(new Error("Unknown error"));
              } else {
                r(t);
              }
            }
            this.requestRawWithCallback(e, t, callbackForResult);
          });
        });
      }
      requestRawWithCallback(e, t, r) {
        if (typeof t === "string") {
          if (!e.options.headers) {
            e.options.headers = {};
          }
          e.options.headers["Content-Length"] = Buffer.byteLength(t, "utf8");
        }
        let n = false;
        function handleResult(e, t) {
          if (!n) {
            n = true;
            r(e, t);
          }
        }
        const o = e.httpModule.request(e.options, (e) => {
          const t = new HttpClientResponse(e);
          handleResult(undefined, t);
        });
        let s;
        o.on("socket", (e) => {
          s = e;
        });
        o.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (s) {
            s.end();
          }
          handleResult(new Error(`Request timeout: ${e.options.path}`));
        });
        o.on("error", function (e) {
          handleResult(e);
        });
        if (t && typeof t === "string") {
          o.write(t, "utf8");
        }
        if (t && typeof t !== "string") {
          t.on("close", function () {
            o.end();
          });
          t.pipe(o);
        } else {
          o.end();
        }
      }
      getAgent(e) {
        const t = new URL(e);
        return this._getAgent(t);
      }
      getAgentDispatcher(e) {
        const t = new URL(e);
        const r = c.getProxyUrl(t);
        const n = r && r.hostname;
        if (!n) {
          return;
        }
        return this._getProxyAgentDispatcher(t, r);
      }
      _prepareRequest(e, t, r) {
        const n = {};
        n.parsedUrl = t;
        const o = n.parsedUrl.protocol === "https:";
        n.httpModule = o ? A : a;
        const s = o ? 443 : 80;
        n.options = {};
        n.options.host = n.parsedUrl.hostname;
        n.options.port = n.parsedUrl.port ? parseInt(n.parsedUrl.port) : s;
        n.options.path = (n.parsedUrl.pathname || "") + (n.parsedUrl.search || "");
        n.options.method = e;
        n.options.headers = this._mergeHeaders(r);
        if (this.userAgent != null) {
          n.options.headers["user-agent"] = this.userAgent;
        }
        n.options.agent = this._getAgent(n.parsedUrl);
        if (this.handlers) {
          for (const e of this.handlers) {
            e.prepareRequest(n.options);
          }
        }
        return n;
      }
      _mergeHeaders(e) {
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(e || {}));
        }
        return lowercaseKeys(e || {});
      }
      _getExistingOrDefaultHeader(e, t, r) {
        let n;
        if (this.requestOptions && this.requestOptions.headers) {
          n = lowercaseKeys(this.requestOptions.headers)[t];
        }
        return e[t] || n || r;
      }
      _getAgent(e) {
        let t;
        const r = c.getProxyUrl(e);
        const n = r && r.hostname;
        if (this._keepAlive && n) {
          t = this._proxyAgent;
        }
        if (!n) {
          t = this._agent;
        }
        if (t) {
          return t;
        }
        const o = e.protocol === "https:";
        let s = 100;
        if (this.requestOptions) {
          s = this.requestOptions.maxSockets || a.globalAgent.maxSockets;
        }
        if (r && r.hostname) {
          const e = {
            maxSockets: s,
            keepAlive: this._keepAlive,
            proxy: Object.assign(Object.assign({}, (r.username || r.password) && { proxyAuth: `${r.username}:${r.password}` }), {
              host: r.hostname,
              port: r.port,
            }),
          };
          let n;
          const i = r.protocol === "https:";
          if (o) {
            n = i ? u.httpsOverHttps : u.httpsOverHttp;
          } else {
            n = i ? u.httpOverHttps : u.httpOverHttp;
          }
          t = n(e);
          this._proxyAgent = t;
        }
        if (!t) {
          const e = { keepAlive: this._keepAlive, maxSockets: s };
          t = o ? new A.Agent(e) : new a.Agent(e);
          this._agent = t;
        }
        if (o && this._ignoreSslError) {
          t.options = Object.assign(t.options || {}, { rejectUnauthorized: false });
        }
        return t;
      }
      _getProxyAgentDispatcher(e, t) {
        let r;
        if (this._keepAlive) {
          r = this._proxyAgentDispatcher;
        }
        if (r) {
          return r;
        }
        const n = e.protocol === "https:";
        r = new l.ProxyAgent(
          Object.assign({ uri: t.href, pipelining: !this._keepAlive ? 0 : 1 }, (t.username || t.password) && { token: `${t.username}:${t.password}` })
        );
        this._proxyAgentDispatcher = r;
        if (n && this._ignoreSslError) {
          r.options = Object.assign(r.options.requestTls || {}, { rejectUnauthorized: false });
        }
        return r;
      }
      _performExponentialBackoff(e) {
        return i(this, void 0, void 0, function* () {
          e = Math.min(I, e);
          const t = y * Math.pow(2, e);
          return new Promise((e) => setTimeout(() => e(), t));
        });
      }
      _processResponse(e, t) {
        return i(this, void 0, void 0, function* () {
          return new Promise((r, n) =>
            i(this, void 0, void 0, function* () {
              const o = e.message.statusCode || 0;
              const s = { statusCode: o, result: null, headers: {} };
              if (o === p.NotFound) {
                r(s);
              }
              function dateTimeDeserializer(e, t) {
                if (typeof t === "string") {
                  const e = new Date(t);
                  if (!isNaN(e.valueOf())) {
                    return e;
                  }
                }
                return t;
              }
              let i;
              let a;
              try {
                a = yield e.readBody();
                if (a && a.length > 0) {
                  if (t && t.deserializeDates) {
                    i = JSON.parse(a, dateTimeDeserializer);
                  } else {
                    i = JSON.parse(a);
                  }
                  s.result = i;
                }
                s.headers = e.message.headers;
              } catch (e) {}
              if (o > 299) {
                let e;
                if (i && i.message) {
                  e = i.message;
                } else if (a && a.length > 0) {
                  e = a;
                } else {
                  e = `Failed request: (${o})`;
                }
                const t = new HttpClientError(e, o);
                t.result = s.result;
                n(t);
              } else {
                r(s);
              }
            })
          );
        });
      }
    }
    t.HttpClient = HttpClient;
    const lowercaseKeys = (e) => Object.keys(e).reduce((t, r) => ((t[r.toLowerCase()] = e[r]), t), {});
  },
  54988: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.checkBypass = t.getProxyUrl = void 0;
    function getProxyUrl(e) {
      const t = e.protocol === "https:";
      if (checkBypass(e)) {
        return undefined;
      }
      const r = (() => {
        if (t) {
          return process.env["https_proxy"] || process.env["HTTPS_PROXY"];
        } else {
          return process.env["http_proxy"] || process.env["HTTP_PROXY"];
        }
      })();
      if (r) {
        try {
          return new URL(r);
        } catch (e) {
          if (!r.startsWith("http://") && !r.startsWith("https://")) return new URL(`http://${r}`);
        }
      } else {
        return undefined;
      }
    }
    t.getProxyUrl = getProxyUrl;
    function checkBypass(e) {
      if (!e.hostname) {
        return false;
      }
      const t = e.hostname;
      if (isLoopbackAddress(t)) {
        return true;
      }
      const r = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
      if (!r) {
        return false;
      }
      let n;
      if (e.port) {
        n = Number(e.port);
      } else if (e.protocol === "http:") {
        n = 80;
      } else if (e.protocol === "https:") {
        n = 443;
      }
      const o = [e.hostname.toUpperCase()];
      if (typeof n === "number") {
        o.push(`${o[0]}:${n}`);
      }
      for (const e of r
        .split(",")
        .map((e) => e.trim().toUpperCase())
        .filter((e) => e)) {
        if (e === "*" || o.some((t) => t === e || t.endsWith(`.${e}`) || (e.startsWith(".") && t.endsWith(`${e}`)))) {
          return true;
        }
      }
      return false;
    }
    t.checkBypass = checkBypass;
    function isLoopbackAddress(e) {
      const t = e.toLowerCase();
      return t === "localhost" || t.startsWith("127.") || t.startsWith("[::1]") || t.startsWith("[0:0:0:0:0:0:0:1]");
    }
  },
  77864: (e) => {
    var t = Object.defineProperty;
    var r = Object.getOwnPropertyDescriptor;
    var n = Object.getOwnPropertyNames;
    var o = Object.prototype.hasOwnProperty;
    var __export = (e, r) => {
      for (var n in r) t(e, n, { get: r[n], enumerable: true });
    };
    var __copyProps = (e, s, i, a) => {
      if ((s && typeof s === "object") || typeof s === "function") {
        for (let A of n(s)) if (!o.call(e, A) && A !== i) t(e, A, { get: () => s[A], enumerable: !(a = r(s, A)) || a.enumerable });
      }
      return e;
    };
    var __toCommonJS = (e) => __copyProps(t({}, "__esModule", { value: true }), e);
    var s = {};
    __export(s, { createTokenAuth: () => c });
    e.exports = __toCommonJS(s);
    var i = /^v1\./;
    var a = /^ghs_/;
    var A = /^ghu_/;
    async function auth(e) {
      const t = e.split(/\./).length === 3;
      const r = i.test(e) || a.test(e);
      const n = A.test(e);
      const o = t ? "app" : r ? "installation" : n ? "user-to-server" : "oauth";
      return { type: "token", token: e, tokenType: o };
    }
    function withAuthorizationPrefix(e) {
      if (e.split(/\./).length === 3) {
        return `bearer ${e}`;
      }
      return `token ${e}`;
    }
    async function hook(e, t, r, n) {
      const o = t.endpoint.merge(r, n);
      o.headers.authorization = withAuthorizationPrefix(e);
      return t(o);
    }
    var c = function createTokenAuth2(e) {
      if (!e) {
        throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
      }
      if (typeof e !== "string") {
        throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
      }
      e = e.replace(/^(token|bearer) +/i, "");
      return Object.assign(auth.bind(null, e), { hook: hook.bind(null, e) });
    };
    0 && 0;
  },
  61897: (e, t, r) => {
    var n = Object.defineProperty;
    var o = Object.getOwnPropertyDescriptor;
    var s = Object.getOwnPropertyNames;
    var i = Object.prototype.hasOwnProperty;
    var __export = (e, t) => {
      for (var r in t) n(e, r, { get: t[r], enumerable: true });
    };
    var __copyProps = (e, t, r, a) => {
      if ((t && typeof t === "object") || typeof t === "function") {
        for (let A of s(t)) if (!i.call(e, A) && A !== r) n(e, A, { get: () => t[A], enumerable: !(a = o(t, A)) || a.enumerable });
      }
      return e;
    };
    var __toCommonJS = (e) => __copyProps(n({}, "__esModule", { value: true }), e);
    var a = {};
    __export(a, { Octokit: () => E });
    e.exports = __toCommonJS(a);
    var A = r(33843);
    var c = r(52732);
    var u = r(66255);
    var l = r(70007);
    var p = r(77864);
    var d = "5.2.0";
    var noop = () => {};
    var g = console.warn.bind(console);
    var m = console.error.bind(console);
    var h = `octokit-core.js/${d} ${(0, A.getUserAgent)()}`;
    var E = class {
      static {
        this.VERSION = d;
      }
      static defaults(e) {
        const t = class extends this {
          constructor(...t) {
            const r = t[0] || {};
            if (typeof e === "function") {
              super(e(r));
              return;
            }
            super(Object.assign({}, e, r, r.userAgent && e.userAgent ? { userAgent: `${r.userAgent} ${e.userAgent}` } : null));
          }
        };
        return t;
      }
      static {
        this.plugins = [];
      }
      static plugin(...e) {
        const t = this.plugins;
        const r = class extends this {
          static {
            this.plugins = t.concat(e.filter((e) => !t.includes(e)));
          }
        };
        return r;
      }
      constructor(e = {}) {
        const t = new c.Collection();
        const r = {
          baseUrl: u.request.endpoint.DEFAULTS.baseUrl,
          headers: {},
          request: Object.assign({}, e.request, { hook: t.bind(null, "request") }),
          mediaType: { previews: [], format: "" },
        };
        r.headers["user-agent"] = e.userAgent ? `${e.userAgent} ${h}` : h;
        if (e.baseUrl) {
          r.baseUrl = e.baseUrl;
        }
        if (e.previews) {
          r.mediaType.previews = e.previews;
        }
        if (e.timeZone) {
          r.headers["time-zone"] = e.timeZone;
        }
        this.request = u.request.defaults(r);
        this.graphql = (0, l.withCustomRequest)(this.request).defaults(r);
        this.log = Object.assign({ debug: noop, info: noop, warn: g, error: m }, e.log);
        this.hook = t;
        if (!e.authStrategy) {
          if (!e.auth) {
            this.auth = async () => ({ type: "unauthenticated" });
          } else {
            const r = (0, p.createTokenAuth)(e.auth);
            t.wrap("request", r.hook);
            this.auth = r;
          }
        } else {
          const { authStrategy: r, ...n } = e;
          const o = r(Object.assign({ request: this.request, log: this.log, octokit: this, octokitOptions: n }, e.auth));
          t.wrap("request", o.hook);
          this.auth = o;
        }
        const n = this.constructor;
        for (let t = 0; t < n.plugins.length; ++t) {
          Object.assign(this, n.plugins[t](this, e));
        }
      }
    };
    0 && 0;
  },
  54471: (e, t, r) => {
    var n = Object.defineProperty;
    var o = Object.getOwnPropertyDescriptor;
    var s = Object.getOwnPropertyNames;
    var i = Object.prototype.hasOwnProperty;
    var __export = (e, t) => {
      for (var r in t) n(e, r, { get: t[r], enumerable: true });
    };
    var __copyProps = (e, t, r, a) => {
      if ((t && typeof t === "object") || typeof t === "function") {
        for (let A of s(t)) if (!i.call(e, A) && A !== r) n(e, A, { get: () => t[A], enumerable: !(a = o(t, A)) || a.enumerable });
      }
      return e;
    };
    var __toCommonJS = (e) => __copyProps(n({}, "__esModule", { value: true }), e);
    var a = {};
    __export(a, { endpoint: () => d });
    e.exports = __toCommonJS(a);
    var A = r(33843);
    var c = "9.0.5";
    var u = `octokit-endpoint.js/${c} ${(0, A.getUserAgent)()}`;
    var l = {
      method: "GET",
      baseUrl: "https://api.github.com",
      headers: { accept: "application/vnd.github.v3+json", "user-agent": u },
      mediaType: { format: "" },
    };
    function lowercaseKeys(e) {
      if (!e) {
        return {};
      }
      return Object.keys(e).reduce((t, r) => {
        t[r.toLowerCase()] = e[r];
        return t;
      }, {});
    }
    function isPlainObject(e) {
      if (typeof e !== "object" || e === null) return false;
      if (Object.prototype.toString.call(e) !== "[object Object]") return false;
      const t = Object.getPrototypeOf(e);
      if (t === null) return true;
      const r = Object.prototype.hasOwnProperty.call(t, "constructor") && t.constructor;
      return typeof r === "function" && r instanceof r && Function.prototype.call(r) === Function.prototype.call(e);
    }
    function mergeDeep(e, t) {
      const r = Object.assign({}, e);
      Object.keys(t).forEach((n) => {
        if (isPlainObject(t[n])) {
          if (!(n in e)) Object.assign(r, { [n]: t[n] });
          else r[n] = mergeDeep(e[n], t[n]);
        } else {
          Object.assign(r, { [n]: t[n] });
        }
      });
      return r;
    }
    function removeUndefinedProperties(e) {
      for (const t in e) {
        if (e[t] === void 0) {
          delete e[t];
        }
      }
      return e;
    }
    function merge(e, t, r) {
      if (typeof t === "string") {
        let [e, n] = t.split(" ");
        r = Object.assign(n ? { method: e, url: n } : { url: e }, r);
      } else {
        r = Object.assign({}, t);
      }
      r.headers = lowercaseKeys(r.headers);
      removeUndefinedProperties(r);
      removeUndefinedProperties(r.headers);
      const n = mergeDeep(e || {}, r);
      if (r.url === "/graphql") {
        if (e && e.mediaType.previews?.length) {
          n.mediaType.previews = e.mediaType.previews.filter((e) => !n.mediaType.previews.includes(e)).concat(n.mediaType.previews);
        }
        n.mediaType.previews = (n.mediaType.previews || []).map((e) => e.replace(/-preview/, ""));
      }
      return n;
    }
    function addQueryParameters(e, t) {
      const r = /\?/.test(e) ? "&" : "?";
      const n = Object.keys(t);
      if (n.length === 0) {
        return e;
      }
      return (
        e +
        r +
        n
          .map((e) => {
            if (e === "q") {
              return "q=" + t.q.split("+").map(encodeURIComponent).join("+");
            }
            return `${e}=${encodeURIComponent(t[e])}`;
          })
          .join("&")
      );
    }
    var p = /\{[^}]+\}/g;
    function removeNonChars(e) {
      return e.replace(/^\W+|\W+$/g, "").split(/,/);
    }
    function extractUrlVariableNames(e) {
      const t = e.match(p);
      if (!t) {
        return [];
      }
      return t.map(removeNonChars).reduce((e, t) => e.concat(t), []);
    }
    function omit(e, t) {
      const r = { __proto__: null };
      for (const n of Object.keys(e)) {
        if (t.indexOf(n) === -1) {
          r[n] = e[n];
        }
      }
      return r;
    }
    function encodeReserved(e) {
      return e
        .split(/(%[0-9A-Fa-f]{2})/g)
        .map(function (e) {
          if (!/%[0-9A-Fa-f]/.test(e)) {
            e = encodeURI(e).replace(/%5B/g, "[").replace(/%5D/g, "]");
          }
          return e;
        })
        .join("");
    }
    function encodeUnreserved(e) {
      return encodeURIComponent(e).replace(/[!'()*]/g, function (e) {
        return "%" + e.charCodeAt(0).toString(16).toUpperCase();
      });
    }
    function encodeValue(e, t, r) {
      t = e === "+" || e === "#" ? encodeReserved(t) : encodeUnreserved(t);
      if (r) {
        return encodeUnreserved(r) + "=" + t;
      } else {
        return t;
      }
    }
    function isDefined(e) {
      return e !== void 0 && e !== null;
    }
    function isKeyOperator(e) {
      return e === ";" || e === "&" || e === "?";
    }
    function getValues(e, t, r, n) {
      var o = e[r],
        s = [];
      if (isDefined(o) && o !== "") {
        if (typeof o === "string" || typeof o === "number" || typeof o === "boolean") {
          o = o.toString();
          if (n && n !== "*") {
            o = o.substring(0, parseInt(n, 10));
          }
          s.push(encodeValue(t, o, isKeyOperator(t) ? r : ""));
        } else {
          if (n === "*") {
            if (Array.isArray(o)) {
              o.filter(isDefined).forEach(function (e) {
                s.push(encodeValue(t, e, isKeyOperator(t) ? r : ""));
              });
            } else {
              Object.keys(o).forEach(function (e) {
                if (isDefined(o[e])) {
                  s.push(encodeValue(t, o[e], e));
                }
              });
            }
          } else {
            const e = [];
            if (Array.isArray(o)) {
              o.filter(isDefined).forEach(function (r) {
                e.push(encodeValue(t, r));
              });
            } else {
              Object.keys(o).forEach(function (r) {
                if (isDefined(o[r])) {
                  e.push(encodeUnreserved(r));
                  e.push(encodeValue(t, o[r].toString()));
                }
              });
            }
            if (isKeyOperator(t)) {
              s.push(encodeUnreserved(r) + "=" + e.join(","));
            } else if (e.length !== 0) {
              s.push(e.join(","));
            }
          }
        }
      } else {
        if (t === ";") {
          if (isDefined(o)) {
            s.push(encodeUnreserved(r));
          }
        } else if (o === "" && (t === "&" || t === "?")) {
          s.push(encodeUnreserved(r) + "=");
        } else if (o === "") {
          s.push("");
        }
      }
      return s;
    }
    function parseUrl(e) {
      return { expand: expand.bind(null, e) };
    }
    function expand(e, t) {
      var r = ["+", "#", ".", "/", ";", "?", "&"];
      e = e.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function (e, n, o) {
        if (n) {
          let e = "";
          const o = [];
          if (r.indexOf(n.charAt(0)) !== -1) {
            e = n.charAt(0);
            n = n.substr(1);
          }
          n.split(/,/g).forEach(function (r) {
            var n = /([^:\*]*)(?::(\d+)|(\*))?/.exec(r);
            o.push(getValues(t, e, n[1], n[2] || n[3]));
          });
          if (e && e !== "+") {
            var s = ",";
            if (e === "?") {
              s = "&";
            } else if (e !== "#") {
              s = e;
            }
            return (o.length !== 0 ? e : "") + o.join(s);
          } else {
            return o.join(",");
          }
        } else {
          return encodeReserved(o);
        }
      });
      if (e === "/") {
        return e;
      } else {
        return e.replace(/\/$/, "");
      }
    }
    function parse(e) {
      let t = e.method.toUpperCase();
      let r = (e.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
      let n = Object.assign({}, e.headers);
      let o;
      let s = omit(e, ["method", "baseUrl", "url", "headers", "request", "mediaType"]);
      const i = extractUrlVariableNames(r);
      r = parseUrl(r).expand(s);
      if (!/^http/.test(r)) {
        r = e.baseUrl + r;
      }
      const a = Object.keys(e)
        .filter((e) => i.includes(e))
        .concat("baseUrl");
      const A = omit(s, a);
      const c = /application\/octet-stream/i.test(n.accept);
      if (!c) {
        if (e.mediaType.format) {
          n.accept = n.accept
            .split(/,/)
            .map((t) => t.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${e.mediaType.format}`))
            .join(",");
        }
        if (r.endsWith("/graphql")) {
          if (e.mediaType.previews?.length) {
            const t = n.accept.match(/[\w-]+(?=-preview)/g) || [];
            n.accept = t
              .concat(e.mediaType.previews)
              .map((t) => {
                const r = e.mediaType.format ? `.${e.mediaType.format}` : "+json";
                return `application/vnd.github.${t}-preview${r}`;
              })
              .join(",");
          }
        }
      }
      if (["GET", "HEAD"].includes(t)) {
        r = addQueryParameters(r, A);
      } else {
        if ("data" in A) {
          o = A.data;
        } else {
          if (Object.keys(A).length) {
            o = A;
          }
        }
      }
      if (!n["content-type"] && typeof o !== "undefined") {
        n["content-type"] = "application/json; charset=utf-8";
      }
      if (["PATCH", "PUT"].includes(t) && typeof o === "undefined") {
        o = "";
      }
      return Object.assign({ method: t, url: r, headers: n }, typeof o !== "undefined" ? { body: o } : null, e.request ? { request: e.request } : null);
    }
    function endpointWithDefaults(e, t, r) {
      return parse(merge(e, t, r));
    }
    function withDefaults(e, t) {
      const r = merge(e, t);
      const n = endpointWithDefaults.bind(null, r);
      return Object.assign(n, { DEFAULTS: r, defaults: withDefaults.bind(null, r), merge: merge.bind(null, r), parse: parse });
    }
    var d = withDefaults(null, l);
    0 && 0;
  },
  95171: function (e, t, r) {
    (function (e, n) {
      true ? n(t, r(61860), r(28422)) : 0;
    })(this, function (e, t, r) {
      "use strict";
      var n = new Map();
      var o = new Map();
      var s = true;
      var i = false;
      function normalize(e) {
        return e.replace(/[\s,]+/g, " ").trim();
      }
      function cacheKeyFromLoc(e) {
        return normalize(e.source.body.substring(e.start, e.end));
      }
      function processFragments(e) {
        var r = new Set();
        var n = [];
        e.definitions.forEach(function (e) {
          if (e.kind === "FragmentDefinition") {
            var t = e.name.value;
            var i = cacheKeyFromLoc(e.loc);
            var a = o.get(t);
            if (a && !a.has(i)) {
              if (s) {
                console.warn(
                  "Warning: fragment with name " +
                    t +
                    " already exists.\n" +
                    "graphql-tag enforces all fragment names across your application to be unique; read more about\n" +
                    "this in the docs: http://dev.apollodata.com/core/fragments.html#unique-names"
                );
              }
            } else if (!a) {
              o.set(t, (a = new Set()));
            }
            a.add(i);
            if (!r.has(i)) {
              r.add(i);
              n.push(e);
            }
          } else {
            n.push(e);
          }
        });
        return t.__assign(t.__assign({}, e), { definitions: n });
      }
      function stripLoc(e) {
        var t = new Set(e.definitions);
        t.forEach(function (e) {
          if (e.loc) delete e.loc;
          Object.keys(e).forEach(function (r) {
            var n = e[r];
            if (n && typeof n === "object") {
              t.add(n);
            }
          });
        });
        var r = e.loc;
        if (r) {
          delete r.startToken;
          delete r.endToken;
        }
        return e;
      }
      function parseDocument(e) {
        var t = normalize(e);
        if (!n.has(t)) {
          var o = r.parse(e, { experimentalFragmentVariables: i, allowLegacyFragmentVariables: i });
          if (!o || o.kind !== "Document") {
            throw new Error("Not a valid GraphQL document.");
          }
          n.set(t, stripLoc(processFragments(o)));
        }
        return n.get(t);
      }
      function gql(e) {
        var t = [];
        for (var r = 1; r < arguments.length; r++) {
          t[r - 1] = arguments[r];
        }
        if (typeof e === "string") {
          e = [e];
        }
        var n = e[0];
        t.forEach(function (t, r) {
          if (t && t.kind === "Document") {
            n += t.loc.source.body;
          } else {
            n += t;
          }
          n += e[r + 1];
        });
        return parseDocument(n);
      }
      function resetCaches() {
        n.clear();
        o.clear();
      }
      function disableFragmentWarnings() {
        s = false;
      }
      function enableExperimentalFragmentVariables() {
        i = true;
      }
      function disableExperimentalFragmentVariables() {
        i = false;
      }
      var a = {
        gql: gql,
        resetCaches: resetCaches,
        disableFragmentWarnings: disableFragmentWarnings,
        enableExperimentalFragmentVariables: enableExperimentalFragmentVariables,
        disableExperimentalFragmentVariables: disableExperimentalFragmentVariables,
      };
      (function (e) {
        (e.gql = a.gql),
          (e.resetCaches = a.resetCaches),
          (e.disableFragmentWarnings = a.disableFragmentWarnings),
          (e.enableExperimentalFragmentVariables = a.enableExperimentalFragmentVariables),
          (e.disableExperimentalFragmentVariables = a.disableExperimentalFragmentVariables);
      })(gql || (gql = {}));
      gql["default"] = gql;
      var A = gql;
      e.default = A;
      e.disableExperimentalFragmentVariables = disableExperimentalFragmentVariables;
      e.disableFragmentWarnings = disableFragmentWarnings;
      e.enableExperimentalFragmentVariables = enableExperimentalFragmentVariables;
      e.gql = gql;
      e.resetCaches = resetCaches;
      Object.defineProperty(e, "__esModule", { value: true });
    });
  },
  31970: (e, t, r) => {
    e.exports = r(95171).gql;
  },
  23750: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.GraphQLError = void 0;
    t.formatError = formatError;
    t.printError = printError;
    var n = r(84849);
    var o = r(82986);
    var s = r(33369);
    function toNormalizedOptions(e) {
      const t = e[0];
      if (t == null || "kind" in t || "length" in t) {
        return { nodes: t, source: e[1], positions: e[2], path: e[3], originalError: e[4], extensions: e[5] };
      }
      return t;
    }
    class GraphQLError extends Error {
      constructor(e, ...t) {
        var r, s, i;
        const { nodes: a, source: A, positions: c, path: u, originalError: l, extensions: p } = toNormalizedOptions(t);
        super(e);
        this.name = "GraphQLError";
        this.path = u !== null && u !== void 0 ? u : undefined;
        this.originalError = l !== null && l !== void 0 ? l : undefined;
        this.nodes = undefinedIfEmpty(Array.isArray(a) ? a : a ? [a] : undefined);
        const d = undefinedIfEmpty((r = this.nodes) === null || r === void 0 ? void 0 : r.map((e) => e.loc).filter((e) => e != null));
        this.source = A !== null && A !== void 0 ? A : d === null || d === void 0 ? void 0 : (s = d[0]) === null || s === void 0 ? void 0 : s.source;
        this.positions = c !== null && c !== void 0 ? c : d === null || d === void 0 ? void 0 : d.map((e) => e.start);
        this.locations =
          c && A ? c.map((e) => (0, o.getLocation)(A, e)) : d === null || d === void 0 ? void 0 : d.map((e) => (0, o.getLocation)(e.source, e.start));
        const g = (0, n.isObjectLike)(l === null || l === void 0 ? void 0 : l.extensions) ? (l === null || l === void 0 ? void 0 : l.extensions) : undefined;
        this.extensions = (i = p !== null && p !== void 0 ? p : g) !== null && i !== void 0 ? i : Object.create(null);
        Object.defineProperties(this, {
          message: { writable: true, enumerable: true },
          name: { enumerable: false },
          nodes: { enumerable: false },
          source: { enumerable: false },
          positions: { enumerable: false },
          originalError: { enumerable: false },
        });
        if (l !== null && l !== void 0 && l.stack) {
          Object.defineProperty(this, "stack", { value: l.stack, writable: true, configurable: true });
        } else if (Error.captureStackTrace) {
          Error.captureStackTrace(this, GraphQLError);
        } else {
          Object.defineProperty(this, "stack", { value: Error().stack, writable: true, configurable: true });
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLError";
      }
      toString() {
        let e = this.message;
        if (this.nodes) {
          for (const t of this.nodes) {
            if (t.loc) {
              e += "\n\n" + (0, s.printLocation)(t.loc);
            }
          }
        } else if (this.source && this.locations) {
          for (const t of this.locations) {
            e += "\n\n" + (0, s.printSourceLocation)(this.source, t);
          }
        }
        return e;
      }
      toJSON() {
        const e = { message: this.message };
        if (this.locations != null) {
          e.locations = this.locations;
        }
        if (this.path != null) {
          e.path = this.path;
        }
        if (this.extensions != null && Object.keys(this.extensions).length > 0) {
          e.extensions = this.extensions;
        }
        return e;
      }
    }
    t.GraphQLError = GraphQLError;
    function undefinedIfEmpty(e) {
      return e === undefined || e.length === 0 ? undefined : e;
    }
    function printError(e) {
      return e.toString();
    }
    function formatError(e) {
      return e.toJSON();
    }
  },
  34987: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    Object.defineProperty(t, "GraphQLError", {
      enumerable: true,
      get: function () {
        return n.GraphQLError;
      },
    });
    Object.defineProperty(t, "formatError", {
      enumerable: true,
      get: function () {
        return n.formatError;
      },
    });
    Object.defineProperty(t, "locatedError", {
      enumerable: true,
      get: function () {
        return s.locatedError;
      },
    });
    Object.defineProperty(t, "printError", {
      enumerable: true,
      get: function () {
        return n.printError;
      },
    });
    Object.defineProperty(t, "syntaxError", {
      enumerable: true,
      get: function () {
        return o.syntaxError;
      },
    });
    var n = r(23750);
    var o = r(41144);
    var s = r(65323);
  },
  65323: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.locatedError = locatedError;
    var n = r(7060);
    var o = r(23750);
    function locatedError(e, t, r) {
      var s;
      const i = (0, n.toError)(e);
      if (isLocatedGraphQLError(i)) {
        return i;
      }
      return new o.GraphQLError(i.message, {
        nodes: (s = i.nodes) !== null && s !== void 0 ? s : t,
        source: i.source,
        positions: i.positions,
        path: r,
        originalError: i,
      });
    }
    function isLocatedGraphQLError(e) {
      return Array.isArray(e.path);
    }
  },
  41144: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.syntaxError = syntaxError;
    var n = r(23750);
    function syntaxError(e, t, r) {
      return new n.GraphQLError(`Syntax Error: ${r}`, { source: e, positions: [t] });
    }
  },
  76092: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.collectFields = collectFields;
    t.collectSubfields = collectSubfields;
    var n = r(19254);
    var o = r(46250);
    var s = r(58941);
    var i = r(45669);
    var a = r(2657);
    function collectFields(e, t, r, n, o) {
      const s = new Map();
      collectFieldsImpl(e, t, r, n, o, s, new Set());
      return s;
    }
    function collectSubfields(e, t, r, n, o) {
      const s = new Map();
      const i = new Set();
      for (const a of o) {
        if (a.selectionSet) {
          collectFieldsImpl(e, t, r, n, a.selectionSet, s, i);
        }
      }
      return s;
    }
    function collectFieldsImpl(e, t, r, o, s, i, a) {
      for (const A of s.selections) {
        switch (A.kind) {
          case n.Kind.FIELD: {
            if (!shouldIncludeNode(r, A)) {
              continue;
            }
            const e = getFieldEntryKey(A);
            const t = i.get(e);
            if (t !== undefined) {
              t.push(A);
            } else {
              i.set(e, [A]);
            }
            break;
          }
          case n.Kind.INLINE_FRAGMENT: {
            if (!shouldIncludeNode(r, A) || !doesFragmentConditionMatch(e, A, o)) {
              continue;
            }
            collectFieldsImpl(e, t, r, o, A.selectionSet, i, a);
            break;
          }
          case n.Kind.FRAGMENT_SPREAD: {
            const n = A.name.value;
            if (a.has(n) || !shouldIncludeNode(r, A)) {
              continue;
            }
            a.add(n);
            const s = t[n];
            if (!s || !doesFragmentConditionMatch(e, s, o)) {
              continue;
            }
            collectFieldsImpl(e, t, r, o, s.selectionSet, i, a);
            break;
          }
        }
      }
    }
    function shouldIncludeNode(e, t) {
      const r = (0, a.getDirectiveValues)(s.GraphQLSkipDirective, t, e);
      if ((r === null || r === void 0 ? void 0 : r.if) === true) {
        return false;
      }
      const n = (0, a.getDirectiveValues)(s.GraphQLIncludeDirective, t, e);
      if ((n === null || n === void 0 ? void 0 : n.if) === false) {
        return false;
      }
      return true;
    }
    function doesFragmentConditionMatch(e, t, r) {
      const n = t.typeCondition;
      if (!n) {
        return true;
      }
      const s = (0, i.typeFromAST)(e, n);
      if (s === r) {
        return true;
      }
      if ((0, o.isAbstractType)(s)) {
        return e.isSubType(s, r);
      }
      return false;
    }
    function getFieldEntryKey(e) {
      return e.alias ? e.alias.value : e.name.value;
    }
  },
  75964: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.assertValidExecutionArguments = assertValidExecutionArguments;
    t.buildExecutionContext = buildExecutionContext;
    t.buildResolveInfo = buildResolveInfo;
    t.defaultTypeResolver = t.defaultFieldResolver = void 0;
    t.execute = execute;
    t.executeSync = executeSync;
    t.getFieldDef = getFieldDef;
    var n = r(53284);
    var o = r(71801);
    var s = r(67305);
    var i = r(12916);
    var a = r(84849);
    var A = r(21916);
    var c = r(54872);
    var u = r(42090);
    var l = r(20654);
    var p = r(64222);
    var d = r(23750);
    var g = r(65323);
    var m = r(26081);
    var h = r(19254);
    var E = r(46250);
    var I = r(47564);
    var y = r(22689);
    var C = r(76092);
    var b = r(2657);
    const Q = (0, c.memoize3)((e, t, r) => (0, C.collectSubfields)(e.schema, e.fragments, e.variableValues, t, r));
    function execute(e) {
      arguments.length < 2 || (0, n.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
      const { schema: t, document: r, variableValues: o, rootValue: s } = e;
      assertValidExecutionArguments(t, r, o);
      const i = buildExecutionContext(e);
      if (!("schema" in i)) {
        return { errors: i };
      }
      try {
        const { operation: e } = i;
        const t = executeOperation(i, e, s);
        if ((0, A.isPromise)(t)) {
          return t.then(
            (e) => buildResponse(e, i.errors),
            (e) => {
              i.errors.push(e);
              return buildResponse(null, i.errors);
            }
          );
        }
        return buildResponse(t, i.errors);
      } catch (e) {
        i.errors.push(e);
        return buildResponse(null, i.errors);
      }
    }
    function executeSync(e) {
      const t = execute(e);
      if ((0, A.isPromise)(t)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return t;
    }
    function buildResponse(e, t) {
      return t.length === 0 ? { data: e } : { errors: t, data: e };
    }
    function assertValidExecutionArguments(e, t, r) {
      t || (0, n.devAssert)(false, "Must provide document.");
      (0, y.assertValidSchema)(e);
      r == null ||
        (0, a.isObjectLike)(r) ||
        (0, n.devAssert)(
          false,
          "Variables must be provided as an Object where each property is a variable value. Perhaps look to see if an unparsed JSON string was provided."
        );
    }
    function buildExecutionContext(e) {
      var t, r;
      const {
        schema: n,
        document: o,
        rootValue: s,
        contextValue: i,
        variableValues: a,
        operationName: A,
        fieldResolver: c,
        typeResolver: u,
        subscribeFieldResolver: l,
      } = e;
      let p;
      const g = Object.create(null);
      for (const e of o.definitions) {
        switch (e.kind) {
          case h.Kind.OPERATION_DEFINITION:
            if (A == null) {
              if (p !== undefined) {
                return [new d.GraphQLError("Must provide operation name if query contains multiple operations.")];
              }
              p = e;
            } else if (((t = e.name) === null || t === void 0 ? void 0 : t.value) === A) {
              p = e;
            }
            break;
          case h.Kind.FRAGMENT_DEFINITION:
            g[e.name.value] = e;
            break;
          default:
        }
      }
      if (!p) {
        if (A != null) {
          return [new d.GraphQLError(`Unknown operation named "${A}".`)];
        }
        return [new d.GraphQLError("Must provide an operation.")];
      }
      const m = (r = p.variableDefinitions) !== null && r !== void 0 ? r : [];
      const E = (0, b.getVariableValues)(n, m, a !== null && a !== void 0 ? a : {}, { maxErrors: 50 });
      if (E.errors) {
        return E.errors;
      }
      return {
        schema: n,
        fragments: g,
        rootValue: s,
        contextValue: i,
        operation: p,
        variableValues: E.coerced,
        fieldResolver: c !== null && c !== void 0 ? c : defaultFieldResolver,
        typeResolver: u !== null && u !== void 0 ? u : defaultTypeResolver,
        subscribeFieldResolver: l !== null && l !== void 0 ? l : defaultFieldResolver,
        errors: [],
      };
    }
    function executeOperation(e, t, r) {
      const n = e.schema.getRootType(t.operation);
      if (n == null) {
        throw new d.GraphQLError(`Schema is not configured to execute ${t.operation} operation.`, { nodes: t });
      }
      const o = (0, C.collectFields)(e.schema, e.fragments, e.variableValues, n, t.selectionSet);
      const s = undefined;
      switch (t.operation) {
        case m.OperationTypeNode.QUERY:
          return executeFields(e, n, r, s, o);
        case m.OperationTypeNode.MUTATION:
          return executeFieldsSerially(e, n, r, s, o);
        case m.OperationTypeNode.SUBSCRIPTION:
          return executeFields(e, n, r, s, o);
      }
    }
    function executeFieldsSerially(e, t, r, n, o) {
      return (0, p.promiseReduce)(
        o.entries(),
        (o, [s, i]) => {
          const a = (0, u.addPath)(n, s, t.name);
          const c = executeField(e, t, r, i, a);
          if (c === undefined) {
            return o;
          }
          if ((0, A.isPromise)(c)) {
            return c.then((e) => {
              o[s] = e;
              return o;
            });
          }
          o[s] = c;
          return o;
        },
        Object.create(null)
      );
    }
    function executeFields(e, t, r, n, o) {
      const s = Object.create(null);
      let i = false;
      try {
        for (const [a, c] of o.entries()) {
          const o = (0, u.addPath)(n, a, t.name);
          const l = executeField(e, t, r, c, o);
          if (l !== undefined) {
            s[a] = l;
            if ((0, A.isPromise)(l)) {
              i = true;
            }
          }
        }
      } catch (e) {
        if (i) {
          return (0, l.promiseForObject)(s).finally(() => {
            throw e;
          });
        }
        throw e;
      }
      if (!i) {
        return s;
      }
      return (0, l.promiseForObject)(s);
    }
    function executeField(e, t, r, n, o) {
      var s;
      const i = getFieldDef(e.schema, t, n[0]);
      if (!i) {
        return;
      }
      const a = i.type;
      const c = (s = i.resolve) !== null && s !== void 0 ? s : e.fieldResolver;
      const l = buildResolveInfo(e, i, n, t, o);
      try {
        const t = (0, b.getArgumentValues)(i, n[0], e.variableValues);
        const s = e.contextValue;
        const p = c(r, t, s, l);
        let d;
        if ((0, A.isPromise)(p)) {
          d = p.then((t) => completeValue(e, a, n, l, o, t));
        } else {
          d = completeValue(e, a, n, l, o, p);
        }
        if ((0, A.isPromise)(d)) {
          return d.then(undefined, (t) => {
            const r = (0, g.locatedError)(t, n, (0, u.pathToArray)(o));
            return handleFieldError(r, a, e);
          });
        }
        return d;
      } catch (t) {
        const r = (0, g.locatedError)(t, n, (0, u.pathToArray)(o));
        return handleFieldError(r, a, e);
      }
    }
    function buildResolveInfo(e, t, r, n, o) {
      return {
        fieldName: t.name,
        fieldNodes: r,
        returnType: t.type,
        parentType: n,
        path: o,
        schema: e.schema,
        fragments: e.fragments,
        rootValue: e.rootValue,
        operation: e.operation,
        variableValues: e.variableValues,
      };
    }
    function handleFieldError(e, t, r) {
      if ((0, E.isNonNullType)(t)) {
        throw e;
      }
      r.errors.push(e);
      return null;
    }
    function completeValue(e, t, r, n, i, a) {
      if (a instanceof Error) {
        throw a;
      }
      if ((0, E.isNonNullType)(t)) {
        const o = completeValue(e, t.ofType, r, n, i, a);
        if (o === null) {
          throw new Error(`Cannot return null for non-nullable field ${n.parentType.name}.${n.fieldName}.`);
        }
        return o;
      }
      if (a == null) {
        return null;
      }
      if ((0, E.isListType)(t)) {
        return completeListValue(e, t, r, n, i, a);
      }
      if ((0, E.isLeafType)(t)) {
        return completeLeafValue(t, a);
      }
      if ((0, E.isAbstractType)(t)) {
        return completeAbstractValue(e, t, r, n, i, a);
      }
      if ((0, E.isObjectType)(t)) {
        return completeObjectValue(e, t, r, n, i, a);
      }
      false || (0, s.invariant)(false, "Cannot complete value of unexpected output type: " + (0, o.inspect)(t));
    }
    function completeListValue(e, t, r, n, o, s) {
      if (!(0, i.isIterableObject)(s)) {
        throw new d.GraphQLError(`Expected Iterable, but did not find one for field "${n.parentType.name}.${n.fieldName}".`);
      }
      const a = t.ofType;
      let c = false;
      const l = Array.from(s, (t, s) => {
        const i = (0, u.addPath)(o, s, undefined);
        try {
          let o;
          if ((0, A.isPromise)(t)) {
            o = t.then((t) => completeValue(e, a, r, n, i, t));
          } else {
            o = completeValue(e, a, r, n, i, t);
          }
          if ((0, A.isPromise)(o)) {
            c = true;
            return o.then(undefined, (t) => {
              const n = (0, g.locatedError)(t, r, (0, u.pathToArray)(i));
              return handleFieldError(n, a, e);
            });
          }
          return o;
        } catch (t) {
          const n = (0, g.locatedError)(t, r, (0, u.pathToArray)(i));
          return handleFieldError(n, a, e);
        }
      });
      return c ? Promise.all(l) : l;
    }
    function completeLeafValue(e, t) {
      const r = e.serialize(t);
      if (r == null) {
        throw new Error(`Expected \`${(0, o.inspect)(e)}.serialize(${(0, o.inspect)(t)})\` to ` + `return non-nullable value, returned: ${(0, o.inspect)(r)}`);
      }
      return r;
    }
    function completeAbstractValue(e, t, r, n, o, s) {
      var i;
      const a = (i = t.resolveType) !== null && i !== void 0 ? i : e.typeResolver;
      const c = e.contextValue;
      const u = a(s, c, n, t);
      if ((0, A.isPromise)(u)) {
        return u.then((i) => completeObjectValue(e, ensureValidRuntimeType(i, e, t, r, n, s), r, n, o, s));
      }
      return completeObjectValue(e, ensureValidRuntimeType(u, e, t, r, n, s), r, n, o, s);
    }
    function ensureValidRuntimeType(e, t, r, n, s, i) {
      if (e == null) {
        throw new d.GraphQLError(
          `Abstract type "${r.name}" must resolve to an Object type at runtime for field "${s.parentType.name}.${s.fieldName}". Either the "${r.name}" type should provide a "resolveType" function or each possible type should provide an "isTypeOf" function.`,
          n
        );
      }
      if ((0, E.isObjectType)(e)) {
        throw new d.GraphQLError("Support for returning GraphQLObjectType from resolveType was removed in graphql-js@16.0.0 please return type name instead.");
      }
      if (typeof e !== "string") {
        throw new d.GraphQLError(
          `Abstract type "${r.name}" must resolve to an Object type at runtime for field "${s.parentType.name}.${s.fieldName}" with ` +
            `value ${(0, o.inspect)(i)}, received "${(0, o.inspect)(e)}".`
        );
      }
      const a = t.schema.getType(e);
      if (a == null) {
        throw new d.GraphQLError(`Abstract type "${r.name}" was resolved to a type "${e}" that does not exist inside the schema.`, { nodes: n });
      }
      if (!(0, E.isObjectType)(a)) {
        throw new d.GraphQLError(`Abstract type "${r.name}" was resolved to a non-object type "${e}".`, { nodes: n });
      }
      if (!t.schema.isSubType(r, a)) {
        throw new d.GraphQLError(`Runtime Object type "${a.name}" is not a possible type for "${r.name}".`, { nodes: n });
      }
      return a;
    }
    function completeObjectValue(e, t, r, n, o, s) {
      const i = Q(e, t, r);
      if (t.isTypeOf) {
        const a = t.isTypeOf(s, e.contextValue, n);
        if ((0, A.isPromise)(a)) {
          return a.then((n) => {
            if (!n) {
              throw invalidReturnTypeError(t, s, r);
            }
            return executeFields(e, t, s, o, i);
          });
        }
        if (!a) {
          throw invalidReturnTypeError(t, s, r);
        }
      }
      return executeFields(e, t, s, o, i);
    }
    function invalidReturnTypeError(e, t, r) {
      return new d.GraphQLError(`Expected value of type "${e.name}" but got: ${(0, o.inspect)(t)}.`, { nodes: r });
    }
    const defaultTypeResolver = function (e, t, r, n) {
      if ((0, a.isObjectLike)(e) && typeof e.__typename === "string") {
        return e.__typename;
      }
      const o = r.schema.getPossibleTypes(n);
      const s = [];
      for (let n = 0; n < o.length; n++) {
        const i = o[n];
        if (i.isTypeOf) {
          const o = i.isTypeOf(e, t, r);
          if ((0, A.isPromise)(o)) {
            s[n] = o;
          } else if (o) {
            return i.name;
          }
        }
      }
      if (s.length) {
        return Promise.all(s).then((e) => {
          for (let t = 0; t < e.length; t++) {
            if (e[t]) {
              return o[t].name;
            }
          }
        });
      }
    };
    t.defaultTypeResolver = defaultTypeResolver;
    const defaultFieldResolver = function (e, t, r, n) {
      if ((0, a.isObjectLike)(e) || typeof e === "function") {
        const o = e[n.fieldName];
        if (typeof o === "function") {
          return e[n.fieldName](t, r, n);
        }
        return o;
      }
    };
    t.defaultFieldResolver = defaultFieldResolver;
    function getFieldDef(e, t, r) {
      const n = r.name.value;
      if (n === I.SchemaMetaFieldDef.name && e.getQueryType() === t) {
        return I.SchemaMetaFieldDef;
      } else if (n === I.TypeMetaFieldDef.name && e.getQueryType() === t) {
        return I.TypeMetaFieldDef;
      } else if (n === I.TypeNameMetaFieldDef.name) {
        return I.TypeNameMetaFieldDef;
      }
      return t.getFields()[n];
    }
  },
  69843: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    Object.defineProperty(t, "createSourceEventStream", {
      enumerable: true,
      get: function () {
        return s.createSourceEventStream;
      },
    });
    Object.defineProperty(t, "defaultFieldResolver", {
      enumerable: true,
      get: function () {
        return o.defaultFieldResolver;
      },
    });
    Object.defineProperty(t, "defaultTypeResolver", {
      enumerable: true,
      get: function () {
        return o.defaultTypeResolver;
      },
    });
    Object.defineProperty(t, "execute", {
      enumerable: true,
      get: function () {
        return o.execute;
      },
    });
    Object.defineProperty(t, "executeSync", {
      enumerable: true,
      get: function () {
        return o.executeSync;
      },
    });
    Object.defineProperty(t, "getArgumentValues", {
      enumerable: true,
      get: function () {
        return i.getArgumentValues;
      },
    });
    Object.defineProperty(t, "getDirectiveValues", {
      enumerable: true,
      get: function () {
        return i.getDirectiveValues;
      },
    });
    Object.defineProperty(t, "getVariableValues", {
      enumerable: true,
      get: function () {
        return i.getVariableValues;
      },
    });
    Object.defineProperty(t, "responsePathAsArray", {
      enumerable: true,
      get: function () {
        return n.pathToArray;
      },
    });
    Object.defineProperty(t, "subscribe", {
      enumerable: true,
      get: function () {
        return s.subscribe;
      },
    });
    var n = r(42090);
    var o = r(75964);
    var s = r(45359);
    var i = r(2657);
  },
  51263: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.mapAsyncIterator = mapAsyncIterator;
    function mapAsyncIterator(e, t) {
      const r = e[Symbol.asyncIterator]();
      async function mapResult(e) {
        if (e.done) {
          return e;
        }
        try {
          return { value: await t(e.value), done: false };
        } catch (e) {
          if (typeof r.return === "function") {
            try {
              await r.return();
            } catch (e) {}
          }
          throw e;
        }
      }
      return {
        async next() {
          return mapResult(await r.next());
        },
        async return() {
          return typeof r.return === "function" ? mapResult(await r.return()) : { value: undefined, done: true };
        },
        async throw(e) {
          if (typeof r.throw === "function") {
            return mapResult(await r.throw(e));
          }
          throw e;
        },
        [Symbol.asyncIterator]() {
          return this;
        },
      };
    }
  },
  45359: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.createSourceEventStream = createSourceEventStream;
    t.subscribe = subscribe;
    var n = r(53284);
    var o = r(71801);
    var s = r(21043);
    var i = r(42090);
    var a = r(23750);
    var A = r(65323);
    var c = r(76092);
    var u = r(75964);
    var l = r(51263);
    var p = r(2657);
    async function subscribe(e) {
      arguments.length < 2 || (0, n.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
      const t = await createSourceEventStream(e);
      if (!(0, s.isAsyncIterable)(t)) {
        return t;
      }
      const mapSourceToResponse = (t) => (0, u.execute)({ ...e, rootValue: t });
      return (0, l.mapAsyncIterator)(t, mapSourceToResponse);
    }
    function toNormalizedArgs(e) {
      const t = e[0];
      if (t && "document" in t) {
        return t;
      }
      return { schema: t, document: e[1], rootValue: e[2], contextValue: e[3], variableValues: e[4], operationName: e[5], subscribeFieldResolver: e[6] };
    }
    async function createSourceEventStream(...e) {
      const t = toNormalizedArgs(e);
      const { schema: r, document: n, variableValues: i } = t;
      (0, u.assertValidExecutionArguments)(r, n, i);
      const A = (0, u.buildExecutionContext)(t);
      if (!("schema" in A)) {
        return { errors: A };
      }
      try {
        const e = await executeSubscription(A);
        if (!(0, s.isAsyncIterable)(e)) {
          throw new Error("Subscription field must return Async Iterable. " + `Received: ${(0, o.inspect)(e)}.`);
        }
        return e;
      } catch (e) {
        if (e instanceof a.GraphQLError) {
          return { errors: [e] };
        }
        throw e;
      }
    }
    async function executeSubscription(e) {
      const { schema: t, fragments: r, operation: n, variableValues: o, rootValue: s } = e;
      const l = t.getSubscriptionType();
      if (l == null) {
        throw new a.GraphQLError("Schema is not configured to execute subscription operation.", { nodes: n });
      }
      const d = (0, c.collectFields)(t, r, o, l, n.selectionSet);
      const [g, m] = [...d.entries()][0];
      const h = (0, u.getFieldDef)(t, l, m[0]);
      if (!h) {
        const e = m[0].name.value;
        throw new a.GraphQLError(`The subscription field "${e}" is not defined.`, { nodes: m });
      }
      const E = (0, i.addPath)(undefined, g, l.name);
      const I = (0, u.buildResolveInfo)(e, h, m, l, E);
      try {
        var y;
        const t = (0, p.getArgumentValues)(h, m[0], o);
        const r = e.contextValue;
        const n = (y = h.subscribe) !== null && y !== void 0 ? y : e.subscribeFieldResolver;
        const i = await n(s, t, r, I);
        if (i instanceof Error) {
          throw i;
        }
        return i;
      } catch (e) {
        throw (0, A.locatedError)(e, m, (0, i.pathToArray)(E));
      }
    }
  },
  2657: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.getArgumentValues = getArgumentValues;
    t.getDirectiveValues = getDirectiveValues;
    t.getVariableValues = getVariableValues;
    var n = r(71801);
    var o = r(97982);
    var s = r(81292);
    var i = r(23750);
    var a = r(19254);
    var A = r(85401);
    var c = r(46250);
    var u = r(39837);
    var l = r(45669);
    var p = r(36302);
    function getVariableValues(e, t, r, n) {
      const o = [];
      const s = n === null || n === void 0 ? void 0 : n.maxErrors;
      try {
        const n = coerceVariableValues(e, t, r, (e) => {
          if (s != null && o.length >= s) {
            throw new i.GraphQLError("Too many errors processing variables, error limit reached. Execution aborted.");
          }
          o.push(e);
        });
        if (o.length === 0) {
          return { coerced: n };
        }
      } catch (e) {
        o.push(e);
      }
      return { errors: o };
    }
    function coerceVariableValues(e, t, r, o) {
      const a = {};
      for (const d of t) {
        const t = d.variable.name.value;
        const g = (0, l.typeFromAST)(e, d.type);
        if (!(0, c.isInputType)(g)) {
          const e = (0, A.print)(d.type);
          o(new i.GraphQLError(`Variable "$${t}" expected value of type "${e}" which cannot be used as an input type.`, { nodes: d.type }));
          continue;
        }
        if (!hasOwnProperty(r, t)) {
          if (d.defaultValue) {
            a[t] = (0, p.valueFromAST)(d.defaultValue, g);
          } else if ((0, c.isNonNullType)(g)) {
            const e = (0, n.inspect)(g);
            o(new i.GraphQLError(`Variable "$${t}" of required type "${e}" was not provided.`, { nodes: d }));
          }
          continue;
        }
        const m = r[t];
        if (m === null && (0, c.isNonNullType)(g)) {
          const e = (0, n.inspect)(g);
          o(new i.GraphQLError(`Variable "$${t}" of non-null type "${e}" must not be null.`, { nodes: d }));
          continue;
        }
        a[t] = (0, u.coerceInputValue)(m, g, (e, r, a) => {
          let A = `Variable "$${t}" got invalid value ` + (0, n.inspect)(r);
          if (e.length > 0) {
            A += ` at "${t}${(0, s.printPathArray)(e)}"`;
          }
          o(new i.GraphQLError(A + "; " + a.message, { nodes: d, originalError: a }));
        });
      }
      return a;
    }
    function getArgumentValues(e, t, r) {
      var s;
      const u = {};
      const l = (s = t.arguments) !== null && s !== void 0 ? s : [];
      const d = (0, o.keyMap)(l, (e) => e.name.value);
      for (const o of e.args) {
        const e = o.name;
        const s = o.type;
        const l = d[e];
        if (!l) {
          if (o.defaultValue !== undefined) {
            u[e] = o.defaultValue;
          } else if ((0, c.isNonNullType)(s)) {
            throw new i.GraphQLError(`Argument "${e}" of required type "${(0, n.inspect)(s)}" ` + "was not provided.", { nodes: t });
          }
          continue;
        }
        const g = l.value;
        let m = g.kind === a.Kind.NULL;
        if (g.kind === a.Kind.VARIABLE) {
          const t = g.name.value;
          if (r == null || !hasOwnProperty(r, t)) {
            if (o.defaultValue !== undefined) {
              u[e] = o.defaultValue;
            } else if ((0, c.isNonNullType)(s)) {
              throw new i.GraphQLError(
                `Argument "${e}" of required type "${(0, n.inspect)(s)}" ` + `was provided the variable "$${t}" which was not provided a runtime value.`,
                { nodes: g }
              );
            }
            continue;
          }
          m = r[t] == null;
        }
        if (m && (0, c.isNonNullType)(s)) {
          throw new i.GraphQLError(`Argument "${e}" of non-null type "${(0, n.inspect)(s)}" ` + "must not be null.", { nodes: g });
        }
        const h = (0, p.valueFromAST)(g, s, r);
        if (h === undefined) {
          throw new i.GraphQLError(`Argument "${e}" has invalid value ${(0, A.print)(g)}.`, { nodes: g });
        }
        u[e] = h;
      }
      return u;
    }
    function getDirectiveValues(e, t, r) {
      var n;
      const o = (n = t.directives) === null || n === void 0 ? void 0 : n.find((t) => t.name.value === e.name);
      if (o) {
        return getArgumentValues(e, o, r);
      }
    }
    function hasOwnProperty(e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }
  },
  32623: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.graphql = graphql;
    t.graphqlSync = graphqlSync;
    var n = r(53284);
    var o = r(21916);
    var s = r(71878);
    var i = r(22689);
    var a = r(90592);
    var A = r(75964);
    function graphql(e) {
      return new Promise((t) => t(graphqlImpl(e)));
    }
    function graphqlSync(e) {
      const t = graphqlImpl(e);
      if ((0, o.isPromise)(t)) {
        throw new Error("GraphQL execution failed to complete synchronously.");
      }
      return t;
    }
    function graphqlImpl(e) {
      arguments.length < 2 || (0, n.devAssert)(false, "graphql@16 dropped long-deprecated support for positional arguments, please pass an object instead.");
      const { schema: t, source: r, rootValue: o, contextValue: c, variableValues: u, operationName: l, fieldResolver: p, typeResolver: d } = e;
      const g = (0, i.validateSchema)(t);
      if (g.length > 0) {
        return { errors: g };
      }
      let m;
      try {
        m = (0, s.parse)(r);
      } catch (e) {
        return { errors: [e] };
      }
      const h = (0, a.validate)(t, m);
      if (h.length > 0) {
        return { errors: h };
      }
      return (0, A.execute)({ schema: t, document: m, rootValue: o, contextValue: c, variableValues: u, operationName: l, fieldResolver: p, typeResolver: d });
    }
  },
  28422: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    Object.defineProperty(t, "BREAK", {
      enumerable: true,
      get: function () {
        return i.BREAK;
      },
    });
    Object.defineProperty(t, "BreakingChangeType", {
      enumerable: true,
      get: function () {
        return u.BreakingChangeType;
      },
    });
    Object.defineProperty(t, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: function () {
        return s.DEFAULT_DEPRECATION_REASON;
      },
    });
    Object.defineProperty(t, "DangerousChangeType", {
      enumerable: true,
      get: function () {
        return u.DangerousChangeType;
      },
    });
    Object.defineProperty(t, "DirectiveLocation", {
      enumerable: true,
      get: function () {
        return i.DirectiveLocation;
      },
    });
    Object.defineProperty(t, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: function () {
        return A.ExecutableDefinitionsRule;
      },
    });
    Object.defineProperty(t, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: function () {
        return A.FieldsOnCorrectTypeRule;
      },
    });
    Object.defineProperty(t, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: function () {
        return A.FragmentsOnCompositeTypesRule;
      },
    });
    Object.defineProperty(t, "GRAPHQL_MAX_INT", {
      enumerable: true,
      get: function () {
        return s.GRAPHQL_MAX_INT;
      },
    });
    Object.defineProperty(t, "GRAPHQL_MIN_INT", {
      enumerable: true,
      get: function () {
        return s.GRAPHQL_MIN_INT;
      },
    });
    Object.defineProperty(t, "GraphQLBoolean", {
      enumerable: true,
      get: function () {
        return s.GraphQLBoolean;
      },
    });
    Object.defineProperty(t, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLDeprecatedDirective;
      },
    });
    Object.defineProperty(t, "GraphQLDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLDirective;
      },
    });
    Object.defineProperty(t, "GraphQLEnumType", {
      enumerable: true,
      get: function () {
        return s.GraphQLEnumType;
      },
    });
    Object.defineProperty(t, "GraphQLError", {
      enumerable: true,
      get: function () {
        return c.GraphQLError;
      },
    });
    Object.defineProperty(t, "GraphQLFloat", {
      enumerable: true,
      get: function () {
        return s.GraphQLFloat;
      },
    });
    Object.defineProperty(t, "GraphQLID", {
      enumerable: true,
      get: function () {
        return s.GraphQLID;
      },
    });
    Object.defineProperty(t, "GraphQLIncludeDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLIncludeDirective;
      },
    });
    Object.defineProperty(t, "GraphQLInputObjectType", {
      enumerable: true,
      get: function () {
        return s.GraphQLInputObjectType;
      },
    });
    Object.defineProperty(t, "GraphQLInt", {
      enumerable: true,
      get: function () {
        return s.GraphQLInt;
      },
    });
    Object.defineProperty(t, "GraphQLInterfaceType", {
      enumerable: true,
      get: function () {
        return s.GraphQLInterfaceType;
      },
    });
    Object.defineProperty(t, "GraphQLList", {
      enumerable: true,
      get: function () {
        return s.GraphQLList;
      },
    });
    Object.defineProperty(t, "GraphQLNonNull", {
      enumerable: true,
      get: function () {
        return s.GraphQLNonNull;
      },
    });
    Object.defineProperty(t, "GraphQLObjectType", {
      enumerable: true,
      get: function () {
        return s.GraphQLObjectType;
      },
    });
    Object.defineProperty(t, "GraphQLOneOfDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLOneOfDirective;
      },
    });
    Object.defineProperty(t, "GraphQLScalarType", {
      enumerable: true,
      get: function () {
        return s.GraphQLScalarType;
      },
    });
    Object.defineProperty(t, "GraphQLSchema", {
      enumerable: true,
      get: function () {
        return s.GraphQLSchema;
      },
    });
    Object.defineProperty(t, "GraphQLSkipDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLSkipDirective;
      },
    });
    Object.defineProperty(t, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLSpecifiedByDirective;
      },
    });
    Object.defineProperty(t, "GraphQLString", {
      enumerable: true,
      get: function () {
        return s.GraphQLString;
      },
    });
    Object.defineProperty(t, "GraphQLUnionType", {
      enumerable: true,
      get: function () {
        return s.GraphQLUnionType;
      },
    });
    Object.defineProperty(t, "Kind", {
      enumerable: true,
      get: function () {
        return i.Kind;
      },
    });
    Object.defineProperty(t, "KnownArgumentNamesRule", {
      enumerable: true,
      get: function () {
        return A.KnownArgumentNamesRule;
      },
    });
    Object.defineProperty(t, "KnownDirectivesRule", {
      enumerable: true,
      get: function () {
        return A.KnownDirectivesRule;
      },
    });
    Object.defineProperty(t, "KnownFragmentNamesRule", {
      enumerable: true,
      get: function () {
        return A.KnownFragmentNamesRule;
      },
    });
    Object.defineProperty(t, "KnownTypeNamesRule", {
      enumerable: true,
      get: function () {
        return A.KnownTypeNamesRule;
      },
    });
    Object.defineProperty(t, "Lexer", {
      enumerable: true,
      get: function () {
        return i.Lexer;
      },
    });
    Object.defineProperty(t, "Location", {
      enumerable: true,
      get: function () {
        return i.Location;
      },
    });
    Object.defineProperty(t, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: function () {
        return A.LoneAnonymousOperationRule;
      },
    });
    Object.defineProperty(t, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: function () {
        return A.LoneSchemaDefinitionRule;
      },
    });
    Object.defineProperty(t, "MaxIntrospectionDepthRule", {
      enumerable: true,
      get: function () {
        return A.MaxIntrospectionDepthRule;
      },
    });
    Object.defineProperty(t, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: function () {
        return A.NoDeprecatedCustomRule;
      },
    });
    Object.defineProperty(t, "NoFragmentCyclesRule", {
      enumerable: true,
      get: function () {
        return A.NoFragmentCyclesRule;
      },
    });
    Object.defineProperty(t, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: function () {
        return A.NoSchemaIntrospectionCustomRule;
      },
    });
    Object.defineProperty(t, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: function () {
        return A.NoUndefinedVariablesRule;
      },
    });
    Object.defineProperty(t, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: function () {
        return A.NoUnusedFragmentsRule;
      },
    });
    Object.defineProperty(t, "NoUnusedVariablesRule", {
      enumerable: true,
      get: function () {
        return A.NoUnusedVariablesRule;
      },
    });
    Object.defineProperty(t, "OperationTypeNode", {
      enumerable: true,
      get: function () {
        return i.OperationTypeNode;
      },
    });
    Object.defineProperty(t, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: function () {
        return A.OverlappingFieldsCanBeMergedRule;
      },
    });
    Object.defineProperty(t, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: function () {
        return A.PossibleFragmentSpreadsRule;
      },
    });
    Object.defineProperty(t, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: function () {
        return A.PossibleTypeExtensionsRule;
      },
    });
    Object.defineProperty(t, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: function () {
        return A.ProvidedRequiredArgumentsRule;
      },
    });
    Object.defineProperty(t, "ScalarLeafsRule", {
      enumerable: true,
      get: function () {
        return A.ScalarLeafsRule;
      },
    });
    Object.defineProperty(t, "SchemaMetaFieldDef", {
      enumerable: true,
      get: function () {
        return s.SchemaMetaFieldDef;
      },
    });
    Object.defineProperty(t, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: function () {
        return A.SingleFieldSubscriptionsRule;
      },
    });
    Object.defineProperty(t, "Source", {
      enumerable: true,
      get: function () {
        return i.Source;
      },
    });
    Object.defineProperty(t, "Token", {
      enumerable: true,
      get: function () {
        return i.Token;
      },
    });
    Object.defineProperty(t, "TokenKind", {
      enumerable: true,
      get: function () {
        return i.TokenKind;
      },
    });
    Object.defineProperty(t, "TypeInfo", {
      enumerable: true,
      get: function () {
        return u.TypeInfo;
      },
    });
    Object.defineProperty(t, "TypeKind", {
      enumerable: true,
      get: function () {
        return s.TypeKind;
      },
    });
    Object.defineProperty(t, "TypeMetaFieldDef", {
      enumerable: true,
      get: function () {
        return s.TypeMetaFieldDef;
      },
    });
    Object.defineProperty(t, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: function () {
        return s.TypeNameMetaFieldDef;
      },
    });
    Object.defineProperty(t, "UniqueArgumentDefinitionNamesRule", {
      enumerable: true,
      get: function () {
        return A.UniqueArgumentDefinitionNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: function () {
        return A.UniqueArgumentNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: function () {
        return A.UniqueDirectiveNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: function () {
        return A.UniqueDirectivesPerLocationRule;
      },
    });
    Object.defineProperty(t, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: function () {
        return A.UniqueEnumValueNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: function () {
        return A.UniqueFieldDefinitionNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: function () {
        return A.UniqueFragmentNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: function () {
        return A.UniqueInputFieldNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueOperationNamesRule", {
      enumerable: true,
      get: function () {
        return A.UniqueOperationNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueOperationTypesRule", {
      enumerable: true,
      get: function () {
        return A.UniqueOperationTypesRule;
      },
    });
    Object.defineProperty(t, "UniqueTypeNamesRule", {
      enumerable: true,
      get: function () {
        return A.UniqueTypeNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueVariableNamesRule", {
      enumerable: true,
      get: function () {
        return A.UniqueVariableNamesRule;
      },
    });
    Object.defineProperty(t, "ValidationContext", {
      enumerable: true,
      get: function () {
        return A.ValidationContext;
      },
    });
    Object.defineProperty(t, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: function () {
        return A.ValuesOfCorrectTypeRule;
      },
    });
    Object.defineProperty(t, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: function () {
        return A.VariablesAreInputTypesRule;
      },
    });
    Object.defineProperty(t, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: function () {
        return A.VariablesInAllowedPositionRule;
      },
    });
    Object.defineProperty(t, "__Directive", {
      enumerable: true,
      get: function () {
        return s.__Directive;
      },
    });
    Object.defineProperty(t, "__DirectiveLocation", {
      enumerable: true,
      get: function () {
        return s.__DirectiveLocation;
      },
    });
    Object.defineProperty(t, "__EnumValue", {
      enumerable: true,
      get: function () {
        return s.__EnumValue;
      },
    });
    Object.defineProperty(t, "__Field", {
      enumerable: true,
      get: function () {
        return s.__Field;
      },
    });
    Object.defineProperty(t, "__InputValue", {
      enumerable: true,
      get: function () {
        return s.__InputValue;
      },
    });
    Object.defineProperty(t, "__Schema", {
      enumerable: true,
      get: function () {
        return s.__Schema;
      },
    });
    Object.defineProperty(t, "__Type", {
      enumerable: true,
      get: function () {
        return s.__Type;
      },
    });
    Object.defineProperty(t, "__TypeKind", {
      enumerable: true,
      get: function () {
        return s.__TypeKind;
      },
    });
    Object.defineProperty(t, "assertAbstractType", {
      enumerable: true,
      get: function () {
        return s.assertAbstractType;
      },
    });
    Object.defineProperty(t, "assertCompositeType", {
      enumerable: true,
      get: function () {
        return s.assertCompositeType;
      },
    });
    Object.defineProperty(t, "assertDirective", {
      enumerable: true,
      get: function () {
        return s.assertDirective;
      },
    });
    Object.defineProperty(t, "assertEnumType", {
      enumerable: true,
      get: function () {
        return s.assertEnumType;
      },
    });
    Object.defineProperty(t, "assertEnumValueName", {
      enumerable: true,
      get: function () {
        return s.assertEnumValueName;
      },
    });
    Object.defineProperty(t, "assertInputObjectType", {
      enumerable: true,
      get: function () {
        return s.assertInputObjectType;
      },
    });
    Object.defineProperty(t, "assertInputType", {
      enumerable: true,
      get: function () {
        return s.assertInputType;
      },
    });
    Object.defineProperty(t, "assertInterfaceType", {
      enumerable: true,
      get: function () {
        return s.assertInterfaceType;
      },
    });
    Object.defineProperty(t, "assertLeafType", {
      enumerable: true,
      get: function () {
        return s.assertLeafType;
      },
    });
    Object.defineProperty(t, "assertListType", {
      enumerable: true,
      get: function () {
        return s.assertListType;
      },
    });
    Object.defineProperty(t, "assertName", {
      enumerable: true,
      get: function () {
        return s.assertName;
      },
    });
    Object.defineProperty(t, "assertNamedType", {
      enumerable: true,
      get: function () {
        return s.assertNamedType;
      },
    });
    Object.defineProperty(t, "assertNonNullType", {
      enumerable: true,
      get: function () {
        return s.assertNonNullType;
      },
    });
    Object.defineProperty(t, "assertNullableType", {
      enumerable: true,
      get: function () {
        return s.assertNullableType;
      },
    });
    Object.defineProperty(t, "assertObjectType", {
      enumerable: true,
      get: function () {
        return s.assertObjectType;
      },
    });
    Object.defineProperty(t, "assertOutputType", {
      enumerable: true,
      get: function () {
        return s.assertOutputType;
      },
    });
    Object.defineProperty(t, "assertScalarType", {
      enumerable: true,
      get: function () {
        return s.assertScalarType;
      },
    });
    Object.defineProperty(t, "assertSchema", {
      enumerable: true,
      get: function () {
        return s.assertSchema;
      },
    });
    Object.defineProperty(t, "assertType", {
      enumerable: true,
      get: function () {
        return s.assertType;
      },
    });
    Object.defineProperty(t, "assertUnionType", {
      enumerable: true,
      get: function () {
        return s.assertUnionType;
      },
    });
    Object.defineProperty(t, "assertValidName", {
      enumerable: true,
      get: function () {
        return u.assertValidName;
      },
    });
    Object.defineProperty(t, "assertValidSchema", {
      enumerable: true,
      get: function () {
        return s.assertValidSchema;
      },
    });
    Object.defineProperty(t, "assertWrappingType", {
      enumerable: true,
      get: function () {
        return s.assertWrappingType;
      },
    });
    Object.defineProperty(t, "astFromValue", {
      enumerable: true,
      get: function () {
        return u.astFromValue;
      },
    });
    Object.defineProperty(t, "buildASTSchema", {
      enumerable: true,
      get: function () {
        return u.buildASTSchema;
      },
    });
    Object.defineProperty(t, "buildClientSchema", {
      enumerable: true,
      get: function () {
        return u.buildClientSchema;
      },
    });
    Object.defineProperty(t, "buildSchema", {
      enumerable: true,
      get: function () {
        return u.buildSchema;
      },
    });
    Object.defineProperty(t, "coerceInputValue", {
      enumerable: true,
      get: function () {
        return u.coerceInputValue;
      },
    });
    Object.defineProperty(t, "concatAST", {
      enumerable: true,
      get: function () {
        return u.concatAST;
      },
    });
    Object.defineProperty(t, "createSourceEventStream", {
      enumerable: true,
      get: function () {
        return a.createSourceEventStream;
      },
    });
    Object.defineProperty(t, "defaultFieldResolver", {
      enumerable: true,
      get: function () {
        return a.defaultFieldResolver;
      },
    });
    Object.defineProperty(t, "defaultTypeResolver", {
      enumerable: true,
      get: function () {
        return a.defaultTypeResolver;
      },
    });
    Object.defineProperty(t, "doTypesOverlap", {
      enumerable: true,
      get: function () {
        return u.doTypesOverlap;
      },
    });
    Object.defineProperty(t, "execute", {
      enumerable: true,
      get: function () {
        return a.execute;
      },
    });
    Object.defineProperty(t, "executeSync", {
      enumerable: true,
      get: function () {
        return a.executeSync;
      },
    });
    Object.defineProperty(t, "extendSchema", {
      enumerable: true,
      get: function () {
        return u.extendSchema;
      },
    });
    Object.defineProperty(t, "findBreakingChanges", {
      enumerable: true,
      get: function () {
        return u.findBreakingChanges;
      },
    });
    Object.defineProperty(t, "findDangerousChanges", {
      enumerable: true,
      get: function () {
        return u.findDangerousChanges;
      },
    });
    Object.defineProperty(t, "formatError", {
      enumerable: true,
      get: function () {
        return c.formatError;
      },
    });
    Object.defineProperty(t, "getArgumentValues", {
      enumerable: true,
      get: function () {
        return a.getArgumentValues;
      },
    });
    Object.defineProperty(t, "getDirectiveValues", {
      enumerable: true,
      get: function () {
        return a.getDirectiveValues;
      },
    });
    Object.defineProperty(t, "getEnterLeaveForKind", {
      enumerable: true,
      get: function () {
        return i.getEnterLeaveForKind;
      },
    });
    Object.defineProperty(t, "getIntrospectionQuery", {
      enumerable: true,
      get: function () {
        return u.getIntrospectionQuery;
      },
    });
    Object.defineProperty(t, "getLocation", {
      enumerable: true,
      get: function () {
        return i.getLocation;
      },
    });
    Object.defineProperty(t, "getNamedType", {
      enumerable: true,
      get: function () {
        return s.getNamedType;
      },
    });
    Object.defineProperty(t, "getNullableType", {
      enumerable: true,
      get: function () {
        return s.getNullableType;
      },
    });
    Object.defineProperty(t, "getOperationAST", {
      enumerable: true,
      get: function () {
        return u.getOperationAST;
      },
    });
    Object.defineProperty(t, "getOperationRootType", {
      enumerable: true,
      get: function () {
        return u.getOperationRootType;
      },
    });
    Object.defineProperty(t, "getVariableValues", {
      enumerable: true,
      get: function () {
        return a.getVariableValues;
      },
    });
    Object.defineProperty(t, "getVisitFn", {
      enumerable: true,
      get: function () {
        return i.getVisitFn;
      },
    });
    Object.defineProperty(t, "graphql", {
      enumerable: true,
      get: function () {
        return o.graphql;
      },
    });
    Object.defineProperty(t, "graphqlSync", {
      enumerable: true,
      get: function () {
        return o.graphqlSync;
      },
    });
    Object.defineProperty(t, "introspectionFromSchema", {
      enumerable: true,
      get: function () {
        return u.introspectionFromSchema;
      },
    });
    Object.defineProperty(t, "introspectionTypes", {
      enumerable: true,
      get: function () {
        return s.introspectionTypes;
      },
    });
    Object.defineProperty(t, "isAbstractType", {
      enumerable: true,
      get: function () {
        return s.isAbstractType;
      },
    });
    Object.defineProperty(t, "isCompositeType", {
      enumerable: true,
      get: function () {
        return s.isCompositeType;
      },
    });
    Object.defineProperty(t, "isConstValueNode", {
      enumerable: true,
      get: function () {
        return i.isConstValueNode;
      },
    });
    Object.defineProperty(t, "isDefinitionNode", {
      enumerable: true,
      get: function () {
        return i.isDefinitionNode;
      },
    });
    Object.defineProperty(t, "isDirective", {
      enumerable: true,
      get: function () {
        return s.isDirective;
      },
    });
    Object.defineProperty(t, "isEnumType", {
      enumerable: true,
      get: function () {
        return s.isEnumType;
      },
    });
    Object.defineProperty(t, "isEqualType", {
      enumerable: true,
      get: function () {
        return u.isEqualType;
      },
    });
    Object.defineProperty(t, "isExecutableDefinitionNode", {
      enumerable: true,
      get: function () {
        return i.isExecutableDefinitionNode;
      },
    });
    Object.defineProperty(t, "isInputObjectType", {
      enumerable: true,
      get: function () {
        return s.isInputObjectType;
      },
    });
    Object.defineProperty(t, "isInputType", {
      enumerable: true,
      get: function () {
        return s.isInputType;
      },
    });
    Object.defineProperty(t, "isInterfaceType", {
      enumerable: true,
      get: function () {
        return s.isInterfaceType;
      },
    });
    Object.defineProperty(t, "isIntrospectionType", {
      enumerable: true,
      get: function () {
        return s.isIntrospectionType;
      },
    });
    Object.defineProperty(t, "isLeafType", {
      enumerable: true,
      get: function () {
        return s.isLeafType;
      },
    });
    Object.defineProperty(t, "isListType", {
      enumerable: true,
      get: function () {
        return s.isListType;
      },
    });
    Object.defineProperty(t, "isNamedType", {
      enumerable: true,
      get: function () {
        return s.isNamedType;
      },
    });
    Object.defineProperty(t, "isNonNullType", {
      enumerable: true,
      get: function () {
        return s.isNonNullType;
      },
    });
    Object.defineProperty(t, "isNullableType", {
      enumerable: true,
      get: function () {
        return s.isNullableType;
      },
    });
    Object.defineProperty(t, "isObjectType", {
      enumerable: true,
      get: function () {
        return s.isObjectType;
      },
    });
    Object.defineProperty(t, "isOutputType", {
      enumerable: true,
      get: function () {
        return s.isOutputType;
      },
    });
    Object.defineProperty(t, "isRequiredArgument", {
      enumerable: true,
      get: function () {
        return s.isRequiredArgument;
      },
    });
    Object.defineProperty(t, "isRequiredInputField", {
      enumerable: true,
      get: function () {
        return s.isRequiredInputField;
      },
    });
    Object.defineProperty(t, "isScalarType", {
      enumerable: true,
      get: function () {
        return s.isScalarType;
      },
    });
    Object.defineProperty(t, "isSchema", {
      enumerable: true,
      get: function () {
        return s.isSchema;
      },
    });
    Object.defineProperty(t, "isSelectionNode", {
      enumerable: true,
      get: function () {
        return i.isSelectionNode;
      },
    });
    Object.defineProperty(t, "isSpecifiedDirective", {
      enumerable: true,
      get: function () {
        return s.isSpecifiedDirective;
      },
    });
    Object.defineProperty(t, "isSpecifiedScalarType", {
      enumerable: true,
      get: function () {
        return s.isSpecifiedScalarType;
      },
    });
    Object.defineProperty(t, "isType", {
      enumerable: true,
      get: function () {
        return s.isType;
      },
    });
    Object.defineProperty(t, "isTypeDefinitionNode", {
      enumerable: true,
      get: function () {
        return i.isTypeDefinitionNode;
      },
    });
    Object.defineProperty(t, "isTypeExtensionNode", {
      enumerable: true,
      get: function () {
        return i.isTypeExtensionNode;
      },
    });
    Object.defineProperty(t, "isTypeNode", {
      enumerable: true,
      get: function () {
        return i.isTypeNode;
      },
    });
    Object.defineProperty(t, "isTypeSubTypeOf", {
      enumerable: true,
      get: function () {
        return u.isTypeSubTypeOf;
      },
    });
    Object.defineProperty(t, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: function () {
        return i.isTypeSystemDefinitionNode;
      },
    });
    Object.defineProperty(t, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: function () {
        return i.isTypeSystemExtensionNode;
      },
    });
    Object.defineProperty(t, "isUnionType", {
      enumerable: true,
      get: function () {
        return s.isUnionType;
      },
    });
    Object.defineProperty(t, "isValidNameError", {
      enumerable: true,
      get: function () {
        return u.isValidNameError;
      },
    });
    Object.defineProperty(t, "isValueNode", {
      enumerable: true,
      get: function () {
        return i.isValueNode;
      },
    });
    Object.defineProperty(t, "isWrappingType", {
      enumerable: true,
      get: function () {
        return s.isWrappingType;
      },
    });
    Object.defineProperty(t, "lexicographicSortSchema", {
      enumerable: true,
      get: function () {
        return u.lexicographicSortSchema;
      },
    });
    Object.defineProperty(t, "locatedError", {
      enumerable: true,
      get: function () {
        return c.locatedError;
      },
    });
    Object.defineProperty(t, "parse", {
      enumerable: true,
      get: function () {
        return i.parse;
      },
    });
    Object.defineProperty(t, "parseConstValue", {
      enumerable: true,
      get: function () {
        return i.parseConstValue;
      },
    });
    Object.defineProperty(t, "parseType", {
      enumerable: true,
      get: function () {
        return i.parseType;
      },
    });
    Object.defineProperty(t, "parseValue", {
      enumerable: true,
      get: function () {
        return i.parseValue;
      },
    });
    Object.defineProperty(t, "print", {
      enumerable: true,
      get: function () {
        return i.print;
      },
    });
    Object.defineProperty(t, "printError", {
      enumerable: true,
      get: function () {
        return c.printError;
      },
    });
    Object.defineProperty(t, "printIntrospectionSchema", {
      enumerable: true,
      get: function () {
        return u.printIntrospectionSchema;
      },
    });
    Object.defineProperty(t, "printLocation", {
      enumerable: true,
      get: function () {
        return i.printLocation;
      },
    });
    Object.defineProperty(t, "printSchema", {
      enumerable: true,
      get: function () {
        return u.printSchema;
      },
    });
    Object.defineProperty(t, "printSourceLocation", {
      enumerable: true,
      get: function () {
        return i.printSourceLocation;
      },
    });
    Object.defineProperty(t, "printType", {
      enumerable: true,
      get: function () {
        return u.printType;
      },
    });
    Object.defineProperty(t, "recommendedRules", {
      enumerable: true,
      get: function () {
        return A.recommendedRules;
      },
    });
    Object.defineProperty(t, "resolveObjMapThunk", {
      enumerable: true,
      get: function () {
        return s.resolveObjMapThunk;
      },
    });
    Object.defineProperty(t, "resolveReadonlyArrayThunk", {
      enumerable: true,
      get: function () {
        return s.resolveReadonlyArrayThunk;
      },
    });
    Object.defineProperty(t, "responsePathAsArray", {
      enumerable: true,
      get: function () {
        return a.responsePathAsArray;
      },
    });
    Object.defineProperty(t, "separateOperations", {
      enumerable: true,
      get: function () {
        return u.separateOperations;
      },
    });
    Object.defineProperty(t, "specifiedDirectives", {
      enumerable: true,
      get: function () {
        return s.specifiedDirectives;
      },
    });
    Object.defineProperty(t, "specifiedRules", {
      enumerable: true,
      get: function () {
        return A.specifiedRules;
      },
    });
    Object.defineProperty(t, "specifiedScalarTypes", {
      enumerable: true,
      get: function () {
        return s.specifiedScalarTypes;
      },
    });
    Object.defineProperty(t, "stripIgnoredCharacters", {
      enumerable: true,
      get: function () {
        return u.stripIgnoredCharacters;
      },
    });
    Object.defineProperty(t, "subscribe", {
      enumerable: true,
      get: function () {
        return a.subscribe;
      },
    });
    Object.defineProperty(t, "syntaxError", {
      enumerable: true,
      get: function () {
        return c.syntaxError;
      },
    });
    Object.defineProperty(t, "typeFromAST", {
      enumerable: true,
      get: function () {
        return u.typeFromAST;
      },
    });
    Object.defineProperty(t, "validate", {
      enumerable: true,
      get: function () {
        return A.validate;
      },
    });
    Object.defineProperty(t, "validateSchema", {
      enumerable: true,
      get: function () {
        return s.validateSchema;
      },
    });
    Object.defineProperty(t, "valueFromAST", {
      enumerable: true,
      get: function () {
        return u.valueFromAST;
      },
    });
    Object.defineProperty(t, "valueFromASTUntyped", {
      enumerable: true,
      get: function () {
        return u.valueFromASTUntyped;
      },
    });
    Object.defineProperty(t, "version", {
      enumerable: true,
      get: function () {
        return n.version;
      },
    });
    Object.defineProperty(t, "versionInfo", {
      enumerable: true,
      get: function () {
        return n.versionInfo;
      },
    });
    Object.defineProperty(t, "visit", {
      enumerable: true,
      get: function () {
        return i.visit;
      },
    });
    Object.defineProperty(t, "visitInParallel", {
      enumerable: true,
      get: function () {
        return i.visitInParallel;
      },
    });
    Object.defineProperty(t, "visitWithTypeInfo", {
      enumerable: true,
      get: function () {
        return u.visitWithTypeInfo;
      },
    });
    var n = r(28818);
    var o = r(32623);
    var s = r(5387);
    var i = r(17609);
    var a = r(69843);
    var A = r(18280);
    var c = r(34987);
    var u = r(32729);
  },
  42090: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.addPath = addPath;
    t.pathToArray = pathToArray;
    function addPath(e, t, r) {
      return { prev: e, key: t, typename: r };
    }
    function pathToArray(e) {
      const t = [];
      let r = e;
      while (r) {
        t.push(r.key);
        r = r.prev;
      }
      return t.reverse();
    }
  },
  53284: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.devAssert = devAssert;
    function devAssert(e, t) {
      const r = Boolean(e);
      if (!r) {
        throw new Error(t);
      }
    }
  },
  62384: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.didYouMean = didYouMean;
    const r = 5;
    function didYouMean(e, t) {
      const [n, o] = t ? [e, t] : [undefined, e];
      let s = " Did you mean ";
      if (n) {
        s += n + " ";
      }
      const i = o.map((e) => `"${e}"`);
      switch (i.length) {
        case 0:
          return "";
        case 1:
          return s + i[0] + "?";
        case 2:
          return s + i[0] + " or " + i[1] + "?";
      }
      const a = i.slice(0, r);
      const A = a.pop();
      return s + a.join(", ") + ", or " + A + "?";
    }
  },
  91763: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.groupBy = groupBy;
    function groupBy(e, t) {
      const r = new Map();
      for (const n of e) {
        const e = t(n);
        const o = r.get(e);
        if (o === undefined) {
          r.set(e, [n]);
        } else {
          o.push(n);
        }
      }
      return r;
    }
  },
  32017: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.identityFunc = identityFunc;
    function identityFunc(e) {
      return e;
    }
  },
  71801: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.inspect = inspect;
    const r = 10;
    const n = 2;
    function inspect(e) {
      return formatValue(e, []);
    }
    function formatValue(e, t) {
      switch (typeof e) {
        case "string":
          return JSON.stringify(e);
        case "function":
          return e.name ? `[function ${e.name}]` : "[function]";
        case "object":
          return formatObjectValue(e, t);
        default:
          return String(e);
      }
    }
    function formatObjectValue(e, t) {
      if (e === null) {
        return "null";
      }
      if (t.includes(e)) {
        return "[Circular]";
      }
      const r = [...t, e];
      if (isJSONable(e)) {
        const t = e.toJSON();
        if (t !== e) {
          return typeof t === "string" ? t : formatValue(t, r);
        }
      } else if (Array.isArray(e)) {
        return formatArray(e, r);
      }
      return formatObject(e, r);
    }
    function isJSONable(e) {
      return typeof e.toJSON === "function";
    }
    function formatObject(e, t) {
      const r = Object.entries(e);
      if (r.length === 0) {
        return "{}";
      }
      if (t.length > n) {
        return "[" + getObjectTag(e) + "]";
      }
      const o = r.map(([e, r]) => e + ": " + formatValue(r, t));
      return "{ " + o.join(", ") + " }";
    }
    function formatArray(e, t) {
      if (e.length === 0) {
        return "[]";
      }
      if (t.length > n) {
        return "[Array]";
      }
      const o = Math.min(r, e.length);
      const s = e.length - o;
      const i = [];
      for (let r = 0; r < o; ++r) {
        i.push(formatValue(e[r], t));
      }
      if (s === 1) {
        i.push("... 1 more item");
      } else if (s > 1) {
        i.push(`... ${s} more items`);
      }
      return "[" + i.join(", ") + "]";
    }
    function getObjectTag(e) {
      const t = Object.prototype.toString
        .call(e)
        .replace(/^\[object /, "")
        .replace(/]$/, "");
      if (t === "Object" && typeof e.constructor === "function") {
        const t = e.constructor.name;
        if (typeof t === "string" && t !== "") {
          return t;
        }
      }
      return t;
    }
  },
  24551: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.instanceOf = void 0;
    var n = r(71801);
    const o = globalThis.process && process.env.NODE_ENV === "production";
    const s = o
      ? function instanceOf(e, t) {
          return e instanceof t;
        }
      : function instanceOf(e, t) {
          if (e instanceof t) {
            return true;
          }
          if (typeof e === "object" && e !== null) {
            var r;
            const o = t.prototype[Symbol.toStringTag];
            const s = Symbol.toStringTag in e ? e[Symbol.toStringTag] : (r = e.constructor) === null || r === void 0 ? void 0 : r.name;
            if (o === s) {
              const t = (0, n.inspect)(e);
              throw new Error(
                `Cannot use ${o} "${t}" from another module or realm.\n\nEnsure that there is only one instance of "graphql" in the node_modules\ndirectory. If different versions of "graphql" are the dependencies of other\nrelied on modules, use "resolutions" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate "graphql" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results.`
              );
            }
          }
          return false;
        };
    t.instanceOf = s;
  },
  67305: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.invariant = invariant;
    function invariant(e, t) {
      const r = Boolean(e);
      if (!r) {
        throw new Error(t != null ? t : "Unexpected invariant triggered.");
      }
    }
  },
  21043: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.isAsyncIterable = isAsyncIterable;
    function isAsyncIterable(e) {
      return typeof (e === null || e === void 0 ? void 0 : e[Symbol.asyncIterator]) === "function";
    }
  },
  12916: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.isIterableObject = isIterableObject;
    function isIterableObject(e) {
      return typeof e === "object" && typeof (e === null || e === void 0 ? void 0 : e[Symbol.iterator]) === "function";
    }
  },
  84849: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.isObjectLike = isObjectLike;
    function isObjectLike(e) {
      return typeof e == "object" && e !== null;
    }
  },
  21916: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.isPromise = isPromise;
    function isPromise(e) {
      return typeof (e === null || e === void 0 ? void 0 : e.then) === "function";
    }
  },
  97982: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.keyMap = keyMap;
    function keyMap(e, t) {
      const r = Object.create(null);
      for (const n of e) {
        r[t(n)] = n;
      }
      return r;
    }
  },
  7897: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.keyValMap = keyValMap;
    function keyValMap(e, t, r) {
      const n = Object.create(null);
      for (const o of e) {
        n[t(o)] = r(o);
      }
      return n;
    }
  },
  73830: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.mapValue = mapValue;
    function mapValue(e, t) {
      const r = Object.create(null);
      for (const n of Object.keys(e)) {
        r[n] = t(e[n], n);
      }
      return r;
    }
  },
  54872: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.memoize3 = memoize3;
    function memoize3(e) {
      let t;
      return function memoized(r, n, o) {
        if (t === undefined) {
          t = new WeakMap();
        }
        let s = t.get(r);
        if (s === undefined) {
          s = new WeakMap();
          t.set(r, s);
        }
        let i = s.get(n);
        if (i === undefined) {
          i = new WeakMap();
          s.set(n, i);
        }
        let a = i.get(o);
        if (a === undefined) {
          a = e(r, n, o);
          i.set(o, a);
        }
        return a;
      };
    }
  },
  9585: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.naturalCompare = naturalCompare;
    function naturalCompare(e, t) {
      let n = 0;
      let o = 0;
      while (n < e.length && o < t.length) {
        let s = e.charCodeAt(n);
        let i = t.charCodeAt(o);
        if (isDigit(s) && isDigit(i)) {
          let a = 0;
          do {
            ++n;
            a = a * 10 + s - r;
            s = e.charCodeAt(n);
          } while (isDigit(s) && a > 0);
          let A = 0;
          do {
            ++o;
            A = A * 10 + i - r;
            i = t.charCodeAt(o);
          } while (isDigit(i) && A > 0);
          if (a < A) {
            return -1;
          }
          if (a > A) {
            return 1;
          }
        } else {
          if (s < i) {
            return -1;
          }
          if (s > i) {
            return 1;
          }
          ++n;
          ++o;
        }
      }
      return e.length - t.length;
    }
    const r = 48;
    const n = 57;
    function isDigit(e) {
      return !isNaN(e) && r <= e && e <= n;
    }
  },
  81292: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.printPathArray = printPathArray;
    function printPathArray(e) {
      return e.map((e) => (typeof e === "number" ? "[" + e.toString() + "]" : "." + e)).join("");
    }
  },
  20654: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.promiseForObject = promiseForObject;
    function promiseForObject(e) {
      return Promise.all(Object.values(e)).then((t) => {
        const r = Object.create(null);
        for (const [n, o] of Object.keys(e).entries()) {
          r[o] = t[n];
        }
        return r;
      });
    }
  },
  64222: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.promiseReduce = promiseReduce;
    var n = r(21916);
    function promiseReduce(e, t, r) {
      let o = r;
      for (const r of e) {
        o = (0, n.isPromise)(o) ? o.then((e) => t(e, r)) : t(o, r);
      }
      return o;
    }
  },
  18765: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.suggestionList = suggestionList;
    var n = r(9585);
    function suggestionList(e, t) {
      const r = Object.create(null);
      const o = new LexicalDistance(e);
      const s = Math.floor(e.length * 0.4) + 1;
      for (const e of t) {
        const t = o.measure(e, s);
        if (t !== undefined) {
          r[e] = t;
        }
      }
      return Object.keys(r).sort((e, t) => {
        const o = r[e] - r[t];
        return o !== 0 ? o : (0, n.naturalCompare)(e, t);
      });
    }
    class LexicalDistance {
      constructor(e) {
        this._input = e;
        this._inputLowerCase = e.toLowerCase();
        this._inputArray = stringToArray(this._inputLowerCase);
        this._rows = [new Array(e.length + 1).fill(0), new Array(e.length + 1).fill(0), new Array(e.length + 1).fill(0)];
      }
      measure(e, t) {
        if (this._input === e) {
          return 0;
        }
        const r = e.toLowerCase();
        if (this._inputLowerCase === r) {
          return 1;
        }
        let n = stringToArray(r);
        let o = this._inputArray;
        if (n.length < o.length) {
          const e = n;
          n = o;
          o = e;
        }
        const s = n.length;
        const i = o.length;
        if (s - i > t) {
          return undefined;
        }
        const a = this._rows;
        for (let e = 0; e <= i; e++) {
          a[0][e] = e;
        }
        for (let e = 1; e <= s; e++) {
          const r = a[(e - 1) % 3];
          const s = a[e % 3];
          let A = (s[0] = e);
          for (let t = 1; t <= i; t++) {
            const i = n[e - 1] === o[t - 1] ? 0 : 1;
            let c = Math.min(r[t] + 1, s[t - 1] + 1, r[t - 1] + i);
            if (e > 1 && t > 1 && n[e - 1] === o[t - 2] && n[e - 2] === o[t - 1]) {
              const r = a[(e - 2) % 3][t - 2];
              c = Math.min(c, r + 1);
            }
            if (c < A) {
              A = c;
            }
            s[t] = c;
          }
          if (A > t) {
            return undefined;
          }
        }
        const A = a[s % 3][i];
        return A <= t ? A : undefined;
      }
    }
    function stringToArray(e) {
      const t = e.length;
      const r = new Array(t);
      for (let n = 0; n < t; ++n) {
        r[n] = e.charCodeAt(n);
      }
      return r;
    }
  },
  7060: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.toError = toError;
    var n = r(71801);
    function toError(e) {
      return e instanceof Error ? e : new NonErrorThrown(e);
    }
    class NonErrorThrown extends Error {
      constructor(e) {
        super("Unexpected error value: " + (0, n.inspect)(e));
        this.name = "NonErrorThrown";
        this.thrownValue = e;
      }
    }
  },
  27949: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.toObjMap = toObjMap;
    function toObjMap(e) {
      if (e == null) {
        return Object.create(null);
      }
      if (Object.getPrototypeOf(e) === null) {
        return e;
      }
      const t = Object.create(null);
      for (const [r, n] of Object.entries(e)) {
        t[r] = n;
      }
      return t;
    }
  },
  26081: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Token = t.QueryDocumentKeys = t.OperationTypeNode = t.Location = void 0;
    t.isNode = isNode;
    class Location {
      constructor(e, t, r) {
        this.start = e.start;
        this.end = t.end;
        this.startToken = e;
        this.endToken = t;
        this.source = r;
      }
      get [Symbol.toStringTag]() {
        return "Location";
      }
      toJSON() {
        return { start: this.start, end: this.end };
      }
    }
    t.Location = Location;
    class Token {
      constructor(e, t, r, n, o, s) {
        this.kind = e;
        this.start = t;
        this.end = r;
        this.line = n;
        this.column = o;
        this.value = s;
        this.prev = null;
        this.next = null;
      }
      get [Symbol.toStringTag]() {
        return "Token";
      }
      toJSON() {
        return { kind: this.kind, value: this.value, line: this.line, column: this.column };
      }
    }
    t.Token = Token;
    const r = {
      Name: [],
      Document: ["definitions"],
      OperationDefinition: ["name", "variableDefinitions", "directives", "selectionSet"],
      VariableDefinition: ["variable", "type", "defaultValue", "directives"],
      Variable: ["name"],
      SelectionSet: ["selections"],
      Field: ["alias", "name", "arguments", "directives", "selectionSet"],
      Argument: ["name", "value"],
      FragmentSpread: ["name", "directives"],
      InlineFragment: ["typeCondition", "directives", "selectionSet"],
      FragmentDefinition: ["name", "variableDefinitions", "typeCondition", "directives", "selectionSet"],
      IntValue: [],
      FloatValue: [],
      StringValue: [],
      BooleanValue: [],
      NullValue: [],
      EnumValue: [],
      ListValue: ["values"],
      ObjectValue: ["fields"],
      ObjectField: ["name", "value"],
      Directive: ["name", "arguments"],
      NamedType: ["name"],
      ListType: ["type"],
      NonNullType: ["type"],
      SchemaDefinition: ["description", "directives", "operationTypes"],
      OperationTypeDefinition: ["type"],
      ScalarTypeDefinition: ["description", "name", "directives"],
      ObjectTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
      FieldDefinition: ["description", "name", "arguments", "type", "directives"],
      InputValueDefinition: ["description", "name", "type", "defaultValue", "directives"],
      InterfaceTypeDefinition: ["description", "name", "interfaces", "directives", "fields"],
      UnionTypeDefinition: ["description", "name", "directives", "types"],
      EnumTypeDefinition: ["description", "name", "directives", "values"],
      EnumValueDefinition: ["description", "name", "directives"],
      InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
      DirectiveDefinition: ["description", "name", "arguments", "locations"],
      SchemaExtension: ["directives", "operationTypes"],
      ScalarTypeExtension: ["name", "directives"],
      ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
      InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
      UnionTypeExtension: ["name", "directives", "types"],
      EnumTypeExtension: ["name", "directives", "values"],
      InputObjectTypeExtension: ["name", "directives", "fields"],
    };
    t.QueryDocumentKeys = r;
    const n = new Set(Object.keys(r));
    function isNode(e) {
      const t = e === null || e === void 0 ? void 0 : e.kind;
      return typeof t === "string" && n.has(t);
    }
    var o;
    t.OperationTypeNode = o;
    (function (e) {
      e["QUERY"] = "query";
      e["MUTATION"] = "mutation";
      e["SUBSCRIPTION"] = "subscription";
    })(o || (t.OperationTypeNode = o = {}));
  },
  44077: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.dedentBlockStringLines = dedentBlockStringLines;
    t.isPrintableAsBlockString = isPrintableAsBlockString;
    t.printBlockString = printBlockString;
    var n = r(58396);
    function dedentBlockStringLines(e) {
      var t;
      let r = Number.MAX_SAFE_INTEGER;
      let n = null;
      let o = -1;
      for (let t = 0; t < e.length; ++t) {
        var s;
        const i = e[t];
        const a = leadingWhitespace(i);
        if (a === i.length) {
          continue;
        }
        n = (s = n) !== null && s !== void 0 ? s : t;
        o = t;
        if (t !== 0 && a < r) {
          r = a;
        }
      }
      return e.map((e, t) => (t === 0 ? e : e.slice(r))).slice((t = n) !== null && t !== void 0 ? t : 0, o + 1);
    }
    function leadingWhitespace(e) {
      let t = 0;
      while (t < e.length && (0, n.isWhiteSpace)(e.charCodeAt(t))) {
        ++t;
      }
      return t;
    }
    function isPrintableAsBlockString(e) {
      if (e === "") {
        return true;
      }
      let t = true;
      let r = false;
      let n = true;
      let o = false;
      for (let s = 0; s < e.length; ++s) {
        switch (e.codePointAt(s)) {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 11:
          case 12:
          case 14:
          case 15:
            return false;
          case 13:
            return false;
          case 10:
            if (t && !o) {
              return false;
            }
            o = true;
            t = true;
            r = false;
            break;
          case 9:
          case 32:
            r || (r = t);
            break;
          default:
            n && (n = r);
            t = false;
        }
      }
      if (t) {
        return false;
      }
      if (n && o) {
        return false;
      }
      return true;
    }
    function printBlockString(e, t) {
      const r = e.replace(/"""/g, '\\"""');
      const o = r.split(/\r\n|[\n\r]/g);
      const s = o.length === 1;
      const i = o.length > 1 && o.slice(1).every((e) => e.length === 0 || (0, n.isWhiteSpace)(e.charCodeAt(0)));
      const a = r.endsWith('\\"""');
      const A = e.endsWith('"') && !a;
      const c = e.endsWith("\\");
      const u = A || c;
      const l = !(t !== null && t !== void 0 && t.minimize) && (!s || e.length > 70 || u || i || a);
      let p = "";
      const d = s && (0, n.isWhiteSpace)(e.charCodeAt(0));
      if ((l && !d) || i) {
        p += "\n";
      }
      p += r;
      if (l || u) {
        p += "\n";
      }
      return '"""' + p + '"""';
    }
  },
  58396: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.isDigit = isDigit;
    t.isLetter = isLetter;
    t.isNameContinue = isNameContinue;
    t.isNameStart = isNameStart;
    t.isWhiteSpace = isWhiteSpace;
    function isWhiteSpace(e) {
      return e === 9 || e === 32;
    }
    function isDigit(e) {
      return e >= 48 && e <= 57;
    }
    function isLetter(e) {
      return (e >= 97 && e <= 122) || (e >= 65 && e <= 90);
    }
    function isNameStart(e) {
      return isLetter(e) || e === 95;
    }
    function isNameContinue(e) {
      return isLetter(e) || isDigit(e) || e === 95;
    }
  },
  57503: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.DirectiveLocation = void 0;
    var r;
    t.DirectiveLocation = r;
    (function (e) {
      e["QUERY"] = "QUERY";
      e["MUTATION"] = "MUTATION";
      e["SUBSCRIPTION"] = "SUBSCRIPTION";
      e["FIELD"] = "FIELD";
      e["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
      e["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
      e["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
      e["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
      e["SCHEMA"] = "SCHEMA";
      e["SCALAR"] = "SCALAR";
      e["OBJECT"] = "OBJECT";
      e["FIELD_DEFINITION"] = "FIELD_DEFINITION";
      e["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
      e["INTERFACE"] = "INTERFACE";
      e["UNION"] = "UNION";
      e["ENUM"] = "ENUM";
      e["ENUM_VALUE"] = "ENUM_VALUE";
      e["INPUT_OBJECT"] = "INPUT_OBJECT";
      e["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
    })(r || (t.DirectiveLocation = r = {}));
  },
  17609: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    Object.defineProperty(t, "BREAK", {
      enumerable: true,
      get: function () {
        return l.BREAK;
      },
    });
    Object.defineProperty(t, "DirectiveLocation", {
      enumerable: true,
      get: function () {
        return g.DirectiveLocation;
      },
    });
    Object.defineProperty(t, "Kind", {
      enumerable: true,
      get: function () {
        return i.Kind;
      },
    });
    Object.defineProperty(t, "Lexer", {
      enumerable: true,
      get: function () {
        return A.Lexer;
      },
    });
    Object.defineProperty(t, "Location", {
      enumerable: true,
      get: function () {
        return p.Location;
      },
    });
    Object.defineProperty(t, "OperationTypeNode", {
      enumerable: true,
      get: function () {
        return p.OperationTypeNode;
      },
    });
    Object.defineProperty(t, "Source", {
      enumerable: true,
      get: function () {
        return n.Source;
      },
    });
    Object.defineProperty(t, "Token", {
      enumerable: true,
      get: function () {
        return p.Token;
      },
    });
    Object.defineProperty(t, "TokenKind", {
      enumerable: true,
      get: function () {
        return a.TokenKind;
      },
    });
    Object.defineProperty(t, "getEnterLeaveForKind", {
      enumerable: true,
      get: function () {
        return l.getEnterLeaveForKind;
      },
    });
    Object.defineProperty(t, "getLocation", {
      enumerable: true,
      get: function () {
        return o.getLocation;
      },
    });
    Object.defineProperty(t, "getVisitFn", {
      enumerable: true,
      get: function () {
        return l.getVisitFn;
      },
    });
    Object.defineProperty(t, "isConstValueNode", {
      enumerable: true,
      get: function () {
        return d.isConstValueNode;
      },
    });
    Object.defineProperty(t, "isDefinitionNode", {
      enumerable: true,
      get: function () {
        return d.isDefinitionNode;
      },
    });
    Object.defineProperty(t, "isExecutableDefinitionNode", {
      enumerable: true,
      get: function () {
        return d.isExecutableDefinitionNode;
      },
    });
    Object.defineProperty(t, "isSelectionNode", {
      enumerable: true,
      get: function () {
        return d.isSelectionNode;
      },
    });
    Object.defineProperty(t, "isTypeDefinitionNode", {
      enumerable: true,
      get: function () {
        return d.isTypeDefinitionNode;
      },
    });
    Object.defineProperty(t, "isTypeExtensionNode", {
      enumerable: true,
      get: function () {
        return d.isTypeExtensionNode;
      },
    });
    Object.defineProperty(t, "isTypeNode", {
      enumerable: true,
      get: function () {
        return d.isTypeNode;
      },
    });
    Object.defineProperty(t, "isTypeSystemDefinitionNode", {
      enumerable: true,
      get: function () {
        return d.isTypeSystemDefinitionNode;
      },
    });
    Object.defineProperty(t, "isTypeSystemExtensionNode", {
      enumerable: true,
      get: function () {
        return d.isTypeSystemExtensionNode;
      },
    });
    Object.defineProperty(t, "isValueNode", {
      enumerable: true,
      get: function () {
        return d.isValueNode;
      },
    });
    Object.defineProperty(t, "parse", {
      enumerable: true,
      get: function () {
        return c.parse;
      },
    });
    Object.defineProperty(t, "parseConstValue", {
      enumerable: true,
      get: function () {
        return c.parseConstValue;
      },
    });
    Object.defineProperty(t, "parseType", {
      enumerable: true,
      get: function () {
        return c.parseType;
      },
    });
    Object.defineProperty(t, "parseValue", {
      enumerable: true,
      get: function () {
        return c.parseValue;
      },
    });
    Object.defineProperty(t, "print", {
      enumerable: true,
      get: function () {
        return u.print;
      },
    });
    Object.defineProperty(t, "printLocation", {
      enumerable: true,
      get: function () {
        return s.printLocation;
      },
    });
    Object.defineProperty(t, "printSourceLocation", {
      enumerable: true,
      get: function () {
        return s.printSourceLocation;
      },
    });
    Object.defineProperty(t, "visit", {
      enumerable: true,
      get: function () {
        return l.visit;
      },
    });
    Object.defineProperty(t, "visitInParallel", {
      enumerable: true,
      get: function () {
        return l.visitInParallel;
      },
    });
    var n = r(58588);
    var o = r(82986);
    var s = r(33369);
    var i = r(19254);
    var a = r(22894);
    var A = r(91523);
    var c = r(71878);
    var u = r(85401);
    var l = r(45399);
    var p = r(26081);
    var d = r(24147);
    var g = r(57503);
  },
  19254: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Kind = void 0;
    var r;
    t.Kind = r;
    (function (e) {
      e["NAME"] = "Name";
      e["DOCUMENT"] = "Document";
      e["OPERATION_DEFINITION"] = "OperationDefinition";
      e["VARIABLE_DEFINITION"] = "VariableDefinition";
      e["SELECTION_SET"] = "SelectionSet";
      e["FIELD"] = "Field";
      e["ARGUMENT"] = "Argument";
      e["FRAGMENT_SPREAD"] = "FragmentSpread";
      e["INLINE_FRAGMENT"] = "InlineFragment";
      e["FRAGMENT_DEFINITION"] = "FragmentDefinition";
      e["VARIABLE"] = "Variable";
      e["INT"] = "IntValue";
      e["FLOAT"] = "FloatValue";
      e["STRING"] = "StringValue";
      e["BOOLEAN"] = "BooleanValue";
      e["NULL"] = "NullValue";
      e["ENUM"] = "EnumValue";
      e["LIST"] = "ListValue";
      e["OBJECT"] = "ObjectValue";
      e["OBJECT_FIELD"] = "ObjectField";
      e["DIRECTIVE"] = "Directive";
      e["NAMED_TYPE"] = "NamedType";
      e["LIST_TYPE"] = "ListType";
      e["NON_NULL_TYPE"] = "NonNullType";
      e["SCHEMA_DEFINITION"] = "SchemaDefinition";
      e["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
      e["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
      e["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
      e["FIELD_DEFINITION"] = "FieldDefinition";
      e["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
      e["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
      e["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
      e["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
      e["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
      e["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
      e["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
      e["SCHEMA_EXTENSION"] = "SchemaExtension";
      e["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
      e["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
      e["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
      e["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
      e["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
      e["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
    })(r || (t.Kind = r = {}));
  },
  91523: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Lexer = void 0;
    t.isPunctuatorTokenKind = isPunctuatorTokenKind;
    var n = r(41144);
    var o = r(26081);
    var s = r(44077);
    var i = r(58396);
    var a = r(22894);
    class Lexer {
      constructor(e) {
        const t = new o.Token(a.TokenKind.SOF, 0, 0, 0, 0);
        this.source = e;
        this.lastToken = t;
        this.token = t;
        this.line = 1;
        this.lineStart = 0;
      }
      get [Symbol.toStringTag]() {
        return "Lexer";
      }
      advance() {
        this.lastToken = this.token;
        const e = (this.token = this.lookahead());
        return e;
      }
      lookahead() {
        let e = this.token;
        if (e.kind !== a.TokenKind.EOF) {
          do {
            if (e.next) {
              e = e.next;
            } else {
              const t = readNextToken(this, e.end);
              e.next = t;
              t.prev = e;
              e = t;
            }
          } while (e.kind === a.TokenKind.COMMENT);
        }
        return e;
      }
    }
    t.Lexer = Lexer;
    function isPunctuatorTokenKind(e) {
      return (
        e === a.TokenKind.BANG ||
        e === a.TokenKind.DOLLAR ||
        e === a.TokenKind.AMP ||
        e === a.TokenKind.PAREN_L ||
        e === a.TokenKind.PAREN_R ||
        e === a.TokenKind.SPREAD ||
        e === a.TokenKind.COLON ||
        e === a.TokenKind.EQUALS ||
        e === a.TokenKind.AT ||
        e === a.TokenKind.BRACKET_L ||
        e === a.TokenKind.BRACKET_R ||
        e === a.TokenKind.BRACE_L ||
        e === a.TokenKind.PIPE ||
        e === a.TokenKind.BRACE_R
      );
    }
    function isUnicodeScalarValue(e) {
      return (e >= 0 && e <= 55295) || (e >= 57344 && e <= 1114111);
    }
    function isSupplementaryCodePoint(e, t) {
      return isLeadingSurrogate(e.charCodeAt(t)) && isTrailingSurrogate(e.charCodeAt(t + 1));
    }
    function isLeadingSurrogate(e) {
      return e >= 55296 && e <= 56319;
    }
    function isTrailingSurrogate(e) {
      return e >= 56320 && e <= 57343;
    }
    function printCodePointAt(e, t) {
      const r = e.source.body.codePointAt(t);
      if (r === undefined) {
        return a.TokenKind.EOF;
      } else if (r >= 32 && r <= 126) {
        const e = String.fromCodePoint(r);
        return e === '"' ? "'\"'" : `"${e}"`;
      }
      return "U+" + r.toString(16).toUpperCase().padStart(4, "0");
    }
    function createToken(e, t, r, n, s) {
      const i = e.line;
      const a = 1 + r - e.lineStart;
      return new o.Token(t, r, n, i, a, s);
    }
    function readNextToken(e, t) {
      const r = e.source.body;
      const o = r.length;
      let s = t;
      while (s < o) {
        const t = r.charCodeAt(s);
        switch (t) {
          case 65279:
          case 9:
          case 32:
          case 44:
            ++s;
            continue;
          case 10:
            ++s;
            ++e.line;
            e.lineStart = s;
            continue;
          case 13:
            if (r.charCodeAt(s + 1) === 10) {
              s += 2;
            } else {
              ++s;
            }
            ++e.line;
            e.lineStart = s;
            continue;
          case 35:
            return readComment(e, s);
          case 33:
            return createToken(e, a.TokenKind.BANG, s, s + 1);
          case 36:
            return createToken(e, a.TokenKind.DOLLAR, s, s + 1);
          case 38:
            return createToken(e, a.TokenKind.AMP, s, s + 1);
          case 40:
            return createToken(e, a.TokenKind.PAREN_L, s, s + 1);
          case 41:
            return createToken(e, a.TokenKind.PAREN_R, s, s + 1);
          case 46:
            if (r.charCodeAt(s + 1) === 46 && r.charCodeAt(s + 2) === 46) {
              return createToken(e, a.TokenKind.SPREAD, s, s + 3);
            }
            break;
          case 58:
            return createToken(e, a.TokenKind.COLON, s, s + 1);
          case 61:
            return createToken(e, a.TokenKind.EQUALS, s, s + 1);
          case 64:
            return createToken(e, a.TokenKind.AT, s, s + 1);
          case 91:
            return createToken(e, a.TokenKind.BRACKET_L, s, s + 1);
          case 93:
            return createToken(e, a.TokenKind.BRACKET_R, s, s + 1);
          case 123:
            return createToken(e, a.TokenKind.BRACE_L, s, s + 1);
          case 124:
            return createToken(e, a.TokenKind.PIPE, s, s + 1);
          case 125:
            return createToken(e, a.TokenKind.BRACE_R, s, s + 1);
          case 34:
            if (r.charCodeAt(s + 1) === 34 && r.charCodeAt(s + 2) === 34) {
              return readBlockString(e, s);
            }
            return readString(e, s);
        }
        if ((0, i.isDigit)(t) || t === 45) {
          return readNumber(e, s, t);
        }
        if ((0, i.isNameStart)(t)) {
          return readName(e, s);
        }
        throw (0, n.syntaxError)(
          e.source,
          s,
          t === 39
            ? "Unexpected single quote character ('), did you mean to use a double quote (\")?"
            : isUnicodeScalarValue(t) || isSupplementaryCodePoint(r, s)
              ? `Unexpected character: ${printCodePointAt(e, s)}.`
              : `Invalid character: ${printCodePointAt(e, s)}.`
        );
      }
      return createToken(e, a.TokenKind.EOF, o, o);
    }
    function readComment(e, t) {
      const r = e.source.body;
      const n = r.length;
      let o = t + 1;
      while (o < n) {
        const e = r.charCodeAt(o);
        if (e === 10 || e === 13) {
          break;
        }
        if (isUnicodeScalarValue(e)) {
          ++o;
        } else if (isSupplementaryCodePoint(r, o)) {
          o += 2;
        } else {
          break;
        }
      }
      return createToken(e, a.TokenKind.COMMENT, t, o, r.slice(t + 1, o));
    }
    function readNumber(e, t, r) {
      const o = e.source.body;
      let s = t;
      let A = r;
      let c = false;
      if (A === 45) {
        A = o.charCodeAt(++s);
      }
      if (A === 48) {
        A = o.charCodeAt(++s);
        if ((0, i.isDigit)(A)) {
          throw (0, n.syntaxError)(e.source, s, `Invalid number, unexpected digit after 0: ${printCodePointAt(e, s)}.`);
        }
      } else {
        s = readDigits(e, s, A);
        A = o.charCodeAt(s);
      }
      if (A === 46) {
        c = true;
        A = o.charCodeAt(++s);
        s = readDigits(e, s, A);
        A = o.charCodeAt(s);
      }
      if (A === 69 || A === 101) {
        c = true;
        A = o.charCodeAt(++s);
        if (A === 43 || A === 45) {
          A = o.charCodeAt(++s);
        }
        s = readDigits(e, s, A);
        A = o.charCodeAt(s);
      }
      if (A === 46 || (0, i.isNameStart)(A)) {
        throw (0, n.syntaxError)(e.source, s, `Invalid number, expected digit but got: ${printCodePointAt(e, s)}.`);
      }
      return createToken(e, c ? a.TokenKind.FLOAT : a.TokenKind.INT, t, s, o.slice(t, s));
    }
    function readDigits(e, t, r) {
      if (!(0, i.isDigit)(r)) {
        throw (0, n.syntaxError)(e.source, t, `Invalid number, expected digit but got: ${printCodePointAt(e, t)}.`);
      }
      const o = e.source.body;
      let s = t + 1;
      while ((0, i.isDigit)(o.charCodeAt(s))) {
        ++s;
      }
      return s;
    }
    function readString(e, t) {
      const r = e.source.body;
      const o = r.length;
      let s = t + 1;
      let i = s;
      let A = "";
      while (s < o) {
        const o = r.charCodeAt(s);
        if (o === 34) {
          A += r.slice(i, s);
          return createToken(e, a.TokenKind.STRING, t, s + 1, A);
        }
        if (o === 92) {
          A += r.slice(i, s);
          const t =
            r.charCodeAt(s + 1) === 117
              ? r.charCodeAt(s + 2) === 123
                ? readEscapedUnicodeVariableWidth(e, s)
                : readEscapedUnicodeFixedWidth(e, s)
              : readEscapedCharacter(e, s);
          A += t.value;
          s += t.size;
          i = s;
          continue;
        }
        if (o === 10 || o === 13) {
          break;
        }
        if (isUnicodeScalarValue(o)) {
          ++s;
        } else if (isSupplementaryCodePoint(r, s)) {
          s += 2;
        } else {
          throw (0, n.syntaxError)(e.source, s, `Invalid character within String: ${printCodePointAt(e, s)}.`);
        }
      }
      throw (0, n.syntaxError)(e.source, s, "Unterminated string.");
    }
    function readEscapedUnicodeVariableWidth(e, t) {
      const r = e.source.body;
      let o = 0;
      let s = 3;
      while (s < 12) {
        const e = r.charCodeAt(t + s++);
        if (e === 125) {
          if (s < 5 || !isUnicodeScalarValue(o)) {
            break;
          }
          return { value: String.fromCodePoint(o), size: s };
        }
        o = (o << 4) | readHexDigit(e);
        if (o < 0) {
          break;
        }
      }
      throw (0, n.syntaxError)(e.source, t, `Invalid Unicode escape sequence: "${r.slice(t, t + s)}".`);
    }
    function readEscapedUnicodeFixedWidth(e, t) {
      const r = e.source.body;
      const o = read16BitHexCode(r, t + 2);
      if (isUnicodeScalarValue(o)) {
        return { value: String.fromCodePoint(o), size: 6 };
      }
      if (isLeadingSurrogate(o)) {
        if (r.charCodeAt(t + 6) === 92 && r.charCodeAt(t + 7) === 117) {
          const e = read16BitHexCode(r, t + 8);
          if (isTrailingSurrogate(e)) {
            return { value: String.fromCodePoint(o, e), size: 12 };
          }
        }
      }
      throw (0, n.syntaxError)(e.source, t, `Invalid Unicode escape sequence: "${r.slice(t, t + 6)}".`);
    }
    function read16BitHexCode(e, t) {
      return (
        (readHexDigit(e.charCodeAt(t)) << 12) |
        (readHexDigit(e.charCodeAt(t + 1)) << 8) |
        (readHexDigit(e.charCodeAt(t + 2)) << 4) |
        readHexDigit(e.charCodeAt(t + 3))
      );
    }
    function readHexDigit(e) {
      return e >= 48 && e <= 57 ? e - 48 : e >= 65 && e <= 70 ? e - 55 : e >= 97 && e <= 102 ? e - 87 : -1;
    }
    function readEscapedCharacter(e, t) {
      const r = e.source.body;
      const o = r.charCodeAt(t + 1);
      switch (o) {
        case 34:
          return { value: '"', size: 2 };
        case 92:
          return { value: "\\", size: 2 };
        case 47:
          return { value: "/", size: 2 };
        case 98:
          return { value: "\b", size: 2 };
        case 102:
          return { value: "\f", size: 2 };
        case 110:
          return { value: "\n", size: 2 };
        case 114:
          return { value: "\r", size: 2 };
        case 116:
          return { value: "\t", size: 2 };
      }
      throw (0, n.syntaxError)(e.source, t, `Invalid character escape sequence: "${r.slice(t, t + 2)}".`);
    }
    function readBlockString(e, t) {
      const r = e.source.body;
      const o = r.length;
      let i = e.lineStart;
      let A = t + 3;
      let c = A;
      let u = "";
      const l = [];
      while (A < o) {
        const o = r.charCodeAt(A);
        if (o === 34 && r.charCodeAt(A + 1) === 34 && r.charCodeAt(A + 2) === 34) {
          u += r.slice(c, A);
          l.push(u);
          const n = createToken(e, a.TokenKind.BLOCK_STRING, t, A + 3, (0, s.dedentBlockStringLines)(l).join("\n"));
          e.line += l.length - 1;
          e.lineStart = i;
          return n;
        }
        if (o === 92 && r.charCodeAt(A + 1) === 34 && r.charCodeAt(A + 2) === 34 && r.charCodeAt(A + 3) === 34) {
          u += r.slice(c, A);
          c = A + 1;
          A += 4;
          continue;
        }
        if (o === 10 || o === 13) {
          u += r.slice(c, A);
          l.push(u);
          if (o === 13 && r.charCodeAt(A + 1) === 10) {
            A += 2;
          } else {
            ++A;
          }
          u = "";
          c = A;
          i = A;
          continue;
        }
        if (isUnicodeScalarValue(o)) {
          ++A;
        } else if (isSupplementaryCodePoint(r, A)) {
          A += 2;
        } else {
          throw (0, n.syntaxError)(e.source, A, `Invalid character within String: ${printCodePointAt(e, A)}.`);
        }
      }
      throw (0, n.syntaxError)(e.source, A, "Unterminated string.");
    }
    function readName(e, t) {
      const r = e.source.body;
      const n = r.length;
      let o = t + 1;
      while (o < n) {
        const e = r.charCodeAt(o);
        if ((0, i.isNameContinue)(e)) {
          ++o;
        } else {
          break;
        }
      }
      return createToken(e, a.TokenKind.NAME, t, o, r.slice(t, o));
    }
  },
  82986: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.getLocation = getLocation;
    var n = r(67305);
    const o = /\r\n|[\n\r]/g;
    function getLocation(e, t) {
      let r = 0;
      let s = 1;
      for (const i of e.body.matchAll(o)) {
        typeof i.index === "number" || (0, n.invariant)(false);
        if (i.index >= t) {
          break;
        }
        r = i.index + i[0].length;
        s += 1;
      }
      return { line: s, column: t + 1 - r };
    }
  },
  71878: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Parser = void 0;
    t.parse = parse;
    t.parseConstValue = parseConstValue;
    t.parseType = parseType;
    t.parseValue = parseValue;
    var n = r(41144);
    var o = r(26081);
    var s = r(57503);
    var i = r(19254);
    var a = r(91523);
    var A = r(58588);
    var c = r(22894);
    function parse(e, t) {
      const r = new Parser(e, t);
      return r.parseDocument();
    }
    function parseValue(e, t) {
      const r = new Parser(e, t);
      r.expectToken(c.TokenKind.SOF);
      const n = r.parseValueLiteral(false);
      r.expectToken(c.TokenKind.EOF);
      return n;
    }
    function parseConstValue(e, t) {
      const r = new Parser(e, t);
      r.expectToken(c.TokenKind.SOF);
      const n = r.parseConstValueLiteral();
      r.expectToken(c.TokenKind.EOF);
      return n;
    }
    function parseType(e, t) {
      const r = new Parser(e, t);
      r.expectToken(c.TokenKind.SOF);
      const n = r.parseTypeReference();
      r.expectToken(c.TokenKind.EOF);
      return n;
    }
    class Parser {
      constructor(e, t = {}) {
        const r = (0, A.isSource)(e) ? e : new A.Source(e);
        this._lexer = new a.Lexer(r);
        this._options = t;
        this._tokenCounter = 0;
      }
      parseName() {
        const e = this.expectToken(c.TokenKind.NAME);
        return this.node(e, { kind: i.Kind.NAME, value: e.value });
      }
      parseDocument() {
        return this.node(this._lexer.token, { kind: i.Kind.DOCUMENT, definitions: this.many(c.TokenKind.SOF, this.parseDefinition, c.TokenKind.EOF) });
      }
      parseDefinition() {
        if (this.peek(c.TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        }
        const e = this.peekDescription();
        const t = e ? this._lexer.lookahead() : this._lexer.token;
        if (t.kind === c.TokenKind.NAME) {
          switch (t.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
          if (e) {
            throw (0, n.syntaxError)(
              this._lexer.source,
              this._lexer.token.start,
              "Unexpected description, descriptions are supported only on type definitions."
            );
          }
          switch (t.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        }
        throw this.unexpected(t);
      }
      parseOperationDefinition() {
        const e = this._lexer.token;
        if (this.peek(c.TokenKind.BRACE_L)) {
          return this.node(e, {
            kind: i.Kind.OPERATION_DEFINITION,
            operation: o.OperationTypeNode.QUERY,
            name: undefined,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet(),
          });
        }
        const t = this.parseOperationType();
        let r;
        if (this.peek(c.TokenKind.NAME)) {
          r = this.parseName();
        }
        return this.node(e, {
          kind: i.Kind.OPERATION_DEFINITION,
          operation: t,
          name: r,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
        });
      }
      parseOperationType() {
        const e = this.expectToken(c.TokenKind.NAME);
        switch (e.value) {
          case "query":
            return o.OperationTypeNode.QUERY;
          case "mutation":
            return o.OperationTypeNode.MUTATION;
          case "subscription":
            return o.OperationTypeNode.SUBSCRIPTION;
        }
        throw this.unexpected(e);
      }
      parseVariableDefinitions() {
        return this.optionalMany(c.TokenKind.PAREN_L, this.parseVariableDefinition, c.TokenKind.PAREN_R);
      }
      parseVariableDefinition() {
        return this.node(this._lexer.token, {
          kind: i.Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(c.TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(c.TokenKind.EQUALS) ? this.parseConstValueLiteral() : undefined,
          directives: this.parseConstDirectives(),
        });
      }
      parseVariable() {
        const e = this._lexer.token;
        this.expectToken(c.TokenKind.DOLLAR);
        return this.node(e, { kind: i.Kind.VARIABLE, name: this.parseName() });
      }
      parseSelectionSet() {
        return this.node(this._lexer.token, {
          kind: i.Kind.SELECTION_SET,
          selections: this.many(c.TokenKind.BRACE_L, this.parseSelection, c.TokenKind.BRACE_R),
        });
      }
      parseSelection() {
        return this.peek(c.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      }
      parseField() {
        const e = this._lexer.token;
        const t = this.parseName();
        let r;
        let n;
        if (this.expectOptionalToken(c.TokenKind.COLON)) {
          r = t;
          n = this.parseName();
        } else {
          n = t;
        }
        return this.node(e, {
          kind: i.Kind.FIELD,
          alias: r,
          name: n,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(c.TokenKind.BRACE_L) ? this.parseSelectionSet() : undefined,
        });
      }
      parseArguments(e) {
        const t = e ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(c.TokenKind.PAREN_L, t, c.TokenKind.PAREN_R);
      }
      parseArgument(e = false) {
        const t = this._lexer.token;
        const r = this.parseName();
        this.expectToken(c.TokenKind.COLON);
        return this.node(t, { kind: i.Kind.ARGUMENT, name: r, value: this.parseValueLiteral(e) });
      }
      parseConstArgument() {
        return this.parseArgument(true);
      }
      parseFragment() {
        const e = this._lexer.token;
        this.expectToken(c.TokenKind.SPREAD);
        const t = this.expectOptionalKeyword("on");
        if (!t && this.peek(c.TokenKind.NAME)) {
          return this.node(e, { kind: i.Kind.FRAGMENT_SPREAD, name: this.parseFragmentName(), directives: this.parseDirectives(false) });
        }
        return this.node(e, {
          kind: i.Kind.INLINE_FRAGMENT,
          typeCondition: t ? this.parseNamedType() : undefined,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
        });
      }
      parseFragmentDefinition() {
        const e = this._lexer.token;
        this.expectKeyword("fragment");
        if (this._options.allowLegacyFragmentVariables === true) {
          return this.node(e, {
            kind: i.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet(),
          });
        }
        return this.node(e, {
          kind: i.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
        });
      }
      parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      }
      parseValueLiteral(e) {
        const t = this._lexer.token;
        switch (t.kind) {
          case c.TokenKind.BRACKET_L:
            return this.parseList(e);
          case c.TokenKind.BRACE_L:
            return this.parseObject(e);
          case c.TokenKind.INT:
            this.advanceLexer();
            return this.node(t, { kind: i.Kind.INT, value: t.value });
          case c.TokenKind.FLOAT:
            this.advanceLexer();
            return this.node(t, { kind: i.Kind.FLOAT, value: t.value });
          case c.TokenKind.STRING:
          case c.TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case c.TokenKind.NAME:
            this.advanceLexer();
            switch (t.value) {
              case "true":
                return this.node(t, { kind: i.Kind.BOOLEAN, value: true });
              case "false":
                return this.node(t, { kind: i.Kind.BOOLEAN, value: false });
              case "null":
                return this.node(t, { kind: i.Kind.NULL });
              default:
                return this.node(t, { kind: i.Kind.ENUM, value: t.value });
            }
          case c.TokenKind.DOLLAR:
            if (e) {
              this.expectToken(c.TokenKind.DOLLAR);
              if (this._lexer.token.kind === c.TokenKind.NAME) {
                const e = this._lexer.token.value;
                throw (0, n.syntaxError)(this._lexer.source, t.start, `Unexpected variable "$${e}" in constant value.`);
              } else {
                throw this.unexpected(t);
              }
            }
            return this.parseVariable();
          default:
            throw this.unexpected();
        }
      }
      parseConstValueLiteral() {
        return this.parseValueLiteral(true);
      }
      parseStringLiteral() {
        const e = this._lexer.token;
        this.advanceLexer();
        return this.node(e, { kind: i.Kind.STRING, value: e.value, block: e.kind === c.TokenKind.BLOCK_STRING });
      }
      parseList(e) {
        const item = () => this.parseValueLiteral(e);
        return this.node(this._lexer.token, { kind: i.Kind.LIST, values: this.any(c.TokenKind.BRACKET_L, item, c.TokenKind.BRACKET_R) });
      }
      parseObject(e) {
        const item = () => this.parseObjectField(e);
        return this.node(this._lexer.token, { kind: i.Kind.OBJECT, fields: this.any(c.TokenKind.BRACE_L, item, c.TokenKind.BRACE_R) });
      }
      parseObjectField(e) {
        const t = this._lexer.token;
        const r = this.parseName();
        this.expectToken(c.TokenKind.COLON);
        return this.node(t, { kind: i.Kind.OBJECT_FIELD, name: r, value: this.parseValueLiteral(e) });
      }
      parseDirectives(e) {
        const t = [];
        while (this.peek(c.TokenKind.AT)) {
          t.push(this.parseDirective(e));
        }
        return t;
      }
      parseConstDirectives() {
        return this.parseDirectives(true);
      }
      parseDirective(e) {
        const t = this._lexer.token;
        this.expectToken(c.TokenKind.AT);
        return this.node(t, { kind: i.Kind.DIRECTIVE, name: this.parseName(), arguments: this.parseArguments(e) });
      }
      parseTypeReference() {
        const e = this._lexer.token;
        let t;
        if (this.expectOptionalToken(c.TokenKind.BRACKET_L)) {
          const r = this.parseTypeReference();
          this.expectToken(c.TokenKind.BRACKET_R);
          t = this.node(e, { kind: i.Kind.LIST_TYPE, type: r });
        } else {
          t = this.parseNamedType();
        }
        if (this.expectOptionalToken(c.TokenKind.BANG)) {
          return this.node(e, { kind: i.Kind.NON_NULL_TYPE, type: t });
        }
        return t;
      }
      parseNamedType() {
        return this.node(this._lexer.token, { kind: i.Kind.NAMED_TYPE, name: this.parseName() });
      }
      peekDescription() {
        return this.peek(c.TokenKind.STRING) || this.peek(c.TokenKind.BLOCK_STRING);
      }
      parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      }
      parseSchemaDefinition() {
        const e = this._lexer.token;
        const t = this.parseDescription();
        this.expectKeyword("schema");
        const r = this.parseConstDirectives();
        const n = this.many(c.TokenKind.BRACE_L, this.parseOperationTypeDefinition, c.TokenKind.BRACE_R);
        return this.node(e, { kind: i.Kind.SCHEMA_DEFINITION, description: t, directives: r, operationTypes: n });
      }
      parseOperationTypeDefinition() {
        const e = this._lexer.token;
        const t = this.parseOperationType();
        this.expectToken(c.TokenKind.COLON);
        const r = this.parseNamedType();
        return this.node(e, { kind: i.Kind.OPERATION_TYPE_DEFINITION, operation: t, type: r });
      }
      parseScalarTypeDefinition() {
        const e = this._lexer.token;
        const t = this.parseDescription();
        this.expectKeyword("scalar");
        const r = this.parseName();
        const n = this.parseConstDirectives();
        return this.node(e, { kind: i.Kind.SCALAR_TYPE_DEFINITION, description: t, name: r, directives: n });
      }
      parseObjectTypeDefinition() {
        const e = this._lexer.token;
        const t = this.parseDescription();
        this.expectKeyword("type");
        const r = this.parseName();
        const n = this.parseImplementsInterfaces();
        const o = this.parseConstDirectives();
        const s = this.parseFieldsDefinition();
        return this.node(e, { kind: i.Kind.OBJECT_TYPE_DEFINITION, description: t, name: r, interfaces: n, directives: o, fields: s });
      }
      parseImplementsInterfaces() {
        return this.expectOptionalKeyword("implements") ? this.delimitedMany(c.TokenKind.AMP, this.parseNamedType) : [];
      }
      parseFieldsDefinition() {
        return this.optionalMany(c.TokenKind.BRACE_L, this.parseFieldDefinition, c.TokenKind.BRACE_R);
      }
      parseFieldDefinition() {
        const e = this._lexer.token;
        const t = this.parseDescription();
        const r = this.parseName();
        const n = this.parseArgumentDefs();
        this.expectToken(c.TokenKind.COLON);
        const o = this.parseTypeReference();
        const s = this.parseConstDirectives();
        return this.node(e, { kind: i.Kind.FIELD_DEFINITION, description: t, name: r, arguments: n, type: o, directives: s });
      }
      parseArgumentDefs() {
        return this.optionalMany(c.TokenKind.PAREN_L, this.parseInputValueDef, c.TokenKind.PAREN_R);
      }
      parseInputValueDef() {
        const e = this._lexer.token;
        const t = this.parseDescription();
        const r = this.parseName();
        this.expectToken(c.TokenKind.COLON);
        const n = this.parseTypeReference();
        let o;
        if (this.expectOptionalToken(c.TokenKind.EQUALS)) {
          o = this.parseConstValueLiteral();
        }
        const s = this.parseConstDirectives();
        return this.node(e, { kind: i.Kind.INPUT_VALUE_DEFINITION, description: t, name: r, type: n, defaultValue: o, directives: s });
      }
      parseInterfaceTypeDefinition() {
        const e = this._lexer.token;
        const t = this.parseDescription();
        this.expectKeyword("interface");
        const r = this.parseName();
        const n = this.parseImplementsInterfaces();
        const o = this.parseConstDirectives();
        const s = this.parseFieldsDefinition();
        return this.node(e, { kind: i.Kind.INTERFACE_TYPE_DEFINITION, description: t, name: r, interfaces: n, directives: o, fields: s });
      }
      parseUnionTypeDefinition() {
        const e = this._lexer.token;
        const t = this.parseDescription();
        this.expectKeyword("union");
        const r = this.parseName();
        const n = this.parseConstDirectives();
        const o = this.parseUnionMemberTypes();
        return this.node(e, { kind: i.Kind.UNION_TYPE_DEFINITION, description: t, name: r, directives: n, types: o });
      }
      parseUnionMemberTypes() {
        return this.expectOptionalToken(c.TokenKind.EQUALS) ? this.delimitedMany(c.TokenKind.PIPE, this.parseNamedType) : [];
      }
      parseEnumTypeDefinition() {
        const e = this._lexer.token;
        const t = this.parseDescription();
        this.expectKeyword("enum");
        const r = this.parseName();
        const n = this.parseConstDirectives();
        const o = this.parseEnumValuesDefinition();
        return this.node(e, { kind: i.Kind.ENUM_TYPE_DEFINITION, description: t, name: r, directives: n, values: o });
      }
      parseEnumValuesDefinition() {
        return this.optionalMany(c.TokenKind.BRACE_L, this.parseEnumValueDefinition, c.TokenKind.BRACE_R);
      }
      parseEnumValueDefinition() {
        const e = this._lexer.token;
        const t = this.parseDescription();
        const r = this.parseEnumValueName();
        const n = this.parseConstDirectives();
        return this.node(e, { kind: i.Kind.ENUM_VALUE_DEFINITION, description: t, name: r, directives: n });
      }
      parseEnumValueName() {
        if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
          throw (0, n.syntaxError)(
            this._lexer.source,
            this._lexer.token.start,
            `${getTokenDesc(this._lexer.token)} is reserved and cannot be used for an enum value.`
          );
        }
        return this.parseName();
      }
      parseInputObjectTypeDefinition() {
        const e = this._lexer.token;
        const t = this.parseDescription();
        this.expectKeyword("input");
        const r = this.parseName();
        const n = this.parseConstDirectives();
        const o = this.parseInputFieldsDefinition();
        return this.node(e, { kind: i.Kind.INPUT_OBJECT_TYPE_DEFINITION, description: t, name: r, directives: n, fields: o });
      }
      parseInputFieldsDefinition() {
        return this.optionalMany(c.TokenKind.BRACE_L, this.parseInputValueDef, c.TokenKind.BRACE_R);
      }
      parseTypeSystemExtension() {
        const e = this._lexer.lookahead();
        if (e.kind === c.TokenKind.NAME) {
          switch (e.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(e);
      }
      parseSchemaExtension() {
        const e = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        const t = this.parseConstDirectives();
        const r = this.optionalMany(c.TokenKind.BRACE_L, this.parseOperationTypeDefinition, c.TokenKind.BRACE_R);
        if (t.length === 0 && r.length === 0) {
          throw this.unexpected();
        }
        return this.node(e, { kind: i.Kind.SCHEMA_EXTENSION, directives: t, operationTypes: r });
      }
      parseScalarTypeExtension() {
        const e = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        const t = this.parseName();
        const r = this.parseConstDirectives();
        if (r.length === 0) {
          throw this.unexpected();
        }
        return this.node(e, { kind: i.Kind.SCALAR_TYPE_EXTENSION, name: t, directives: r });
      }
      parseObjectTypeExtension() {
        const e = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        const t = this.parseName();
        const r = this.parseImplementsInterfaces();
        const n = this.parseConstDirectives();
        const o = this.parseFieldsDefinition();
        if (r.length === 0 && n.length === 0 && o.length === 0) {
          throw this.unexpected();
        }
        return this.node(e, { kind: i.Kind.OBJECT_TYPE_EXTENSION, name: t, interfaces: r, directives: n, fields: o });
      }
      parseInterfaceTypeExtension() {
        const e = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        const t = this.parseName();
        const r = this.parseImplementsInterfaces();
        const n = this.parseConstDirectives();
        const o = this.parseFieldsDefinition();
        if (r.length === 0 && n.length === 0 && o.length === 0) {
          throw this.unexpected();
        }
        return this.node(e, { kind: i.Kind.INTERFACE_TYPE_EXTENSION, name: t, interfaces: r, directives: n, fields: o });
      }
      parseUnionTypeExtension() {
        const e = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        const t = this.parseName();
        const r = this.parseConstDirectives();
        const n = this.parseUnionMemberTypes();
        if (r.length === 0 && n.length === 0) {
          throw this.unexpected();
        }
        return this.node(e, { kind: i.Kind.UNION_TYPE_EXTENSION, name: t, directives: r, types: n });
      }
      parseEnumTypeExtension() {
        const e = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        const t = this.parseName();
        const r = this.parseConstDirectives();
        const n = this.parseEnumValuesDefinition();
        if (r.length === 0 && n.length === 0) {
          throw this.unexpected();
        }
        return this.node(e, { kind: i.Kind.ENUM_TYPE_EXTENSION, name: t, directives: r, values: n });
      }
      parseInputObjectTypeExtension() {
        const e = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        const t = this.parseName();
        const r = this.parseConstDirectives();
        const n = this.parseInputFieldsDefinition();
        if (r.length === 0 && n.length === 0) {
          throw this.unexpected();
        }
        return this.node(e, { kind: i.Kind.INPUT_OBJECT_TYPE_EXTENSION, name: t, directives: r, fields: n });
      }
      parseDirectiveDefinition() {
        const e = this._lexer.token;
        const t = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(c.TokenKind.AT);
        const r = this.parseName();
        const n = this.parseArgumentDefs();
        const o = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        const s = this.parseDirectiveLocations();
        return this.node(e, { kind: i.Kind.DIRECTIVE_DEFINITION, description: t, name: r, arguments: n, repeatable: o, locations: s });
      }
      parseDirectiveLocations() {
        return this.delimitedMany(c.TokenKind.PIPE, this.parseDirectiveLocation);
      }
      parseDirectiveLocation() {
        const e = this._lexer.token;
        const t = this.parseName();
        if (Object.prototype.hasOwnProperty.call(s.DirectiveLocation, t.value)) {
          return t;
        }
        throw this.unexpected(e);
      }
      node(e, t) {
        if (this._options.noLocation !== true) {
          t.loc = new o.Location(e, this._lexer.lastToken, this._lexer.source);
        }
        return t;
      }
      peek(e) {
        return this._lexer.token.kind === e;
      }
      expectToken(e) {
        const t = this._lexer.token;
        if (t.kind === e) {
          this.advanceLexer();
          return t;
        }
        throw (0, n.syntaxError)(this._lexer.source, t.start, `Expected ${getTokenKindDesc(e)}, found ${getTokenDesc(t)}.`);
      }
      expectOptionalToken(e) {
        const t = this._lexer.token;
        if (t.kind === e) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      expectKeyword(e) {
        const t = this._lexer.token;
        if (t.kind === c.TokenKind.NAME && t.value === e) {
          this.advanceLexer();
        } else {
          throw (0, n.syntaxError)(this._lexer.source, t.start, `Expected "${e}", found ${getTokenDesc(t)}.`);
        }
      }
      expectOptionalKeyword(e) {
        const t = this._lexer.token;
        if (t.kind === c.TokenKind.NAME && t.value === e) {
          this.advanceLexer();
          return true;
        }
        return false;
      }
      unexpected(e) {
        const t = e !== null && e !== void 0 ? e : this._lexer.token;
        return (0, n.syntaxError)(this._lexer.source, t.start, `Unexpected ${getTokenDesc(t)}.`);
      }
      any(e, t, r) {
        this.expectToken(e);
        const n = [];
        while (!this.expectOptionalToken(r)) {
          n.push(t.call(this));
        }
        return n;
      }
      optionalMany(e, t, r) {
        if (this.expectOptionalToken(e)) {
          const e = [];
          do {
            e.push(t.call(this));
          } while (!this.expectOptionalToken(r));
          return e;
        }
        return [];
      }
      many(e, t, r) {
        this.expectToken(e);
        const n = [];
        do {
          n.push(t.call(this));
        } while (!this.expectOptionalToken(r));
        return n;
      }
      delimitedMany(e, t) {
        this.expectOptionalToken(e);
        const r = [];
        do {
          r.push(t.call(this));
        } while (this.expectOptionalToken(e));
        return r;
      }
      advanceLexer() {
        const { maxTokens: e } = this._options;
        const t = this._lexer.advance();
        if (e !== undefined && t.kind !== c.TokenKind.EOF) {
          ++this._tokenCounter;
          if (this._tokenCounter > e) {
            throw (0, n.syntaxError)(this._lexer.source, t.start, `Document contains more that ${e} tokens. Parsing aborted.`);
          }
        }
      }
    }
    t.Parser = Parser;
    function getTokenDesc(e) {
      const t = e.value;
      return getTokenKindDesc(e.kind) + (t != null ? ` "${t}"` : "");
    }
    function getTokenKindDesc(e) {
      return (0, a.isPunctuatorTokenKind)(e) ? `"${e}"` : e;
    }
  },
  24147: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.isConstValueNode = isConstValueNode;
    t.isDefinitionNode = isDefinitionNode;
    t.isExecutableDefinitionNode = isExecutableDefinitionNode;
    t.isSelectionNode = isSelectionNode;
    t.isTypeDefinitionNode = isTypeDefinitionNode;
    t.isTypeExtensionNode = isTypeExtensionNode;
    t.isTypeNode = isTypeNode;
    t.isTypeSystemDefinitionNode = isTypeSystemDefinitionNode;
    t.isTypeSystemExtensionNode = isTypeSystemExtensionNode;
    t.isValueNode = isValueNode;
    var n = r(19254);
    function isDefinitionNode(e) {
      return isExecutableDefinitionNode(e) || isTypeSystemDefinitionNode(e) || isTypeSystemExtensionNode(e);
    }
    function isExecutableDefinitionNode(e) {
      return e.kind === n.Kind.OPERATION_DEFINITION || e.kind === n.Kind.FRAGMENT_DEFINITION;
    }
    function isSelectionNode(e) {
      return e.kind === n.Kind.FIELD || e.kind === n.Kind.FRAGMENT_SPREAD || e.kind === n.Kind.INLINE_FRAGMENT;
    }
    function isValueNode(e) {
      return (
        e.kind === n.Kind.VARIABLE ||
        e.kind === n.Kind.INT ||
        e.kind === n.Kind.FLOAT ||
        e.kind === n.Kind.STRING ||
        e.kind === n.Kind.BOOLEAN ||
        e.kind === n.Kind.NULL ||
        e.kind === n.Kind.ENUM ||
        e.kind === n.Kind.LIST ||
        e.kind === n.Kind.OBJECT
      );
    }
    function isConstValueNode(e) {
      return (
        isValueNode(e) &&
        (e.kind === n.Kind.LIST
          ? e.values.some(isConstValueNode)
          : e.kind === n.Kind.OBJECT
            ? e.fields.some((e) => isConstValueNode(e.value))
            : e.kind !== n.Kind.VARIABLE)
      );
    }
    function isTypeNode(e) {
      return e.kind === n.Kind.NAMED_TYPE || e.kind === n.Kind.LIST_TYPE || e.kind === n.Kind.NON_NULL_TYPE;
    }
    function isTypeSystemDefinitionNode(e) {
      return e.kind === n.Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(e) || e.kind === n.Kind.DIRECTIVE_DEFINITION;
    }
    function isTypeDefinitionNode(e) {
      return (
        e.kind === n.Kind.SCALAR_TYPE_DEFINITION ||
        e.kind === n.Kind.OBJECT_TYPE_DEFINITION ||
        e.kind === n.Kind.INTERFACE_TYPE_DEFINITION ||
        e.kind === n.Kind.UNION_TYPE_DEFINITION ||
        e.kind === n.Kind.ENUM_TYPE_DEFINITION ||
        e.kind === n.Kind.INPUT_OBJECT_TYPE_DEFINITION
      );
    }
    function isTypeSystemExtensionNode(e) {
      return e.kind === n.Kind.SCHEMA_EXTENSION || isTypeExtensionNode(e);
    }
    function isTypeExtensionNode(e) {
      return (
        e.kind === n.Kind.SCALAR_TYPE_EXTENSION ||
        e.kind === n.Kind.OBJECT_TYPE_EXTENSION ||
        e.kind === n.Kind.INTERFACE_TYPE_EXTENSION ||
        e.kind === n.Kind.UNION_TYPE_EXTENSION ||
        e.kind === n.Kind.ENUM_TYPE_EXTENSION ||
        e.kind === n.Kind.INPUT_OBJECT_TYPE_EXTENSION
      );
    }
  },
  33369: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.printLocation = printLocation;
    t.printSourceLocation = printSourceLocation;
    var n = r(82986);
    function printLocation(e) {
      return printSourceLocation(e.source, (0, n.getLocation)(e.source, e.start));
    }
    function printSourceLocation(e, t) {
      const r = e.locationOffset.column - 1;
      const n = "".padStart(r) + e.body;
      const o = t.line - 1;
      const s = e.locationOffset.line - 1;
      const i = t.line + s;
      const a = t.line === 1 ? r : 0;
      const A = t.column + a;
      const c = `${e.name}:${i}:${A}\n`;
      const u = n.split(/\r\n|[\n\r]/g);
      const l = u[o];
      if (l.length > 120) {
        const e = Math.floor(A / 80);
        const t = A % 80;
        const r = [];
        for (let e = 0; e < l.length; e += 80) {
          r.push(l.slice(e, e + 80));
        }
        return c + printPrefixedLines([[`${i} |`, r[0]], ...r.slice(1, e + 1).map((e) => ["|", e]), ["|", "^".padStart(t)], ["|", r[e + 1]]]);
      }
      return (
        c +
        printPrefixedLines([
          [`${i - 1} |`, u[o - 1]],
          [`${i} |`, l],
          ["|", "^".padStart(A)],
          [`${i + 1} |`, u[o + 1]],
        ])
      );
    }
    function printPrefixedLines(e) {
      const t = e.filter(([e, t]) => t !== undefined);
      const r = Math.max(...t.map(([e]) => e.length));
      return t.map(([e, t]) => e.padStart(r) + (t ? " " + t : "")).join("\n");
    }
  },
  5663: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.printString = printString;
    function printString(e) {
      return `"${e.replace(r, escapedReplacer)}"`;
    }
    const r = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
    function escapedReplacer(e) {
      return n[e.charCodeAt(0)];
    }
    const n = [
      "\\u0000",
      "\\u0001",
      "\\u0002",
      "\\u0003",
      "\\u0004",
      "\\u0005",
      "\\u0006",
      "\\u0007",
      "\\b",
      "\\t",
      "\\n",
      "\\u000B",
      "\\f",
      "\\r",
      "\\u000E",
      "\\u000F",
      "\\u0010",
      "\\u0011",
      "\\u0012",
      "\\u0013",
      "\\u0014",
      "\\u0015",
      "\\u0016",
      "\\u0017",
      "\\u0018",
      "\\u0019",
      "\\u001A",
      "\\u001B",
      "\\u001C",
      "\\u001D",
      "\\u001E",
      "\\u001F",
      "",
      "",
      '\\"',
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\\\",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "",
      "\\u007F",
      "\\u0080",
      "\\u0081",
      "\\u0082",
      "\\u0083",
      "\\u0084",
      "\\u0085",
      "\\u0086",
      "\\u0087",
      "\\u0088",
      "\\u0089",
      "\\u008A",
      "\\u008B",
      "\\u008C",
      "\\u008D",
      "\\u008E",
      "\\u008F",
      "\\u0090",
      "\\u0091",
      "\\u0092",
      "\\u0093",
      "\\u0094",
      "\\u0095",
      "\\u0096",
      "\\u0097",
      "\\u0098",
      "\\u0099",
      "\\u009A",
      "\\u009B",
      "\\u009C",
      "\\u009D",
      "\\u009E",
      "\\u009F",
    ];
  },
  85401: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.print = print;
    var n = r(44077);
    var o = r(5663);
    var s = r(45399);
    function print(e) {
      return (0, s.visit)(e, a);
    }
    const i = 80;
    const a = {
      Name: { leave: (e) => e.value },
      Variable: { leave: (e) => "$" + e.name },
      Document: { leave: (e) => join(e.definitions, "\n\n") },
      OperationDefinition: {
        leave(e) {
          const t = wrap("(", join(e.variableDefinitions, ", "), ")");
          const r = join([e.operation, join([e.name, t]), join(e.directives, " ")], " ");
          return (r === "query" ? "" : r + " ") + e.selectionSet;
        },
      },
      VariableDefinition: { leave: ({ variable: e, type: t, defaultValue: r, directives: n }) => e + ": " + t + wrap(" = ", r) + wrap(" ", join(n, " ")) },
      SelectionSet: { leave: ({ selections: e }) => block(e) },
      Field: {
        leave({ alias: e, name: t, arguments: r, directives: n, selectionSet: o }) {
          const s = wrap("", e, ": ") + t;
          let a = s + wrap("(", join(r, ", "), ")");
          if (a.length > i) {
            a = s + wrap("(\n", indent(join(r, "\n")), "\n)");
          }
          return join([a, join(n, " "), o], " ");
        },
      },
      Argument: { leave: ({ name: e, value: t }) => e + ": " + t },
      FragmentSpread: { leave: ({ name: e, directives: t }) => "..." + e + wrap(" ", join(t, " ")) },
      InlineFragment: { leave: ({ typeCondition: e, directives: t, selectionSet: r }) => join(["...", wrap("on ", e), join(t, " "), r], " ") },
      FragmentDefinition: {
        leave: ({ name: e, typeCondition: t, variableDefinitions: r, directives: n, selectionSet: o }) =>
          `fragment ${e}${wrap("(", join(r, ", "), ")")} ` + `on ${t} ${wrap("", join(n, " "), " ")}` + o,
      },
      IntValue: { leave: ({ value: e }) => e },
      FloatValue: { leave: ({ value: e }) => e },
      StringValue: { leave: ({ value: e, block: t }) => (t ? (0, n.printBlockString)(e) : (0, o.printString)(e)) },
      BooleanValue: { leave: ({ value: e }) => (e ? "true" : "false") },
      NullValue: { leave: () => "null" },
      EnumValue: { leave: ({ value: e }) => e },
      ListValue: { leave: ({ values: e }) => "[" + join(e, ", ") + "]" },
      ObjectValue: { leave: ({ fields: e }) => "{" + join(e, ", ") + "}" },
      ObjectField: { leave: ({ name: e, value: t }) => e + ": " + t },
      Directive: { leave: ({ name: e, arguments: t }) => "@" + e + wrap("(", join(t, ", "), ")") },
      NamedType: { leave: ({ name: e }) => e },
      ListType: { leave: ({ type: e }) => "[" + e + "]" },
      NonNullType: { leave: ({ type: e }) => e + "!" },
      SchemaDefinition: { leave: ({ description: e, directives: t, operationTypes: r }) => wrap("", e, "\n") + join(["schema", join(t, " "), block(r)], " ") },
      OperationTypeDefinition: { leave: ({ operation: e, type: t }) => e + ": " + t },
      ScalarTypeDefinition: { leave: ({ description: e, name: t, directives: r }) => wrap("", e, "\n") + join(["scalar", t, join(r, " ")], " ") },
      ObjectTypeDefinition: {
        leave: ({ description: e, name: t, interfaces: r, directives: n, fields: o }) =>
          wrap("", e, "\n") + join(["type", t, wrap("implements ", join(r, " & ")), join(n, " "), block(o)], " "),
      },
      FieldDefinition: {
        leave: ({ description: e, name: t, arguments: r, type: n, directives: o }) =>
          wrap("", e, "\n") +
          t +
          (hasMultilineItems(r) ? wrap("(\n", indent(join(r, "\n")), "\n)") : wrap("(", join(r, ", "), ")")) +
          ": " +
          n +
          wrap(" ", join(o, " ")),
      },
      InputValueDefinition: {
        leave: ({ description: e, name: t, type: r, defaultValue: n, directives: o }) =>
          wrap("", e, "\n") + join([t + ": " + r, wrap("= ", n), join(o, " ")], " "),
      },
      InterfaceTypeDefinition: {
        leave: ({ description: e, name: t, interfaces: r, directives: n, fields: o }) =>
          wrap("", e, "\n") + join(["interface", t, wrap("implements ", join(r, " & ")), join(n, " "), block(o)], " "),
      },
      UnionTypeDefinition: {
        leave: ({ description: e, name: t, directives: r, types: n }) => wrap("", e, "\n") + join(["union", t, join(r, " "), wrap("= ", join(n, " | "))], " "),
      },
      EnumTypeDefinition: {
        leave: ({ description: e, name: t, directives: r, values: n }) => wrap("", e, "\n") + join(["enum", t, join(r, " "), block(n)], " "),
      },
      EnumValueDefinition: { leave: ({ description: e, name: t, directives: r }) => wrap("", e, "\n") + join([t, join(r, " ")], " ") },
      InputObjectTypeDefinition: {
        leave: ({ description: e, name: t, directives: r, fields: n }) => wrap("", e, "\n") + join(["input", t, join(r, " "), block(n)], " "),
      },
      DirectiveDefinition: {
        leave: ({ description: e, name: t, arguments: r, repeatable: n, locations: o }) =>
          wrap("", e, "\n") +
          "directive @" +
          t +
          (hasMultilineItems(r) ? wrap("(\n", indent(join(r, "\n")), "\n)") : wrap("(", join(r, ", "), ")")) +
          (n ? " repeatable" : "") +
          " on " +
          join(o, " | "),
      },
      SchemaExtension: { leave: ({ directives: e, operationTypes: t }) => join(["extend schema", join(e, " "), block(t)], " ") },
      ScalarTypeExtension: { leave: ({ name: e, directives: t }) => join(["extend scalar", e, join(t, " ")], " ") },
      ObjectTypeExtension: {
        leave: ({ name: e, interfaces: t, directives: r, fields: n }) =>
          join(["extend type", e, wrap("implements ", join(t, " & ")), join(r, " "), block(n)], " "),
      },
      InterfaceTypeExtension: {
        leave: ({ name: e, interfaces: t, directives: r, fields: n }) =>
          join(["extend interface", e, wrap("implements ", join(t, " & ")), join(r, " "), block(n)], " "),
      },
      UnionTypeExtension: { leave: ({ name: e, directives: t, types: r }) => join(["extend union", e, join(t, " "), wrap("= ", join(r, " | "))], " ") },
      EnumTypeExtension: { leave: ({ name: e, directives: t, values: r }) => join(["extend enum", e, join(t, " "), block(r)], " ") },
      InputObjectTypeExtension: { leave: ({ name: e, directives: t, fields: r }) => join(["extend input", e, join(t, " "), block(r)], " ") },
    };
    function join(e, t = "") {
      var r;
      return (r = e === null || e === void 0 ? void 0 : e.filter((e) => e).join(t)) !== null && r !== void 0 ? r : "";
    }
    function block(e) {
      return wrap("{\n", indent(join(e, "\n")), "\n}");
    }
    function wrap(e, t, r = "") {
      return t != null && t !== "" ? e + t + r : "";
    }
    function indent(e) {
      return wrap("  ", e.replace(/\n/g, "\n  "));
    }
    function hasMultilineItems(e) {
      var t;
      return (t = e === null || e === void 0 ? void 0 : e.some((e) => e.includes("\n"))) !== null && t !== void 0 ? t : false;
    }
  },
  58588: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Source = void 0;
    t.isSource = isSource;
    var n = r(53284);
    var o = r(71801);
    var s = r(24551);
    class Source {
      constructor(e, t = "GraphQL request", r = { line: 1, column: 1 }) {
        typeof e === "string" || (0, n.devAssert)(false, `Body must be a string. Received: ${(0, o.inspect)(e)}.`);
        this.body = e;
        this.name = t;
        this.locationOffset = r;
        this.locationOffset.line > 0 || (0, n.devAssert)(false, "line in locationOffset is 1-indexed and must be positive.");
        this.locationOffset.column > 0 || (0, n.devAssert)(false, "column in locationOffset is 1-indexed and must be positive.");
      }
      get [Symbol.toStringTag]() {
        return "Source";
      }
    }
    t.Source = Source;
    function isSource(e) {
      return (0, s.instanceOf)(e, Source);
    }
  },
  22894: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TokenKind = void 0;
    var r;
    t.TokenKind = r;
    (function (e) {
      e["SOF"] = "<SOF>";
      e["EOF"] = "<EOF>";
      e["BANG"] = "!";
      e["DOLLAR"] = "$";
      e["AMP"] = "&";
      e["PAREN_L"] = "(";
      e["PAREN_R"] = ")";
      e["SPREAD"] = "...";
      e["COLON"] = ":";
      e["EQUALS"] = "=";
      e["AT"] = "@";
      e["BRACKET_L"] = "[";
      e["BRACKET_R"] = "]";
      e["BRACE_L"] = "{";
      e["PIPE"] = "|";
      e["BRACE_R"] = "}";
      e["NAME"] = "Name";
      e["INT"] = "Int";
      e["FLOAT"] = "Float";
      e["STRING"] = "String";
      e["BLOCK_STRING"] = "BlockString";
      e["COMMENT"] = "Comment";
    })(r || (t.TokenKind = r = {}));
  },
  45399: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.BREAK = void 0;
    t.getEnterLeaveForKind = getEnterLeaveForKind;
    t.getVisitFn = getVisitFn;
    t.visit = visit;
    t.visitInParallel = visitInParallel;
    var n = r(53284);
    var o = r(71801);
    var s = r(26081);
    var i = r(19254);
    const a = Object.freeze({});
    t.BREAK = a;
    function visit(e, t, r = s.QueryDocumentKeys) {
      const A = new Map();
      for (const e of Object.values(i.Kind)) {
        A.set(e, getEnterLeaveForKind(t, e));
      }
      let c = undefined;
      let u = Array.isArray(e);
      let l = [e];
      let p = -1;
      let d = [];
      let g = e;
      let m = undefined;
      let h = undefined;
      const E = [];
      const I = [];
      do {
        p++;
        const e = p === l.length;
        const i = e && d.length !== 0;
        if (e) {
          m = I.length === 0 ? undefined : E[E.length - 1];
          g = h;
          h = I.pop();
          if (i) {
            if (u) {
              g = g.slice();
              let e = 0;
              for (const [t, r] of d) {
                const n = t - e;
                if (r === null) {
                  g.splice(n, 1);
                  e++;
                } else {
                  g[n] = r;
                }
              }
            } else {
              g = Object.defineProperties({}, Object.getOwnPropertyDescriptors(g));
              for (const [e, t] of d) {
                g[e] = t;
              }
            }
          }
          p = c.index;
          l = c.keys;
          d = c.edits;
          u = c.inArray;
          c = c.prev;
        } else if (h) {
          m = u ? p : l[p];
          g = h[m];
          if (g === null || g === undefined) {
            continue;
          }
          E.push(m);
        }
        let Q;
        if (!Array.isArray(g)) {
          var y, C;
          (0, s.isNode)(g) || (0, n.devAssert)(false, `Invalid AST Node: ${(0, o.inspect)(g)}.`);
          const r = e ? ((y = A.get(g.kind)) === null || y === void 0 ? void 0 : y.leave) : (C = A.get(g.kind)) === null || C === void 0 ? void 0 : C.enter;
          Q = r === null || r === void 0 ? void 0 : r.call(t, g, m, h, E, I);
          if (Q === a) {
            break;
          }
          if (Q === false) {
            if (!e) {
              E.pop();
              continue;
            }
          } else if (Q !== undefined) {
            d.push([m, Q]);
            if (!e) {
              if ((0, s.isNode)(Q)) {
                g = Q;
              } else {
                E.pop();
                continue;
              }
            }
          }
        }
        if (Q === undefined && i) {
          d.push([m, g]);
        }
        if (e) {
          E.pop();
        } else {
          var b;
          c = { inArray: u, index: p, keys: l, edits: d, prev: c };
          u = Array.isArray(g);
          l = u ? g : (b = r[g.kind]) !== null && b !== void 0 ? b : [];
          p = -1;
          d = [];
          if (h) {
            I.push(h);
          }
          h = g;
        }
      } while (c !== undefined);
      if (d.length !== 0) {
        return d[d.length - 1][1];
      }
      return e;
    }
    function visitInParallel(e) {
      const t = new Array(e.length).fill(null);
      const r = Object.create(null);
      for (const n of Object.values(i.Kind)) {
        let o = false;
        const s = new Array(e.length).fill(undefined);
        const i = new Array(e.length).fill(undefined);
        for (let t = 0; t < e.length; ++t) {
          const { enter: r, leave: a } = getEnterLeaveForKind(e[t], n);
          o || (o = r != null || a != null);
          s[t] = r;
          i[t] = a;
        }
        if (!o) {
          continue;
        }
        const A = {
          enter(...r) {
            const n = r[0];
            for (let i = 0; i < e.length; i++) {
              if (t[i] === null) {
                var o;
                const A = (o = s[i]) === null || o === void 0 ? void 0 : o.apply(e[i], r);
                if (A === false) {
                  t[i] = n;
                } else if (A === a) {
                  t[i] = a;
                } else if (A !== undefined) {
                  return A;
                }
              }
            }
          },
          leave(...r) {
            const n = r[0];
            for (let s = 0; s < e.length; s++) {
              if (t[s] === null) {
                var o;
                const n = (o = i[s]) === null || o === void 0 ? void 0 : o.apply(e[s], r);
                if (n === a) {
                  t[s] = a;
                } else if (n !== undefined && n !== false) {
                  return n;
                }
              } else if (t[s] === n) {
                t[s] = null;
              }
            }
          },
        };
        r[n] = A;
      }
      return r;
    }
    function getEnterLeaveForKind(e, t) {
      const r = e[t];
      if (typeof r === "object") {
        return r;
      } else if (typeof r === "function") {
        return { enter: r, leave: undefined };
      }
      return { enter: e.enter, leave: e.leave };
    }
    function getVisitFn(e, t, r) {
      const { enter: n, leave: o } = getEnterLeaveForKind(e, t);
      return r ? o : n;
    }
  },
  27442: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.assertEnumValueName = assertEnumValueName;
    t.assertName = assertName;
    var n = r(53284);
    var o = r(23750);
    var s = r(58396);
    function assertName(e) {
      e != null || (0, n.devAssert)(false, "Must provide name.");
      typeof e === "string" || (0, n.devAssert)(false, "Expected name to be a string.");
      if (e.length === 0) {
        throw new o.GraphQLError("Expected name to be a non-empty string.");
      }
      for (let t = 1; t < e.length; ++t) {
        if (!(0, s.isNameContinue)(e.charCodeAt(t))) {
          throw new o.GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${e}" does not.`);
        }
      }
      if (!(0, s.isNameStart)(e.charCodeAt(0))) {
        throw new o.GraphQLError(`Names must start with [_a-zA-Z] but "${e}" does not.`);
      }
      return e;
    }
    function assertEnumValueName(e) {
      if (e === "true" || e === "false" || e === "null") {
        throw new o.GraphQLError(`Enum values cannot be named: ${e}`);
      }
      return assertName(e);
    }
  },
  46250: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.GraphQLUnionType =
      t.GraphQLScalarType =
      t.GraphQLObjectType =
      t.GraphQLNonNull =
      t.GraphQLList =
      t.GraphQLInterfaceType =
      t.GraphQLInputObjectType =
      t.GraphQLEnumType =
        void 0;
    t.argsToArgsConfig = argsToArgsConfig;
    t.assertAbstractType = assertAbstractType;
    t.assertCompositeType = assertCompositeType;
    t.assertEnumType = assertEnumType;
    t.assertInputObjectType = assertInputObjectType;
    t.assertInputType = assertInputType;
    t.assertInterfaceType = assertInterfaceType;
    t.assertLeafType = assertLeafType;
    t.assertListType = assertListType;
    t.assertNamedType = assertNamedType;
    t.assertNonNullType = assertNonNullType;
    t.assertNullableType = assertNullableType;
    t.assertObjectType = assertObjectType;
    t.assertOutputType = assertOutputType;
    t.assertScalarType = assertScalarType;
    t.assertType = assertType;
    t.assertUnionType = assertUnionType;
    t.assertWrappingType = assertWrappingType;
    t.defineArguments = defineArguments;
    t.getNamedType = getNamedType;
    t.getNullableType = getNullableType;
    t.isAbstractType = isAbstractType;
    t.isCompositeType = isCompositeType;
    t.isEnumType = isEnumType;
    t.isInputObjectType = isInputObjectType;
    t.isInputType = isInputType;
    t.isInterfaceType = isInterfaceType;
    t.isLeafType = isLeafType;
    t.isListType = isListType;
    t.isNamedType = isNamedType;
    t.isNonNullType = isNonNullType;
    t.isNullableType = isNullableType;
    t.isObjectType = isObjectType;
    t.isOutputType = isOutputType;
    t.isRequiredArgument = isRequiredArgument;
    t.isRequiredInputField = isRequiredInputField;
    t.isScalarType = isScalarType;
    t.isType = isType;
    t.isUnionType = isUnionType;
    t.isWrappingType = isWrappingType;
    t.resolveObjMapThunk = resolveObjMapThunk;
    t.resolveReadonlyArrayThunk = resolveReadonlyArrayThunk;
    var n = r(53284);
    var o = r(62384);
    var s = r(32017);
    var i = r(71801);
    var a = r(24551);
    var A = r(84849);
    var c = r(97982);
    var u = r(7897);
    var l = r(73830);
    var p = r(18765);
    var d = r(27949);
    var g = r(23750);
    var m = r(19254);
    var h = r(85401);
    var E = r(8021);
    var I = r(27442);
    function isType(e) {
      return (
        isScalarType(e) || isObjectType(e) || isInterfaceType(e) || isUnionType(e) || isEnumType(e) || isInputObjectType(e) || isListType(e) || isNonNullType(e)
      );
    }
    function assertType(e) {
      if (!isType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL type.`);
      }
      return e;
    }
    function isScalarType(e) {
      return (0, a.instanceOf)(e, GraphQLScalarType);
    }
    function assertScalarType(e) {
      if (!isScalarType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL Scalar type.`);
      }
      return e;
    }
    function isObjectType(e) {
      return (0, a.instanceOf)(e, GraphQLObjectType);
    }
    function assertObjectType(e) {
      if (!isObjectType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL Object type.`);
      }
      return e;
    }
    function isInterfaceType(e) {
      return (0, a.instanceOf)(e, GraphQLInterfaceType);
    }
    function assertInterfaceType(e) {
      if (!isInterfaceType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL Interface type.`);
      }
      return e;
    }
    function isUnionType(e) {
      return (0, a.instanceOf)(e, GraphQLUnionType);
    }
    function assertUnionType(e) {
      if (!isUnionType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL Union type.`);
      }
      return e;
    }
    function isEnumType(e) {
      return (0, a.instanceOf)(e, GraphQLEnumType);
    }
    function assertEnumType(e) {
      if (!isEnumType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL Enum type.`);
      }
      return e;
    }
    function isInputObjectType(e) {
      return (0, a.instanceOf)(e, GraphQLInputObjectType);
    }
    function assertInputObjectType(e) {
      if (!isInputObjectType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL Input Object type.`);
      }
      return e;
    }
    function isListType(e) {
      return (0, a.instanceOf)(e, GraphQLList);
    }
    function assertListType(e) {
      if (!isListType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL List type.`);
      }
      return e;
    }
    function isNonNullType(e) {
      return (0, a.instanceOf)(e, GraphQLNonNull);
    }
    function assertNonNullType(e) {
      if (!isNonNullType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL Non-Null type.`);
      }
      return e;
    }
    function isInputType(e) {
      return isScalarType(e) || isEnumType(e) || isInputObjectType(e) || (isWrappingType(e) && isInputType(e.ofType));
    }
    function assertInputType(e) {
      if (!isInputType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL input type.`);
      }
      return e;
    }
    function isOutputType(e) {
      return isScalarType(e) || isObjectType(e) || isInterfaceType(e) || isUnionType(e) || isEnumType(e) || (isWrappingType(e) && isOutputType(e.ofType));
    }
    function assertOutputType(e) {
      if (!isOutputType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL output type.`);
      }
      return e;
    }
    function isLeafType(e) {
      return isScalarType(e) || isEnumType(e);
    }
    function assertLeafType(e) {
      if (!isLeafType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL leaf type.`);
      }
      return e;
    }
    function isCompositeType(e) {
      return isObjectType(e) || isInterfaceType(e) || isUnionType(e);
    }
    function assertCompositeType(e) {
      if (!isCompositeType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL composite type.`);
      }
      return e;
    }
    function isAbstractType(e) {
      return isInterfaceType(e) || isUnionType(e);
    }
    function assertAbstractType(e) {
      if (!isAbstractType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL abstract type.`);
      }
      return e;
    }
    class GraphQLList {
      constructor(e) {
        isType(e) || (0, n.devAssert)(false, `Expected ${(0, i.inspect)(e)} to be a GraphQL type.`);
        this.ofType = e;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLList";
      }
      toString() {
        return "[" + String(this.ofType) + "]";
      }
      toJSON() {
        return this.toString();
      }
    }
    t.GraphQLList = GraphQLList;
    class GraphQLNonNull {
      constructor(e) {
        isNullableType(e) || (0, n.devAssert)(false, `Expected ${(0, i.inspect)(e)} to be a GraphQL nullable type.`);
        this.ofType = e;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLNonNull";
      }
      toString() {
        return String(this.ofType) + "!";
      }
      toJSON() {
        return this.toString();
      }
    }
    t.GraphQLNonNull = GraphQLNonNull;
    function isWrappingType(e) {
      return isListType(e) || isNonNullType(e);
    }
    function assertWrappingType(e) {
      if (!isWrappingType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL wrapping type.`);
      }
      return e;
    }
    function isNullableType(e) {
      return isType(e) && !isNonNullType(e);
    }
    function assertNullableType(e) {
      if (!isNullableType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL nullable type.`);
      }
      return e;
    }
    function getNullableType(e) {
      if (e) {
        return isNonNullType(e) ? e.ofType : e;
      }
    }
    function isNamedType(e) {
      return isScalarType(e) || isObjectType(e) || isInterfaceType(e) || isUnionType(e) || isEnumType(e) || isInputObjectType(e);
    }
    function assertNamedType(e) {
      if (!isNamedType(e)) {
        throw new Error(`Expected ${(0, i.inspect)(e)} to be a GraphQL named type.`);
      }
      return e;
    }
    function getNamedType(e) {
      if (e) {
        let t = e;
        while (isWrappingType(t)) {
          t = t.ofType;
        }
        return t;
      }
    }
    function resolveReadonlyArrayThunk(e) {
      return typeof e === "function" ? e() : e;
    }
    function resolveObjMapThunk(e) {
      return typeof e === "function" ? e() : e;
    }
    class GraphQLScalarType {
      constructor(e) {
        var t, r, o, a;
        const A = (t = e.parseValue) !== null && t !== void 0 ? t : s.identityFunc;
        this.name = (0, I.assertName)(e.name);
        this.description = e.description;
        this.specifiedByURL = e.specifiedByURL;
        this.serialize = (r = e.serialize) !== null && r !== void 0 ? r : s.identityFunc;
        this.parseValue = A;
        this.parseLiteral = (o = e.parseLiteral) !== null && o !== void 0 ? o : (e, t) => A((0, E.valueFromASTUntyped)(e, t));
        this.extensions = (0, d.toObjMap)(e.extensions);
        this.astNode = e.astNode;
        this.extensionASTNodes = (a = e.extensionASTNodes) !== null && a !== void 0 ? a : [];
        e.specifiedByURL == null ||
          typeof e.specifiedByURL === "string" ||
          (0, n.devAssert)(false, `${this.name} must provide "specifiedByURL" as a string, ` + `but got: ${(0, i.inspect)(e.specifiedByURL)}.`);
        e.serialize == null ||
          typeof e.serialize === "function" ||
          (0, n.devAssert)(
            false,
            `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
          );
        if (e.parseLiteral) {
          (typeof e.parseValue === "function" && typeof e.parseLiteral === "function") ||
            (0, n.devAssert)(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLScalarType";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          specifiedByURL: this.specifiedByURL,
          serialize: this.serialize,
          parseValue: this.parseValue,
          parseLiteral: this.parseLiteral,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    }
    t.GraphQLScalarType = GraphQLScalarType;
    class GraphQLObjectType {
      constructor(e) {
        var t;
        this.name = (0, I.assertName)(e.name);
        this.description = e.description;
        this.isTypeOf = e.isTypeOf;
        this.extensions = (0, d.toObjMap)(e.extensions);
        this.astNode = e.astNode;
        this.extensionASTNodes = (t = e.extensionASTNodes) !== null && t !== void 0 ? t : [];
        this._fields = () => defineFieldMap(e);
        this._interfaces = () => defineInterfaces(e);
        e.isTypeOf == null ||
          typeof e.isTypeOf === "function" ||
          (0, n.devAssert)(false, `${this.name} must provide "isTypeOf" as a function, ` + `but got: ${(0, i.inspect)(e.isTypeOf)}.`);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          isTypeOf: this.isTypeOf,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    }
    t.GraphQLObjectType = GraphQLObjectType;
    function defineInterfaces(e) {
      var t;
      const r = resolveReadonlyArrayThunk((t = e.interfaces) !== null && t !== void 0 ? t : []);
      Array.isArray(r) || (0, n.devAssert)(false, `${e.name} interfaces must be an Array or a function which returns an Array.`);
      return r;
    }
    function defineFieldMap(e) {
      const t = resolveObjMapThunk(e.fields);
      isPlainObj(t) || (0, n.devAssert)(false, `${e.name} fields must be an object with field names as keys or a function which returns such an object.`);
      return (0, l.mapValue)(t, (t, r) => {
        var o;
        isPlainObj(t) || (0, n.devAssert)(false, `${e.name}.${r} field config must be an object.`);
        t.resolve == null ||
          typeof t.resolve === "function" ||
          (0, n.devAssert)(false, `${e.name}.${r} field resolver must be a function if ` + `provided, but got: ${(0, i.inspect)(t.resolve)}.`);
        const s = (o = t.args) !== null && o !== void 0 ? o : {};
        isPlainObj(s) || (0, n.devAssert)(false, `${e.name}.${r} args must be an object with argument names as keys.`);
        return {
          name: (0, I.assertName)(r),
          description: t.description,
          type: t.type,
          args: defineArguments(s),
          resolve: t.resolve,
          subscribe: t.subscribe,
          deprecationReason: t.deprecationReason,
          extensions: (0, d.toObjMap)(t.extensions),
          astNode: t.astNode,
        };
      });
    }
    function defineArguments(e) {
      return Object.entries(e).map(([e, t]) => ({
        name: (0, I.assertName)(e),
        description: t.description,
        type: t.type,
        defaultValue: t.defaultValue,
        deprecationReason: t.deprecationReason,
        extensions: (0, d.toObjMap)(t.extensions),
        astNode: t.astNode,
      }));
    }
    function isPlainObj(e) {
      return (0, A.isObjectLike)(e) && !Array.isArray(e);
    }
    function fieldsToFieldsConfig(e) {
      return (0, l.mapValue)(e, (e) => ({
        description: e.description,
        type: e.type,
        args: argsToArgsConfig(e.args),
        resolve: e.resolve,
        subscribe: e.subscribe,
        deprecationReason: e.deprecationReason,
        extensions: e.extensions,
        astNode: e.astNode,
      }));
    }
    function argsToArgsConfig(e) {
      return (0, u.keyValMap)(
        e,
        (e) => e.name,
        (e) => ({
          description: e.description,
          type: e.type,
          defaultValue: e.defaultValue,
          deprecationReason: e.deprecationReason,
          extensions: e.extensions,
          astNode: e.astNode,
        })
      );
    }
    function isRequiredArgument(e) {
      return isNonNullType(e.type) && e.defaultValue === undefined;
    }
    class GraphQLInterfaceType {
      constructor(e) {
        var t;
        this.name = (0, I.assertName)(e.name);
        this.description = e.description;
        this.resolveType = e.resolveType;
        this.extensions = (0, d.toObjMap)(e.extensions);
        this.astNode = e.astNode;
        this.extensionASTNodes = (t = e.extensionASTNodes) !== null && t !== void 0 ? t : [];
        this._fields = defineFieldMap.bind(undefined, e);
        this._interfaces = defineInterfaces.bind(undefined, e);
        e.resolveType == null ||
          typeof e.resolveType === "function" ||
          (0, n.devAssert)(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${(0, i.inspect)(e.resolveType)}.`);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInterfaceType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      getInterfaces() {
        if (typeof this._interfaces === "function") {
          this._interfaces = this._interfaces();
        }
        return this._interfaces;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          interfaces: this.getInterfaces(),
          fields: fieldsToFieldsConfig(this.getFields()),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    }
    t.GraphQLInterfaceType = GraphQLInterfaceType;
    class GraphQLUnionType {
      constructor(e) {
        var t;
        this.name = (0, I.assertName)(e.name);
        this.description = e.description;
        this.resolveType = e.resolveType;
        this.extensions = (0, d.toObjMap)(e.extensions);
        this.astNode = e.astNode;
        this.extensionASTNodes = (t = e.extensionASTNodes) !== null && t !== void 0 ? t : [];
        this._types = defineTypes.bind(undefined, e);
        e.resolveType == null ||
          typeof e.resolveType === "function" ||
          (0, n.devAssert)(false, `${this.name} must provide "resolveType" as a function, ` + `but got: ${(0, i.inspect)(e.resolveType)}.`);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLUnionType";
      }
      getTypes() {
        if (typeof this._types === "function") {
          this._types = this._types();
        }
        return this._types;
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          types: this.getTypes(),
          resolveType: this.resolveType,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    }
    t.GraphQLUnionType = GraphQLUnionType;
    function defineTypes(e) {
      const t = resolveReadonlyArrayThunk(e.types);
      Array.isArray(t) || (0, n.devAssert)(false, `Must provide Array of types or a function which returns such an array for Union ${e.name}.`);
      return t;
    }
    class GraphQLEnumType {
      constructor(e) {
        var t;
        this.name = (0, I.assertName)(e.name);
        this.description = e.description;
        this.extensions = (0, d.toObjMap)(e.extensions);
        this.astNode = e.astNode;
        this.extensionASTNodes = (t = e.extensionASTNodes) !== null && t !== void 0 ? t : [];
        this._values = typeof e.values === "function" ? e.values : defineEnumValues(this.name, e.values);
        this._valueLookup = null;
        this._nameLookup = null;
      }
      get [Symbol.toStringTag]() {
        return "GraphQLEnumType";
      }
      getValues() {
        if (typeof this._values === "function") {
          this._values = defineEnumValues(this.name, this._values());
        }
        return this._values;
      }
      getValue(e) {
        if (this._nameLookup === null) {
          this._nameLookup = (0, c.keyMap)(this.getValues(), (e) => e.name);
        }
        return this._nameLookup[e];
      }
      serialize(e) {
        if (this._valueLookup === null) {
          this._valueLookup = new Map(this.getValues().map((e) => [e.value, e]));
        }
        const t = this._valueLookup.get(e);
        if (t === undefined) {
          throw new g.GraphQLError(`Enum "${this.name}" cannot represent value: ${(0, i.inspect)(e)}`);
        }
        return t.name;
      }
      parseValue(e) {
        if (typeof e !== "string") {
          const t = (0, i.inspect)(e);
          throw new g.GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${t}.` + didYouMeanEnumValue(this, t));
        }
        const t = this.getValue(e);
        if (t == null) {
          throw new g.GraphQLError(`Value "${e}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, e));
        }
        return t.value;
      }
      parseLiteral(e, t) {
        if (e.kind !== m.Kind.ENUM) {
          const t = (0, h.print)(e);
          throw new g.GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${t}.` + didYouMeanEnumValue(this, t), { nodes: e });
        }
        const r = this.getValue(e.value);
        if (r == null) {
          const t = (0, h.print)(e);
          throw new g.GraphQLError(`Value "${t}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, t), { nodes: e });
        }
        return r.value;
      }
      toConfig() {
        const e = (0, u.keyValMap)(
          this.getValues(),
          (e) => e.name,
          (e) => ({ description: e.description, value: e.value, deprecationReason: e.deprecationReason, extensions: e.extensions, astNode: e.astNode })
        );
        return {
          name: this.name,
          description: this.description,
          values: e,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    }
    t.GraphQLEnumType = GraphQLEnumType;
    function didYouMeanEnumValue(e, t) {
      const r = e.getValues().map((e) => e.name);
      const n = (0, p.suggestionList)(t, r);
      return (0, o.didYouMean)("the enum value", n);
    }
    function defineEnumValues(e, t) {
      isPlainObj(t) || (0, n.devAssert)(false, `${e} values must be an object with value names as keys.`);
      return Object.entries(t).map(([t, r]) => {
        isPlainObj(r) ||
          (0, n.devAssert)(false, `${e}.${t} must refer to an object with a "value" key ` + `representing an internal value but got: ${(0, i.inspect)(r)}.`);
        return {
          name: (0, I.assertEnumValueName)(t),
          description: r.description,
          value: r.value !== undefined ? r.value : t,
          deprecationReason: r.deprecationReason,
          extensions: (0, d.toObjMap)(r.extensions),
          astNode: r.astNode,
        };
      });
    }
    class GraphQLInputObjectType {
      constructor(e) {
        var t, r;
        this.name = (0, I.assertName)(e.name);
        this.description = e.description;
        this.extensions = (0, d.toObjMap)(e.extensions);
        this.astNode = e.astNode;
        this.extensionASTNodes = (t = e.extensionASTNodes) !== null && t !== void 0 ? t : [];
        this.isOneOf = (r = e.isOneOf) !== null && r !== void 0 ? r : false;
        this._fields = defineInputFieldMap.bind(undefined, e);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLInputObjectType";
      }
      getFields() {
        if (typeof this._fields === "function") {
          this._fields = this._fields();
        }
        return this._fields;
      }
      toConfig() {
        const e = (0, l.mapValue)(this.getFields(), (e) => ({
          description: e.description,
          type: e.type,
          defaultValue: e.defaultValue,
          deprecationReason: e.deprecationReason,
          extensions: e.extensions,
          astNode: e.astNode,
        }));
        return {
          name: this.name,
          description: this.description,
          fields: e,
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          isOneOf: this.isOneOf,
        };
      }
      toString() {
        return this.name;
      }
      toJSON() {
        return this.toString();
      }
    }
    t.GraphQLInputObjectType = GraphQLInputObjectType;
    function defineInputFieldMap(e) {
      const t = resolveObjMapThunk(e.fields);
      isPlainObj(t) || (0, n.devAssert)(false, `${e.name} fields must be an object with field names as keys or a function which returns such an object.`);
      return (0, l.mapValue)(t, (t, r) => {
        !("resolve" in t) || (0, n.devAssert)(false, `${e.name}.${r} field has a resolve property, but Input Types cannot define resolvers.`);
        return {
          name: (0, I.assertName)(r),
          description: t.description,
          type: t.type,
          defaultValue: t.defaultValue,
          deprecationReason: t.deprecationReason,
          extensions: (0, d.toObjMap)(t.extensions),
          astNode: t.astNode,
        };
      });
    }
    function isRequiredInputField(e) {
      return isNonNullType(e.type) && e.defaultValue === undefined;
    }
  },
  58941: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.GraphQLSpecifiedByDirective =
      t.GraphQLSkipDirective =
      t.GraphQLOneOfDirective =
      t.GraphQLIncludeDirective =
      t.GraphQLDirective =
      t.GraphQLDeprecatedDirective =
      t.DEFAULT_DEPRECATION_REASON =
        void 0;
    t.assertDirective = assertDirective;
    t.isDirective = isDirective;
    t.isSpecifiedDirective = isSpecifiedDirective;
    t.specifiedDirectives = void 0;
    var n = r(53284);
    var o = r(71801);
    var s = r(24551);
    var i = r(84849);
    var a = r(27949);
    var A = r(57503);
    var c = r(27442);
    var u = r(46250);
    var l = r(83894);
    function isDirective(e) {
      return (0, s.instanceOf)(e, GraphQLDirective);
    }
    function assertDirective(e) {
      if (!isDirective(e)) {
        throw new Error(`Expected ${(0, o.inspect)(e)} to be a GraphQL directive.`);
      }
      return e;
    }
    class GraphQLDirective {
      constructor(e) {
        var t, r;
        this.name = (0, c.assertName)(e.name);
        this.description = e.description;
        this.locations = e.locations;
        this.isRepeatable = (t = e.isRepeatable) !== null && t !== void 0 ? t : false;
        this.extensions = (0, a.toObjMap)(e.extensions);
        this.astNode = e.astNode;
        Array.isArray(e.locations) || (0, n.devAssert)(false, `@${e.name} locations must be an Array.`);
        const o = (r = e.args) !== null && r !== void 0 ? r : {};
        ((0, i.isObjectLike)(o) && !Array.isArray(o)) || (0, n.devAssert)(false, `@${e.name} args must be an object with argument names as keys.`);
        this.args = (0, u.defineArguments)(o);
      }
      get [Symbol.toStringTag]() {
        return "GraphQLDirective";
      }
      toConfig() {
        return {
          name: this.name,
          description: this.description,
          locations: this.locations,
          args: (0, u.argsToArgsConfig)(this.args),
          isRepeatable: this.isRepeatable,
          extensions: this.extensions,
          astNode: this.astNode,
        };
      }
      toString() {
        return "@" + this.name;
      }
      toJSON() {
        return this.toString();
      }
    }
    t.GraphQLDirective = GraphQLDirective;
    const p = new GraphQLDirective({
      name: "include",
      description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
      locations: [A.DirectiveLocation.FIELD, A.DirectiveLocation.FRAGMENT_SPREAD, A.DirectiveLocation.INLINE_FRAGMENT],
      args: { if: { type: new u.GraphQLNonNull(l.GraphQLBoolean), description: "Included when true." } },
    });
    t.GraphQLIncludeDirective = p;
    const d = new GraphQLDirective({
      name: "skip",
      description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
      locations: [A.DirectiveLocation.FIELD, A.DirectiveLocation.FRAGMENT_SPREAD, A.DirectiveLocation.INLINE_FRAGMENT],
      args: { if: { type: new u.GraphQLNonNull(l.GraphQLBoolean), description: "Skipped when true." } },
    });
    t.GraphQLSkipDirective = d;
    const g = "No longer supported";
    t.DEFAULT_DEPRECATION_REASON = g;
    const m = new GraphQLDirective({
      name: "deprecated",
      description: "Marks an element of a GraphQL schema as no longer supported.",
      locations: [
        A.DirectiveLocation.FIELD_DEFINITION,
        A.DirectiveLocation.ARGUMENT_DEFINITION,
        A.DirectiveLocation.INPUT_FIELD_DEFINITION,
        A.DirectiveLocation.ENUM_VALUE,
      ],
      args: {
        reason: {
          type: l.GraphQLString,
          description:
            "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
          defaultValue: g,
        },
      },
    });
    t.GraphQLDeprecatedDirective = m;
    const h = new GraphQLDirective({
      name: "specifiedBy",
      description: "Exposes a URL that specifies the behavior of this scalar.",
      locations: [A.DirectiveLocation.SCALAR],
      args: { url: { type: new u.GraphQLNonNull(l.GraphQLString), description: "The URL that specifies the behavior of this scalar." } },
    });
    t.GraphQLSpecifiedByDirective = h;
    const E = new GraphQLDirective({
      name: "oneOf",
      description: "Indicates exactly one field must be supplied and this field must not be `null`.",
      locations: [A.DirectiveLocation.INPUT_OBJECT],
      args: {},
    });
    t.GraphQLOneOfDirective = E;
    const I = Object.freeze([p, d, m, h, E]);
    t.specifiedDirectives = I;
    function isSpecifiedDirective(e) {
      return I.some(({ name: t }) => t === e.name);
    }
  },
  5387: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    Object.defineProperty(t, "DEFAULT_DEPRECATION_REASON", {
      enumerable: true,
      get: function () {
        return s.DEFAULT_DEPRECATION_REASON;
      },
    });
    Object.defineProperty(t, "GRAPHQL_MAX_INT", {
      enumerable: true,
      get: function () {
        return i.GRAPHQL_MAX_INT;
      },
    });
    Object.defineProperty(t, "GRAPHQL_MIN_INT", {
      enumerable: true,
      get: function () {
        return i.GRAPHQL_MIN_INT;
      },
    });
    Object.defineProperty(t, "GraphQLBoolean", {
      enumerable: true,
      get: function () {
        return i.GraphQLBoolean;
      },
    });
    Object.defineProperty(t, "GraphQLDeprecatedDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLDeprecatedDirective;
      },
    });
    Object.defineProperty(t, "GraphQLDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLDirective;
      },
    });
    Object.defineProperty(t, "GraphQLEnumType", {
      enumerable: true,
      get: function () {
        return o.GraphQLEnumType;
      },
    });
    Object.defineProperty(t, "GraphQLFloat", {
      enumerable: true,
      get: function () {
        return i.GraphQLFloat;
      },
    });
    Object.defineProperty(t, "GraphQLID", {
      enumerable: true,
      get: function () {
        return i.GraphQLID;
      },
    });
    Object.defineProperty(t, "GraphQLIncludeDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLIncludeDirective;
      },
    });
    Object.defineProperty(t, "GraphQLInputObjectType", {
      enumerable: true,
      get: function () {
        return o.GraphQLInputObjectType;
      },
    });
    Object.defineProperty(t, "GraphQLInt", {
      enumerable: true,
      get: function () {
        return i.GraphQLInt;
      },
    });
    Object.defineProperty(t, "GraphQLInterfaceType", {
      enumerable: true,
      get: function () {
        return o.GraphQLInterfaceType;
      },
    });
    Object.defineProperty(t, "GraphQLList", {
      enumerable: true,
      get: function () {
        return o.GraphQLList;
      },
    });
    Object.defineProperty(t, "GraphQLNonNull", {
      enumerable: true,
      get: function () {
        return o.GraphQLNonNull;
      },
    });
    Object.defineProperty(t, "GraphQLObjectType", {
      enumerable: true,
      get: function () {
        return o.GraphQLObjectType;
      },
    });
    Object.defineProperty(t, "GraphQLOneOfDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLOneOfDirective;
      },
    });
    Object.defineProperty(t, "GraphQLScalarType", {
      enumerable: true,
      get: function () {
        return o.GraphQLScalarType;
      },
    });
    Object.defineProperty(t, "GraphQLSchema", {
      enumerable: true,
      get: function () {
        return n.GraphQLSchema;
      },
    });
    Object.defineProperty(t, "GraphQLSkipDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLSkipDirective;
      },
    });
    Object.defineProperty(t, "GraphQLSpecifiedByDirective", {
      enumerable: true,
      get: function () {
        return s.GraphQLSpecifiedByDirective;
      },
    });
    Object.defineProperty(t, "GraphQLString", {
      enumerable: true,
      get: function () {
        return i.GraphQLString;
      },
    });
    Object.defineProperty(t, "GraphQLUnionType", {
      enumerable: true,
      get: function () {
        return o.GraphQLUnionType;
      },
    });
    Object.defineProperty(t, "SchemaMetaFieldDef", {
      enumerable: true,
      get: function () {
        return a.SchemaMetaFieldDef;
      },
    });
    Object.defineProperty(t, "TypeKind", {
      enumerable: true,
      get: function () {
        return a.TypeKind;
      },
    });
    Object.defineProperty(t, "TypeMetaFieldDef", {
      enumerable: true,
      get: function () {
        return a.TypeMetaFieldDef;
      },
    });
    Object.defineProperty(t, "TypeNameMetaFieldDef", {
      enumerable: true,
      get: function () {
        return a.TypeNameMetaFieldDef;
      },
    });
    Object.defineProperty(t, "__Directive", {
      enumerable: true,
      get: function () {
        return a.__Directive;
      },
    });
    Object.defineProperty(t, "__DirectiveLocation", {
      enumerable: true,
      get: function () {
        return a.__DirectiveLocation;
      },
    });
    Object.defineProperty(t, "__EnumValue", {
      enumerable: true,
      get: function () {
        return a.__EnumValue;
      },
    });
    Object.defineProperty(t, "__Field", {
      enumerable: true,
      get: function () {
        return a.__Field;
      },
    });
    Object.defineProperty(t, "__InputValue", {
      enumerable: true,
      get: function () {
        return a.__InputValue;
      },
    });
    Object.defineProperty(t, "__Schema", {
      enumerable: true,
      get: function () {
        return a.__Schema;
      },
    });
    Object.defineProperty(t, "__Type", {
      enumerable: true,
      get: function () {
        return a.__Type;
      },
    });
    Object.defineProperty(t, "__TypeKind", {
      enumerable: true,
      get: function () {
        return a.__TypeKind;
      },
    });
    Object.defineProperty(t, "assertAbstractType", {
      enumerable: true,
      get: function () {
        return o.assertAbstractType;
      },
    });
    Object.defineProperty(t, "assertCompositeType", {
      enumerable: true,
      get: function () {
        return o.assertCompositeType;
      },
    });
    Object.defineProperty(t, "assertDirective", {
      enumerable: true,
      get: function () {
        return s.assertDirective;
      },
    });
    Object.defineProperty(t, "assertEnumType", {
      enumerable: true,
      get: function () {
        return o.assertEnumType;
      },
    });
    Object.defineProperty(t, "assertEnumValueName", {
      enumerable: true,
      get: function () {
        return c.assertEnumValueName;
      },
    });
    Object.defineProperty(t, "assertInputObjectType", {
      enumerable: true,
      get: function () {
        return o.assertInputObjectType;
      },
    });
    Object.defineProperty(t, "assertInputType", {
      enumerable: true,
      get: function () {
        return o.assertInputType;
      },
    });
    Object.defineProperty(t, "assertInterfaceType", {
      enumerable: true,
      get: function () {
        return o.assertInterfaceType;
      },
    });
    Object.defineProperty(t, "assertLeafType", {
      enumerable: true,
      get: function () {
        return o.assertLeafType;
      },
    });
    Object.defineProperty(t, "assertListType", {
      enumerable: true,
      get: function () {
        return o.assertListType;
      },
    });
    Object.defineProperty(t, "assertName", {
      enumerable: true,
      get: function () {
        return c.assertName;
      },
    });
    Object.defineProperty(t, "assertNamedType", {
      enumerable: true,
      get: function () {
        return o.assertNamedType;
      },
    });
    Object.defineProperty(t, "assertNonNullType", {
      enumerable: true,
      get: function () {
        return o.assertNonNullType;
      },
    });
    Object.defineProperty(t, "assertNullableType", {
      enumerable: true,
      get: function () {
        return o.assertNullableType;
      },
    });
    Object.defineProperty(t, "assertObjectType", {
      enumerable: true,
      get: function () {
        return o.assertObjectType;
      },
    });
    Object.defineProperty(t, "assertOutputType", {
      enumerable: true,
      get: function () {
        return o.assertOutputType;
      },
    });
    Object.defineProperty(t, "assertScalarType", {
      enumerable: true,
      get: function () {
        return o.assertScalarType;
      },
    });
    Object.defineProperty(t, "assertSchema", {
      enumerable: true,
      get: function () {
        return n.assertSchema;
      },
    });
    Object.defineProperty(t, "assertType", {
      enumerable: true,
      get: function () {
        return o.assertType;
      },
    });
    Object.defineProperty(t, "assertUnionType", {
      enumerable: true,
      get: function () {
        return o.assertUnionType;
      },
    });
    Object.defineProperty(t, "assertValidSchema", {
      enumerable: true,
      get: function () {
        return A.assertValidSchema;
      },
    });
    Object.defineProperty(t, "assertWrappingType", {
      enumerable: true,
      get: function () {
        return o.assertWrappingType;
      },
    });
    Object.defineProperty(t, "getNamedType", {
      enumerable: true,
      get: function () {
        return o.getNamedType;
      },
    });
    Object.defineProperty(t, "getNullableType", {
      enumerable: true,
      get: function () {
        return o.getNullableType;
      },
    });
    Object.defineProperty(t, "introspectionTypes", {
      enumerable: true,
      get: function () {
        return a.introspectionTypes;
      },
    });
    Object.defineProperty(t, "isAbstractType", {
      enumerable: true,
      get: function () {
        return o.isAbstractType;
      },
    });
    Object.defineProperty(t, "isCompositeType", {
      enumerable: true,
      get: function () {
        return o.isCompositeType;
      },
    });
    Object.defineProperty(t, "isDirective", {
      enumerable: true,
      get: function () {
        return s.isDirective;
      },
    });
    Object.defineProperty(t, "isEnumType", {
      enumerable: true,
      get: function () {
        return o.isEnumType;
      },
    });
    Object.defineProperty(t, "isInputObjectType", {
      enumerable: true,
      get: function () {
        return o.isInputObjectType;
      },
    });
    Object.defineProperty(t, "isInputType", {
      enumerable: true,
      get: function () {
        return o.isInputType;
      },
    });
    Object.defineProperty(t, "isInterfaceType", {
      enumerable: true,
      get: function () {
        return o.isInterfaceType;
      },
    });
    Object.defineProperty(t, "isIntrospectionType", {
      enumerable: true,
      get: function () {
        return a.isIntrospectionType;
      },
    });
    Object.defineProperty(t, "isLeafType", {
      enumerable: true,
      get: function () {
        return o.isLeafType;
      },
    });
    Object.defineProperty(t, "isListType", {
      enumerable: true,
      get: function () {
        return o.isListType;
      },
    });
    Object.defineProperty(t, "isNamedType", {
      enumerable: true,
      get: function () {
        return o.isNamedType;
      },
    });
    Object.defineProperty(t, "isNonNullType", {
      enumerable: true,
      get: function () {
        return o.isNonNullType;
      },
    });
    Object.defineProperty(t, "isNullableType", {
      enumerable: true,
      get: function () {
        return o.isNullableType;
      },
    });
    Object.defineProperty(t, "isObjectType", {
      enumerable: true,
      get: function () {
        return o.isObjectType;
      },
    });
    Object.defineProperty(t, "isOutputType", {
      enumerable: true,
      get: function () {
        return o.isOutputType;
      },
    });
    Object.defineProperty(t, "isRequiredArgument", {
      enumerable: true,
      get: function () {
        return o.isRequiredArgument;
      },
    });
    Object.defineProperty(t, "isRequiredInputField", {
      enumerable: true,
      get: function () {
        return o.isRequiredInputField;
      },
    });
    Object.defineProperty(t, "isScalarType", {
      enumerable: true,
      get: function () {
        return o.isScalarType;
      },
    });
    Object.defineProperty(t, "isSchema", {
      enumerable: true,
      get: function () {
        return n.isSchema;
      },
    });
    Object.defineProperty(t, "isSpecifiedDirective", {
      enumerable: true,
      get: function () {
        return s.isSpecifiedDirective;
      },
    });
    Object.defineProperty(t, "isSpecifiedScalarType", {
      enumerable: true,
      get: function () {
        return i.isSpecifiedScalarType;
      },
    });
    Object.defineProperty(t, "isType", {
      enumerable: true,
      get: function () {
        return o.isType;
      },
    });
    Object.defineProperty(t, "isUnionType", {
      enumerable: true,
      get: function () {
        return o.isUnionType;
      },
    });
    Object.defineProperty(t, "isWrappingType", {
      enumerable: true,
      get: function () {
        return o.isWrappingType;
      },
    });
    Object.defineProperty(t, "resolveObjMapThunk", {
      enumerable: true,
      get: function () {
        return o.resolveObjMapThunk;
      },
    });
    Object.defineProperty(t, "resolveReadonlyArrayThunk", {
      enumerable: true,
      get: function () {
        return o.resolveReadonlyArrayThunk;
      },
    });
    Object.defineProperty(t, "specifiedDirectives", {
      enumerable: true,
      get: function () {
        return s.specifiedDirectives;
      },
    });
    Object.defineProperty(t, "specifiedScalarTypes", {
      enumerable: true,
      get: function () {
        return i.specifiedScalarTypes;
      },
    });
    Object.defineProperty(t, "validateSchema", {
      enumerable: true,
      get: function () {
        return A.validateSchema;
      },
    });
    var n = r(71672);
    var o = r(46250);
    var s = r(58941);
    var i = r(83894);
    var a = r(47564);
    var A = r(22689);
    var c = r(27442);
  },
  47564: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.introspectionTypes =
      t.__TypeKind =
      t.__Type =
      t.__Schema =
      t.__InputValue =
      t.__Field =
      t.__EnumValue =
      t.__DirectiveLocation =
      t.__Directive =
      t.TypeNameMetaFieldDef =
      t.TypeMetaFieldDef =
      t.TypeKind =
      t.SchemaMetaFieldDef =
        void 0;
    t.isIntrospectionType = isIntrospectionType;
    var n = r(71801);
    var o = r(67305);
    var s = r(57503);
    var i = r(85401);
    var a = r(97520);
    var A = r(46250);
    var c = r(83894);
    const u = new A.GraphQLObjectType({
      name: "__Schema",
      description:
        "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
      fields: () => ({
        description: { type: c.GraphQLString, resolve: (e) => e.description },
        types: {
          description: "A list of all types supported by this server.",
          type: new A.GraphQLNonNull(new A.GraphQLList(new A.GraphQLNonNull(d))),
          resolve(e) {
            return Object.values(e.getTypeMap());
          },
        },
        queryType: { description: "The type that query operations will be rooted at.", type: new A.GraphQLNonNull(d), resolve: (e) => e.getQueryType() },
        mutationType: {
          description: "If this server supports mutation, the type that mutation operations will be rooted at.",
          type: d,
          resolve: (e) => e.getMutationType(),
        },
        subscriptionType: {
          description: "If this server support subscription, the type that subscription operations will be rooted at.",
          type: d,
          resolve: (e) => e.getSubscriptionType(),
        },
        directives: {
          description: "A list of all directives supported by this server.",
          type: new A.GraphQLNonNull(new A.GraphQLList(new A.GraphQLNonNull(l))),
          resolve: (e) => e.getDirectives(),
        },
      }),
    });
    t.__Schema = u;
    const l = new A.GraphQLObjectType({
      name: "__Directive",
      description:
        "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
      fields: () => ({
        name: { type: new A.GraphQLNonNull(c.GraphQLString), resolve: (e) => e.name },
        description: { type: c.GraphQLString, resolve: (e) => e.description },
        isRepeatable: { type: new A.GraphQLNonNull(c.GraphQLBoolean), resolve: (e) => e.isRepeatable },
        locations: { type: new A.GraphQLNonNull(new A.GraphQLList(new A.GraphQLNonNull(p))), resolve: (e) => e.locations },
        args: {
          type: new A.GraphQLNonNull(new A.GraphQLList(new A.GraphQLNonNull(m))),
          args: { includeDeprecated: { type: c.GraphQLBoolean, defaultValue: false } },
          resolve(e, { includeDeprecated: t }) {
            return t ? e.args : e.args.filter((e) => e.deprecationReason == null);
          },
        },
      }),
    });
    t.__Directive = l;
    const p = new A.GraphQLEnumType({
      name: "__DirectiveLocation",
      description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
      values: {
        QUERY: { value: s.DirectiveLocation.QUERY, description: "Location adjacent to a query operation." },
        MUTATION: { value: s.DirectiveLocation.MUTATION, description: "Location adjacent to a mutation operation." },
        SUBSCRIPTION: { value: s.DirectiveLocation.SUBSCRIPTION, description: "Location adjacent to a subscription operation." },
        FIELD: { value: s.DirectiveLocation.FIELD, description: "Location adjacent to a field." },
        FRAGMENT_DEFINITION: { value: s.DirectiveLocation.FRAGMENT_DEFINITION, description: "Location adjacent to a fragment definition." },
        FRAGMENT_SPREAD: { value: s.DirectiveLocation.FRAGMENT_SPREAD, description: "Location adjacent to a fragment spread." },
        INLINE_FRAGMENT: { value: s.DirectiveLocation.INLINE_FRAGMENT, description: "Location adjacent to an inline fragment." },
        VARIABLE_DEFINITION: { value: s.DirectiveLocation.VARIABLE_DEFINITION, description: "Location adjacent to a variable definition." },
        SCHEMA: { value: s.DirectiveLocation.SCHEMA, description: "Location adjacent to a schema definition." },
        SCALAR: { value: s.DirectiveLocation.SCALAR, description: "Location adjacent to a scalar definition." },
        OBJECT: { value: s.DirectiveLocation.OBJECT, description: "Location adjacent to an object type definition." },
        FIELD_DEFINITION: { value: s.DirectiveLocation.FIELD_DEFINITION, description: "Location adjacent to a field definition." },
        ARGUMENT_DEFINITION: { value: s.DirectiveLocation.ARGUMENT_DEFINITION, description: "Location adjacent to an argument definition." },
        INTERFACE: { value: s.DirectiveLocation.INTERFACE, description: "Location adjacent to an interface definition." },
        UNION: { value: s.DirectiveLocation.UNION, description: "Location adjacent to a union definition." },
        ENUM: { value: s.DirectiveLocation.ENUM, description: "Location adjacent to an enum definition." },
        ENUM_VALUE: { value: s.DirectiveLocation.ENUM_VALUE, description: "Location adjacent to an enum value definition." },
        INPUT_OBJECT: { value: s.DirectiveLocation.INPUT_OBJECT, description: "Location adjacent to an input object type definition." },
        INPUT_FIELD_DEFINITION: { value: s.DirectiveLocation.INPUT_FIELD_DEFINITION, description: "Location adjacent to an input object field definition." },
      },
    });
    t.__DirectiveLocation = p;
    const d = new A.GraphQLObjectType({
      name: "__Type",
      description:
        "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
      fields: () => ({
        kind: {
          type: new A.GraphQLNonNull(I),
          resolve(e) {
            if ((0, A.isScalarType)(e)) {
              return E.SCALAR;
            }
            if ((0, A.isObjectType)(e)) {
              return E.OBJECT;
            }
            if ((0, A.isInterfaceType)(e)) {
              return E.INTERFACE;
            }
            if ((0, A.isUnionType)(e)) {
              return E.UNION;
            }
            if ((0, A.isEnumType)(e)) {
              return E.ENUM;
            }
            if ((0, A.isInputObjectType)(e)) {
              return E.INPUT_OBJECT;
            }
            if ((0, A.isListType)(e)) {
              return E.LIST;
            }
            if ((0, A.isNonNullType)(e)) {
              return E.NON_NULL;
            }
            false || (0, o.invariant)(false, `Unexpected type: "${(0, n.inspect)(e)}".`);
          },
        },
        name: { type: c.GraphQLString, resolve: (e) => ("name" in e ? e.name : undefined) },
        description: { type: c.GraphQLString, resolve: (e) => ("description" in e ? e.description : undefined) },
        specifiedByURL: { type: c.GraphQLString, resolve: (e) => ("specifiedByURL" in e ? e.specifiedByURL : undefined) },
        fields: {
          type: new A.GraphQLList(new A.GraphQLNonNull(g)),
          args: { includeDeprecated: { type: c.GraphQLBoolean, defaultValue: false } },
          resolve(e, { includeDeprecated: t }) {
            if ((0, A.isObjectType)(e) || (0, A.isInterfaceType)(e)) {
              const r = Object.values(e.getFields());
              return t ? r : r.filter((e) => e.deprecationReason == null);
            }
          },
        },
        interfaces: {
          type: new A.GraphQLList(new A.GraphQLNonNull(d)),
          resolve(e) {
            if ((0, A.isObjectType)(e) || (0, A.isInterfaceType)(e)) {
              return e.getInterfaces();
            }
          },
        },
        possibleTypes: {
          type: new A.GraphQLList(new A.GraphQLNonNull(d)),
          resolve(e, t, r, { schema: n }) {
            if ((0, A.isAbstractType)(e)) {
              return n.getPossibleTypes(e);
            }
          },
        },
        enumValues: {
          type: new A.GraphQLList(new A.GraphQLNonNull(h)),
          args: { includeDeprecated: { type: c.GraphQLBoolean, defaultValue: false } },
          resolve(e, { includeDeprecated: t }) {
            if ((0, A.isEnumType)(e)) {
              const r = e.getValues();
              return t ? r : r.filter((e) => e.deprecationReason == null);
            }
          },
        },
        inputFields: {
          type: new A.GraphQLList(new A.GraphQLNonNull(m)),
          args: { includeDeprecated: { type: c.GraphQLBoolean, defaultValue: false } },
          resolve(e, { includeDeprecated: t }) {
            if ((0, A.isInputObjectType)(e)) {
              const r = Object.values(e.getFields());
              return t ? r : r.filter((e) => e.deprecationReason == null);
            }
          },
        },
        ofType: { type: d, resolve: (e) => ("ofType" in e ? e.ofType : undefined) },
        isOneOf: {
          type: c.GraphQLBoolean,
          resolve: (e) => {
            if ((0, A.isInputObjectType)(e)) {
              return e.isOneOf;
            }
          },
        },
      }),
    });
    t.__Type = d;
    const g = new A.GraphQLObjectType({
      name: "__Field",
      description:
        "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
      fields: () => ({
        name: { type: new A.GraphQLNonNull(c.GraphQLString), resolve: (e) => e.name },
        description: { type: c.GraphQLString, resolve: (e) => e.description },
        args: {
          type: new A.GraphQLNonNull(new A.GraphQLList(new A.GraphQLNonNull(m))),
          args: { includeDeprecated: { type: c.GraphQLBoolean, defaultValue: false } },
          resolve(e, { includeDeprecated: t }) {
            return t ? e.args : e.args.filter((e) => e.deprecationReason == null);
          },
        },
        type: { type: new A.GraphQLNonNull(d), resolve: (e) => e.type },
        isDeprecated: { type: new A.GraphQLNonNull(c.GraphQLBoolean), resolve: (e) => e.deprecationReason != null },
        deprecationReason: { type: c.GraphQLString, resolve: (e) => e.deprecationReason },
      }),
    });
    t.__Field = g;
    const m = new A.GraphQLObjectType({
      name: "__InputValue",
      description:
        "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
      fields: () => ({
        name: { type: new A.GraphQLNonNull(c.GraphQLString), resolve: (e) => e.name },
        description: { type: c.GraphQLString, resolve: (e) => e.description },
        type: { type: new A.GraphQLNonNull(d), resolve: (e) => e.type },
        defaultValue: {
          type: c.GraphQLString,
          description: "A GraphQL-formatted string representing the default value for this input value.",
          resolve(e) {
            const { type: t, defaultValue: r } = e;
            const n = (0, a.astFromValue)(r, t);
            return n ? (0, i.print)(n) : null;
          },
        },
        isDeprecated: { type: new A.GraphQLNonNull(c.GraphQLBoolean), resolve: (e) => e.deprecationReason != null },
        deprecationReason: { type: c.GraphQLString, resolve: (e) => e.deprecationReason },
      }),
    });
    t.__InputValue = m;
    const h = new A.GraphQLObjectType({
      name: "__EnumValue",
      description:
        "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
      fields: () => ({
        name: { type: new A.GraphQLNonNull(c.GraphQLString), resolve: (e) => e.name },
        description: { type: c.GraphQLString, resolve: (e) => e.description },
        isDeprecated: { type: new A.GraphQLNonNull(c.GraphQLBoolean), resolve: (e) => e.deprecationReason != null },
        deprecationReason: { type: c.GraphQLString, resolve: (e) => e.deprecationReason },
      }),
    });
    t.__EnumValue = h;
    var E;
    t.TypeKind = E;
    (function (e) {
      e["SCALAR"] = "SCALAR";
      e["OBJECT"] = "OBJECT";
      e["INTERFACE"] = "INTERFACE";
      e["UNION"] = "UNION";
      e["ENUM"] = "ENUM";
      e["INPUT_OBJECT"] = "INPUT_OBJECT";
      e["LIST"] = "LIST";
      e["NON_NULL"] = "NON_NULL";
    })(E || (t.TypeKind = E = {}));
    const I = new A.GraphQLEnumType({
      name: "__TypeKind",
      description: "An enum describing what kind of type a given `__Type` is.",
      values: {
        SCALAR: { value: E.SCALAR, description: "Indicates this type is a scalar." },
        OBJECT: { value: E.OBJECT, description: "Indicates this type is an object. `fields` and `interfaces` are valid fields." },
        INTERFACE: { value: E.INTERFACE, description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields." },
        UNION: { value: E.UNION, description: "Indicates this type is a union. `possibleTypes` is a valid field." },
        ENUM: { value: E.ENUM, description: "Indicates this type is an enum. `enumValues` is a valid field." },
        INPUT_OBJECT: { value: E.INPUT_OBJECT, description: "Indicates this type is an input object. `inputFields` is a valid field." },
        LIST: { value: E.LIST, description: "Indicates this type is a list. `ofType` is a valid field." },
        NON_NULL: { value: E.NON_NULL, description: "Indicates this type is a non-null. `ofType` is a valid field." },
      },
    });
    t.__TypeKind = I;
    const y = {
      name: "__schema",
      type: new A.GraphQLNonNull(u),
      description: "Access the current type schema of this server.",
      args: [],
      resolve: (e, t, r, { schema: n }) => n,
      deprecationReason: undefined,
      extensions: Object.create(null),
      astNode: undefined,
    };
    t.SchemaMetaFieldDef = y;
    const C = {
      name: "__type",
      type: d,
      description: "Request the type information of a single type.",
      args: [
        {
          name: "name",
          description: undefined,
          type: new A.GraphQLNonNull(c.GraphQLString),
          defaultValue: undefined,
          deprecationReason: undefined,
          extensions: Object.create(null),
          astNode: undefined,
        },
      ],
      resolve: (e, { name: t }, r, { schema: n }) => n.getType(t),
      deprecationReason: undefined,
      extensions: Object.create(null),
      astNode: undefined,
    };
    t.TypeMetaFieldDef = C;
    const b = {
      name: "__typename",
      type: new A.GraphQLNonNull(c.GraphQLString),
      description: "The name of the current Object type at runtime.",
      args: [],
      resolve: (e, t, r, { parentType: n }) => n.name,
      deprecationReason: undefined,
      extensions: Object.create(null),
      astNode: undefined,
    };
    t.TypeNameMetaFieldDef = b;
    const Q = Object.freeze([u, l, p, d, g, m, h, I]);
    t.introspectionTypes = Q;
    function isIntrospectionType(e) {
      return Q.some(({ name: t }) => e.name === t);
    }
  },
  83894: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.GraphQLString = t.GraphQLInt = t.GraphQLID = t.GraphQLFloat = t.GraphQLBoolean = t.GRAPHQL_MIN_INT = t.GRAPHQL_MAX_INT = void 0;
    t.isSpecifiedScalarType = isSpecifiedScalarType;
    t.specifiedScalarTypes = void 0;
    var n = r(71801);
    var o = r(84849);
    var s = r(23750);
    var i = r(19254);
    var a = r(85401);
    var A = r(46250);
    const c = 2147483647;
    t.GRAPHQL_MAX_INT = c;
    const u = -2147483648;
    t.GRAPHQL_MIN_INT = u;
    const l = new A.GraphQLScalarType({
      name: "Int",
      description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
      serialize(e) {
        const t = serializeObject(e);
        if (typeof t === "boolean") {
          return t ? 1 : 0;
        }
        let r = t;
        if (typeof t === "string" && t !== "") {
          r = Number(t);
        }
        if (typeof r !== "number" || !Number.isInteger(r)) {
          throw new s.GraphQLError(`Int cannot represent non-integer value: ${(0, n.inspect)(t)}`);
        }
        if (r > c || r < u) {
          throw new s.GraphQLError("Int cannot represent non 32-bit signed integer value: " + (0, n.inspect)(t));
        }
        return r;
      },
      parseValue(e) {
        if (typeof e !== "number" || !Number.isInteger(e)) {
          throw new s.GraphQLError(`Int cannot represent non-integer value: ${(0, n.inspect)(e)}`);
        }
        if (e > c || e < u) {
          throw new s.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${e}`);
        }
        return e;
      },
      parseLiteral(e) {
        if (e.kind !== i.Kind.INT) {
          throw new s.GraphQLError(`Int cannot represent non-integer value: ${(0, a.print)(e)}`, { nodes: e });
        }
        const t = parseInt(e.value, 10);
        if (t > c || t < u) {
          throw new s.GraphQLError(`Int cannot represent non 32-bit signed integer value: ${e.value}`, { nodes: e });
        }
        return t;
      },
    });
    t.GraphQLInt = l;
    const p = new A.GraphQLScalarType({
      name: "Float",
      description:
        "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
      serialize(e) {
        const t = serializeObject(e);
        if (typeof t === "boolean") {
          return t ? 1 : 0;
        }
        let r = t;
        if (typeof t === "string" && t !== "") {
          r = Number(t);
        }
        if (typeof r !== "number" || !Number.isFinite(r)) {
          throw new s.GraphQLError(`Float cannot represent non numeric value: ${(0, n.inspect)(t)}`);
        }
        return r;
      },
      parseValue(e) {
        if (typeof e !== "number" || !Number.isFinite(e)) {
          throw new s.GraphQLError(`Float cannot represent non numeric value: ${(0, n.inspect)(e)}`);
        }
        return e;
      },
      parseLiteral(e) {
        if (e.kind !== i.Kind.FLOAT && e.kind !== i.Kind.INT) {
          throw new s.GraphQLError(`Float cannot represent non numeric value: ${(0, a.print)(e)}`, e);
        }
        return parseFloat(e.value);
      },
    });
    t.GraphQLFloat = p;
    const d = new A.GraphQLScalarType({
      name: "String",
      description:
        "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
      serialize(e) {
        const t = serializeObject(e);
        if (typeof t === "string") {
          return t;
        }
        if (typeof t === "boolean") {
          return t ? "true" : "false";
        }
        if (typeof t === "number" && Number.isFinite(t)) {
          return t.toString();
        }
        throw new s.GraphQLError(`String cannot represent value: ${(0, n.inspect)(e)}`);
      },
      parseValue(e) {
        if (typeof e !== "string") {
          throw new s.GraphQLError(`String cannot represent a non string value: ${(0, n.inspect)(e)}`);
        }
        return e;
      },
      parseLiteral(e) {
        if (e.kind !== i.Kind.STRING) {
          throw new s.GraphQLError(`String cannot represent a non string value: ${(0, a.print)(e)}`, { nodes: e });
        }
        return e.value;
      },
    });
    t.GraphQLString = d;
    const g = new A.GraphQLScalarType({
      name: "Boolean",
      description: "The `Boolean` scalar type represents `true` or `false`.",
      serialize(e) {
        const t = serializeObject(e);
        if (typeof t === "boolean") {
          return t;
        }
        if (Number.isFinite(t)) {
          return t !== 0;
        }
        throw new s.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, n.inspect)(t)}`);
      },
      parseValue(e) {
        if (typeof e !== "boolean") {
          throw new s.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, n.inspect)(e)}`);
        }
        return e;
      },
      parseLiteral(e) {
        if (e.kind !== i.Kind.BOOLEAN) {
          throw new s.GraphQLError(`Boolean cannot represent a non boolean value: ${(0, a.print)(e)}`, { nodes: e });
        }
        return e.value;
      },
    });
    t.GraphQLBoolean = g;
    const m = new A.GraphQLScalarType({
      name: "ID",
      description:
        'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
      serialize(e) {
        const t = serializeObject(e);
        if (typeof t === "string") {
          return t;
        }
        if (Number.isInteger(t)) {
          return String(t);
        }
        throw new s.GraphQLError(`ID cannot represent value: ${(0, n.inspect)(e)}`);
      },
      parseValue(e) {
        if (typeof e === "string") {
          return e;
        }
        if (typeof e === "number" && Number.isInteger(e)) {
          return e.toString();
        }
        throw new s.GraphQLError(`ID cannot represent value: ${(0, n.inspect)(e)}`);
      },
      parseLiteral(e) {
        if (e.kind !== i.Kind.STRING && e.kind !== i.Kind.INT) {
          throw new s.GraphQLError("ID cannot represent a non-string and non-integer value: " + (0, a.print)(e), { nodes: e });
        }
        return e.value;
      },
    });
    t.GraphQLID = m;
    const h = Object.freeze([d, l, p, g, m]);
    t.specifiedScalarTypes = h;
    function isSpecifiedScalarType(e) {
      return h.some(({ name: t }) => e.name === t);
    }
    function serializeObject(e) {
      if ((0, o.isObjectLike)(e)) {
        if (typeof e.valueOf === "function") {
          const t = e.valueOf();
          if (!(0, o.isObjectLike)(t)) {
            return t;
          }
        }
        if (typeof e.toJSON === "function") {
          return e.toJSON();
        }
      }
      return e;
    }
  },
  71672: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.GraphQLSchema = void 0;
    t.assertSchema = assertSchema;
    t.isSchema = isSchema;
    var n = r(53284);
    var o = r(71801);
    var s = r(24551);
    var i = r(84849);
    var a = r(27949);
    var A = r(26081);
    var c = r(46250);
    var u = r(58941);
    var l = r(47564);
    function isSchema(e) {
      return (0, s.instanceOf)(e, GraphQLSchema);
    }
    function assertSchema(e) {
      if (!isSchema(e)) {
        throw new Error(`Expected ${(0, o.inspect)(e)} to be a GraphQL schema.`);
      }
      return e;
    }
    class GraphQLSchema {
      constructor(e) {
        var t, r;
        this.__validationErrors = e.assumeValid === true ? [] : undefined;
        (0, i.isObjectLike)(e) || (0, n.devAssert)(false, "Must provide configuration object.");
        !e.types || Array.isArray(e.types) || (0, n.devAssert)(false, `"types" must be Array if provided but got: ${(0, o.inspect)(e.types)}.`);
        !e.directives ||
          Array.isArray(e.directives) ||
          (0, n.devAssert)(false, '"directives" must be Array if provided but got: ' + `${(0, o.inspect)(e.directives)}.`);
        this.description = e.description;
        this.extensions = (0, a.toObjMap)(e.extensions);
        this.astNode = e.astNode;
        this.extensionASTNodes = (t = e.extensionASTNodes) !== null && t !== void 0 ? t : [];
        this._queryType = e.query;
        this._mutationType = e.mutation;
        this._subscriptionType = e.subscription;
        this._directives = (r = e.directives) !== null && r !== void 0 ? r : u.specifiedDirectives;
        const s = new Set(e.types);
        if (e.types != null) {
          for (const t of e.types) {
            s.delete(t);
            collectReferencedTypes(t, s);
          }
        }
        if (this._queryType != null) {
          collectReferencedTypes(this._queryType, s);
        }
        if (this._mutationType != null) {
          collectReferencedTypes(this._mutationType, s);
        }
        if (this._subscriptionType != null) {
          collectReferencedTypes(this._subscriptionType, s);
        }
        for (const e of this._directives) {
          if ((0, u.isDirective)(e)) {
            for (const t of e.args) {
              collectReferencedTypes(t.type, s);
            }
          }
        }
        collectReferencedTypes(l.__Schema, s);
        this._typeMap = Object.create(null);
        this._subTypeMap = Object.create(null);
        this._implementationsMap = Object.create(null);
        for (const e of s) {
          if (e == null) {
            continue;
          }
          const t = e.name;
          t || (0, n.devAssert)(false, "One of the provided types for building the Schema is missing a name.");
          if (this._typeMap[t] !== undefined) {
            throw new Error(`Schema must contain uniquely named types but contains multiple types named "${t}".`);
          }
          this._typeMap[t] = e;
          if ((0, c.isInterfaceType)(e)) {
            for (const t of e.getInterfaces()) {
              if ((0, c.isInterfaceType)(t)) {
                let r = this._implementationsMap[t.name];
                if (r === undefined) {
                  r = this._implementationsMap[t.name] = { objects: [], interfaces: [] };
                }
                r.interfaces.push(e);
              }
            }
          } else if ((0, c.isObjectType)(e)) {
            for (const t of e.getInterfaces()) {
              if ((0, c.isInterfaceType)(t)) {
                let r = this._implementationsMap[t.name];
                if (r === undefined) {
                  r = this._implementationsMap[t.name] = { objects: [], interfaces: [] };
                }
                r.objects.push(e);
              }
            }
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "GraphQLSchema";
      }
      getQueryType() {
        return this._queryType;
      }
      getMutationType() {
        return this._mutationType;
      }
      getSubscriptionType() {
        return this._subscriptionType;
      }
      getRootType(e) {
        switch (e) {
          case A.OperationTypeNode.QUERY:
            return this.getQueryType();
          case A.OperationTypeNode.MUTATION:
            return this.getMutationType();
          case A.OperationTypeNode.SUBSCRIPTION:
            return this.getSubscriptionType();
        }
      }
      getTypeMap() {
        return this._typeMap;
      }
      getType(e) {
        return this.getTypeMap()[e];
      }
      getPossibleTypes(e) {
        return (0, c.isUnionType)(e) ? e.getTypes() : this.getImplementations(e).objects;
      }
      getImplementations(e) {
        const t = this._implementationsMap[e.name];
        return t !== null && t !== void 0 ? t : { objects: [], interfaces: [] };
      }
      isSubType(e, t) {
        let r = this._subTypeMap[e.name];
        if (r === undefined) {
          r = Object.create(null);
          if ((0, c.isUnionType)(e)) {
            for (const t of e.getTypes()) {
              r[t.name] = true;
            }
          } else {
            const t = this.getImplementations(e);
            for (const e of t.objects) {
              r[e.name] = true;
            }
            for (const e of t.interfaces) {
              r[e.name] = true;
            }
          }
          this._subTypeMap[e.name] = r;
        }
        return r[t.name] !== undefined;
      }
      getDirectives() {
        return this._directives;
      }
      getDirective(e) {
        return this.getDirectives().find((t) => t.name === e);
      }
      toConfig() {
        return {
          description: this.description,
          query: this.getQueryType(),
          mutation: this.getMutationType(),
          subscription: this.getSubscriptionType(),
          types: Object.values(this.getTypeMap()),
          directives: this.getDirectives(),
          extensions: this.extensions,
          astNode: this.astNode,
          extensionASTNodes: this.extensionASTNodes,
          assumeValid: this.__validationErrors !== undefined,
        };
      }
    }
    t.GraphQLSchema = GraphQLSchema;
    function collectReferencedTypes(e, t) {
      const r = (0, c.getNamedType)(e);
      if (!t.has(r)) {
        t.add(r);
        if ((0, c.isUnionType)(r)) {
          for (const e of r.getTypes()) {
            collectReferencedTypes(e, t);
          }
        } else if ((0, c.isObjectType)(r) || (0, c.isInterfaceType)(r)) {
          for (const e of r.getInterfaces()) {
            collectReferencedTypes(e, t);
          }
          for (const e of Object.values(r.getFields())) {
            collectReferencedTypes(e.type, t);
            for (const r of e.args) {
              collectReferencedTypes(r.type, t);
            }
          }
        } else if ((0, c.isInputObjectType)(r)) {
          for (const e of Object.values(r.getFields())) {
            collectReferencedTypes(e.type, t);
          }
        }
      }
      return t;
    }
  },
  22689: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.assertValidSchema = assertValidSchema;
    t.validateSchema = validateSchema;
    var n = r(71801);
    var o = r(23750);
    var s = r(26081);
    var i = r(48808);
    var a = r(46250);
    var A = r(58941);
    var c = r(47564);
    var u = r(71672);
    function validateSchema(e) {
      (0, u.assertSchema)(e);
      if (e.__validationErrors) {
        return e.__validationErrors;
      }
      const t = new SchemaValidationContext(e);
      validateRootTypes(t);
      validateDirectives(t);
      validateTypes(t);
      const r = t.getErrors();
      e.__validationErrors = r;
      return r;
    }
    function assertValidSchema(e) {
      const t = validateSchema(e);
      if (t.length !== 0) {
        throw new Error(t.map((e) => e.message).join("\n\n"));
      }
    }
    class SchemaValidationContext {
      constructor(e) {
        this._errors = [];
        this.schema = e;
      }
      reportError(e, t) {
        const r = Array.isArray(t) ? t.filter(Boolean) : t;
        this._errors.push(new o.GraphQLError(e, { nodes: r }));
      }
      getErrors() {
        return this._errors;
      }
    }
    function validateRootTypes(e) {
      const t = e.schema;
      const r = t.getQueryType();
      if (!r) {
        e.reportError("Query root type must be provided.", t.astNode);
      } else if (!(0, a.isObjectType)(r)) {
        var o;
        e.reportError(
          `Query root type must be Object type, it cannot be ${(0, n.inspect)(r)}.`,
          (o = getOperationTypeNode(t, s.OperationTypeNode.QUERY)) !== null && o !== void 0 ? o : r.astNode
        );
      }
      const i = t.getMutationType();
      if (i && !(0, a.isObjectType)(i)) {
        var A;
        e.reportError(
          "Mutation root type must be Object type if provided, it cannot be " + `${(0, n.inspect)(i)}.`,
          (A = getOperationTypeNode(t, s.OperationTypeNode.MUTATION)) !== null && A !== void 0 ? A : i.astNode
        );
      }
      const c = t.getSubscriptionType();
      if (c && !(0, a.isObjectType)(c)) {
        var u;
        e.reportError(
          "Subscription root type must be Object type if provided, it cannot be " + `${(0, n.inspect)(c)}.`,
          (u = getOperationTypeNode(t, s.OperationTypeNode.SUBSCRIPTION)) !== null && u !== void 0 ? u : c.astNode
        );
      }
    }
    function getOperationTypeNode(e, t) {
      var r;
      return (r = [e.astNode, ...e.extensionASTNodes]
        .flatMap((e) => {
          var t;
          return (t = e === null || e === void 0 ? void 0 : e.operationTypes) !== null && t !== void 0 ? t : [];
        })
        .find((e) => e.operation === t)) === null || r === void 0
        ? void 0
        : r.type;
    }
    function validateDirectives(e) {
      for (const r of e.schema.getDirectives()) {
        if (!(0, A.isDirective)(r)) {
          e.reportError(`Expected directive but got: ${(0, n.inspect)(r)}.`, r === null || r === void 0 ? void 0 : r.astNode);
          continue;
        }
        validateName(e, r);
        for (const o of r.args) {
          validateName(e, o);
          if (!(0, a.isInputType)(o.type)) {
            e.reportError(`The type of @${r.name}(${o.name}:) must be Input Type ` + `but got: ${(0, n.inspect)(o.type)}.`, o.astNode);
          }
          if ((0, a.isRequiredArgument)(o) && o.deprecationReason != null) {
            var t;
            e.reportError(`Required argument @${r.name}(${o.name}:) cannot be deprecated.`, [
              getDeprecatedDirectiveNode(o.astNode),
              (t = o.astNode) === null || t === void 0 ? void 0 : t.type,
            ]);
          }
        }
      }
    }
    function validateName(e, t) {
      if (t.name.startsWith("__")) {
        e.reportError(`Name "${t.name}" must not begin with "__", which is reserved by GraphQL introspection.`, t.astNode);
      }
    }
    function validateTypes(e) {
      const t = createInputObjectCircularRefsValidator(e);
      const r = e.schema.getTypeMap();
      for (const o of Object.values(r)) {
        if (!(0, a.isNamedType)(o)) {
          e.reportError(`Expected GraphQL named type but got: ${(0, n.inspect)(o)}.`, o.astNode);
          continue;
        }
        if (!(0, c.isIntrospectionType)(o)) {
          validateName(e, o);
        }
        if ((0, a.isObjectType)(o)) {
          validateFields(e, o);
          validateInterfaces(e, o);
        } else if ((0, a.isInterfaceType)(o)) {
          validateFields(e, o);
          validateInterfaces(e, o);
        } else if ((0, a.isUnionType)(o)) {
          validateUnionMembers(e, o);
        } else if ((0, a.isEnumType)(o)) {
          validateEnumValues(e, o);
        } else if ((0, a.isInputObjectType)(o)) {
          validateInputFields(e, o);
          t(o);
        }
      }
    }
    function validateFields(e, t) {
      const r = Object.values(t.getFields());
      if (r.length === 0) {
        e.reportError(`Type ${t.name} must define one or more fields.`, [t.astNode, ...t.extensionASTNodes]);
      }
      for (const A of r) {
        validateName(e, A);
        if (!(0, a.isOutputType)(A.type)) {
          var o;
          e.reportError(
            `The type of ${t.name}.${A.name} must be Output Type ` + `but got: ${(0, n.inspect)(A.type)}.`,
            (o = A.astNode) === null || o === void 0 ? void 0 : o.type
          );
        }
        for (const r of A.args) {
          const o = r.name;
          validateName(e, r);
          if (!(0, a.isInputType)(r.type)) {
            var s;
            e.reportError(
              `The type of ${t.name}.${A.name}(${o}:) must be Input ` + `Type but got: ${(0, n.inspect)(r.type)}.`,
              (s = r.astNode) === null || s === void 0 ? void 0 : s.type
            );
          }
          if ((0, a.isRequiredArgument)(r) && r.deprecationReason != null) {
            var i;
            e.reportError(`Required argument ${t.name}.${A.name}(${o}:) cannot be deprecated.`, [
              getDeprecatedDirectiveNode(r.astNode),
              (i = r.astNode) === null || i === void 0 ? void 0 : i.type,
            ]);
          }
        }
      }
    }
    function validateInterfaces(e, t) {
      const r = Object.create(null);
      for (const o of t.getInterfaces()) {
        if (!(0, a.isInterfaceType)(o)) {
          e.reportError(
            `Type ${(0, n.inspect)(t)} must only implement Interface types, ` + `it cannot implement ${(0, n.inspect)(o)}.`,
            getAllImplementsInterfaceNodes(t, o)
          );
          continue;
        }
        if (t === o) {
          e.reportError(`Type ${t.name} cannot implement itself because it would create a circular reference.`, getAllImplementsInterfaceNodes(t, o));
          continue;
        }
        if (r[o.name]) {
          e.reportError(`Type ${t.name} can only implement ${o.name} once.`, getAllImplementsInterfaceNodes(t, o));
          continue;
        }
        r[o.name] = true;
        validateTypeImplementsAncestors(e, t, o);
        validateTypeImplementsInterface(e, t, o);
      }
    }
    function validateTypeImplementsInterface(e, t, r) {
      const o = t.getFields();
      for (const l of Object.values(r.getFields())) {
        const p = l.name;
        const d = o[p];
        if (!d) {
          e.reportError(`Interface field ${r.name}.${p} expected but ${t.name} does not provide it.`, [l.astNode, t.astNode, ...t.extensionASTNodes]);
          continue;
        }
        if (!(0, i.isTypeSubTypeOf)(e.schema, d.type, l.type)) {
          var s, A;
          e.reportError(
            `Interface field ${r.name}.${p} expects type ` + `${(0, n.inspect)(l.type)} but ${t.name}.${p} ` + `is type ${(0, n.inspect)(d.type)}.`,
            [(s = l.astNode) === null || s === void 0 ? void 0 : s.type, (A = d.astNode) === null || A === void 0 ? void 0 : A.type]
          );
        }
        for (const o of l.args) {
          const s = o.name;
          const a = d.args.find((e) => e.name === s);
          if (!a) {
            e.reportError(`Interface field argument ${r.name}.${p}(${s}:) expected but ${t.name}.${p} does not provide it.`, [o.astNode, d.astNode]);
            continue;
          }
          if (!(0, i.isEqualType)(o.type, a.type)) {
            var c, u;
            e.reportError(
              `Interface field argument ${r.name}.${p}(${s}:) ` +
                `expects type ${(0, n.inspect)(o.type)} but ` +
                `${t.name}.${p}(${s}:) is type ` +
                `${(0, n.inspect)(a.type)}.`,
              [(c = o.astNode) === null || c === void 0 ? void 0 : c.type, (u = a.astNode) === null || u === void 0 ? void 0 : u.type]
            );
          }
        }
        for (const n of d.args) {
          const o = n.name;
          const s = l.args.find((e) => e.name === o);
          if (!s && (0, a.isRequiredArgument)(n)) {
            e.reportError(`Object field ${t.name}.${p} includes required argument ${o} that is missing from the Interface field ${r.name}.${p}.`, [
              n.astNode,
              l.astNode,
            ]);
          }
        }
      }
    }
    function validateTypeImplementsAncestors(e, t, r) {
      const n = t.getInterfaces();
      for (const o of r.getInterfaces()) {
        if (!n.includes(o)) {
          e.reportError(
            o === t
              ? `Type ${t.name} cannot implement ${r.name} because it would create a circular reference.`
              : `Type ${t.name} must implement ${o.name} because it is implemented by ${r.name}.`,
            [...getAllImplementsInterfaceNodes(r, o), ...getAllImplementsInterfaceNodes(t, r)]
          );
        }
      }
    }
    function validateUnionMembers(e, t) {
      const r = t.getTypes();
      if (r.length === 0) {
        e.reportError(`Union type ${t.name} must define one or more member types.`, [t.astNode, ...t.extensionASTNodes]);
      }
      const o = Object.create(null);
      for (const s of r) {
        if (o[s.name]) {
          e.reportError(`Union type ${t.name} can only include type ${s.name} once.`, getUnionMemberTypeNodes(t, s.name));
          continue;
        }
        o[s.name] = true;
        if (!(0, a.isObjectType)(s)) {
          e.reportError(
            `Union type ${t.name} can only include Object types, ` + `it cannot include ${(0, n.inspect)(s)}.`,
            getUnionMemberTypeNodes(t, String(s))
          );
        }
      }
    }
    function validateEnumValues(e, t) {
      const r = t.getValues();
      if (r.length === 0) {
        e.reportError(`Enum type ${t.name} must define one or more values.`, [t.astNode, ...t.extensionASTNodes]);
      }
      for (const t of r) {
        validateName(e, t);
      }
    }
    function validateInputFields(e, t) {
      const r = Object.values(t.getFields());
      if (r.length === 0) {
        e.reportError(`Input Object type ${t.name} must define one or more fields.`, [t.astNode, ...t.extensionASTNodes]);
      }
      for (const i of r) {
        validateName(e, i);
        if (!(0, a.isInputType)(i.type)) {
          var o;
          e.reportError(
            `The type of ${t.name}.${i.name} must be Input Type ` + `but got: ${(0, n.inspect)(i.type)}.`,
            (o = i.astNode) === null || o === void 0 ? void 0 : o.type
          );
        }
        if ((0, a.isRequiredInputField)(i) && i.deprecationReason != null) {
          var s;
          e.reportError(`Required input field ${t.name}.${i.name} cannot be deprecated.`, [
            getDeprecatedDirectiveNode(i.astNode),
            (s = i.astNode) === null || s === void 0 ? void 0 : s.type,
          ]);
        }
        if (t.isOneOf) {
          validateOneOfInputObjectField(t, i, e);
        }
      }
    }
    function validateOneOfInputObjectField(e, t, r) {
      if ((0, a.isNonNullType)(t.type)) {
        var n;
        r.reportError(`OneOf input field ${e.name}.${t.name} must be nullable.`, (n = t.astNode) === null || n === void 0 ? void 0 : n.type);
      }
      if (t.defaultValue !== undefined) {
        r.reportError(`OneOf input field ${e.name}.${t.name} cannot have a default value.`, t.astNode);
      }
    }
    function createInputObjectCircularRefsValidator(e) {
      const t = Object.create(null);
      const r = [];
      const n = Object.create(null);
      return detectCycleRecursive;
      function detectCycleRecursive(o) {
        if (t[o.name]) {
          return;
        }
        t[o.name] = true;
        n[o.name] = r.length;
        const s = Object.values(o.getFields());
        for (const t of s) {
          if ((0, a.isNonNullType)(t.type) && (0, a.isInputObjectType)(t.type.ofType)) {
            const o = t.type.ofType;
            const s = n[o.name];
            r.push(t);
            if (s === undefined) {
              detectCycleRecursive(o);
            } else {
              const t = r.slice(s);
              const n = t.map((e) => e.name).join(".");
              e.reportError(
                `Cannot reference Input Object "${o.name}" within itself through a series of non-null fields: "${n}".`,
                t.map((e) => e.astNode)
              );
            }
            r.pop();
          }
        }
        n[o.name] = undefined;
      }
    }
    function getAllImplementsInterfaceNodes(e, t) {
      const { astNode: r, extensionASTNodes: n } = e;
      const o = r != null ? [r, ...n] : n;
      return o
        .flatMap((e) => {
          var t;
          return (t = e.interfaces) !== null && t !== void 0 ? t : [];
        })
        .filter((e) => e.name.value === t.name);
    }
    function getUnionMemberTypeNodes(e, t) {
      const { astNode: r, extensionASTNodes: n } = e;
      const o = r != null ? [r, ...n] : n;
      return o
        .flatMap((e) => {
          var t;
          return (t = e.types) !== null && t !== void 0 ? t : [];
        })
        .filter((e) => e.name.value === t);
    }
    function getDeprecatedDirectiveNode(e) {
      var t;
      return e === null || e === void 0
        ? void 0
        : (t = e.directives) === null || t === void 0
          ? void 0
          : t.find((e) => e.name.value === A.GraphQLDeprecatedDirective.name);
    }
  },
  71165: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TypeInfo = void 0;
    t.visitWithTypeInfo = visitWithTypeInfo;
    var n = r(26081);
    var o = r(19254);
    var s = r(45399);
    var i = r(46250);
    var a = r(47564);
    var A = r(45669);
    class TypeInfo {
      constructor(e, t, r) {
        this._schema = e;
        this._typeStack = [];
        this._parentTypeStack = [];
        this._inputTypeStack = [];
        this._fieldDefStack = [];
        this._defaultValueStack = [];
        this._directive = null;
        this._argument = null;
        this._enumValue = null;
        this._getFieldDef = r !== null && r !== void 0 ? r : getFieldDef;
        if (t) {
          if ((0, i.isInputType)(t)) {
            this._inputTypeStack.push(t);
          }
          if ((0, i.isCompositeType)(t)) {
            this._parentTypeStack.push(t);
          }
          if ((0, i.isOutputType)(t)) {
            this._typeStack.push(t);
          }
        }
      }
      get [Symbol.toStringTag]() {
        return "TypeInfo";
      }
      getType() {
        if (this._typeStack.length > 0) {
          return this._typeStack[this._typeStack.length - 1];
        }
      }
      getParentType() {
        if (this._parentTypeStack.length > 0) {
          return this._parentTypeStack[this._parentTypeStack.length - 1];
        }
      }
      getInputType() {
        if (this._inputTypeStack.length > 0) {
          return this._inputTypeStack[this._inputTypeStack.length - 1];
        }
      }
      getParentInputType() {
        if (this._inputTypeStack.length > 1) {
          return this._inputTypeStack[this._inputTypeStack.length - 2];
        }
      }
      getFieldDef() {
        if (this._fieldDefStack.length > 0) {
          return this._fieldDefStack[this._fieldDefStack.length - 1];
        }
      }
      getDefaultValue() {
        if (this._defaultValueStack.length > 0) {
          return this._defaultValueStack[this._defaultValueStack.length - 1];
        }
      }
      getDirective() {
        return this._directive;
      }
      getArgument() {
        return this._argument;
      }
      getEnumValue() {
        return this._enumValue;
      }
      enter(e) {
        const t = this._schema;
        switch (e.kind) {
          case o.Kind.SELECTION_SET: {
            const e = (0, i.getNamedType)(this.getType());
            this._parentTypeStack.push((0, i.isCompositeType)(e) ? e : undefined);
            break;
          }
          case o.Kind.FIELD: {
            const r = this.getParentType();
            let n;
            let o;
            if (r) {
              n = this._getFieldDef(t, r, e);
              if (n) {
                o = n.type;
              }
            }
            this._fieldDefStack.push(n);
            this._typeStack.push((0, i.isOutputType)(o) ? o : undefined);
            break;
          }
          case o.Kind.DIRECTIVE:
            this._directive = t.getDirective(e.name.value);
            break;
          case o.Kind.OPERATION_DEFINITION: {
            const r = t.getRootType(e.operation);
            this._typeStack.push((0, i.isObjectType)(r) ? r : undefined);
            break;
          }
          case o.Kind.INLINE_FRAGMENT:
          case o.Kind.FRAGMENT_DEFINITION: {
            const r = e.typeCondition;
            const n = r ? (0, A.typeFromAST)(t, r) : (0, i.getNamedType)(this.getType());
            this._typeStack.push((0, i.isOutputType)(n) ? n : undefined);
            break;
          }
          case o.Kind.VARIABLE_DEFINITION: {
            const r = (0, A.typeFromAST)(t, e.type);
            this._inputTypeStack.push((0, i.isInputType)(r) ? r : undefined);
            break;
          }
          case o.Kind.ARGUMENT: {
            var r;
            let t;
            let n;
            const o = (r = this.getDirective()) !== null && r !== void 0 ? r : this.getFieldDef();
            if (o) {
              t = o.args.find((t) => t.name === e.name.value);
              if (t) {
                n = t.type;
              }
            }
            this._argument = t;
            this._defaultValueStack.push(t ? t.defaultValue : undefined);
            this._inputTypeStack.push((0, i.isInputType)(n) ? n : undefined);
            break;
          }
          case o.Kind.LIST: {
            const e = (0, i.getNullableType)(this.getInputType());
            const t = (0, i.isListType)(e) ? e.ofType : e;
            this._defaultValueStack.push(undefined);
            this._inputTypeStack.push((0, i.isInputType)(t) ? t : undefined);
            break;
          }
          case o.Kind.OBJECT_FIELD: {
            const t = (0, i.getNamedType)(this.getInputType());
            let r;
            let n;
            if ((0, i.isInputObjectType)(t)) {
              n = t.getFields()[e.name.value];
              if (n) {
                r = n.type;
              }
            }
            this._defaultValueStack.push(n ? n.defaultValue : undefined);
            this._inputTypeStack.push((0, i.isInputType)(r) ? r : undefined);
            break;
          }
          case o.Kind.ENUM: {
            const t = (0, i.getNamedType)(this.getInputType());
            let r;
            if ((0, i.isEnumType)(t)) {
              r = t.getValue(e.value);
            }
            this._enumValue = r;
            break;
          }
          default:
        }
      }
      leave(e) {
        switch (e.kind) {
          case o.Kind.SELECTION_SET:
            this._parentTypeStack.pop();
            break;
          case o.Kind.FIELD:
            this._fieldDefStack.pop();
            this._typeStack.pop();
            break;
          case o.Kind.DIRECTIVE:
            this._directive = null;
            break;
          case o.Kind.OPERATION_DEFINITION:
          case o.Kind.INLINE_FRAGMENT:
          case o.Kind.FRAGMENT_DEFINITION:
            this._typeStack.pop();
            break;
          case o.Kind.VARIABLE_DEFINITION:
            this._inputTypeStack.pop();
            break;
          case o.Kind.ARGUMENT:
            this._argument = null;
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case o.Kind.LIST:
          case o.Kind.OBJECT_FIELD:
            this._defaultValueStack.pop();
            this._inputTypeStack.pop();
            break;
          case o.Kind.ENUM:
            this._enumValue = null;
            break;
          default:
        }
      }
    }
    t.TypeInfo = TypeInfo;
    function getFieldDef(e, t, r) {
      const n = r.name.value;
      if (n === a.SchemaMetaFieldDef.name && e.getQueryType() === t) {
        return a.SchemaMetaFieldDef;
      }
      if (n === a.TypeMetaFieldDef.name && e.getQueryType() === t) {
        return a.TypeMetaFieldDef;
      }
      if (n === a.TypeNameMetaFieldDef.name && (0, i.isCompositeType)(t)) {
        return a.TypeNameMetaFieldDef;
      }
      if ((0, i.isObjectType)(t) || (0, i.isInterfaceType)(t)) {
        return t.getFields()[n];
      }
    }
    function visitWithTypeInfo(e, t) {
      return {
        enter(...r) {
          const o = r[0];
          e.enter(o);
          const i = (0, s.getEnterLeaveForKind)(t, o.kind).enter;
          if (i) {
            const s = i.apply(t, r);
            if (s !== undefined) {
              e.leave(o);
              if ((0, n.isNode)(s)) {
                e.enter(s);
              }
            }
            return s;
          }
        },
        leave(...r) {
          const n = r[0];
          const o = (0, s.getEnterLeaveForKind)(t, n.kind).leave;
          let i;
          if (o) {
            i = o.apply(t, r);
          }
          e.leave(n);
          return i;
        },
      };
    }
  },
  77226: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.assertValidName = assertValidName;
    t.isValidNameError = isValidNameError;
    var n = r(53284);
    var o = r(23750);
    var s = r(27442);
    function assertValidName(e) {
      const t = isValidNameError(e);
      if (t) {
        throw t;
      }
      return e;
    }
    function isValidNameError(e) {
      typeof e === "string" || (0, n.devAssert)(false, "Expected name to be a string.");
      if (e.startsWith("__")) {
        return new o.GraphQLError(`Name "${e}" must not begin with "__", which is reserved by GraphQL introspection.`);
      }
      try {
        (0, s.assertName)(e);
      } catch (e) {
        return e;
      }
    }
  },
  97520: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.astFromValue = astFromValue;
    var n = r(71801);
    var o = r(67305);
    var s = r(12916);
    var i = r(84849);
    var a = r(19254);
    var A = r(46250);
    var c = r(83894);
    function astFromValue(e, t) {
      if ((0, A.isNonNullType)(t)) {
        const r = astFromValue(e, t.ofType);
        if ((r === null || r === void 0 ? void 0 : r.kind) === a.Kind.NULL) {
          return null;
        }
        return r;
      }
      if (e === null) {
        return { kind: a.Kind.NULL };
      }
      if (e === undefined) {
        return null;
      }
      if ((0, A.isListType)(t)) {
        const r = t.ofType;
        if ((0, s.isIterableObject)(e)) {
          const t = [];
          for (const n of e) {
            const e = astFromValue(n, r);
            if (e != null) {
              t.push(e);
            }
          }
          return { kind: a.Kind.LIST, values: t };
        }
        return astFromValue(e, r);
      }
      if ((0, A.isInputObjectType)(t)) {
        if (!(0, i.isObjectLike)(e)) {
          return null;
        }
        const r = [];
        for (const n of Object.values(t.getFields())) {
          const t = astFromValue(e[n.name], n.type);
          if (t) {
            r.push({ kind: a.Kind.OBJECT_FIELD, name: { kind: a.Kind.NAME, value: n.name }, value: t });
          }
        }
        return { kind: a.Kind.OBJECT, fields: r };
      }
      if ((0, A.isLeafType)(t)) {
        const r = t.serialize(e);
        if (r == null) {
          return null;
        }
        if (typeof r === "boolean") {
          return { kind: a.Kind.BOOLEAN, value: r };
        }
        if (typeof r === "number" && Number.isFinite(r)) {
          const e = String(r);
          return u.test(e) ? { kind: a.Kind.INT, value: e } : { kind: a.Kind.FLOAT, value: e };
        }
        if (typeof r === "string") {
          if ((0, A.isEnumType)(t)) {
            return { kind: a.Kind.ENUM, value: r };
          }
          if (t === c.GraphQLID && u.test(r)) {
            return { kind: a.Kind.INT, value: r };
          }
          return { kind: a.Kind.STRING, value: r };
        }
        throw new TypeError(`Cannot convert value to AST: ${(0, n.inspect)(r)}.`);
      }
      false || (0, o.invariant)(false, "Unexpected input type: " + (0, n.inspect)(t));
    }
    const u = /^-?(?:0|[1-9][0-9]*)$/;
  },
  82402: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.buildASTSchema = buildASTSchema;
    t.buildSchema = buildSchema;
    var n = r(53284);
    var o = r(19254);
    var s = r(71878);
    var i = r(58941);
    var a = r(71672);
    var A = r(90592);
    var c = r(30690);
    function buildASTSchema(e, t) {
      (e != null && e.kind === o.Kind.DOCUMENT) || (0, n.devAssert)(false, "Must provide valid Document AST.");
      if ((t === null || t === void 0 ? void 0 : t.assumeValid) !== true && (t === null || t === void 0 ? void 0 : t.assumeValidSDL) !== true) {
        (0, A.assertValidSDL)(e);
      }
      const r = { description: undefined, types: [], directives: [], extensions: Object.create(null), extensionASTNodes: [], assumeValid: false };
      const s = (0, c.extendSchemaImpl)(r, e, t);
      if (s.astNode == null) {
        for (const e of s.types) {
          switch (e.name) {
            case "Query":
              s.query = e;
              break;
            case "Mutation":
              s.mutation = e;
              break;
            case "Subscription":
              s.subscription = e;
              break;
          }
        }
      }
      const u = [...s.directives, ...i.specifiedDirectives.filter((e) => s.directives.every((t) => t.name !== e.name))];
      return new a.GraphQLSchema({ ...s, directives: u });
    }
    function buildSchema(e, t) {
      const r = (0, s.parse)(e, {
        noLocation: t === null || t === void 0 ? void 0 : t.noLocation,
        allowLegacyFragmentVariables: t === null || t === void 0 ? void 0 : t.allowLegacyFragmentVariables,
      });
      return buildASTSchema(r, {
        assumeValidSDL: t === null || t === void 0 ? void 0 : t.assumeValidSDL,
        assumeValid: t === null || t === void 0 ? void 0 : t.assumeValid,
      });
    }
  },
  48741: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.buildClientSchema = buildClientSchema;
    var n = r(53284);
    var o = r(71801);
    var s = r(84849);
    var i = r(7897);
    var a = r(71878);
    var A = r(46250);
    var c = r(58941);
    var u = r(47564);
    var l = r(83894);
    var p = r(71672);
    var d = r(36302);
    function buildClientSchema(e, t) {
      ((0, s.isObjectLike)(e) && (0, s.isObjectLike)(e.__schema)) ||
        (0, n.devAssert)(
          false,
          `Invalid or incomplete introspection result. Ensure that you are passing "data" property of introspection response and no "errors" was returned alongside: ${(0, o.inspect)(e)}.`
        );
      const r = e.__schema;
      const g = (0, i.keyValMap)(
        r.types,
        (e) => e.name,
        (e) => buildType(e)
      );
      for (const e of [...l.specifiedScalarTypes, ...u.introspectionTypes]) {
        if (g[e.name]) {
          g[e.name] = e;
        }
      }
      const m = r.queryType ? getObjectType(r.queryType) : null;
      const h = r.mutationType ? getObjectType(r.mutationType) : null;
      const E = r.subscriptionType ? getObjectType(r.subscriptionType) : null;
      const I = r.directives ? r.directives.map(buildDirective) : [];
      return new p.GraphQLSchema({
        description: r.description,
        query: m,
        mutation: h,
        subscription: E,
        types: Object.values(g),
        directives: I,
        assumeValid: t === null || t === void 0 ? void 0 : t.assumeValid,
      });
      function getType(e) {
        if (e.kind === u.TypeKind.LIST) {
          const t = e.ofType;
          if (!t) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          return new A.GraphQLList(getType(t));
        }
        if (e.kind === u.TypeKind.NON_NULL) {
          const t = e.ofType;
          if (!t) {
            throw new Error("Decorated type deeper than introspection query.");
          }
          const r = getType(t);
          return new A.GraphQLNonNull((0, A.assertNullableType)(r));
        }
        return getNamedType(e);
      }
      function getNamedType(e) {
        const t = e.name;
        if (!t) {
          throw new Error(`Unknown type reference: ${(0, o.inspect)(e)}.`);
        }
        const r = g[t];
        if (!r) {
          throw new Error(
            `Invalid or incomplete schema, unknown type: ${t}. Ensure that a full introspection query is used in order to build a client schema.`
          );
        }
        return r;
      }
      function getObjectType(e) {
        return (0, A.assertObjectType)(getNamedType(e));
      }
      function getInterfaceType(e) {
        return (0, A.assertInterfaceType)(getNamedType(e));
      }
      function buildType(e) {
        if (e != null && e.name != null && e.kind != null) {
          switch (e.kind) {
            case u.TypeKind.SCALAR:
              return buildScalarDef(e);
            case u.TypeKind.OBJECT:
              return buildObjectDef(e);
            case u.TypeKind.INTERFACE:
              return buildInterfaceDef(e);
            case u.TypeKind.UNION:
              return buildUnionDef(e);
            case u.TypeKind.ENUM:
              return buildEnumDef(e);
            case u.TypeKind.INPUT_OBJECT:
              return buildInputObjectDef(e);
          }
        }
        const t = (0, o.inspect)(e);
        throw new Error(`Invalid or incomplete introspection result. Ensure that a full introspection query is used in order to build a client schema: ${t}.`);
      }
      function buildScalarDef(e) {
        return new A.GraphQLScalarType({ name: e.name, description: e.description, specifiedByURL: e.specifiedByURL });
      }
      function buildImplementationsList(e) {
        if (e.interfaces === null && e.kind === u.TypeKind.INTERFACE) {
          return [];
        }
        if (!e.interfaces) {
          const t = (0, o.inspect)(e);
          throw new Error(`Introspection result missing interfaces: ${t}.`);
        }
        return e.interfaces.map(getInterfaceType);
      }
      function buildObjectDef(e) {
        return new A.GraphQLObjectType({
          name: e.name,
          description: e.description,
          interfaces: () => buildImplementationsList(e),
          fields: () => buildFieldDefMap(e),
        });
      }
      function buildInterfaceDef(e) {
        return new A.GraphQLInterfaceType({
          name: e.name,
          description: e.description,
          interfaces: () => buildImplementationsList(e),
          fields: () => buildFieldDefMap(e),
        });
      }
      function buildUnionDef(e) {
        if (!e.possibleTypes) {
          const t = (0, o.inspect)(e);
          throw new Error(`Introspection result missing possibleTypes: ${t}.`);
        }
        return new A.GraphQLUnionType({ name: e.name, description: e.description, types: () => e.possibleTypes.map(getObjectType) });
      }
      function buildEnumDef(e) {
        if (!e.enumValues) {
          const t = (0, o.inspect)(e);
          throw new Error(`Introspection result missing enumValues: ${t}.`);
        }
        return new A.GraphQLEnumType({
          name: e.name,
          description: e.description,
          values: (0, i.keyValMap)(
            e.enumValues,
            (e) => e.name,
            (e) => ({ description: e.description, deprecationReason: e.deprecationReason })
          ),
        });
      }
      function buildInputObjectDef(e) {
        if (!e.inputFields) {
          const t = (0, o.inspect)(e);
          throw new Error(`Introspection result missing inputFields: ${t}.`);
        }
        return new A.GraphQLInputObjectType({
          name: e.name,
          description: e.description,
          fields: () => buildInputValueDefMap(e.inputFields),
          isOneOf: e.isOneOf,
        });
      }
      function buildFieldDefMap(e) {
        if (!e.fields) {
          throw new Error(`Introspection result missing fields: ${(0, o.inspect)(e)}.`);
        }
        return (0, i.keyValMap)(e.fields, (e) => e.name, buildField);
      }
      function buildField(e) {
        const t = getType(e.type);
        if (!(0, A.isOutputType)(t)) {
          const e = (0, o.inspect)(t);
          throw new Error(`Introspection must provide output type for fields, but received: ${e}.`);
        }
        if (!e.args) {
          const t = (0, o.inspect)(e);
          throw new Error(`Introspection result missing field args: ${t}.`);
        }
        return { description: e.description, deprecationReason: e.deprecationReason, type: t, args: buildInputValueDefMap(e.args) };
      }
      function buildInputValueDefMap(e) {
        return (0, i.keyValMap)(e, (e) => e.name, buildInputValue);
      }
      function buildInputValue(e) {
        const t = getType(e.type);
        if (!(0, A.isInputType)(t)) {
          const e = (0, o.inspect)(t);
          throw new Error(`Introspection must provide input type for arguments, but received: ${e}.`);
        }
        const r = e.defaultValue != null ? (0, d.valueFromAST)((0, a.parseValue)(e.defaultValue), t) : undefined;
        return { description: e.description, type: t, defaultValue: r, deprecationReason: e.deprecationReason };
      }
      function buildDirective(e) {
        if (!e.args) {
          const t = (0, o.inspect)(e);
          throw new Error(`Introspection result missing directive args: ${t}.`);
        }
        if (!e.locations) {
          const t = (0, o.inspect)(e);
          throw new Error(`Introspection result missing directive locations: ${t}.`);
        }
        return new c.GraphQLDirective({
          name: e.name,
          description: e.description,
          isRepeatable: e.isRepeatable,
          locations: e.locations.slice(),
          args: buildInputValueDefMap(e.args),
        });
      }
    }
  },
  39837: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.coerceInputValue = coerceInputValue;
    var n = r(62384);
    var o = r(71801);
    var s = r(67305);
    var i = r(12916);
    var a = r(84849);
    var A = r(42090);
    var c = r(81292);
    var u = r(18765);
    var l = r(23750);
    var p = r(46250);
    function coerceInputValue(e, t, r = defaultOnError) {
      return coerceInputValueImpl(e, t, r, undefined);
    }
    function defaultOnError(e, t, r) {
      let n = "Invalid value " + (0, o.inspect)(t);
      if (e.length > 0) {
        n += ` at "value${(0, c.printPathArray)(e)}"`;
      }
      r.message = n + ": " + r.message;
      throw r;
    }
    function coerceInputValueImpl(e, t, r, c) {
      if ((0, p.isNonNullType)(t)) {
        if (e != null) {
          return coerceInputValueImpl(e, t.ofType, r, c);
        }
        r((0, A.pathToArray)(c), e, new l.GraphQLError(`Expected non-nullable type "${(0, o.inspect)(t)}" not to be null.`));
        return;
      }
      if (e == null) {
        return null;
      }
      if ((0, p.isListType)(t)) {
        const n = t.ofType;
        if ((0, i.isIterableObject)(e)) {
          return Array.from(e, (e, t) => {
            const o = (0, A.addPath)(c, t, undefined);
            return coerceInputValueImpl(e, n, r, o);
          });
        }
        return [coerceInputValueImpl(e, n, r, c)];
      }
      if ((0, p.isInputObjectType)(t)) {
        if (!(0, a.isObjectLike)(e)) {
          r((0, A.pathToArray)(c), e, new l.GraphQLError(`Expected type "${t.name}" to be an object.`));
          return;
        }
        const s = {};
        const i = t.getFields();
        for (const n of Object.values(i)) {
          const i = e[n.name];
          if (i === undefined) {
            if (n.defaultValue !== undefined) {
              s[n.name] = n.defaultValue;
            } else if ((0, p.isNonNullType)(n.type)) {
              const t = (0, o.inspect)(n.type);
              r((0, A.pathToArray)(c), e, new l.GraphQLError(`Field "${n.name}" of required type "${t}" was not provided.`));
            }
            continue;
          }
          s[n.name] = coerceInputValueImpl(i, n.type, r, (0, A.addPath)(c, n.name, t.name));
        }
        for (const o of Object.keys(e)) {
          if (!i[o]) {
            const s = (0, u.suggestionList)(o, Object.keys(t.getFields()));
            r((0, A.pathToArray)(c), e, new l.GraphQLError(`Field "${o}" is not defined by type "${t.name}".` + (0, n.didYouMean)(s)));
          }
        }
        if (t.isOneOf) {
          const n = Object.keys(s);
          if (n.length !== 1) {
            r((0, A.pathToArray)(c), e, new l.GraphQLError(`Exactly one key must be specified for OneOf type "${t.name}".`));
          }
          const o = n[0];
          const i = s[o];
          if (i === null) {
            r((0, A.pathToArray)(c).concat(o), i, new l.GraphQLError(`Field "${o}" must be non-null.`));
          }
        }
        return s;
      }
      if ((0, p.isLeafType)(t)) {
        let n;
        try {
          n = t.parseValue(e);
        } catch (n) {
          if (n instanceof l.GraphQLError) {
            r((0, A.pathToArray)(c), e, n);
          } else {
            r((0, A.pathToArray)(c), e, new l.GraphQLError(`Expected type "${t.name}". ` + n.message, { originalError: n }));
          }
          return;
        }
        if (n === undefined) {
          r((0, A.pathToArray)(c), e, new l.GraphQLError(`Expected type "${t.name}".`));
        }
        return n;
      }
      false || (0, s.invariant)(false, "Unexpected input type: " + (0, o.inspect)(t));
    }
  },
  69641: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.concatAST = concatAST;
    var n = r(19254);
    function concatAST(e) {
      const t = [];
      for (const r of e) {
        t.push(...r.definitions);
      }
      return { kind: n.Kind.DOCUMENT, definitions: t };
    }
  },
  30690: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.extendSchema = extendSchema;
    t.extendSchemaImpl = extendSchemaImpl;
    var n = r(53284);
    var o = r(71801);
    var s = r(67305);
    var i = r(97982);
    var a = r(73830);
    var A = r(19254);
    var c = r(24147);
    var u = r(46250);
    var l = r(58941);
    var p = r(47564);
    var d = r(83894);
    var g = r(71672);
    var m = r(90592);
    var h = r(2657);
    var E = r(36302);
    function extendSchema(e, t, r) {
      (0, g.assertSchema)(e);
      (t != null && t.kind === A.Kind.DOCUMENT) || (0, n.devAssert)(false, "Must provide valid Document AST.");
      if ((r === null || r === void 0 ? void 0 : r.assumeValid) !== true && (r === null || r === void 0 ? void 0 : r.assumeValidSDL) !== true) {
        (0, m.assertValidSDLExtension)(t, e);
      }
      const o = e.toConfig();
      const s = extendSchemaImpl(o, t, r);
      return o === s ? e : new g.GraphQLSchema(s);
    }
    function extendSchemaImpl(e, t, r) {
      var n, i, g, m;
      const h = [];
      const y = Object.create(null);
      const C = [];
      let b;
      const Q = [];
      for (const e of t.definitions) {
        if (e.kind === A.Kind.SCHEMA_DEFINITION) {
          b = e;
        } else if (e.kind === A.Kind.SCHEMA_EXTENSION) {
          Q.push(e);
        } else if ((0, c.isTypeDefinitionNode)(e)) {
          h.push(e);
        } else if ((0, c.isTypeExtensionNode)(e)) {
          const t = e.name.value;
          const r = y[t];
          y[t] = r ? r.concat([e]) : [e];
        } else if (e.kind === A.Kind.DIRECTIVE_DEFINITION) {
          C.push(e);
        }
      }
      if (Object.keys(y).length === 0 && h.length === 0 && C.length === 0 && Q.length === 0 && b == null) {
        return e;
      }
      const B = Object.create(null);
      for (const t of e.types) {
        B[t.name] = extendNamedType(t);
      }
      for (const e of h) {
        var T;
        const t = e.name.value;
        B[t] = (T = I[t]) !== null && T !== void 0 ? T : buildType(e);
      }
      const v = {
        query: e.query && replaceNamedType(e.query),
        mutation: e.mutation && replaceNamedType(e.mutation),
        subscription: e.subscription && replaceNamedType(e.subscription),
        ...(b && getOperationTypes([b])),
        ...getOperationTypes(Q),
      };
      return {
        description: (n = b) === null || n === void 0 ? void 0 : (i = n.description) === null || i === void 0 ? void 0 : i.value,
        ...v,
        types: Object.values(B),
        directives: [...e.directives.map(replaceDirective), ...C.map(buildDirective)],
        extensions: Object.create(null),
        astNode: (g = b) !== null && g !== void 0 ? g : e.astNode,
        extensionASTNodes: e.extensionASTNodes.concat(Q),
        assumeValid: (m = r === null || r === void 0 ? void 0 : r.assumeValid) !== null && m !== void 0 ? m : false,
      };
      function replaceType(e) {
        if ((0, u.isListType)(e)) {
          return new u.GraphQLList(replaceType(e.ofType));
        }
        if ((0, u.isNonNullType)(e)) {
          return new u.GraphQLNonNull(replaceType(e.ofType));
        }
        return replaceNamedType(e);
      }
      function replaceNamedType(e) {
        return B[e.name];
      }
      function replaceDirective(e) {
        const t = e.toConfig();
        return new l.GraphQLDirective({ ...t, args: (0, a.mapValue)(t.args, extendArg) });
      }
      function extendNamedType(e) {
        if ((0, p.isIntrospectionType)(e) || (0, d.isSpecifiedScalarType)(e)) {
          return e;
        }
        if ((0, u.isScalarType)(e)) {
          return extendScalarType(e);
        }
        if ((0, u.isObjectType)(e)) {
          return extendObjectType(e);
        }
        if ((0, u.isInterfaceType)(e)) {
          return extendInterfaceType(e);
        }
        if ((0, u.isUnionType)(e)) {
          return extendUnionType(e);
        }
        if ((0, u.isEnumType)(e)) {
          return extendEnumType(e);
        }
        if ((0, u.isInputObjectType)(e)) {
          return extendInputObjectType(e);
        }
        false || (0, s.invariant)(false, "Unexpected type: " + (0, o.inspect)(e));
      }
      function extendInputObjectType(e) {
        var t;
        const r = e.toConfig();
        const n = (t = y[r.name]) !== null && t !== void 0 ? t : [];
        return new u.GraphQLInputObjectType({
          ...r,
          fields: () => ({ ...(0, a.mapValue)(r.fields, (e) => ({ ...e, type: replaceType(e.type) })), ...buildInputFieldMap(n) }),
          extensionASTNodes: r.extensionASTNodes.concat(n),
        });
      }
      function extendEnumType(e) {
        var t;
        const r = e.toConfig();
        const n = (t = y[e.name]) !== null && t !== void 0 ? t : [];
        return new u.GraphQLEnumType({ ...r, values: { ...r.values, ...buildEnumValueMap(n) }, extensionASTNodes: r.extensionASTNodes.concat(n) });
      }
      function extendScalarType(e) {
        var t;
        const r = e.toConfig();
        const n = (t = y[r.name]) !== null && t !== void 0 ? t : [];
        let o = r.specifiedByURL;
        for (const e of n) {
          var s;
          o = (s = getSpecifiedByURL(e)) !== null && s !== void 0 ? s : o;
        }
        return new u.GraphQLScalarType({ ...r, specifiedByURL: o, extensionASTNodes: r.extensionASTNodes.concat(n) });
      }
      function extendObjectType(e) {
        var t;
        const r = e.toConfig();
        const n = (t = y[r.name]) !== null && t !== void 0 ? t : [];
        return new u.GraphQLObjectType({
          ...r,
          interfaces: () => [...e.getInterfaces().map(replaceNamedType), ...buildInterfaces(n)],
          fields: () => ({ ...(0, a.mapValue)(r.fields, extendField), ...buildFieldMap(n) }),
          extensionASTNodes: r.extensionASTNodes.concat(n),
        });
      }
      function extendInterfaceType(e) {
        var t;
        const r = e.toConfig();
        const n = (t = y[r.name]) !== null && t !== void 0 ? t : [];
        return new u.GraphQLInterfaceType({
          ...r,
          interfaces: () => [...e.getInterfaces().map(replaceNamedType), ...buildInterfaces(n)],
          fields: () => ({ ...(0, a.mapValue)(r.fields, extendField), ...buildFieldMap(n) }),
          extensionASTNodes: r.extensionASTNodes.concat(n),
        });
      }
      function extendUnionType(e) {
        var t;
        const r = e.toConfig();
        const n = (t = y[r.name]) !== null && t !== void 0 ? t : [];
        return new u.GraphQLUnionType({
          ...r,
          types: () => [...e.getTypes().map(replaceNamedType), ...buildUnionTypes(n)],
          extensionASTNodes: r.extensionASTNodes.concat(n),
        });
      }
      function extendField(e) {
        return { ...e, type: replaceType(e.type), args: e.args && (0, a.mapValue)(e.args, extendArg) };
      }
      function extendArg(e) {
        return { ...e, type: replaceType(e.type) };
      }
      function getOperationTypes(e) {
        const t = {};
        for (const n of e) {
          var r;
          const e = (r = n.operationTypes) !== null && r !== void 0 ? r : [];
          for (const r of e) {
            t[r.operation] = getNamedType(r.type);
          }
        }
        return t;
      }
      function getNamedType(e) {
        var t;
        const r = e.name.value;
        const n = (t = I[r]) !== null && t !== void 0 ? t : B[r];
        if (n === undefined) {
          throw new Error(`Unknown type: "${r}".`);
        }
        return n;
      }
      function getWrappedType(e) {
        if (e.kind === A.Kind.LIST_TYPE) {
          return new u.GraphQLList(getWrappedType(e.type));
        }
        if (e.kind === A.Kind.NON_NULL_TYPE) {
          return new u.GraphQLNonNull(getWrappedType(e.type));
        }
        return getNamedType(e);
      }
      function buildDirective(e) {
        var t;
        return new l.GraphQLDirective({
          name: e.name.value,
          description: (t = e.description) === null || t === void 0 ? void 0 : t.value,
          locations: e.locations.map(({ value: e }) => e),
          isRepeatable: e.repeatable,
          args: buildArgumentMap(e.arguments),
          astNode: e,
        });
      }
      function buildFieldMap(e) {
        const t = Object.create(null);
        for (const o of e) {
          var r;
          const e = (r = o.fields) !== null && r !== void 0 ? r : [];
          for (const r of e) {
            var n;
            t[r.name.value] = {
              type: getWrappedType(r.type),
              description: (n = r.description) === null || n === void 0 ? void 0 : n.value,
              args: buildArgumentMap(r.arguments),
              deprecationReason: getDeprecationReason(r),
              astNode: r,
            };
          }
        }
        return t;
      }
      function buildArgumentMap(e) {
        const t = e !== null && e !== void 0 ? e : [];
        const r = Object.create(null);
        for (const e of t) {
          var n;
          const t = getWrappedType(e.type);
          r[e.name.value] = {
            type: t,
            description: (n = e.description) === null || n === void 0 ? void 0 : n.value,
            defaultValue: (0, E.valueFromAST)(e.defaultValue, t),
            deprecationReason: getDeprecationReason(e),
            astNode: e,
          };
        }
        return r;
      }
      function buildInputFieldMap(e) {
        const t = Object.create(null);
        for (const o of e) {
          var r;
          const e = (r = o.fields) !== null && r !== void 0 ? r : [];
          for (const r of e) {
            var n;
            const e = getWrappedType(r.type);
            t[r.name.value] = {
              type: e,
              description: (n = r.description) === null || n === void 0 ? void 0 : n.value,
              defaultValue: (0, E.valueFromAST)(r.defaultValue, e),
              deprecationReason: getDeprecationReason(r),
              astNode: r,
            };
          }
        }
        return t;
      }
      function buildEnumValueMap(e) {
        const t = Object.create(null);
        for (const o of e) {
          var r;
          const e = (r = o.values) !== null && r !== void 0 ? r : [];
          for (const r of e) {
            var n;
            t[r.name.value] = {
              description: (n = r.description) === null || n === void 0 ? void 0 : n.value,
              deprecationReason: getDeprecationReason(r),
              astNode: r,
            };
          }
        }
        return t;
      }
      function buildInterfaces(e) {
        return e.flatMap((e) => {
          var t, r;
          return (t = (r = e.interfaces) === null || r === void 0 ? void 0 : r.map(getNamedType)) !== null && t !== void 0 ? t : [];
        });
      }
      function buildUnionTypes(e) {
        return e.flatMap((e) => {
          var t, r;
          return (t = (r = e.types) === null || r === void 0 ? void 0 : r.map(getNamedType)) !== null && t !== void 0 ? t : [];
        });
      }
      function buildType(e) {
        var t;
        const r = e.name.value;
        const n = (t = y[r]) !== null && t !== void 0 ? t : [];
        switch (e.kind) {
          case A.Kind.OBJECT_TYPE_DEFINITION: {
            var o;
            const t = [e, ...n];
            return new u.GraphQLObjectType({
              name: r,
              description: (o = e.description) === null || o === void 0 ? void 0 : o.value,
              interfaces: () => buildInterfaces(t),
              fields: () => buildFieldMap(t),
              astNode: e,
              extensionASTNodes: n,
            });
          }
          case A.Kind.INTERFACE_TYPE_DEFINITION: {
            var s;
            const t = [e, ...n];
            return new u.GraphQLInterfaceType({
              name: r,
              description: (s = e.description) === null || s === void 0 ? void 0 : s.value,
              interfaces: () => buildInterfaces(t),
              fields: () => buildFieldMap(t),
              astNode: e,
              extensionASTNodes: n,
            });
          }
          case A.Kind.ENUM_TYPE_DEFINITION: {
            var i;
            const t = [e, ...n];
            return new u.GraphQLEnumType({
              name: r,
              description: (i = e.description) === null || i === void 0 ? void 0 : i.value,
              values: buildEnumValueMap(t),
              astNode: e,
              extensionASTNodes: n,
            });
          }
          case A.Kind.UNION_TYPE_DEFINITION: {
            var a;
            const t = [e, ...n];
            return new u.GraphQLUnionType({
              name: r,
              description: (a = e.description) === null || a === void 0 ? void 0 : a.value,
              types: () => buildUnionTypes(t),
              astNode: e,
              extensionASTNodes: n,
            });
          }
          case A.Kind.SCALAR_TYPE_DEFINITION: {
            var c;
            return new u.GraphQLScalarType({
              name: r,
              description: (c = e.description) === null || c === void 0 ? void 0 : c.value,
              specifiedByURL: getSpecifiedByURL(e),
              astNode: e,
              extensionASTNodes: n,
            });
          }
          case A.Kind.INPUT_OBJECT_TYPE_DEFINITION: {
            var l;
            const t = [e, ...n];
            return new u.GraphQLInputObjectType({
              name: r,
              description: (l = e.description) === null || l === void 0 ? void 0 : l.value,
              fields: () => buildInputFieldMap(t),
              astNode: e,
              extensionASTNodes: n,
              isOneOf: isOneOf(e),
            });
          }
        }
      }
    }
    const I = (0, i.keyMap)([...d.specifiedScalarTypes, ...p.introspectionTypes], (e) => e.name);
    function getDeprecationReason(e) {
      const t = (0, h.getDirectiveValues)(l.GraphQLDeprecatedDirective, e);
      return t === null || t === void 0 ? void 0 : t.reason;
    }
    function getSpecifiedByURL(e) {
      const t = (0, h.getDirectiveValues)(l.GraphQLSpecifiedByDirective, e);
      return t === null || t === void 0 ? void 0 : t.url;
    }
    function isOneOf(e) {
      return Boolean((0, h.getDirectiveValues)(l.GraphQLOneOfDirective, e));
    }
  },
  41058: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.DangerousChangeType = t.BreakingChangeType = void 0;
    t.findBreakingChanges = findBreakingChanges;
    t.findDangerousChanges = findDangerousChanges;
    var n = r(71801);
    var o = r(67305);
    var s = r(97982);
    var i = r(85401);
    var a = r(46250);
    var A = r(83894);
    var c = r(97520);
    var u = r(47440);
    var l;
    t.BreakingChangeType = l;
    (function (e) {
      e["TYPE_REMOVED"] = "TYPE_REMOVED";
      e["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
      e["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
      e["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
      e["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
      e["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
      e["FIELD_REMOVED"] = "FIELD_REMOVED";
      e["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
      e["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
      e["ARG_REMOVED"] = "ARG_REMOVED";
      e["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
      e["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
      e["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
      e["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
      e["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
      e["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
    })(l || (t.BreakingChangeType = l = {}));
    var p;
    t.DangerousChangeType = p;
    (function (e) {
      e["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
      e["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
      e["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
      e["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
      e["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
      e["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
    })(p || (t.DangerousChangeType = p = {}));
    function findBreakingChanges(e, t) {
      return findSchemaChanges(e, t).filter((e) => e.type in l);
    }
    function findDangerousChanges(e, t) {
      return findSchemaChanges(e, t).filter((e) => e.type in p);
    }
    function findSchemaChanges(e, t) {
      return [...findTypeChanges(e, t), ...findDirectiveChanges(e, t)];
    }
    function findDirectiveChanges(e, t) {
      const r = [];
      const n = diff(e.getDirectives(), t.getDirectives());
      for (const e of n.removed) {
        r.push({ type: l.DIRECTIVE_REMOVED, description: `${e.name} was removed.` });
      }
      for (const [e, t] of n.persisted) {
        const n = diff(e.args, t.args);
        for (const t of n.added) {
          if ((0, a.isRequiredArgument)(t)) {
            r.push({ type: l.REQUIRED_DIRECTIVE_ARG_ADDED, description: `A required arg ${t.name} on directive ${e.name} was added.` });
          }
        }
        for (const t of n.removed) {
          r.push({ type: l.DIRECTIVE_ARG_REMOVED, description: `${t.name} was removed from ${e.name}.` });
        }
        if (e.isRepeatable && !t.isRepeatable) {
          r.push({ type: l.DIRECTIVE_REPEATABLE_REMOVED, description: `Repeatable flag was removed from ${e.name}.` });
        }
        for (const n of e.locations) {
          if (!t.locations.includes(n)) {
            r.push({ type: l.DIRECTIVE_LOCATION_REMOVED, description: `${n} was removed from ${e.name}.` });
          }
        }
      }
      return r;
    }
    function findTypeChanges(e, t) {
      const r = [];
      const n = diff(Object.values(e.getTypeMap()), Object.values(t.getTypeMap()));
      for (const e of n.removed) {
        r.push({
          type: l.TYPE_REMOVED,
          description: (0, A.isSpecifiedScalarType)(e)
            ? `Standard scalar ${e.name} was removed because it is not referenced anymore.`
            : `${e.name} was removed.`,
        });
      }
      for (const [e, t] of n.persisted) {
        if ((0, a.isEnumType)(e) && (0, a.isEnumType)(t)) {
          r.push(...findEnumTypeChanges(e, t));
        } else if ((0, a.isUnionType)(e) && (0, a.isUnionType)(t)) {
          r.push(...findUnionTypeChanges(e, t));
        } else if ((0, a.isInputObjectType)(e) && (0, a.isInputObjectType)(t)) {
          r.push(...findInputObjectTypeChanges(e, t));
        } else if ((0, a.isObjectType)(e) && (0, a.isObjectType)(t)) {
          r.push(...findFieldChanges(e, t), ...findImplementedInterfacesChanges(e, t));
        } else if ((0, a.isInterfaceType)(e) && (0, a.isInterfaceType)(t)) {
          r.push(...findFieldChanges(e, t), ...findImplementedInterfacesChanges(e, t));
        } else if (e.constructor !== t.constructor) {
          r.push({ type: l.TYPE_CHANGED_KIND, description: `${e.name} changed from ` + `${typeKindName(e)} to ${typeKindName(t)}.` });
        }
      }
      return r;
    }
    function findInputObjectTypeChanges(e, t) {
      const r = [];
      const n = diff(Object.values(e.getFields()), Object.values(t.getFields()));
      for (const t of n.added) {
        if ((0, a.isRequiredInputField)(t)) {
          r.push({ type: l.REQUIRED_INPUT_FIELD_ADDED, description: `A required field ${t.name} on input type ${e.name} was added.` });
        } else {
          r.push({ type: p.OPTIONAL_INPUT_FIELD_ADDED, description: `An optional field ${t.name} on input type ${e.name} was added.` });
        }
      }
      for (const t of n.removed) {
        r.push({ type: l.FIELD_REMOVED, description: `${e.name}.${t.name} was removed.` });
      }
      for (const [t, o] of n.persisted) {
        const n = isChangeSafeForInputObjectFieldOrFieldArg(t.type, o.type);
        if (!n) {
          r.push({ type: l.FIELD_CHANGED_KIND, description: `${e.name}.${t.name} changed type from ` + `${String(t.type)} to ${String(o.type)}.` });
        }
      }
      return r;
    }
    function findUnionTypeChanges(e, t) {
      const r = [];
      const n = diff(e.getTypes(), t.getTypes());
      for (const t of n.added) {
        r.push({ type: p.TYPE_ADDED_TO_UNION, description: `${t.name} was added to union type ${e.name}.` });
      }
      for (const t of n.removed) {
        r.push({ type: l.TYPE_REMOVED_FROM_UNION, description: `${t.name} was removed from union type ${e.name}.` });
      }
      return r;
    }
    function findEnumTypeChanges(e, t) {
      const r = [];
      const n = diff(e.getValues(), t.getValues());
      for (const t of n.added) {
        r.push({ type: p.VALUE_ADDED_TO_ENUM, description: `${t.name} was added to enum type ${e.name}.` });
      }
      for (const t of n.removed) {
        r.push({ type: l.VALUE_REMOVED_FROM_ENUM, description: `${t.name} was removed from enum type ${e.name}.` });
      }
      return r;
    }
    function findImplementedInterfacesChanges(e, t) {
      const r = [];
      const n = diff(e.getInterfaces(), t.getInterfaces());
      for (const t of n.added) {
        r.push({ type: p.IMPLEMENTED_INTERFACE_ADDED, description: `${t.name} added to interfaces implemented by ${e.name}.` });
      }
      for (const t of n.removed) {
        r.push({ type: l.IMPLEMENTED_INTERFACE_REMOVED, description: `${e.name} no longer implements interface ${t.name}.` });
      }
      return r;
    }
    function findFieldChanges(e, t) {
      const r = [];
      const n = diff(Object.values(e.getFields()), Object.values(t.getFields()));
      for (const t of n.removed) {
        r.push({ type: l.FIELD_REMOVED, description: `${e.name}.${t.name} was removed.` });
      }
      for (const [t, o] of n.persisted) {
        r.push(...findArgChanges(e, t, o));
        const n = isChangeSafeForObjectOrInterfaceField(t.type, o.type);
        if (!n) {
          r.push({ type: l.FIELD_CHANGED_KIND, description: `${e.name}.${t.name} changed type from ` + `${String(t.type)} to ${String(o.type)}.` });
        }
      }
      return r;
    }
    function findArgChanges(e, t, r) {
      const n = [];
      const o = diff(t.args, r.args);
      for (const r of o.removed) {
        n.push({ type: l.ARG_REMOVED, description: `${e.name}.${t.name} arg ${r.name} was removed.` });
      }
      for (const [r, s] of o.persisted) {
        const o = isChangeSafeForInputObjectFieldOrFieldArg(r.type, s.type);
        if (!o) {
          n.push({
            type: l.ARG_CHANGED_KIND,
            description: `${e.name}.${t.name} arg ${r.name} has changed type from ` + `${String(r.type)} to ${String(s.type)}.`,
          });
        } else if (r.defaultValue !== undefined) {
          if (s.defaultValue === undefined) {
            n.push({ type: p.ARG_DEFAULT_VALUE_CHANGE, description: `${e.name}.${t.name} arg ${r.name} defaultValue was removed.` });
          } else {
            const o = stringifyValue(r.defaultValue, r.type);
            const i = stringifyValue(s.defaultValue, s.type);
            if (o !== i) {
              n.push({ type: p.ARG_DEFAULT_VALUE_CHANGE, description: `${e.name}.${t.name} arg ${r.name} has changed defaultValue from ${o} to ${i}.` });
            }
          }
        }
      }
      for (const r of o.added) {
        if ((0, a.isRequiredArgument)(r)) {
          n.push({ type: l.REQUIRED_ARG_ADDED, description: `A required arg ${r.name} on ${e.name}.${t.name} was added.` });
        } else {
          n.push({ type: p.OPTIONAL_ARG_ADDED, description: `An optional arg ${r.name} on ${e.name}.${t.name} was added.` });
        }
      }
      return n;
    }
    function isChangeSafeForObjectOrInterfaceField(e, t) {
      if ((0, a.isListType)(e)) {
        return (
          ((0, a.isListType)(t) && isChangeSafeForObjectOrInterfaceField(e.ofType, t.ofType)) ||
          ((0, a.isNonNullType)(t) && isChangeSafeForObjectOrInterfaceField(e, t.ofType))
        );
      }
      if ((0, a.isNonNullType)(e)) {
        return (0, a.isNonNullType)(t) && isChangeSafeForObjectOrInterfaceField(e.ofType, t.ofType);
      }
      return ((0, a.isNamedType)(t) && e.name === t.name) || ((0, a.isNonNullType)(t) && isChangeSafeForObjectOrInterfaceField(e, t.ofType));
    }
    function isChangeSafeForInputObjectFieldOrFieldArg(e, t) {
      if ((0, a.isListType)(e)) {
        return (0, a.isListType)(t) && isChangeSafeForInputObjectFieldOrFieldArg(e.ofType, t.ofType);
      }
      if ((0, a.isNonNullType)(e)) {
        return (
          ((0, a.isNonNullType)(t) && isChangeSafeForInputObjectFieldOrFieldArg(e.ofType, t.ofType)) ||
          (!(0, a.isNonNullType)(t) && isChangeSafeForInputObjectFieldOrFieldArg(e.ofType, t))
        );
      }
      return (0, a.isNamedType)(t) && e.name === t.name;
    }
    function typeKindName(e) {
      if ((0, a.isScalarType)(e)) {
        return "a Scalar type";
      }
      if ((0, a.isObjectType)(e)) {
        return "an Object type";
      }
      if ((0, a.isInterfaceType)(e)) {
        return "an Interface type";
      }
      if ((0, a.isUnionType)(e)) {
        return "a Union type";
      }
      if ((0, a.isEnumType)(e)) {
        return "an Enum type";
      }
      if ((0, a.isInputObjectType)(e)) {
        return "an Input type";
      }
      false || (0, o.invariant)(false, "Unexpected type: " + (0, n.inspect)(e));
    }
    function stringifyValue(e, t) {
      const r = (0, c.astFromValue)(e, t);
      r != null || (0, o.invariant)(false);
      return (0, i.print)((0, u.sortValueNode)(r));
    }
    function diff(e, t) {
      const r = [];
      const n = [];
      const o = [];
      const i = (0, s.keyMap)(e, ({ name: e }) => e);
      const a = (0, s.keyMap)(t, ({ name: e }) => e);
      for (const t of e) {
        const e = a[t.name];
        if (e === undefined) {
          n.push(t);
        } else {
          o.push([t, e]);
        }
      }
      for (const e of t) {
        if (i[e.name] === undefined) {
          r.push(e);
        }
      }
      return { added: r, persisted: o, removed: n };
    }
  },
  40752: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.getIntrospectionQuery = getIntrospectionQuery;
    function getIntrospectionQuery(e) {
      const t = {
        descriptions: true,
        specifiedByUrl: false,
        directiveIsRepeatable: false,
        schemaDescription: false,
        inputValueDeprecation: false,
        oneOf: false,
        ...e,
      };
      const r = t.descriptions ? "description" : "";
      const n = t.specifiedByUrl ? "specifiedByURL" : "";
      const o = t.directiveIsRepeatable ? "isRepeatable" : "";
      const s = t.schemaDescription ? r : "";
      function inputDeprecation(e) {
        return t.inputValueDeprecation ? e : "";
      }
      const i = t.oneOf ? "isOneOf" : "";
      return `\n    query IntrospectionQuery {\n      __schema {\n        ${s}\n        queryType { name }\n        mutationType { name }\n        subscriptionType { name }\n        types {\n          ...FullType\n        }\n        directives {\n          name\n          ${r}\n          ${o}\n          locations\n          args${inputDeprecation("(includeDeprecated: true)")} {\n            ...InputValue\n          }\n        }\n      }\n    }\n\n    fragment FullType on __Type {\n      kind\n      name\n      ${r}\n      ${n}\n      ${i}\n      fields(includeDeprecated: true) {\n        name\n        ${r}\n        args${inputDeprecation("(includeDeprecated: true)")} {\n          ...InputValue\n        }\n        type {\n          ...TypeRef\n        }\n        isDeprecated\n        deprecationReason\n      }\n      inputFields${inputDeprecation("(includeDeprecated: true)")} {\n        ...InputValue\n      }\n      interfaces {\n        ...TypeRef\n      }\n      enumValues(includeDeprecated: true) {\n        name\n        ${r}\n        isDeprecated\n        deprecationReason\n      }\n      possibleTypes {\n        ...TypeRef\n      }\n    }\n\n    fragment InputValue on __InputValue {\n      name\n      ${r}\n      type { ...TypeRef }\n      defaultValue\n      ${inputDeprecation("isDeprecated")}\n      ${inputDeprecation("deprecationReason")}\n    }\n\n    fragment TypeRef on __Type {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n              ofType {\n                kind\n                name\n                ofType {\n                  kind\n                  name\n                  ofType {\n                    kind\n                    name\n                    ofType {\n                      kind\n                      name\n                      ofType {\n                        kind\n                        name\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  `;
    }
  },
  60882: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.getOperationAST = getOperationAST;
    var n = r(19254);
    function getOperationAST(e, t) {
      let r = null;
      for (const s of e.definitions) {
        if (s.kind === n.Kind.OPERATION_DEFINITION) {
          var o;
          if (t == null) {
            if (r) {
              return null;
            }
            r = s;
          } else if (((o = s.name) === null || o === void 0 ? void 0 : o.value) === t) {
            return s;
          }
        }
      }
      return r;
    }
  },
  73652: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.getOperationRootType = getOperationRootType;
    var n = r(23750);
    function getOperationRootType(e, t) {
      if (t.operation === "query") {
        const r = e.getQueryType();
        if (!r) {
          throw new n.GraphQLError("Schema does not define the required query root type.", { nodes: t });
        }
        return r;
      }
      if (t.operation === "mutation") {
        const r = e.getMutationType();
        if (!r) {
          throw new n.GraphQLError("Schema is not configured for mutations.", { nodes: t });
        }
        return r;
      }
      if (t.operation === "subscription") {
        const r = e.getSubscriptionType();
        if (!r) {
          throw new n.GraphQLError("Schema is not configured for subscriptions.", { nodes: t });
        }
        return r;
      }
      throw new n.GraphQLError("Can only have query, mutation and subscription operations.", { nodes: t });
    }
  },
  32729: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    Object.defineProperty(t, "BreakingChangeType", {
      enumerable: true,
      get: function () {
        return B.BreakingChangeType;
      },
    });
    Object.defineProperty(t, "DangerousChangeType", {
      enumerable: true,
      get: function () {
        return B.DangerousChangeType;
      },
    });
    Object.defineProperty(t, "TypeInfo", {
      enumerable: true,
      get: function () {
        return h.TypeInfo;
      },
    });
    Object.defineProperty(t, "assertValidName", {
      enumerable: true,
      get: function () {
        return Q.assertValidName;
      },
    });
    Object.defineProperty(t, "astFromValue", {
      enumerable: true,
      get: function () {
        return m.astFromValue;
      },
    });
    Object.defineProperty(t, "buildASTSchema", {
      enumerable: true,
      get: function () {
        return A.buildASTSchema;
      },
    });
    Object.defineProperty(t, "buildClientSchema", {
      enumerable: true,
      get: function () {
        return a.buildClientSchema;
      },
    });
    Object.defineProperty(t, "buildSchema", {
      enumerable: true,
      get: function () {
        return A.buildSchema;
      },
    });
    Object.defineProperty(t, "coerceInputValue", {
      enumerable: true,
      get: function () {
        return E.coerceInputValue;
      },
    });
    Object.defineProperty(t, "concatAST", {
      enumerable: true,
      get: function () {
        return I.concatAST;
      },
    });
    Object.defineProperty(t, "doTypesOverlap", {
      enumerable: true,
      get: function () {
        return b.doTypesOverlap;
      },
    });
    Object.defineProperty(t, "extendSchema", {
      enumerable: true,
      get: function () {
        return c.extendSchema;
      },
    });
    Object.defineProperty(t, "findBreakingChanges", {
      enumerable: true,
      get: function () {
        return B.findBreakingChanges;
      },
    });
    Object.defineProperty(t, "findDangerousChanges", {
      enumerable: true,
      get: function () {
        return B.findDangerousChanges;
      },
    });
    Object.defineProperty(t, "getIntrospectionQuery", {
      enumerable: true,
      get: function () {
        return n.getIntrospectionQuery;
      },
    });
    Object.defineProperty(t, "getOperationAST", {
      enumerable: true,
      get: function () {
        return o.getOperationAST;
      },
    });
    Object.defineProperty(t, "getOperationRootType", {
      enumerable: true,
      get: function () {
        return s.getOperationRootType;
      },
    });
    Object.defineProperty(t, "introspectionFromSchema", {
      enumerable: true,
      get: function () {
        return i.introspectionFromSchema;
      },
    });
    Object.defineProperty(t, "isEqualType", {
      enumerable: true,
      get: function () {
        return b.isEqualType;
      },
    });
    Object.defineProperty(t, "isTypeSubTypeOf", {
      enumerable: true,
      get: function () {
        return b.isTypeSubTypeOf;
      },
    });
    Object.defineProperty(t, "isValidNameError", {
      enumerable: true,
      get: function () {
        return Q.isValidNameError;
      },
    });
    Object.defineProperty(t, "lexicographicSortSchema", {
      enumerable: true,
      get: function () {
        return u.lexicographicSortSchema;
      },
    });
    Object.defineProperty(t, "printIntrospectionSchema", {
      enumerable: true,
      get: function () {
        return l.printIntrospectionSchema;
      },
    });
    Object.defineProperty(t, "printSchema", {
      enumerable: true,
      get: function () {
        return l.printSchema;
      },
    });
    Object.defineProperty(t, "printType", {
      enumerable: true,
      get: function () {
        return l.printType;
      },
    });
    Object.defineProperty(t, "separateOperations", {
      enumerable: true,
      get: function () {
        return y.separateOperations;
      },
    });
    Object.defineProperty(t, "stripIgnoredCharacters", {
      enumerable: true,
      get: function () {
        return C.stripIgnoredCharacters;
      },
    });
    Object.defineProperty(t, "typeFromAST", {
      enumerable: true,
      get: function () {
        return p.typeFromAST;
      },
    });
    Object.defineProperty(t, "valueFromAST", {
      enumerable: true,
      get: function () {
        return d.valueFromAST;
      },
    });
    Object.defineProperty(t, "valueFromASTUntyped", {
      enumerable: true,
      get: function () {
        return g.valueFromASTUntyped;
      },
    });
    Object.defineProperty(t, "visitWithTypeInfo", {
      enumerable: true,
      get: function () {
        return h.visitWithTypeInfo;
      },
    });
    var n = r(40752);
    var o = r(60882);
    var s = r(73652);
    var i = r(88477);
    var a = r(48741);
    var A = r(82402);
    var c = r(30690);
    var u = r(61092);
    var l = r(22577);
    var p = r(45669);
    var d = r(36302);
    var g = r(8021);
    var m = r(97520);
    var h = r(71165);
    var E = r(39837);
    var I = r(69641);
    var y = r(5646);
    var C = r(64849);
    var b = r(48808);
    var Q = r(77226);
    var B = r(41058);
  },
  88477: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.introspectionFromSchema = introspectionFromSchema;
    var n = r(67305);
    var o = r(71878);
    var s = r(75964);
    var i = r(40752);
    function introspectionFromSchema(e, t) {
      const r = { specifiedByUrl: true, directiveIsRepeatable: true, schemaDescription: true, inputValueDeprecation: true, oneOf: true, ...t };
      const a = (0, o.parse)((0, i.getIntrospectionQuery)(r));
      const A = (0, s.executeSync)({ schema: e, document: a });
      (!A.errors && A.data) || (0, n.invariant)(false);
      return A.data;
    }
  },
  61092: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.lexicographicSortSchema = lexicographicSortSchema;
    var n = r(71801);
    var o = r(67305);
    var s = r(7897);
    var i = r(9585);
    var a = r(46250);
    var A = r(58941);
    var c = r(47564);
    var u = r(71672);
    function lexicographicSortSchema(e) {
      const t = e.toConfig();
      const r = (0, s.keyValMap)(sortByName(t.types), (e) => e.name, sortNamedType);
      return new u.GraphQLSchema({
        ...t,
        types: Object.values(r),
        directives: sortByName(t.directives).map(sortDirective),
        query: replaceMaybeType(t.query),
        mutation: replaceMaybeType(t.mutation),
        subscription: replaceMaybeType(t.subscription),
      });
      function replaceType(e) {
        if ((0, a.isListType)(e)) {
          return new a.GraphQLList(replaceType(e.ofType));
        } else if ((0, a.isNonNullType)(e)) {
          return new a.GraphQLNonNull(replaceType(e.ofType));
        }
        return replaceNamedType(e);
      }
      function replaceNamedType(e) {
        return r[e.name];
      }
      function replaceMaybeType(e) {
        return e && replaceNamedType(e);
      }
      function sortDirective(e) {
        const t = e.toConfig();
        return new A.GraphQLDirective({ ...t, locations: sortBy(t.locations, (e) => e), args: sortArgs(t.args) });
      }
      function sortArgs(e) {
        return sortObjMap(e, (e) => ({ ...e, type: replaceType(e.type) }));
      }
      function sortFields(e) {
        return sortObjMap(e, (e) => ({ ...e, type: replaceType(e.type), args: e.args && sortArgs(e.args) }));
      }
      function sortInputFields(e) {
        return sortObjMap(e, (e) => ({ ...e, type: replaceType(e.type) }));
      }
      function sortTypes(e) {
        return sortByName(e).map(replaceNamedType);
      }
      function sortNamedType(e) {
        if ((0, a.isScalarType)(e) || (0, c.isIntrospectionType)(e)) {
          return e;
        }
        if ((0, a.isObjectType)(e)) {
          const t = e.toConfig();
          return new a.GraphQLObjectType({ ...t, interfaces: () => sortTypes(t.interfaces), fields: () => sortFields(t.fields) });
        }
        if ((0, a.isInterfaceType)(e)) {
          const t = e.toConfig();
          return new a.GraphQLInterfaceType({ ...t, interfaces: () => sortTypes(t.interfaces), fields: () => sortFields(t.fields) });
        }
        if ((0, a.isUnionType)(e)) {
          const t = e.toConfig();
          return new a.GraphQLUnionType({ ...t, types: () => sortTypes(t.types) });
        }
        if ((0, a.isEnumType)(e)) {
          const t = e.toConfig();
          return new a.GraphQLEnumType({ ...t, values: sortObjMap(t.values, (e) => e) });
        }
        if ((0, a.isInputObjectType)(e)) {
          const t = e.toConfig();
          return new a.GraphQLInputObjectType({ ...t, fields: () => sortInputFields(t.fields) });
        }
        false || (0, o.invariant)(false, "Unexpected type: " + (0, n.inspect)(e));
      }
    }
    function sortObjMap(e, t) {
      const r = Object.create(null);
      for (const n of Object.keys(e).sort(i.naturalCompare)) {
        r[n] = t(e[n]);
      }
      return r;
    }
    function sortByName(e) {
      return sortBy(e, (e) => e.name);
    }
    function sortBy(e, t) {
      return e.slice().sort((e, r) => {
        const n = t(e);
        const o = t(r);
        return (0, i.naturalCompare)(n, o);
      });
    }
  },
  22577: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.printIntrospectionSchema = printIntrospectionSchema;
    t.printSchema = printSchema;
    t.printType = printType;
    var n = r(71801);
    var o = r(67305);
    var s = r(44077);
    var i = r(19254);
    var a = r(85401);
    var A = r(46250);
    var c = r(58941);
    var u = r(47564);
    var l = r(83894);
    var p = r(97520);
    function printSchema(e) {
      return printFilteredSchema(e, (e) => !(0, c.isSpecifiedDirective)(e), isDefinedType);
    }
    function printIntrospectionSchema(e) {
      return printFilteredSchema(e, c.isSpecifiedDirective, u.isIntrospectionType);
    }
    function isDefinedType(e) {
      return !(0, l.isSpecifiedScalarType)(e) && !(0, u.isIntrospectionType)(e);
    }
    function printFilteredSchema(e, t, r) {
      const n = e.getDirectives().filter(t);
      const o = Object.values(e.getTypeMap()).filter(r);
      return [printSchemaDefinition(e), ...n.map((e) => printDirective(e)), ...o.map((e) => printType(e))].filter(Boolean).join("\n\n");
    }
    function printSchemaDefinition(e) {
      if (e.description == null && isSchemaOfCommonNames(e)) {
        return;
      }
      const t = [];
      const r = e.getQueryType();
      if (r) {
        t.push(`  query: ${r.name}`);
      }
      const n = e.getMutationType();
      if (n) {
        t.push(`  mutation: ${n.name}`);
      }
      const o = e.getSubscriptionType();
      if (o) {
        t.push(`  subscription: ${o.name}`);
      }
      return printDescription(e) + `schema {\n${t.join("\n")}\n}`;
    }
    function isSchemaOfCommonNames(e) {
      const t = e.getQueryType();
      if (t && t.name !== "Query") {
        return false;
      }
      const r = e.getMutationType();
      if (r && r.name !== "Mutation") {
        return false;
      }
      const n = e.getSubscriptionType();
      if (n && n.name !== "Subscription") {
        return false;
      }
      return true;
    }
    function printType(e) {
      if ((0, A.isScalarType)(e)) {
        return printScalar(e);
      }
      if ((0, A.isObjectType)(e)) {
        return printObject(e);
      }
      if ((0, A.isInterfaceType)(e)) {
        return printInterface(e);
      }
      if ((0, A.isUnionType)(e)) {
        return printUnion(e);
      }
      if ((0, A.isEnumType)(e)) {
        return printEnum(e);
      }
      if ((0, A.isInputObjectType)(e)) {
        return printInputObject(e);
      }
      false || (0, o.invariant)(false, "Unexpected type: " + (0, n.inspect)(e));
    }
    function printScalar(e) {
      return printDescription(e) + `scalar ${e.name}` + printSpecifiedByURL(e);
    }
    function printImplementedInterfaces(e) {
      const t = e.getInterfaces();
      return t.length ? " implements " + t.map((e) => e.name).join(" & ") : "";
    }
    function printObject(e) {
      return printDescription(e) + `type ${e.name}` + printImplementedInterfaces(e) + printFields(e);
    }
    function printInterface(e) {
      return printDescription(e) + `interface ${e.name}` + printImplementedInterfaces(e) + printFields(e);
    }
    function printUnion(e) {
      const t = e.getTypes();
      const r = t.length ? " = " + t.join(" | ") : "";
      return printDescription(e) + "union " + e.name + r;
    }
    function printEnum(e) {
      const t = e.getValues().map((e, t) => printDescription(e, "  ", !t) + "  " + e.name + printDeprecated(e.deprecationReason));
      return printDescription(e) + `enum ${e.name}` + printBlock(t);
    }
    function printInputObject(e) {
      const t = Object.values(e.getFields()).map((e, t) => printDescription(e, "  ", !t) + "  " + printInputValue(e));
      return printDescription(e) + `input ${e.name}` + (e.isOneOf ? " @oneOf" : "") + printBlock(t);
    }
    function printFields(e) {
      const t = Object.values(e.getFields()).map(
        (e, t) => printDescription(e, "  ", !t) + "  " + e.name + printArgs(e.args, "  ") + ": " + String(e.type) + printDeprecated(e.deprecationReason)
      );
      return printBlock(t);
    }
    function printBlock(e) {
      return e.length !== 0 ? " {\n" + e.join("\n") + "\n}" : "";
    }
    function printArgs(e, t = "") {
      if (e.length === 0) {
        return "";
      }
      if (e.every((e) => !e.description)) {
        return "(" + e.map(printInputValue).join(", ") + ")";
      }
      return "(\n" + e.map((e, r) => printDescription(e, "  " + t, !r) + "  " + t + printInputValue(e)).join("\n") + "\n" + t + ")";
    }
    function printInputValue(e) {
      const t = (0, p.astFromValue)(e.defaultValue, e.type);
      let r = e.name + ": " + String(e.type);
      if (t) {
        r += ` = ${(0, a.print)(t)}`;
      }
      return r + printDeprecated(e.deprecationReason);
    }
    function printDirective(e) {
      return printDescription(e) + "directive @" + e.name + printArgs(e.args) + (e.isRepeatable ? " repeatable" : "") + " on " + e.locations.join(" | ");
    }
    function printDeprecated(e) {
      if (e == null) {
        return "";
      }
      if (e !== c.DEFAULT_DEPRECATION_REASON) {
        const t = (0, a.print)({ kind: i.Kind.STRING, value: e });
        return ` @deprecated(reason: ${t})`;
      }
      return " @deprecated";
    }
    function printSpecifiedByURL(e) {
      if (e.specifiedByURL == null) {
        return "";
      }
      const t = (0, a.print)({ kind: i.Kind.STRING, value: e.specifiedByURL });
      return ` @specifiedBy(url: ${t})`;
    }
    function printDescription(e, t = "", r = true) {
      const { description: n } = e;
      if (n == null) {
        return "";
      }
      const o = (0, a.print)({ kind: i.Kind.STRING, value: n, block: (0, s.isPrintableAsBlockString)(n) });
      const A = t && !r ? "\n" + t : t;
      return A + o.replace(/\n/g, "\n" + t) + "\n";
    }
  },
  5646: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.separateOperations = separateOperations;
    var n = r(19254);
    var o = r(45399);
    function separateOperations(e) {
      const t = [];
      const r = Object.create(null);
      for (const o of e.definitions) {
        switch (o.kind) {
          case n.Kind.OPERATION_DEFINITION:
            t.push(o);
            break;
          case n.Kind.FRAGMENT_DEFINITION:
            r[o.name.value] = collectDependencies(o.selectionSet);
            break;
          default:
        }
      }
      const o = Object.create(null);
      for (const s of t) {
        const t = new Set();
        for (const e of collectDependencies(s.selectionSet)) {
          collectTransitiveDependencies(t, r, e);
        }
        const i = s.name ? s.name.value : "";
        o[i] = { kind: n.Kind.DOCUMENT, definitions: e.definitions.filter((e) => e === s || (e.kind === n.Kind.FRAGMENT_DEFINITION && t.has(e.name.value))) };
      }
      return o;
    }
    function collectTransitiveDependencies(e, t, r) {
      if (!e.has(r)) {
        e.add(r);
        const n = t[r];
        if (n !== undefined) {
          for (const r of n) {
            collectTransitiveDependencies(e, t, r);
          }
        }
      }
    }
    function collectDependencies(e) {
      const t = [];
      (0, o.visit)(e, {
        FragmentSpread(e) {
          t.push(e.name.value);
        },
      });
      return t;
    }
  },
  47440: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.sortValueNode = sortValueNode;
    var n = r(9585);
    var o = r(19254);
    function sortValueNode(e) {
      switch (e.kind) {
        case o.Kind.OBJECT:
          return { ...e, fields: sortFields(e.fields) };
        case o.Kind.LIST:
          return { ...e, values: e.values.map(sortValueNode) };
        case o.Kind.INT:
        case o.Kind.FLOAT:
        case o.Kind.STRING:
        case o.Kind.BOOLEAN:
        case o.Kind.NULL:
        case o.Kind.ENUM:
        case o.Kind.VARIABLE:
          return e;
      }
    }
    function sortFields(e) {
      return e.map((e) => ({ ...e, value: sortValueNode(e.value) })).sort((e, t) => (0, n.naturalCompare)(e.name.value, t.name.value));
    }
  },
  64849: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.stripIgnoredCharacters = stripIgnoredCharacters;
    var n = r(44077);
    var o = r(91523);
    var s = r(58588);
    var i = r(22894);
    function stripIgnoredCharacters(e) {
      const t = (0, s.isSource)(e) ? e : new s.Source(e);
      const r = t.body;
      const a = new o.Lexer(t);
      let A = "";
      let c = false;
      while (a.advance().kind !== i.TokenKind.EOF) {
        const e = a.token;
        const t = e.kind;
        const s = !(0, o.isPunctuatorTokenKind)(e.kind);
        if (c) {
          if (s || e.kind === i.TokenKind.SPREAD) {
            A += " ";
          }
        }
        const u = r.slice(e.start, e.end);
        if (t === i.TokenKind.BLOCK_STRING) {
          A += (0, n.printBlockString)(e.value, { minimize: true });
        } else {
          A += u;
        }
        c = s;
      }
      return A;
    }
  },
  48808: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.doTypesOverlap = doTypesOverlap;
    t.isEqualType = isEqualType;
    t.isTypeSubTypeOf = isTypeSubTypeOf;
    var n = r(46250);
    function isEqualType(e, t) {
      if (e === t) {
        return true;
      }
      if ((0, n.isNonNullType)(e) && (0, n.isNonNullType)(t)) {
        return isEqualType(e.ofType, t.ofType);
      }
      if ((0, n.isListType)(e) && (0, n.isListType)(t)) {
        return isEqualType(e.ofType, t.ofType);
      }
      return false;
    }
    function isTypeSubTypeOf(e, t, r) {
      if (t === r) {
        return true;
      }
      if ((0, n.isNonNullType)(r)) {
        if ((0, n.isNonNullType)(t)) {
          return isTypeSubTypeOf(e, t.ofType, r.ofType);
        }
        return false;
      }
      if ((0, n.isNonNullType)(t)) {
        return isTypeSubTypeOf(e, t.ofType, r);
      }
      if ((0, n.isListType)(r)) {
        if ((0, n.isListType)(t)) {
          return isTypeSubTypeOf(e, t.ofType, r.ofType);
        }
        return false;
      }
      if ((0, n.isListType)(t)) {
        return false;
      }
      return (0, n.isAbstractType)(r) && ((0, n.isInterfaceType)(t) || (0, n.isObjectType)(t)) && e.isSubType(r, t);
    }
    function doTypesOverlap(e, t, r) {
      if (t === r) {
        return true;
      }
      if ((0, n.isAbstractType)(t)) {
        if ((0, n.isAbstractType)(r)) {
          return e.getPossibleTypes(t).some((t) => e.isSubType(r, t));
        }
        return e.isSubType(t, r);
      }
      if ((0, n.isAbstractType)(r)) {
        return e.isSubType(r, t);
      }
      return false;
    }
  },
  45669: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.typeFromAST = typeFromAST;
    var n = r(19254);
    var o = r(46250);
    function typeFromAST(e, t) {
      switch (t.kind) {
        case n.Kind.LIST_TYPE: {
          const r = typeFromAST(e, t.type);
          return r && new o.GraphQLList(r);
        }
        case n.Kind.NON_NULL_TYPE: {
          const r = typeFromAST(e, t.type);
          return r && new o.GraphQLNonNull(r);
        }
        case n.Kind.NAMED_TYPE:
          return e.getType(t.name.value);
      }
    }
  },
  36302: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.valueFromAST = valueFromAST;
    var n = r(71801);
    var o = r(67305);
    var s = r(97982);
    var i = r(19254);
    var a = r(46250);
    function valueFromAST(e, t, r) {
      if (!e) {
        return;
      }
      if (e.kind === i.Kind.VARIABLE) {
        const n = e.name.value;
        if (r == null || r[n] === undefined) {
          return;
        }
        const o = r[n];
        if (o === null && (0, a.isNonNullType)(t)) {
          return;
        }
        return o;
      }
      if ((0, a.isNonNullType)(t)) {
        if (e.kind === i.Kind.NULL) {
          return;
        }
        return valueFromAST(e, t.ofType, r);
      }
      if (e.kind === i.Kind.NULL) {
        return null;
      }
      if ((0, a.isListType)(t)) {
        const n = t.ofType;
        if (e.kind === i.Kind.LIST) {
          const t = [];
          for (const o of e.values) {
            if (isMissingVariable(o, r)) {
              if ((0, a.isNonNullType)(n)) {
                return;
              }
              t.push(null);
            } else {
              const e = valueFromAST(o, n, r);
              if (e === undefined) {
                return;
              }
              t.push(e);
            }
          }
          return t;
        }
        const o = valueFromAST(e, n, r);
        if (o === undefined) {
          return;
        }
        return [o];
      }
      if ((0, a.isInputObjectType)(t)) {
        if (e.kind !== i.Kind.OBJECT) {
          return;
        }
        const n = Object.create(null);
        const o = (0, s.keyMap)(e.fields, (e) => e.name.value);
        for (const e of Object.values(t.getFields())) {
          const t = o[e.name];
          if (!t || isMissingVariable(t.value, r)) {
            if (e.defaultValue !== undefined) {
              n[e.name] = e.defaultValue;
            } else if ((0, a.isNonNullType)(e.type)) {
              return;
            }
            continue;
          }
          const s = valueFromAST(t.value, e.type, r);
          if (s === undefined) {
            return;
          }
          n[e.name] = s;
        }
        if (t.isOneOf) {
          const e = Object.keys(n);
          if (e.length !== 1) {
            return;
          }
          if (n[e[0]] === null) {
            return;
          }
        }
        return n;
      }
      if ((0, a.isLeafType)(t)) {
        let n;
        try {
          n = t.parseLiteral(e, r);
        } catch (e) {
          return;
        }
        if (n === undefined) {
          return;
        }
        return n;
      }
      false || (0, o.invariant)(false, "Unexpected input type: " + (0, n.inspect)(t));
    }
    function isMissingVariable(e, t) {
      return e.kind === i.Kind.VARIABLE && (t == null || t[e.name.value] === undefined);
    }
  },
  8021: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.valueFromASTUntyped = valueFromASTUntyped;
    var n = r(7897);
    var o = r(19254);
    function valueFromASTUntyped(e, t) {
      switch (e.kind) {
        case o.Kind.NULL:
          return null;
        case o.Kind.INT:
          return parseInt(e.value, 10);
        case o.Kind.FLOAT:
          return parseFloat(e.value);
        case o.Kind.STRING:
        case o.Kind.ENUM:
        case o.Kind.BOOLEAN:
          return e.value;
        case o.Kind.LIST:
          return e.values.map((e) => valueFromASTUntyped(e, t));
        case o.Kind.OBJECT:
          return (0, n.keyValMap)(
            e.fields,
            (e) => e.name.value,
            (e) => valueFromASTUntyped(e.value, t)
          );
        case o.Kind.VARIABLE:
          return t === null || t === void 0 ? void 0 : t[e.name.value];
      }
    }
  },
  18686: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ValidationContext = t.SDLValidationContext = t.ASTValidationContext = void 0;
    var n = r(19254);
    var o = r(45399);
    var s = r(71165);
    class ASTValidationContext {
      constructor(e, t) {
        this._ast = e;
        this._fragments = undefined;
        this._fragmentSpreads = new Map();
        this._recursivelyReferencedFragments = new Map();
        this._onError = t;
      }
      get [Symbol.toStringTag]() {
        return "ASTValidationContext";
      }
      reportError(e) {
        this._onError(e);
      }
      getDocument() {
        return this._ast;
      }
      getFragment(e) {
        let t;
        if (this._fragments) {
          t = this._fragments;
        } else {
          t = Object.create(null);
          for (const e of this.getDocument().definitions) {
            if (e.kind === n.Kind.FRAGMENT_DEFINITION) {
              t[e.name.value] = e;
            }
          }
          this._fragments = t;
        }
        return t[e];
      }
      getFragmentSpreads(e) {
        let t = this._fragmentSpreads.get(e);
        if (!t) {
          t = [];
          const r = [e];
          let o;
          while ((o = r.pop())) {
            for (const e of o.selections) {
              if (e.kind === n.Kind.FRAGMENT_SPREAD) {
                t.push(e);
              } else if (e.selectionSet) {
                r.push(e.selectionSet);
              }
            }
          }
          this._fragmentSpreads.set(e, t);
        }
        return t;
      }
      getRecursivelyReferencedFragments(e) {
        let t = this._recursivelyReferencedFragments.get(e);
        if (!t) {
          t = [];
          const r = Object.create(null);
          const n = [e.selectionSet];
          let o;
          while ((o = n.pop())) {
            for (const e of this.getFragmentSpreads(o)) {
              const o = e.name.value;
              if (r[o] !== true) {
                r[o] = true;
                const e = this.getFragment(o);
                if (e) {
                  t.push(e);
                  n.push(e.selectionSet);
                }
              }
            }
          }
          this._recursivelyReferencedFragments.set(e, t);
        }
        return t;
      }
    }
    t.ASTValidationContext = ASTValidationContext;
    class SDLValidationContext extends ASTValidationContext {
      constructor(e, t, r) {
        super(e, r);
        this._schema = t;
      }
      get [Symbol.toStringTag]() {
        return "SDLValidationContext";
      }
      getSchema() {
        return this._schema;
      }
    }
    t.SDLValidationContext = SDLValidationContext;
    class ValidationContext extends ASTValidationContext {
      constructor(e, t, r, n) {
        super(t, n);
        this._schema = e;
        this._typeInfo = r;
        this._variableUsages = new Map();
        this._recursiveVariableUsages = new Map();
      }
      get [Symbol.toStringTag]() {
        return "ValidationContext";
      }
      getSchema() {
        return this._schema;
      }
      getVariableUsages(e) {
        let t = this._variableUsages.get(e);
        if (!t) {
          const r = [];
          const n = new s.TypeInfo(this._schema);
          (0, o.visit)(
            e,
            (0, s.visitWithTypeInfo)(n, {
              VariableDefinition: () => false,
              Variable(e) {
                r.push({ node: e, type: n.getInputType(), defaultValue: n.getDefaultValue() });
              },
            })
          );
          t = r;
          this._variableUsages.set(e, t);
        }
        return t;
      }
      getRecursiveVariableUsages(e) {
        let t = this._recursiveVariableUsages.get(e);
        if (!t) {
          t = this.getVariableUsages(e);
          for (const r of this.getRecursivelyReferencedFragments(e)) {
            t = t.concat(this.getVariableUsages(r));
          }
          this._recursiveVariableUsages.set(e, t);
        }
        return t;
      }
      getType() {
        return this._typeInfo.getType();
      }
      getParentType() {
        return this._typeInfo.getParentType();
      }
      getInputType() {
        return this._typeInfo.getInputType();
      }
      getParentInputType() {
        return this._typeInfo.getParentInputType();
      }
      getFieldDef() {
        return this._typeInfo.getFieldDef();
      }
      getDirective() {
        return this._typeInfo.getDirective();
      }
      getArgument() {
        return this._typeInfo.getArgument();
      }
      getEnumValue() {
        return this._typeInfo.getEnumValue();
      }
    }
    t.ValidationContext = ValidationContext;
  },
  18280: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    Object.defineProperty(t, "ExecutableDefinitionsRule", {
      enumerable: true,
      get: function () {
        return i.ExecutableDefinitionsRule;
      },
    });
    Object.defineProperty(t, "FieldsOnCorrectTypeRule", {
      enumerable: true,
      get: function () {
        return a.FieldsOnCorrectTypeRule;
      },
    });
    Object.defineProperty(t, "FragmentsOnCompositeTypesRule", {
      enumerable: true,
      get: function () {
        return A.FragmentsOnCompositeTypesRule;
      },
    });
    Object.defineProperty(t, "KnownArgumentNamesRule", {
      enumerable: true,
      get: function () {
        return c.KnownArgumentNamesRule;
      },
    });
    Object.defineProperty(t, "KnownDirectivesRule", {
      enumerable: true,
      get: function () {
        return u.KnownDirectivesRule;
      },
    });
    Object.defineProperty(t, "KnownFragmentNamesRule", {
      enumerable: true,
      get: function () {
        return l.KnownFragmentNamesRule;
      },
    });
    Object.defineProperty(t, "KnownTypeNamesRule", {
      enumerable: true,
      get: function () {
        return p.KnownTypeNamesRule;
      },
    });
    Object.defineProperty(t, "LoneAnonymousOperationRule", {
      enumerable: true,
      get: function () {
        return d.LoneAnonymousOperationRule;
      },
    });
    Object.defineProperty(t, "LoneSchemaDefinitionRule", {
      enumerable: true,
      get: function () {
        return S.LoneSchemaDefinitionRule;
      },
    });
    Object.defineProperty(t, "MaxIntrospectionDepthRule", {
      enumerable: true,
      get: function () {
        return k.MaxIntrospectionDepthRule;
      },
    });
    Object.defineProperty(t, "NoDeprecatedCustomRule", {
      enumerable: true,
      get: function () {
        return j.NoDeprecatedCustomRule;
      },
    });
    Object.defineProperty(t, "NoFragmentCyclesRule", {
      enumerable: true,
      get: function () {
        return g.NoFragmentCyclesRule;
      },
    });
    Object.defineProperty(t, "NoSchemaIntrospectionCustomRule", {
      enumerable: true,
      get: function () {
        return V.NoSchemaIntrospectionCustomRule;
      },
    });
    Object.defineProperty(t, "NoUndefinedVariablesRule", {
      enumerable: true,
      get: function () {
        return m.NoUndefinedVariablesRule;
      },
    });
    Object.defineProperty(t, "NoUnusedFragmentsRule", {
      enumerable: true,
      get: function () {
        return h.NoUnusedFragmentsRule;
      },
    });
    Object.defineProperty(t, "NoUnusedVariablesRule", {
      enumerable: true,
      get: function () {
        return E.NoUnusedVariablesRule;
      },
    });
    Object.defineProperty(t, "OverlappingFieldsCanBeMergedRule", {
      enumerable: true,
      get: function () {
        return I.OverlappingFieldsCanBeMergedRule;
      },
    });
    Object.defineProperty(t, "PossibleFragmentSpreadsRule", {
      enumerable: true,
      get: function () {
        return y.PossibleFragmentSpreadsRule;
      },
    });
    Object.defineProperty(t, "PossibleTypeExtensionsRule", {
      enumerable: true,
      get: function () {
        return x.PossibleTypeExtensionsRule;
      },
    });
    Object.defineProperty(t, "ProvidedRequiredArgumentsRule", {
      enumerable: true,
      get: function () {
        return C.ProvidedRequiredArgumentsRule;
      },
    });
    Object.defineProperty(t, "ScalarLeafsRule", {
      enumerable: true,
      get: function () {
        return b.ScalarLeafsRule;
      },
    });
    Object.defineProperty(t, "SingleFieldSubscriptionsRule", {
      enumerable: true,
      get: function () {
        return Q.SingleFieldSubscriptionsRule;
      },
    });
    Object.defineProperty(t, "UniqueArgumentDefinitionNamesRule", {
      enumerable: true,
      get: function () {
        return M.UniqueArgumentDefinitionNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueArgumentNamesRule", {
      enumerable: true,
      get: function () {
        return B.UniqueArgumentNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueDirectiveNamesRule", {
      enumerable: true,
      get: function () {
        return G.UniqueDirectiveNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueDirectivesPerLocationRule", {
      enumerable: true,
      get: function () {
        return T.UniqueDirectivesPerLocationRule;
      },
    });
    Object.defineProperty(t, "UniqueEnumValueNamesRule", {
      enumerable: true,
      get: function () {
        return L.UniqueEnumValueNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueFieldDefinitionNamesRule", {
      enumerable: true,
      get: function () {
        return U.UniqueFieldDefinitionNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueFragmentNamesRule", {
      enumerable: true,
      get: function () {
        return v.UniqueFragmentNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueInputFieldNamesRule", {
      enumerable: true,
      get: function () {
        return w.UniqueInputFieldNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueOperationNamesRule", {
      enumerable: true,
      get: function () {
        return _.UniqueOperationNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueOperationTypesRule", {
      enumerable: true,
      get: function () {
        return N.UniqueOperationTypesRule;
      },
    });
    Object.defineProperty(t, "UniqueTypeNamesRule", {
      enumerable: true,
      get: function () {
        return P.UniqueTypeNamesRule;
      },
    });
    Object.defineProperty(t, "UniqueVariableNamesRule", {
      enumerable: true,
      get: function () {
        return R.UniqueVariableNamesRule;
      },
    });
    Object.defineProperty(t, "ValidationContext", {
      enumerable: true,
      get: function () {
        return o.ValidationContext;
      },
    });
    Object.defineProperty(t, "ValuesOfCorrectTypeRule", {
      enumerable: true,
      get: function () {
        return O.ValuesOfCorrectTypeRule;
      },
    });
    Object.defineProperty(t, "VariablesAreInputTypesRule", {
      enumerable: true,
      get: function () {
        return F.VariablesAreInputTypesRule;
      },
    });
    Object.defineProperty(t, "VariablesInAllowedPositionRule", {
      enumerable: true,
      get: function () {
        return D.VariablesInAllowedPositionRule;
      },
    });
    Object.defineProperty(t, "recommendedRules", {
      enumerable: true,
      get: function () {
        return s.recommendedRules;
      },
    });
    Object.defineProperty(t, "specifiedRules", {
      enumerable: true,
      get: function () {
        return s.specifiedRules;
      },
    });
    Object.defineProperty(t, "validate", {
      enumerable: true,
      get: function () {
        return n.validate;
      },
    });
    var n = r(90592);
    var o = r(18686);
    var s = r(81075);
    var i = r(28668);
    var a = r(42775);
    var A = r(28690);
    var c = r(90284);
    var u = r(8207);
    var l = r(34181);
    var p = r(36237);
    var d = r(29978);
    var g = r(9408);
    var m = r(60838);
    var h = r(42072);
    var E = r(86808);
    var I = r(43481);
    var y = r(60135);
    var C = r(76648);
    var b = r(63827);
    var Q = r(79186);
    var B = r(42894);
    var T = r(5033);
    var v = r(78643);
    var w = r(46067);
    var _ = r(76196);
    var R = r(36055);
    var O = r(38245);
    var F = r(76436);
    var D = r(80041);
    var k = r(95776);
    var S = r(97574);
    var N = r(53385);
    var P = r(81795);
    var L = r(77077);
    var U = r(46108);
    var M = r(39549);
    var G = r(95172);
    var x = r(62641);
    var j = r(10091);
    var V = r(43924);
  },
  28668: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ExecutableDefinitionsRule = ExecutableDefinitionsRule;
    var n = r(23750);
    var o = r(19254);
    var s = r(24147);
    function ExecutableDefinitionsRule(e) {
      return {
        Document(t) {
          for (const r of t.definitions) {
            if (!(0, s.isExecutableDefinitionNode)(r)) {
              const t = r.kind === o.Kind.SCHEMA_DEFINITION || r.kind === o.Kind.SCHEMA_EXTENSION ? "schema" : '"' + r.name.value + '"';
              e.reportError(new n.GraphQLError(`The ${t} definition is not executable.`, { nodes: r }));
            }
          }
          return false;
        },
      };
    }
  },
  42775: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.FieldsOnCorrectTypeRule = FieldsOnCorrectTypeRule;
    var n = r(62384);
    var o = r(9585);
    var s = r(18765);
    var i = r(23750);
    var a = r(46250);
    function FieldsOnCorrectTypeRule(e) {
      return {
        Field(t) {
          const r = e.getParentType();
          if (r) {
            const o = e.getFieldDef();
            if (!o) {
              const o = e.getSchema();
              const s = t.name.value;
              let a = (0, n.didYouMean)("to use an inline fragment on", getSuggestedTypeNames(o, r, s));
              if (a === "") {
                a = (0, n.didYouMean)(getSuggestedFieldNames(r, s));
              }
              e.reportError(new i.GraphQLError(`Cannot query field "${s}" on type "${r.name}".` + a, { nodes: t }));
            }
          }
        },
      };
    }
    function getSuggestedTypeNames(e, t, r) {
      if (!(0, a.isAbstractType)(t)) {
        return [];
      }
      const n = new Set();
      const s = Object.create(null);
      for (const o of e.getPossibleTypes(t)) {
        if (!o.getFields()[r]) {
          continue;
        }
        n.add(o);
        s[o.name] = 1;
        for (const e of o.getInterfaces()) {
          var i;
          if (!e.getFields()[r]) {
            continue;
          }
          n.add(e);
          s[e.name] = ((i = s[e.name]) !== null && i !== void 0 ? i : 0) + 1;
        }
      }
      return [...n]
        .sort((t, r) => {
          const n = s[r.name] - s[t.name];
          if (n !== 0) {
            return n;
          }
          if ((0, a.isInterfaceType)(t) && e.isSubType(t, r)) {
            return -1;
          }
          if ((0, a.isInterfaceType)(r) && e.isSubType(r, t)) {
            return 1;
          }
          return (0, o.naturalCompare)(t.name, r.name);
        })
        .map((e) => e.name);
    }
    function getSuggestedFieldNames(e, t) {
      if ((0, a.isObjectType)(e) || (0, a.isInterfaceType)(e)) {
        const r = Object.keys(e.getFields());
        return (0, s.suggestionList)(t, r);
      }
      return [];
    }
  },
  28690: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.FragmentsOnCompositeTypesRule = FragmentsOnCompositeTypesRule;
    var n = r(23750);
    var o = r(85401);
    var s = r(46250);
    var i = r(45669);
    function FragmentsOnCompositeTypesRule(e) {
      return {
        InlineFragment(t) {
          const r = t.typeCondition;
          if (r) {
            const t = (0, i.typeFromAST)(e.getSchema(), r);
            if (t && !(0, s.isCompositeType)(t)) {
              const t = (0, o.print)(r);
              e.reportError(new n.GraphQLError(`Fragment cannot condition on non composite type "${t}".`, { nodes: r }));
            }
          }
        },
        FragmentDefinition(t) {
          const r = (0, i.typeFromAST)(e.getSchema(), t.typeCondition);
          if (r && !(0, s.isCompositeType)(r)) {
            const r = (0, o.print)(t.typeCondition);
            e.reportError(new n.GraphQLError(`Fragment "${t.name.value}" cannot condition on non composite type "${r}".`, { nodes: t.typeCondition }));
          }
        },
      };
    }
  },
  90284: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.KnownArgumentNamesOnDirectivesRule = KnownArgumentNamesOnDirectivesRule;
    t.KnownArgumentNamesRule = KnownArgumentNamesRule;
    var n = r(62384);
    var o = r(18765);
    var s = r(23750);
    var i = r(19254);
    var a = r(58941);
    function KnownArgumentNamesRule(e) {
      return {
        ...KnownArgumentNamesOnDirectivesRule(e),
        Argument(t) {
          const r = e.getArgument();
          const i = e.getFieldDef();
          const a = e.getParentType();
          if (!r && i && a) {
            const r = t.name.value;
            const A = i.args.map((e) => e.name);
            const c = (0, o.suggestionList)(r, A);
            e.reportError(new s.GraphQLError(`Unknown argument "${r}" on field "${a.name}.${i.name}".` + (0, n.didYouMean)(c), { nodes: t }));
          }
        },
      };
    }
    function KnownArgumentNamesOnDirectivesRule(e) {
      const t = Object.create(null);
      const r = e.getSchema();
      const A = r ? r.getDirectives() : a.specifiedDirectives;
      for (const e of A) {
        t[e.name] = e.args.map((e) => e.name);
      }
      const c = e.getDocument().definitions;
      for (const e of c) {
        if (e.kind === i.Kind.DIRECTIVE_DEFINITION) {
          var u;
          const r = (u = e.arguments) !== null && u !== void 0 ? u : [];
          t[e.name.value] = r.map((e) => e.name.value);
        }
      }
      return {
        Directive(r) {
          const i = r.name.value;
          const a = t[i];
          if (r.arguments && a) {
            for (const t of r.arguments) {
              const r = t.name.value;
              if (!a.includes(r)) {
                const A = (0, o.suggestionList)(r, a);
                e.reportError(new s.GraphQLError(`Unknown argument "${r}" on directive "@${i}".` + (0, n.didYouMean)(A), { nodes: t }));
              }
            }
          }
          return false;
        },
      };
    }
  },
  8207: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.KnownDirectivesRule = KnownDirectivesRule;
    var n = r(71801);
    var o = r(67305);
    var s = r(23750);
    var i = r(26081);
    var a = r(57503);
    var A = r(19254);
    var c = r(58941);
    function KnownDirectivesRule(e) {
      const t = Object.create(null);
      const r = e.getSchema();
      const n = r ? r.getDirectives() : c.specifiedDirectives;
      for (const e of n) {
        t[e.name] = e.locations;
      }
      const o = e.getDocument().definitions;
      for (const e of o) {
        if (e.kind === A.Kind.DIRECTIVE_DEFINITION) {
          t[e.name.value] = e.locations.map((e) => e.value);
        }
      }
      return {
        Directive(r, n, o, i, a) {
          const A = r.name.value;
          const c = t[A];
          if (!c) {
            e.reportError(new s.GraphQLError(`Unknown directive "@${A}".`, { nodes: r }));
            return;
          }
          const u = getDirectiveLocationForASTPath(a);
          if (u && !c.includes(u)) {
            e.reportError(new s.GraphQLError(`Directive "@${A}" may not be used on ${u}.`, { nodes: r }));
          }
        },
      };
    }
    function getDirectiveLocationForASTPath(e) {
      const t = e[e.length - 1];
      "kind" in t || (0, o.invariant)(false);
      switch (t.kind) {
        case A.Kind.OPERATION_DEFINITION:
          return getDirectiveLocationForOperation(t.operation);
        case A.Kind.FIELD:
          return a.DirectiveLocation.FIELD;
        case A.Kind.FRAGMENT_SPREAD:
          return a.DirectiveLocation.FRAGMENT_SPREAD;
        case A.Kind.INLINE_FRAGMENT:
          return a.DirectiveLocation.INLINE_FRAGMENT;
        case A.Kind.FRAGMENT_DEFINITION:
          return a.DirectiveLocation.FRAGMENT_DEFINITION;
        case A.Kind.VARIABLE_DEFINITION:
          return a.DirectiveLocation.VARIABLE_DEFINITION;
        case A.Kind.SCHEMA_DEFINITION:
        case A.Kind.SCHEMA_EXTENSION:
          return a.DirectiveLocation.SCHEMA;
        case A.Kind.SCALAR_TYPE_DEFINITION:
        case A.Kind.SCALAR_TYPE_EXTENSION:
          return a.DirectiveLocation.SCALAR;
        case A.Kind.OBJECT_TYPE_DEFINITION:
        case A.Kind.OBJECT_TYPE_EXTENSION:
          return a.DirectiveLocation.OBJECT;
        case A.Kind.FIELD_DEFINITION:
          return a.DirectiveLocation.FIELD_DEFINITION;
        case A.Kind.INTERFACE_TYPE_DEFINITION:
        case A.Kind.INTERFACE_TYPE_EXTENSION:
          return a.DirectiveLocation.INTERFACE;
        case A.Kind.UNION_TYPE_DEFINITION:
        case A.Kind.UNION_TYPE_EXTENSION:
          return a.DirectiveLocation.UNION;
        case A.Kind.ENUM_TYPE_DEFINITION:
        case A.Kind.ENUM_TYPE_EXTENSION:
          return a.DirectiveLocation.ENUM;
        case A.Kind.ENUM_VALUE_DEFINITION:
          return a.DirectiveLocation.ENUM_VALUE;
        case A.Kind.INPUT_OBJECT_TYPE_DEFINITION:
        case A.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return a.DirectiveLocation.INPUT_OBJECT;
        case A.Kind.INPUT_VALUE_DEFINITION: {
          const t = e[e.length - 3];
          "kind" in t || (0, o.invariant)(false);
          return t.kind === A.Kind.INPUT_OBJECT_TYPE_DEFINITION ? a.DirectiveLocation.INPUT_FIELD_DEFINITION : a.DirectiveLocation.ARGUMENT_DEFINITION;
        }
        default:
          false || (0, o.invariant)(false, "Unexpected kind: " + (0, n.inspect)(t.kind));
      }
    }
    function getDirectiveLocationForOperation(e) {
      switch (e) {
        case i.OperationTypeNode.QUERY:
          return a.DirectiveLocation.QUERY;
        case i.OperationTypeNode.MUTATION:
          return a.DirectiveLocation.MUTATION;
        case i.OperationTypeNode.SUBSCRIPTION:
          return a.DirectiveLocation.SUBSCRIPTION;
      }
    }
  },
  34181: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.KnownFragmentNamesRule = KnownFragmentNamesRule;
    var n = r(23750);
    function KnownFragmentNamesRule(e) {
      return {
        FragmentSpread(t) {
          const r = t.name.value;
          const o = e.getFragment(r);
          if (!o) {
            e.reportError(new n.GraphQLError(`Unknown fragment "${r}".`, { nodes: t.name }));
          }
        },
      };
    }
  },
  36237: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.KnownTypeNamesRule = KnownTypeNamesRule;
    var n = r(62384);
    var o = r(18765);
    var s = r(23750);
    var i = r(24147);
    var a = r(47564);
    var A = r(83894);
    function KnownTypeNamesRule(e) {
      const t = e.getSchema();
      const r = t ? t.getTypeMap() : Object.create(null);
      const a = Object.create(null);
      for (const t of e.getDocument().definitions) {
        if ((0, i.isTypeDefinitionNode)(t)) {
          a[t.name.value] = true;
        }
      }
      const A = [...Object.keys(r), ...Object.keys(a)];
      return {
        NamedType(t, i, u, l, p) {
          const d = t.name.value;
          if (!r[d] && !a[d]) {
            var g;
            const r = (g = p[2]) !== null && g !== void 0 ? g : u;
            const i = r != null && isSDLNode(r);
            if (i && c.includes(d)) {
              return;
            }
            const a = (0, o.suggestionList)(d, i ? c.concat(A) : A);
            e.reportError(new s.GraphQLError(`Unknown type "${d}".` + (0, n.didYouMean)(a), { nodes: t }));
          }
        },
      };
    }
    const c = [...A.specifiedScalarTypes, ...a.introspectionTypes].map((e) => e.name);
    function isSDLNode(e) {
      return "kind" in e && ((0, i.isTypeSystemDefinitionNode)(e) || (0, i.isTypeSystemExtensionNode)(e));
    }
  },
  29978: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.LoneAnonymousOperationRule = LoneAnonymousOperationRule;
    var n = r(23750);
    var o = r(19254);
    function LoneAnonymousOperationRule(e) {
      let t = 0;
      return {
        Document(e) {
          t = e.definitions.filter((e) => e.kind === o.Kind.OPERATION_DEFINITION).length;
        },
        OperationDefinition(r) {
          if (!r.name && t > 1) {
            e.reportError(new n.GraphQLError("This anonymous operation must be the only defined operation.", { nodes: r }));
          }
        },
      };
    }
  },
  97574: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.LoneSchemaDefinitionRule = LoneSchemaDefinitionRule;
    var n = r(23750);
    function LoneSchemaDefinitionRule(e) {
      var t, r, o;
      const s = e.getSchema();
      const i =
        (t =
          (r = (o = s === null || s === void 0 ? void 0 : s.astNode) !== null && o !== void 0 ? o : s === null || s === void 0 ? void 0 : s.getQueryType()) !==
            null && r !== void 0
            ? r
            : s === null || s === void 0
              ? void 0
              : s.getMutationType()) !== null && t !== void 0
          ? t
          : s === null || s === void 0
            ? void 0
            : s.getSubscriptionType();
      let a = 0;
      return {
        SchemaDefinition(t) {
          if (i) {
            e.reportError(new n.GraphQLError("Cannot define a new schema within a schema extension.", { nodes: t }));
            return;
          }
          if (a > 0) {
            e.reportError(new n.GraphQLError("Must provide only one schema definition.", { nodes: t }));
          }
          ++a;
        },
      };
    }
  },
  95776: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.MaxIntrospectionDepthRule = MaxIntrospectionDepthRule;
    var n = r(23750);
    var o = r(19254);
    const s = 3;
    function MaxIntrospectionDepthRule(e) {
      function checkDepth(t, r = Object.create(null), n = 0) {
        if (t.kind === o.Kind.FRAGMENT_SPREAD) {
          const o = t.name.value;
          if (r[o] === true) {
            return false;
          }
          const s = e.getFragment(o);
          if (!s) {
            return false;
          }
          try {
            r[o] = true;
            return checkDepth(s, r, n);
          } finally {
            r[o] = undefined;
          }
        }
        if (
          t.kind === o.Kind.FIELD &&
          (t.name.value === "fields" || t.name.value === "interfaces" || t.name.value === "possibleTypes" || t.name.value === "inputFields")
        ) {
          n++;
          if (n >= s) {
            return true;
          }
        }
        if ("selectionSet" in t && t.selectionSet) {
          for (const e of t.selectionSet.selections) {
            if (checkDepth(e, r, n)) {
              return true;
            }
          }
        }
        return false;
      }
      return {
        Field(t) {
          if (t.name.value === "__schema" || t.name.value === "__type") {
            if (checkDepth(t)) {
              e.reportError(new n.GraphQLError("Maximum introspection depth exceeded", { nodes: [t] }));
              return false;
            }
          }
        },
      };
    }
  },
  9408: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.NoFragmentCyclesRule = NoFragmentCyclesRule;
    var n = r(23750);
    function NoFragmentCyclesRule(e) {
      const t = Object.create(null);
      const r = [];
      const o = Object.create(null);
      return {
        OperationDefinition: () => false,
        FragmentDefinition(e) {
          detectCycleRecursive(e);
          return false;
        },
      };
      function detectCycleRecursive(s) {
        if (t[s.name.value]) {
          return;
        }
        const i = s.name.value;
        t[i] = true;
        const a = e.getFragmentSpreads(s.selectionSet);
        if (a.length === 0) {
          return;
        }
        o[i] = r.length;
        for (const t of a) {
          const s = t.name.value;
          const i = o[s];
          r.push(t);
          if (i === undefined) {
            const t = e.getFragment(s);
            if (t) {
              detectCycleRecursive(t);
            }
          } else {
            const t = r.slice(i);
            const o = t
              .slice(0, -1)
              .map((e) => '"' + e.name.value + '"')
              .join(", ");
            e.reportError(new n.GraphQLError(`Cannot spread fragment "${s}" within itself` + (o !== "" ? ` via ${o}.` : "."), { nodes: t }));
          }
          r.pop();
        }
        o[i] = undefined;
      }
    }
  },
  60838: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.NoUndefinedVariablesRule = NoUndefinedVariablesRule;
    var n = r(23750);
    function NoUndefinedVariablesRule(e) {
      let t = Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            t = Object.create(null);
          },
          leave(r) {
            const o = e.getRecursiveVariableUsages(r);
            for (const { node: s } of o) {
              const o = s.name.value;
              if (t[o] !== true) {
                e.reportError(
                  new n.GraphQLError(r.name ? `Variable "$${o}" is not defined by operation "${r.name.value}".` : `Variable "$${o}" is not defined.`, {
                    nodes: [s, r],
                  })
                );
              }
            }
          },
        },
        VariableDefinition(e) {
          t[e.variable.name.value] = true;
        },
      };
    }
  },
  42072: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.NoUnusedFragmentsRule = NoUnusedFragmentsRule;
    var n = r(23750);
    function NoUnusedFragmentsRule(e) {
      const t = [];
      const r = [];
      return {
        OperationDefinition(e) {
          t.push(e);
          return false;
        },
        FragmentDefinition(e) {
          r.push(e);
          return false;
        },
        Document: {
          leave() {
            const o = Object.create(null);
            for (const r of t) {
              for (const t of e.getRecursivelyReferencedFragments(r)) {
                o[t.name.value] = true;
              }
            }
            for (const t of r) {
              const r = t.name.value;
              if (o[r] !== true) {
                e.reportError(new n.GraphQLError(`Fragment "${r}" is never used.`, { nodes: t }));
              }
            }
          },
        },
      };
    }
  },
  86808: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.NoUnusedVariablesRule = NoUnusedVariablesRule;
    var n = r(23750);
    function NoUnusedVariablesRule(e) {
      let t = [];
      return {
        OperationDefinition: {
          enter() {
            t = [];
          },
          leave(r) {
            const o = Object.create(null);
            const s = e.getRecursiveVariableUsages(r);
            for (const { node: e } of s) {
              o[e.name.value] = true;
            }
            for (const s of t) {
              const t = s.variable.name.value;
              if (o[t] !== true) {
                e.reportError(
                  new n.GraphQLError(r.name ? `Variable "$${t}" is never used in operation "${r.name.value}".` : `Variable "$${t}" is never used.`, {
                    nodes: s,
                  })
                );
              }
            }
          },
        },
        VariableDefinition(e) {
          t.push(e);
        },
      };
    }
  },
  43481: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.OverlappingFieldsCanBeMergedRule = OverlappingFieldsCanBeMergedRule;
    var n = r(71801);
    var o = r(23750);
    var s = r(19254);
    var i = r(85401);
    var a = r(46250);
    var A = r(47440);
    var c = r(45669);
    function reasonMessage(e) {
      if (Array.isArray(e)) {
        return e.map(([e, t]) => `subfields "${e}" conflict because ` + reasonMessage(t)).join(" and ");
      }
      return e;
    }
    function OverlappingFieldsCanBeMergedRule(e) {
      const t = new PairSet();
      const r = new Map();
      return {
        SelectionSet(n) {
          const s = findConflictsWithinSelectionSet(e, r, t, e.getParentType(), n);
          for (const [[t, r], n, i] of s) {
            const s = reasonMessage(r);
            e.reportError(
              new o.GraphQLError(`Fields "${t}" conflict because ${s}. Use different aliases on the fields to fetch both if this was intentional.`, {
                nodes: n.concat(i),
              })
            );
          }
        },
      };
    }
    function findConflictsWithinSelectionSet(e, t, r, n, o) {
      const s = [];
      const [i, a] = getFieldsAndFragmentNames(e, t, n, o);
      collectConflictsWithin(e, s, t, r, i);
      if (a.length !== 0) {
        for (let n = 0; n < a.length; n++) {
          collectConflictsBetweenFieldsAndFragment(e, s, t, r, false, i, a[n]);
          for (let o = n + 1; o < a.length; o++) {
            collectConflictsBetweenFragments(e, s, t, r, false, a[n], a[o]);
          }
        }
      }
      return s;
    }
    function collectConflictsBetweenFieldsAndFragment(e, t, r, n, o, s, i) {
      const a = e.getFragment(i);
      if (!a) {
        return;
      }
      const [A, c] = getReferencedFieldsAndFragmentNames(e, r, a);
      if (s === A) {
        return;
      }
      collectConflictsBetween(e, t, r, n, o, s, A);
      for (const a of c) {
        if (n.has(a, i, o)) {
          continue;
        }
        n.add(a, i, o);
        collectConflictsBetweenFieldsAndFragment(e, t, r, n, o, s, a);
      }
    }
    function collectConflictsBetweenFragments(e, t, r, n, o, s, i) {
      if (s === i) {
        return;
      }
      if (n.has(s, i, o)) {
        return;
      }
      n.add(s, i, o);
      const a = e.getFragment(s);
      const A = e.getFragment(i);
      if (!a || !A) {
        return;
      }
      const [c, u] = getReferencedFieldsAndFragmentNames(e, r, a);
      const [l, p] = getReferencedFieldsAndFragmentNames(e, r, A);
      collectConflictsBetween(e, t, r, n, o, c, l);
      for (const i of p) {
        collectConflictsBetweenFragments(e, t, r, n, o, s, i);
      }
      for (const s of u) {
        collectConflictsBetweenFragments(e, t, r, n, o, s, i);
      }
    }
    function findConflictsBetweenSubSelectionSets(e, t, r, n, o, s, i, a) {
      const A = [];
      const [c, u] = getFieldsAndFragmentNames(e, t, o, s);
      const [l, p] = getFieldsAndFragmentNames(e, t, i, a);
      collectConflictsBetween(e, A, t, r, n, c, l);
      for (const o of p) {
        collectConflictsBetweenFieldsAndFragment(e, A, t, r, n, c, o);
      }
      for (const o of u) {
        collectConflictsBetweenFieldsAndFragment(e, A, t, r, n, l, o);
      }
      for (const o of u) {
        for (const s of p) {
          collectConflictsBetweenFragments(e, A, t, r, n, o, s);
        }
      }
      return A;
    }
    function collectConflictsWithin(e, t, r, n, o) {
      for (const [s, i] of Object.entries(o)) {
        if (i.length > 1) {
          for (let o = 0; o < i.length; o++) {
            for (let a = o + 1; a < i.length; a++) {
              const A = findConflict(e, r, n, false, s, i[o], i[a]);
              if (A) {
                t.push(A);
              }
            }
          }
        }
      }
    }
    function collectConflictsBetween(e, t, r, n, o, s, i) {
      for (const [a, A] of Object.entries(s)) {
        const s = i[a];
        if (s) {
          for (const i of A) {
            for (const A of s) {
              const s = findConflict(e, r, n, o, a, i, A);
              if (s) {
                t.push(s);
              }
            }
          }
        }
      }
    }
    function findConflict(e, t, r, o, s, i, A) {
      const [c, u, l] = i;
      const [p, d, g] = A;
      const m = o || (c !== p && (0, a.isObjectType)(c) && (0, a.isObjectType)(p));
      if (!m) {
        const e = u.name.value;
        const t = d.name.value;
        if (e !== t) {
          return [[s, `"${e}" and "${t}" are different fields`], [u], [d]];
        }
        if (!sameArguments(u, d)) {
          return [[s, "they have differing arguments"], [u], [d]];
        }
      }
      const h = l === null || l === void 0 ? void 0 : l.type;
      const E = g === null || g === void 0 ? void 0 : g.type;
      if (h && E && doTypesConflict(h, E)) {
        return [[s, `they return conflicting types "${(0, n.inspect)(h)}" and "${(0, n.inspect)(E)}"`], [u], [d]];
      }
      const I = u.selectionSet;
      const y = d.selectionSet;
      if (I && y) {
        const n = findConflictsBetweenSubSelectionSets(e, t, r, m, (0, a.getNamedType)(h), I, (0, a.getNamedType)(E), y);
        return subfieldConflicts(n, s, u, d);
      }
    }
    function sameArguments(e, t) {
      const r = e.arguments;
      const n = t.arguments;
      if (r === undefined || r.length === 0) {
        return n === undefined || n.length === 0;
      }
      if (n === undefined || n.length === 0) {
        return false;
      }
      if (r.length !== n.length) {
        return false;
      }
      const o = new Map(n.map(({ name: e, value: t }) => [e.value, t]));
      return r.every((e) => {
        const t = e.value;
        const r = o.get(e.name.value);
        if (r === undefined) {
          return false;
        }
        return stringifyValue(t) === stringifyValue(r);
      });
    }
    function stringifyValue(e) {
      return (0, i.print)((0, A.sortValueNode)(e));
    }
    function doTypesConflict(e, t) {
      if ((0, a.isListType)(e)) {
        return (0, a.isListType)(t) ? doTypesConflict(e.ofType, t.ofType) : true;
      }
      if ((0, a.isListType)(t)) {
        return true;
      }
      if ((0, a.isNonNullType)(e)) {
        return (0, a.isNonNullType)(t) ? doTypesConflict(e.ofType, t.ofType) : true;
      }
      if ((0, a.isNonNullType)(t)) {
        return true;
      }
      if ((0, a.isLeafType)(e) || (0, a.isLeafType)(t)) {
        return e !== t;
      }
      return false;
    }
    function getFieldsAndFragmentNames(e, t, r, n) {
      const o = t.get(n);
      if (o) {
        return o;
      }
      const s = Object.create(null);
      const i = Object.create(null);
      _collectFieldsAndFragmentNames(e, r, n, s, i);
      const a = [s, Object.keys(i)];
      t.set(n, a);
      return a;
    }
    function getReferencedFieldsAndFragmentNames(e, t, r) {
      const n = t.get(r.selectionSet);
      if (n) {
        return n;
      }
      const o = (0, c.typeFromAST)(e.getSchema(), r.typeCondition);
      return getFieldsAndFragmentNames(e, t, o, r.selectionSet);
    }
    function _collectFieldsAndFragmentNames(e, t, r, n, o) {
      for (const i of r.selections) {
        switch (i.kind) {
          case s.Kind.FIELD: {
            const e = i.name.value;
            let r;
            if ((0, a.isObjectType)(t) || (0, a.isInterfaceType)(t)) {
              r = t.getFields()[e];
            }
            const o = i.alias ? i.alias.value : e;
            if (!n[o]) {
              n[o] = [];
            }
            n[o].push([t, i, r]);
            break;
          }
          case s.Kind.FRAGMENT_SPREAD:
            o[i.name.value] = true;
            break;
          case s.Kind.INLINE_FRAGMENT: {
            const r = i.typeCondition;
            const s = r ? (0, c.typeFromAST)(e.getSchema(), r) : t;
            _collectFieldsAndFragmentNames(e, s, i.selectionSet, n, o);
            break;
          }
        }
      }
    }
    function subfieldConflicts(e, t, r, n) {
      if (e.length > 0) {
        return [
          [t, e.map(([e]) => e)],
          [r, ...e.map(([, e]) => e).flat()],
          [n, ...e.map(([, , e]) => e).flat()],
        ];
      }
    }
    class PairSet {
      constructor() {
        this._data = new Map();
      }
      has(e, t, r) {
        var n;
        const [o, s] = e < t ? [e, t] : [t, e];
        const i = (n = this._data.get(o)) === null || n === void 0 ? void 0 : n.get(s);
        if (i === undefined) {
          return false;
        }
        return r ? true : r === i;
      }
      add(e, t, r) {
        const [n, o] = e < t ? [e, t] : [t, e];
        const s = this._data.get(n);
        if (s === undefined) {
          this._data.set(n, new Map([[o, r]]));
        } else {
          s.set(o, r);
        }
      }
    }
  },
  60135: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.PossibleFragmentSpreadsRule = PossibleFragmentSpreadsRule;
    var n = r(71801);
    var o = r(23750);
    var s = r(46250);
    var i = r(48808);
    var a = r(45669);
    function PossibleFragmentSpreadsRule(e) {
      return {
        InlineFragment(t) {
          const r = e.getType();
          const a = e.getParentType();
          if ((0, s.isCompositeType)(r) && (0, s.isCompositeType)(a) && !(0, i.doTypesOverlap)(e.getSchema(), r, a)) {
            const s = (0, n.inspect)(a);
            const i = (0, n.inspect)(r);
            e.reportError(new o.GraphQLError(`Fragment cannot be spread here as objects of type "${s}" can never be of type "${i}".`, { nodes: t }));
          }
        },
        FragmentSpread(t) {
          const r = t.name.value;
          const s = getFragmentType(e, r);
          const a = e.getParentType();
          if (s && a && !(0, i.doTypesOverlap)(e.getSchema(), s, a)) {
            const i = (0, n.inspect)(a);
            const A = (0, n.inspect)(s);
            e.reportError(new o.GraphQLError(`Fragment "${r}" cannot be spread here as objects of type "${i}" can never be of type "${A}".`, { nodes: t }));
          }
        },
      };
    }
    function getFragmentType(e, t) {
      const r = e.getFragment(t);
      if (r) {
        const t = (0, a.typeFromAST)(e.getSchema(), r.typeCondition);
        if ((0, s.isCompositeType)(t)) {
          return t;
        }
      }
    }
  },
  62641: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.PossibleTypeExtensionsRule = PossibleTypeExtensionsRule;
    var n = r(62384);
    var o = r(71801);
    var s = r(67305);
    var i = r(18765);
    var a = r(23750);
    var A = r(19254);
    var c = r(24147);
    var u = r(46250);
    function PossibleTypeExtensionsRule(e) {
      const t = e.getSchema();
      const r = Object.create(null);
      for (const t of e.getDocument().definitions) {
        if ((0, c.isTypeDefinitionNode)(t)) {
          r[t.name.value] = t;
        }
      }
      return {
        ScalarTypeExtension: checkExtension,
        ObjectTypeExtension: checkExtension,
        InterfaceTypeExtension: checkExtension,
        UnionTypeExtension: checkExtension,
        EnumTypeExtension: checkExtension,
        InputObjectTypeExtension: checkExtension,
      };
      function checkExtension(o) {
        const s = o.name.value;
        const A = r[s];
        const c = t === null || t === void 0 ? void 0 : t.getType(s);
        let u;
        if (A) {
          u = l[A.kind];
        } else if (c) {
          u = typeToExtKind(c);
        }
        if (u) {
          if (u !== o.kind) {
            const t = extensionKindToTypeName(o.kind);
            e.reportError(new a.GraphQLError(`Cannot extend non-${t} type "${s}".`, { nodes: A ? [A, o] : o }));
          }
        } else {
          const A = Object.keys({ ...r, ...(t === null || t === void 0 ? void 0 : t.getTypeMap()) });
          const c = (0, i.suggestionList)(s, A);
          e.reportError(new a.GraphQLError(`Cannot extend type "${s}" because it is not defined.` + (0, n.didYouMean)(c), { nodes: o.name }));
        }
      }
    }
    const l = {
      [A.Kind.SCALAR_TYPE_DEFINITION]: A.Kind.SCALAR_TYPE_EXTENSION,
      [A.Kind.OBJECT_TYPE_DEFINITION]: A.Kind.OBJECT_TYPE_EXTENSION,
      [A.Kind.INTERFACE_TYPE_DEFINITION]: A.Kind.INTERFACE_TYPE_EXTENSION,
      [A.Kind.UNION_TYPE_DEFINITION]: A.Kind.UNION_TYPE_EXTENSION,
      [A.Kind.ENUM_TYPE_DEFINITION]: A.Kind.ENUM_TYPE_EXTENSION,
      [A.Kind.INPUT_OBJECT_TYPE_DEFINITION]: A.Kind.INPUT_OBJECT_TYPE_EXTENSION,
    };
    function typeToExtKind(e) {
      if ((0, u.isScalarType)(e)) {
        return A.Kind.SCALAR_TYPE_EXTENSION;
      }
      if ((0, u.isObjectType)(e)) {
        return A.Kind.OBJECT_TYPE_EXTENSION;
      }
      if ((0, u.isInterfaceType)(e)) {
        return A.Kind.INTERFACE_TYPE_EXTENSION;
      }
      if ((0, u.isUnionType)(e)) {
        return A.Kind.UNION_TYPE_EXTENSION;
      }
      if ((0, u.isEnumType)(e)) {
        return A.Kind.ENUM_TYPE_EXTENSION;
      }
      if ((0, u.isInputObjectType)(e)) {
        return A.Kind.INPUT_OBJECT_TYPE_EXTENSION;
      }
      false || (0, s.invariant)(false, "Unexpected type: " + (0, o.inspect)(e));
    }
    function extensionKindToTypeName(e) {
      switch (e) {
        case A.Kind.SCALAR_TYPE_EXTENSION:
          return "scalar";
        case A.Kind.OBJECT_TYPE_EXTENSION:
          return "object";
        case A.Kind.INTERFACE_TYPE_EXTENSION:
          return "interface";
        case A.Kind.UNION_TYPE_EXTENSION:
          return "union";
        case A.Kind.ENUM_TYPE_EXTENSION:
          return "enum";
        case A.Kind.INPUT_OBJECT_TYPE_EXTENSION:
          return "input object";
        default:
          false || (0, s.invariant)(false, "Unexpected kind: " + (0, o.inspect)(e));
      }
    }
  },
  76648: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ProvidedRequiredArgumentsOnDirectivesRule = ProvidedRequiredArgumentsOnDirectivesRule;
    t.ProvidedRequiredArgumentsRule = ProvidedRequiredArgumentsRule;
    var n = r(71801);
    var o = r(97982);
    var s = r(23750);
    var i = r(19254);
    var a = r(85401);
    var A = r(46250);
    var c = r(58941);
    function ProvidedRequiredArgumentsRule(e) {
      return {
        ...ProvidedRequiredArgumentsOnDirectivesRule(e),
        Field: {
          leave(t) {
            var r;
            const o = e.getFieldDef();
            if (!o) {
              return false;
            }
            const i = new Set((r = t.arguments) === null || r === void 0 ? void 0 : r.map((e) => e.name.value));
            for (const r of o.args) {
              if (!i.has(r.name) && (0, A.isRequiredArgument)(r)) {
                const i = (0, n.inspect)(r.type);
                e.reportError(new s.GraphQLError(`Field "${o.name}" argument "${r.name}" of type "${i}" is required, but it was not provided.`, { nodes: t }));
              }
            }
          },
        },
      };
    }
    function ProvidedRequiredArgumentsOnDirectivesRule(e) {
      var t;
      const r = Object.create(null);
      const u = e.getSchema();
      const l = (t = u === null || u === void 0 ? void 0 : u.getDirectives()) !== null && t !== void 0 ? t : c.specifiedDirectives;
      for (const e of l) {
        r[e.name] = (0, o.keyMap)(e.args.filter(A.isRequiredArgument), (e) => e.name);
      }
      const p = e.getDocument().definitions;
      for (const e of p) {
        if (e.kind === i.Kind.DIRECTIVE_DEFINITION) {
          var d;
          const t = (d = e.arguments) !== null && d !== void 0 ? d : [];
          r[e.name.value] = (0, o.keyMap)(t.filter(isRequiredArgumentNode), (e) => e.name.value);
        }
      }
      return {
        Directive: {
          leave(t) {
            const o = t.name.value;
            const i = r[o];
            if (i) {
              var c;
              const r = (c = t.arguments) !== null && c !== void 0 ? c : [];
              const u = new Set(r.map((e) => e.name.value));
              for (const [r, c] of Object.entries(i)) {
                if (!u.has(r)) {
                  const i = (0, A.isType)(c.type) ? (0, n.inspect)(c.type) : (0, a.print)(c.type);
                  e.reportError(new s.GraphQLError(`Directive "@${o}" argument "${r}" of type "${i}" is required, but it was not provided.`, { nodes: t }));
                }
              }
            }
          },
        },
      };
    }
    function isRequiredArgumentNode(e) {
      return e.type.kind === i.Kind.NON_NULL_TYPE && e.defaultValue == null;
    }
  },
  63827: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ScalarLeafsRule = ScalarLeafsRule;
    var n = r(71801);
    var o = r(23750);
    var s = r(46250);
    function ScalarLeafsRule(e) {
      return {
        Field(t) {
          const r = e.getType();
          const i = t.selectionSet;
          if (r) {
            if ((0, s.isLeafType)((0, s.getNamedType)(r))) {
              if (i) {
                const s = t.name.value;
                const a = (0, n.inspect)(r);
                e.reportError(new o.GraphQLError(`Field "${s}" must not have a selection since type "${a}" has no subfields.`, { nodes: i }));
              }
            } else if (!i) {
              const s = t.name.value;
              const i = (0, n.inspect)(r);
              e.reportError(new o.GraphQLError(`Field "${s}" of type "${i}" must have a selection of subfields. Did you mean "${s} { ... }"?`, { nodes: t }));
            }
          }
        },
      };
    }
  },
  79186: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.SingleFieldSubscriptionsRule = SingleFieldSubscriptionsRule;
    var n = r(23750);
    var o = r(19254);
    var s = r(76092);
    function SingleFieldSubscriptionsRule(e) {
      return {
        OperationDefinition(t) {
          if (t.operation === "subscription") {
            const r = e.getSchema();
            const i = r.getSubscriptionType();
            if (i) {
              const a = t.name ? t.name.value : null;
              const A = Object.create(null);
              const c = e.getDocument();
              const u = Object.create(null);
              for (const e of c.definitions) {
                if (e.kind === o.Kind.FRAGMENT_DEFINITION) {
                  u[e.name.value] = e;
                }
              }
              const l = (0, s.collectFields)(r, u, A, i, t.selectionSet);
              if (l.size > 1) {
                const t = [...l.values()];
                const r = t.slice(1);
                const o = r.flat();
                e.reportError(
                  new n.GraphQLError(
                    a != null ? `Subscription "${a}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                    { nodes: o }
                  )
                );
              }
              for (const t of l.values()) {
                const r = t[0];
                const o = r.name.value;
                if (o.startsWith("__")) {
                  e.reportError(
                    new n.GraphQLError(
                      a != null
                        ? `Subscription "${a}" must not select an introspection top level field.`
                        : "Anonymous Subscription must not select an introspection top level field.",
                      { nodes: t }
                    )
                  );
                }
              }
            }
          }
        },
      };
    }
  },
  39549: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueArgumentDefinitionNamesRule = UniqueArgumentDefinitionNamesRule;
    var n = r(91763);
    var o = r(23750);
    function UniqueArgumentDefinitionNamesRule(e) {
      return {
        DirectiveDefinition(e) {
          var t;
          const r = (t = e.arguments) !== null && t !== void 0 ? t : [];
          return checkArgUniqueness(`@${e.name.value}`, r);
        },
        InterfaceTypeDefinition: checkArgUniquenessPerField,
        InterfaceTypeExtension: checkArgUniquenessPerField,
        ObjectTypeDefinition: checkArgUniquenessPerField,
        ObjectTypeExtension: checkArgUniquenessPerField,
      };
      function checkArgUniquenessPerField(e) {
        var t;
        const r = e.name.value;
        const n = (t = e.fields) !== null && t !== void 0 ? t : [];
        for (const e of n) {
          var o;
          const t = e.name.value;
          const n = (o = e.arguments) !== null && o !== void 0 ? o : [];
          checkArgUniqueness(`${r}.${t}`, n);
        }
        return false;
      }
      function checkArgUniqueness(t, r) {
        const s = (0, n.groupBy)(r, (e) => e.name.value);
        for (const [r, n] of s) {
          if (n.length > 1) {
            e.reportError(new o.GraphQLError(`Argument "${t}(${r}:)" can only be defined once.`, { nodes: n.map((e) => e.name) }));
          }
        }
        return false;
      }
    }
  },
  42894: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueArgumentNamesRule = UniqueArgumentNamesRule;
    var n = r(91763);
    var o = r(23750);
    function UniqueArgumentNamesRule(e) {
      return { Field: checkArgUniqueness, Directive: checkArgUniqueness };
      function checkArgUniqueness(t) {
        var r;
        const s = (r = t.arguments) !== null && r !== void 0 ? r : [];
        const i = (0, n.groupBy)(s, (e) => e.name.value);
        for (const [t, r] of i) {
          if (r.length > 1) {
            e.reportError(new o.GraphQLError(`There can be only one argument named "${t}".`, { nodes: r.map((e) => e.name) }));
          }
        }
      }
    }
  },
  95172: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueDirectiveNamesRule = UniqueDirectiveNamesRule;
    var n = r(23750);
    function UniqueDirectiveNamesRule(e) {
      const t = Object.create(null);
      const r = e.getSchema();
      return {
        DirectiveDefinition(o) {
          const s = o.name.value;
          if (r !== null && r !== void 0 && r.getDirective(s)) {
            e.reportError(new n.GraphQLError(`Directive "@${s}" already exists in the schema. It cannot be redefined.`, { nodes: o.name }));
            return;
          }
          if (t[s]) {
            e.reportError(new n.GraphQLError(`There can be only one directive named "@${s}".`, { nodes: [t[s], o.name] }));
          } else {
            t[s] = o.name;
          }
          return false;
        },
      };
    }
  },
  5033: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueDirectivesPerLocationRule = UniqueDirectivesPerLocationRule;
    var n = r(23750);
    var o = r(19254);
    var s = r(24147);
    var i = r(58941);
    function UniqueDirectivesPerLocationRule(e) {
      const t = Object.create(null);
      const r = e.getSchema();
      const a = r ? r.getDirectives() : i.specifiedDirectives;
      for (const e of a) {
        t[e.name] = !e.isRepeatable;
      }
      const A = e.getDocument().definitions;
      for (const e of A) {
        if (e.kind === o.Kind.DIRECTIVE_DEFINITION) {
          t[e.name.value] = !e.repeatable;
        }
      }
      const c = Object.create(null);
      const u = Object.create(null);
      return {
        enter(r) {
          if (!("directives" in r) || !r.directives) {
            return;
          }
          let i;
          if (r.kind === o.Kind.SCHEMA_DEFINITION || r.kind === o.Kind.SCHEMA_EXTENSION) {
            i = c;
          } else if ((0, s.isTypeDefinitionNode)(r) || (0, s.isTypeExtensionNode)(r)) {
            const e = r.name.value;
            i = u[e];
            if (i === undefined) {
              u[e] = i = Object.create(null);
            }
          } else {
            i = Object.create(null);
          }
          for (const o of r.directives) {
            const r = o.name.value;
            if (t[r]) {
              if (i[r]) {
                e.reportError(new n.GraphQLError(`The directive "@${r}" can only be used once at this location.`, { nodes: [i[r], o] }));
              } else {
                i[r] = o;
              }
            }
          }
        },
      };
    }
  },
  77077: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueEnumValueNamesRule = UniqueEnumValueNamesRule;
    var n = r(23750);
    var o = r(46250);
    function UniqueEnumValueNamesRule(e) {
      const t = e.getSchema();
      const r = t ? t.getTypeMap() : Object.create(null);
      const s = Object.create(null);
      return { EnumTypeDefinition: checkValueUniqueness, EnumTypeExtension: checkValueUniqueness };
      function checkValueUniqueness(t) {
        var i;
        const a = t.name.value;
        if (!s[a]) {
          s[a] = Object.create(null);
        }
        const A = (i = t.values) !== null && i !== void 0 ? i : [];
        const c = s[a];
        for (const t of A) {
          const s = t.name.value;
          const i = r[a];
          if ((0, o.isEnumType)(i) && i.getValue(s)) {
            e.reportError(
              new n.GraphQLError(`Enum value "${a}.${s}" already exists in the schema. It cannot also be defined in this type extension.`, { nodes: t.name })
            );
          } else if (c[s]) {
            e.reportError(new n.GraphQLError(`Enum value "${a}.${s}" can only be defined once.`, { nodes: [c[s], t.name] }));
          } else {
            c[s] = t.name;
          }
        }
        return false;
      }
    }
  },
  46108: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueFieldDefinitionNamesRule = UniqueFieldDefinitionNamesRule;
    var n = r(23750);
    var o = r(46250);
    function UniqueFieldDefinitionNamesRule(e) {
      const t = e.getSchema();
      const r = t ? t.getTypeMap() : Object.create(null);
      const o = Object.create(null);
      return {
        InputObjectTypeDefinition: checkFieldUniqueness,
        InputObjectTypeExtension: checkFieldUniqueness,
        InterfaceTypeDefinition: checkFieldUniqueness,
        InterfaceTypeExtension: checkFieldUniqueness,
        ObjectTypeDefinition: checkFieldUniqueness,
        ObjectTypeExtension: checkFieldUniqueness,
      };
      function checkFieldUniqueness(t) {
        var s;
        const i = t.name.value;
        if (!o[i]) {
          o[i] = Object.create(null);
        }
        const a = (s = t.fields) !== null && s !== void 0 ? s : [];
        const A = o[i];
        for (const t of a) {
          const o = t.name.value;
          if (hasField(r[i], o)) {
            e.reportError(
              new n.GraphQLError(`Field "${i}.${o}" already exists in the schema. It cannot also be defined in this type extension.`, { nodes: t.name })
            );
          } else if (A[o]) {
            e.reportError(new n.GraphQLError(`Field "${i}.${o}" can only be defined once.`, { nodes: [A[o], t.name] }));
          } else {
            A[o] = t.name;
          }
        }
        return false;
      }
    }
    function hasField(e, t) {
      if ((0, o.isObjectType)(e) || (0, o.isInterfaceType)(e) || (0, o.isInputObjectType)(e)) {
        return e.getFields()[t] != null;
      }
      return false;
    }
  },
  78643: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueFragmentNamesRule = UniqueFragmentNamesRule;
    var n = r(23750);
    function UniqueFragmentNamesRule(e) {
      const t = Object.create(null);
      return {
        OperationDefinition: () => false,
        FragmentDefinition(r) {
          const o = r.name.value;
          if (t[o]) {
            e.reportError(new n.GraphQLError(`There can be only one fragment named "${o}".`, { nodes: [t[o], r.name] }));
          } else {
            t[o] = r.name;
          }
          return false;
        },
      };
    }
  },
  46067: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueInputFieldNamesRule = UniqueInputFieldNamesRule;
    var n = r(67305);
    var o = r(23750);
    function UniqueInputFieldNamesRule(e) {
      const t = [];
      let r = Object.create(null);
      return {
        ObjectValue: {
          enter() {
            t.push(r);
            r = Object.create(null);
          },
          leave() {
            const e = t.pop();
            e || (0, n.invariant)(false);
            r = e;
          },
        },
        ObjectField(t) {
          const n = t.name.value;
          if (r[n]) {
            e.reportError(new o.GraphQLError(`There can be only one input field named "${n}".`, { nodes: [r[n], t.name] }));
          } else {
            r[n] = t.name;
          }
        },
      };
    }
  },
  76196: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueOperationNamesRule = UniqueOperationNamesRule;
    var n = r(23750);
    function UniqueOperationNamesRule(e) {
      const t = Object.create(null);
      return {
        OperationDefinition(r) {
          const o = r.name;
          if (o) {
            if (t[o.value]) {
              e.reportError(new n.GraphQLError(`There can be only one operation named "${o.value}".`, { nodes: [t[o.value], o] }));
            } else {
              t[o.value] = o;
            }
          }
          return false;
        },
        FragmentDefinition: () => false,
      };
    }
  },
  53385: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueOperationTypesRule = UniqueOperationTypesRule;
    var n = r(23750);
    function UniqueOperationTypesRule(e) {
      const t = e.getSchema();
      const r = Object.create(null);
      const o = t ? { query: t.getQueryType(), mutation: t.getMutationType(), subscription: t.getSubscriptionType() } : {};
      return { SchemaDefinition: checkOperationTypes, SchemaExtension: checkOperationTypes };
      function checkOperationTypes(t) {
        var s;
        const i = (s = t.operationTypes) !== null && s !== void 0 ? s : [];
        for (const t of i) {
          const s = t.operation;
          const i = r[s];
          if (o[s]) {
            e.reportError(new n.GraphQLError(`Type for ${s} already defined in the schema. It cannot be redefined.`, { nodes: t }));
          } else if (i) {
            e.reportError(new n.GraphQLError(`There can be only one ${s} type in schema.`, { nodes: [i, t] }));
          } else {
            r[s] = t;
          }
        }
        return false;
      }
    }
  },
  81795: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueTypeNamesRule = UniqueTypeNamesRule;
    var n = r(23750);
    function UniqueTypeNamesRule(e) {
      const t = Object.create(null);
      const r = e.getSchema();
      return {
        ScalarTypeDefinition: checkTypeName,
        ObjectTypeDefinition: checkTypeName,
        InterfaceTypeDefinition: checkTypeName,
        UnionTypeDefinition: checkTypeName,
        EnumTypeDefinition: checkTypeName,
        InputObjectTypeDefinition: checkTypeName,
      };
      function checkTypeName(o) {
        const s = o.name.value;
        if (r !== null && r !== void 0 && r.getType(s)) {
          e.reportError(new n.GraphQLError(`Type "${s}" already exists in the schema. It cannot also be defined in this type definition.`, { nodes: o.name }));
          return;
        }
        if (t[s]) {
          e.reportError(new n.GraphQLError(`There can be only one type named "${s}".`, { nodes: [t[s], o.name] }));
        } else {
          t[s] = o.name;
        }
        return false;
      }
    }
  },
  36055: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UniqueVariableNamesRule = UniqueVariableNamesRule;
    var n = r(91763);
    var o = r(23750);
    function UniqueVariableNamesRule(e) {
      return {
        OperationDefinition(t) {
          var r;
          const s = (r = t.variableDefinitions) !== null && r !== void 0 ? r : [];
          const i = (0, n.groupBy)(s, (e) => e.variable.name.value);
          for (const [t, r] of i) {
            if (r.length > 1) {
              e.reportError(new o.GraphQLError(`There can be only one variable named "$${t}".`, { nodes: r.map((e) => e.variable.name) }));
            }
          }
        },
      };
    }
  },
  38245: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ValuesOfCorrectTypeRule = ValuesOfCorrectTypeRule;
    var n = r(62384);
    var o = r(71801);
    var s = r(97982);
    var i = r(18765);
    var a = r(23750);
    var A = r(19254);
    var c = r(85401);
    var u = r(46250);
    function ValuesOfCorrectTypeRule(e) {
      let t = {};
      return {
        OperationDefinition: {
          enter() {
            t = {};
          },
        },
        VariableDefinition(e) {
          t[e.variable.name.value] = e;
        },
        ListValue(t) {
          const r = (0, u.getNullableType)(e.getParentInputType());
          if (!(0, u.isListType)(r)) {
            isValidValueNode(e, t);
            return false;
          }
        },
        ObjectValue(r) {
          const n = (0, u.getNamedType)(e.getInputType());
          if (!(0, u.isInputObjectType)(n)) {
            isValidValueNode(e, r);
            return false;
          }
          const i = (0, s.keyMap)(r.fields, (e) => e.name.value);
          for (const t of Object.values(n.getFields())) {
            const s = i[t.name];
            if (!s && (0, u.isRequiredInputField)(t)) {
              const s = (0, o.inspect)(t.type);
              e.reportError(new a.GraphQLError(`Field "${n.name}.${t.name}" of required type "${s}" was not provided.`, { nodes: r }));
            }
          }
          if (n.isOneOf) {
            validateOneOfInputObject(e, r, n, i, t);
          }
        },
        ObjectField(t) {
          const r = (0, u.getNamedType)(e.getParentInputType());
          const o = e.getInputType();
          if (!o && (0, u.isInputObjectType)(r)) {
            const o = (0, i.suggestionList)(t.name.value, Object.keys(r.getFields()));
            e.reportError(new a.GraphQLError(`Field "${t.name.value}" is not defined by type "${r.name}".` + (0, n.didYouMean)(o), { nodes: t }));
          }
        },
        NullValue(t) {
          const r = e.getInputType();
          if ((0, u.isNonNullType)(r)) {
            e.reportError(new a.GraphQLError(`Expected value of type "${(0, o.inspect)(r)}", found ${(0, c.print)(t)}.`, { nodes: t }));
          }
        },
        EnumValue: (t) => isValidValueNode(e, t),
        IntValue: (t) => isValidValueNode(e, t),
        FloatValue: (t) => isValidValueNode(e, t),
        StringValue: (t) => isValidValueNode(e, t),
        BooleanValue: (t) => isValidValueNode(e, t),
      };
    }
    function isValidValueNode(e, t) {
      const r = e.getInputType();
      if (!r) {
        return;
      }
      const n = (0, u.getNamedType)(r);
      if (!(0, u.isLeafType)(n)) {
        const n = (0, o.inspect)(r);
        e.reportError(new a.GraphQLError(`Expected value of type "${n}", found ${(0, c.print)(t)}.`, { nodes: t }));
        return;
      }
      try {
        const s = n.parseLiteral(t, undefined);
        if (s === undefined) {
          const n = (0, o.inspect)(r);
          e.reportError(new a.GraphQLError(`Expected value of type "${n}", found ${(0, c.print)(t)}.`, { nodes: t }));
        }
      } catch (n) {
        const s = (0, o.inspect)(r);
        if (n instanceof a.GraphQLError) {
          e.reportError(n);
        } else {
          e.reportError(new a.GraphQLError(`Expected value of type "${s}", found ${(0, c.print)(t)}; ` + n.message, { nodes: t, originalError: n }));
        }
      }
    }
    function validateOneOfInputObject(e, t, r, n, o) {
      var s;
      const i = Object.keys(n);
      const c = i.length !== 1;
      if (c) {
        e.reportError(new a.GraphQLError(`OneOf Input Object "${r.name}" must specify exactly one key.`, { nodes: [t] }));
        return;
      }
      const u = (s = n[i[0]]) === null || s === void 0 ? void 0 : s.value;
      const l = !u || u.kind === A.Kind.NULL;
      const p = (u === null || u === void 0 ? void 0 : u.kind) === A.Kind.VARIABLE;
      if (l) {
        e.reportError(new a.GraphQLError(`Field "${r.name}.${i[0]}" must be non-null.`, { nodes: [t] }));
        return;
      }
      if (p) {
        const n = u.name.value;
        const s = o[n];
        const i = s.type.kind !== A.Kind.NON_NULL_TYPE;
        if (i) {
          e.reportError(new a.GraphQLError(`Variable "${n}" must be non-nullable to be used for OneOf Input Object "${r.name}".`, { nodes: [t] }));
        }
      }
    }
  },
  76436: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.VariablesAreInputTypesRule = VariablesAreInputTypesRule;
    var n = r(23750);
    var o = r(85401);
    var s = r(46250);
    var i = r(45669);
    function VariablesAreInputTypesRule(e) {
      return {
        VariableDefinition(t) {
          const r = (0, i.typeFromAST)(e.getSchema(), t.type);
          if (r !== undefined && !(0, s.isInputType)(r)) {
            const r = t.variable.name.value;
            const s = (0, o.print)(t.type);
            e.reportError(new n.GraphQLError(`Variable "$${r}" cannot be non-input type "${s}".`, { nodes: t.type }));
          }
        },
      };
    }
  },
  80041: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.VariablesInAllowedPositionRule = VariablesInAllowedPositionRule;
    var n = r(71801);
    var o = r(23750);
    var s = r(19254);
    var i = r(46250);
    var a = r(48808);
    var A = r(45669);
    function VariablesInAllowedPositionRule(e) {
      let t = Object.create(null);
      return {
        OperationDefinition: {
          enter() {
            t = Object.create(null);
          },
          leave(r) {
            const s = e.getRecursiveVariableUsages(r);
            for (const { node: r, type: i, defaultValue: a } of s) {
              const s = r.name.value;
              const c = t[s];
              if (c && i) {
                const t = e.getSchema();
                const u = (0, A.typeFromAST)(t, c.type);
                if (u && !allowedVariableUsage(t, u, c.defaultValue, i, a)) {
                  const t = (0, n.inspect)(u);
                  const a = (0, n.inspect)(i);
                  e.reportError(new o.GraphQLError(`Variable "$${s}" of type "${t}" used in position expecting type "${a}".`, { nodes: [c, r] }));
                }
              }
            }
          },
        },
        VariableDefinition(e) {
          t[e.variable.name.value] = e;
        },
      };
    }
    function allowedVariableUsage(e, t, r, n, o) {
      if ((0, i.isNonNullType)(n) && !(0, i.isNonNullType)(t)) {
        const i = r != null && r.kind !== s.Kind.NULL;
        const A = o !== undefined;
        if (!i && !A) {
          return false;
        }
        const c = n.ofType;
        return (0, a.isTypeSubTypeOf)(e, t, c);
      }
      return (0, a.isTypeSubTypeOf)(e, t, n);
    }
  },
  10091: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.NoDeprecatedCustomRule = NoDeprecatedCustomRule;
    var n = r(67305);
    var o = r(23750);
    var s = r(46250);
    function NoDeprecatedCustomRule(e) {
      return {
        Field(t) {
          const r = e.getFieldDef();
          const s = r === null || r === void 0 ? void 0 : r.deprecationReason;
          if (r && s != null) {
            const i = e.getParentType();
            i != null || (0, n.invariant)(false);
            e.reportError(new o.GraphQLError(`The field ${i.name}.${r.name} is deprecated. ${s}`, { nodes: t }));
          }
        },
        Argument(t) {
          const r = e.getArgument();
          const s = r === null || r === void 0 ? void 0 : r.deprecationReason;
          if (r && s != null) {
            const i = e.getDirective();
            if (i != null) {
              e.reportError(new o.GraphQLError(`Directive "@${i.name}" argument "${r.name}" is deprecated. ${s}`, { nodes: t }));
            } else {
              const i = e.getParentType();
              const a = e.getFieldDef();
              (i != null && a != null) || (0, n.invariant)(false);
              e.reportError(new o.GraphQLError(`Field "${i.name}.${a.name}" argument "${r.name}" is deprecated. ${s}`, { nodes: t }));
            }
          }
        },
        ObjectField(t) {
          const r = (0, s.getNamedType)(e.getParentInputType());
          if ((0, s.isInputObjectType)(r)) {
            const n = r.getFields()[t.name.value];
            const s = n === null || n === void 0 ? void 0 : n.deprecationReason;
            if (s != null) {
              e.reportError(new o.GraphQLError(`The input field ${r.name}.${n.name} is deprecated. ${s}`, { nodes: t }));
            }
          }
        },
        EnumValue(t) {
          const r = e.getEnumValue();
          const i = r === null || r === void 0 ? void 0 : r.deprecationReason;
          if (r && i != null) {
            const a = (0, s.getNamedType)(e.getInputType());
            a != null || (0, n.invariant)(false);
            e.reportError(new o.GraphQLError(`The enum value "${a.name}.${r.name}" is deprecated. ${i}`, { nodes: t }));
          }
        },
      };
    }
  },
  43924: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.NoSchemaIntrospectionCustomRule = NoSchemaIntrospectionCustomRule;
    var n = r(23750);
    var o = r(46250);
    var s = r(47564);
    function NoSchemaIntrospectionCustomRule(e) {
      return {
        Field(t) {
          const r = (0, o.getNamedType)(e.getType());
          if (r && (0, s.isIntrospectionType)(r)) {
            e.reportError(
              new n.GraphQLError(`GraphQL introspection has been disabled, but the requested query contained the field "${t.name.value}".`, { nodes: t })
            );
          }
        },
      };
    }
  },
  81075: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.specifiedSDLRules = t.specifiedRules = t.recommendedRules = void 0;
    var n = r(28668);
    var o = r(42775);
    var s = r(28690);
    var i = r(90284);
    var a = r(8207);
    var A = r(34181);
    var c = r(36237);
    var u = r(29978);
    var l = r(97574);
    var p = r(95776);
    var d = r(9408);
    var g = r(60838);
    var m = r(42072);
    var h = r(86808);
    var E = r(43481);
    var I = r(60135);
    var y = r(62641);
    var C = r(76648);
    var b = r(63827);
    var Q = r(79186);
    var B = r(39549);
    var T = r(42894);
    var v = r(95172);
    var w = r(5033);
    var _ = r(77077);
    var R = r(46108);
    var O = r(78643);
    var F = r(46067);
    var D = r(76196);
    var k = r(53385);
    var S = r(81795);
    var N = r(36055);
    var P = r(38245);
    var L = r(76436);
    var U = r(80041);
    const M = Object.freeze([p.MaxIntrospectionDepthRule]);
    t.recommendedRules = M;
    const G = Object.freeze([
      n.ExecutableDefinitionsRule,
      D.UniqueOperationNamesRule,
      u.LoneAnonymousOperationRule,
      Q.SingleFieldSubscriptionsRule,
      c.KnownTypeNamesRule,
      s.FragmentsOnCompositeTypesRule,
      L.VariablesAreInputTypesRule,
      b.ScalarLeafsRule,
      o.FieldsOnCorrectTypeRule,
      O.UniqueFragmentNamesRule,
      A.KnownFragmentNamesRule,
      m.NoUnusedFragmentsRule,
      I.PossibleFragmentSpreadsRule,
      d.NoFragmentCyclesRule,
      N.UniqueVariableNamesRule,
      g.NoUndefinedVariablesRule,
      h.NoUnusedVariablesRule,
      a.KnownDirectivesRule,
      w.UniqueDirectivesPerLocationRule,
      i.KnownArgumentNamesRule,
      T.UniqueArgumentNamesRule,
      P.ValuesOfCorrectTypeRule,
      C.ProvidedRequiredArgumentsRule,
      U.VariablesInAllowedPositionRule,
      E.OverlappingFieldsCanBeMergedRule,
      F.UniqueInputFieldNamesRule,
      ...M,
    ]);
    t.specifiedRules = G;
    const x = Object.freeze([
      l.LoneSchemaDefinitionRule,
      k.UniqueOperationTypesRule,
      S.UniqueTypeNamesRule,
      _.UniqueEnumValueNamesRule,
      R.UniqueFieldDefinitionNamesRule,
      B.UniqueArgumentDefinitionNamesRule,
      v.UniqueDirectiveNamesRule,
      c.KnownTypeNamesRule,
      a.KnownDirectivesRule,
      w.UniqueDirectivesPerLocationRule,
      y.PossibleTypeExtensionsRule,
      i.KnownArgumentNamesOnDirectivesRule,
      T.UniqueArgumentNamesRule,
      F.UniqueInputFieldNamesRule,
      C.ProvidedRequiredArgumentsOnDirectivesRule,
    ]);
    t.specifiedSDLRules = x;
  },
  90592: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.assertValidSDL = assertValidSDL;
    t.assertValidSDLExtension = assertValidSDLExtension;
    t.validate = validate;
    t.validateSDL = validateSDL;
    var n = r(53284);
    var o = r(23750);
    var s = r(45399);
    var i = r(22689);
    var a = r(71165);
    var A = r(81075);
    var c = r(18686);
    function validate(e, t, r = A.specifiedRules, u, l = new a.TypeInfo(e)) {
      var p;
      const d = (p = u === null || u === void 0 ? void 0 : u.maxErrors) !== null && p !== void 0 ? p : 100;
      t || (0, n.devAssert)(false, "Must provide document.");
      (0, i.assertValidSchema)(e);
      const g = Object.freeze({});
      const m = [];
      const h = new c.ValidationContext(e, t, l, (e) => {
        if (m.length >= d) {
          m.push(new o.GraphQLError("Too many validation errors, error limit reached. Validation aborted."));
          throw g;
        }
        m.push(e);
      });
      const E = (0, s.visitInParallel)(r.map((e) => e(h)));
      try {
        (0, s.visit)(t, (0, a.visitWithTypeInfo)(l, E));
      } catch (e) {
        if (e !== g) {
          throw e;
        }
      }
      return m;
    }
    function validateSDL(e, t, r = A.specifiedSDLRules) {
      const n = [];
      const o = new c.SDLValidationContext(e, t, (e) => {
        n.push(e);
      });
      const i = r.map((e) => e(o));
      (0, s.visit)(e, (0, s.visitInParallel)(i));
      return n;
    }
    function assertValidSDL(e) {
      const t = validateSDL(e);
      if (t.length !== 0) {
        throw new Error(t.map((e) => e.message).join("\n\n"));
      }
    }
    function assertValidSDLExtension(e, t) {
      const r = validateSDL(e, t);
      if (r.length !== 0) {
        throw new Error(r.map((e) => e.message).join("\n\n"));
      }
    }
  },
  28818: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.versionInfo = t.version = void 0;
    const r = "16.9.0";
    t.version = r;
    const n = Object.freeze({ major: 16, minor: 9, patch: 0, preReleaseTag: null });
    t.versionInfo = n;
  },
  70007: (e, t, r) => {
    var n = Object.defineProperty;
    var o = Object.getOwnPropertyDescriptor;
    var s = Object.getOwnPropertyNames;
    var i = Object.prototype.hasOwnProperty;
    var __export = (e, t) => {
      for (var r in t) n(e, r, { get: t[r], enumerable: true });
    };
    var __copyProps = (e, t, r, a) => {
      if ((t && typeof t === "object") || typeof t === "function") {
        for (let A of s(t)) if (!i.call(e, A) && A !== r) n(e, A, { get: () => t[A], enumerable: !(a = o(t, A)) || a.enumerable });
      }
      return e;
    };
    var __toCommonJS = (e) => __copyProps(n({}, "__esModule", { value: true }), e);
    var a = {};
    __export(a, { GraphqlResponseError: () => d, graphql: () => E, withCustomRequest: () => withCustomRequest });
    e.exports = __toCommonJS(a);
    var A = r(66255);
    var c = r(33843);
    var u = "7.1.0";
    var l = r(66255);
    var p = r(66255);
    function _buildMessageForResponseErrors(e) {
      return `Request failed due to following response errors:\n` + e.errors.map((e) => ` - ${e.message}`).join("\n");
    }
    var d = class extends Error {
      constructor(e, t, r) {
        super(_buildMessageForResponseErrors(r));
        this.request = e;
        this.headers = t;
        this.response = r;
        this.name = "GraphqlResponseError";
        this.errors = r.errors;
        this.data = r.data;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
      }
    };
    var g = ["method", "baseUrl", "url", "headers", "request", "query", "mediaType"];
    var m = ["query", "method", "url"];
    var h = /\/api\/v3\/?$/;
    function graphql(e, t, r) {
      if (r) {
        if (typeof t === "string" && "query" in r) {
          return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
        }
        for (const e in r) {
          if (!m.includes(e)) continue;
          return Promise.reject(new Error(`[@octokit/graphql] "${e}" cannot be used as variable name`));
        }
      }
      const n = typeof t === "string" ? Object.assign({ query: t }, r) : t;
      const o = Object.keys(n).reduce((e, t) => {
        if (g.includes(t)) {
          e[t] = n[t];
          return e;
        }
        if (!e.variables) {
          e.variables = {};
        }
        e.variables[t] = n[t];
        return e;
      }, {});
      const s = n.baseUrl || e.endpoint.DEFAULTS.baseUrl;
      if (h.test(s)) {
        o.url = s.replace(h, "/api/graphql");
      }
      return e(o).then((e) => {
        if (e.data.errors) {
          const t = {};
          for (const r of Object.keys(e.headers)) {
            t[r] = e.headers[r];
          }
          throw new d(o, t, e.data);
        }
        return e.data.data;
      });
    }
    function withDefaults(e, t) {
      const r = e.defaults(t);
      const newApi = (e, t) => graphql(r, e, t);
      return Object.assign(newApi, { defaults: withDefaults.bind(null, r), endpoint: r.endpoint });
    }
    var E = withDefaults(A.request, { headers: { "user-agent": `octokit-graphql.js/${u} ${(0, c.getUserAgent)()}` }, method: "POST", url: "/graphql" });
    function withCustomRequest(e) {
      return withDefaults(e, { method: "POST", url: "/graphql" });
    }
    0 && 0;
  },
  38082: (e) => {
    var t = Object.defineProperty;
    var r = Object.getOwnPropertyDescriptor;
    var n = Object.getOwnPropertyNames;
    var o = Object.prototype.hasOwnProperty;
    var __export = (e, r) => {
      for (var n in r) t(e, n, { get: r[n], enumerable: true });
    };
    var __copyProps = (e, s, i, a) => {
      if ((s && typeof s === "object") || typeof s === "function") {
        for (let A of n(s)) if (!o.call(e, A) && A !== i) t(e, A, { get: () => s[A], enumerable: !(a = r(s, A)) || a.enumerable });
      }
      return e;
    };
    var __toCommonJS = (e) => __copyProps(t({}, "__esModule", { value: true }), e);
    var s = {};
    __export(s, {
      composePaginateRest: () => a,
      isPaginatingEndpoint: () => isPaginatingEndpoint,
      paginateRest: () => paginateRest,
      paginatingEndpoints: () => A,
    });
    e.exports = __toCommonJS(s);
    var i = "11.3.1";
    function normalizePaginatedListResponse(e) {
      if (!e.data) {
        return { ...e, data: [] };
      }
      const t = "total_count" in e.data && !("url" in e.data);
      if (!t) return e;
      const r = e.data.incomplete_results;
      const n = e.data.repository_selection;
      const o = e.data.total_count;
      delete e.data.incomplete_results;
      delete e.data.repository_selection;
      delete e.data.total_count;
      const s = Object.keys(e.data)[0];
      const i = e.data[s];
      e.data = i;
      if (typeof r !== "undefined") {
        e.data.incomplete_results = r;
      }
      if (typeof n !== "undefined") {
        e.data.repository_selection = n;
      }
      e.data.total_count = o;
      return e;
    }
    function iterator(e, t, r) {
      const n = typeof t === "function" ? t.endpoint(r) : e.request.endpoint(t, r);
      const o = typeof t === "function" ? t : e.request;
      const s = n.method;
      const i = n.headers;
      let a = n.url;
      return {
        [Symbol.asyncIterator]: () => ({
          async next() {
            if (!a) return { done: true };
            try {
              const e = await o({ method: s, url: a, headers: i });
              const t = normalizePaginatedListResponse(e);
              a = ((t.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
              return { value: t };
            } catch (e) {
              if (e.status !== 409) throw e;
              a = "";
              return { value: { status: 200, headers: {}, data: [] } };
            }
          },
        }),
      };
    }
    function paginate(e, t, r, n) {
      if (typeof r === "function") {
        n = r;
        r = void 0;
      }
      return gather(e, [], iterator(e, t, r)[Symbol.asyncIterator](), n);
    }
    function gather(e, t, r, n) {
      return r.next().then((o) => {
        if (o.done) {
          return t;
        }
        let s = false;
        function done() {
          s = true;
        }
        t = t.concat(n ? n(o.value, done) : o.value.data);
        if (s) {
          return t;
        }
        return gather(e, t, r, n);
      });
    }
    var a = Object.assign(paginate, { iterator: iterator });
    var A = [
      "GET /advisories",
      "GET /app/hook/deliveries",
      "GET /app/installation-requests",
      "GET /app/installations",
      "GET /assignments/{assignment_id}/accepted_assignments",
      "GET /classrooms",
      "GET /classrooms/{classroom_id}/assignments",
      "GET /enterprises/{enterprise}/copilot/usage",
      "GET /enterprises/{enterprise}/dependabot/alerts",
      "GET /enterprises/{enterprise}/secret-scanning/alerts",
      "GET /events",
      "GET /gists",
      "GET /gists/public",
      "GET /gists/starred",
      "GET /gists/{gist_id}/comments",
      "GET /gists/{gist_id}/commits",
      "GET /gists/{gist_id}/forks",
      "GET /installation/repositories",
      "GET /issues",
      "GET /licenses",
      "GET /marketplace_listing/plans",
      "GET /marketplace_listing/plans/{plan_id}/accounts",
      "GET /marketplace_listing/stubbed/plans",
      "GET /marketplace_listing/stubbed/plans/{plan_id}/accounts",
      "GET /networks/{owner}/{repo}/events",
      "GET /notifications",
      "GET /organizations",
      "GET /orgs/{org}/actions/cache/usage-by-repository",
      "GET /orgs/{org}/actions/permissions/repositories",
      "GET /orgs/{org}/actions/runners",
      "GET /orgs/{org}/actions/secrets",
      "GET /orgs/{org}/actions/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/actions/variables",
      "GET /orgs/{org}/actions/variables/{name}/repositories",
      "GET /orgs/{org}/blocks",
      "GET /orgs/{org}/code-scanning/alerts",
      "GET /orgs/{org}/codespaces",
      "GET /orgs/{org}/codespaces/secrets",
      "GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/copilot/billing/seats",
      "GET /orgs/{org}/copilot/usage",
      "GET /orgs/{org}/dependabot/alerts",
      "GET /orgs/{org}/dependabot/secrets",
      "GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories",
      "GET /orgs/{org}/events",
      "GET /orgs/{org}/failed_invitations",
      "GET /orgs/{org}/hooks",
      "GET /orgs/{org}/hooks/{hook_id}/deliveries",
      "GET /orgs/{org}/installations",
      "GET /orgs/{org}/invitations",
      "GET /orgs/{org}/invitations/{invitation_id}/teams",
      "GET /orgs/{org}/issues",
      "GET /orgs/{org}/members",
      "GET /orgs/{org}/members/{username}/codespaces",
      "GET /orgs/{org}/migrations",
      "GET /orgs/{org}/migrations/{migration_id}/repositories",
      "GET /orgs/{org}/organization-roles/{role_id}/teams",
      "GET /orgs/{org}/organization-roles/{role_id}/users",
      "GET /orgs/{org}/outside_collaborators",
      "GET /orgs/{org}/packages",
      "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
      "GET /orgs/{org}/personal-access-token-requests",
      "GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories",
      "GET /orgs/{org}/personal-access-tokens",
      "GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories",
      "GET /orgs/{org}/projects",
      "GET /orgs/{org}/properties/values",
      "GET /orgs/{org}/public_members",
      "GET /orgs/{org}/repos",
      "GET /orgs/{org}/rulesets",
      "GET /orgs/{org}/rulesets/rule-suites",
      "GET /orgs/{org}/secret-scanning/alerts",
      "GET /orgs/{org}/security-advisories",
      "GET /orgs/{org}/team/{team_slug}/copilot/usage",
      "GET /orgs/{org}/teams",
      "GET /orgs/{org}/teams/{team_slug}/discussions",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions",
      "GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions",
      "GET /orgs/{org}/teams/{team_slug}/invitations",
      "GET /orgs/{org}/teams/{team_slug}/members",
      "GET /orgs/{org}/teams/{team_slug}/projects",
      "GET /orgs/{org}/teams/{team_slug}/repos",
      "GET /orgs/{org}/teams/{team_slug}/teams",
      "GET /projects/columns/{column_id}/cards",
      "GET /projects/{project_id}/collaborators",
      "GET /projects/{project_id}/columns",
      "GET /repos/{owner}/{repo}/actions/artifacts",
      "GET /repos/{owner}/{repo}/actions/caches",
      "GET /repos/{owner}/{repo}/actions/organization-secrets",
      "GET /repos/{owner}/{repo}/actions/organization-variables",
      "GET /repos/{owner}/{repo}/actions/runners",
      "GET /repos/{owner}/{repo}/actions/runs",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs",
      "GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs",
      "GET /repos/{owner}/{repo}/actions/secrets",
      "GET /repos/{owner}/{repo}/actions/variables",
      "GET /repos/{owner}/{repo}/actions/workflows",
      "GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs",
      "GET /repos/{owner}/{repo}/activity",
      "GET /repos/{owner}/{repo}/assignees",
      "GET /repos/{owner}/{repo}/branches",
      "GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations",
      "GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs",
      "GET /repos/{owner}/{repo}/code-scanning/alerts",
      "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
      "GET /repos/{owner}/{repo}/code-scanning/analyses",
      "GET /repos/{owner}/{repo}/codespaces",
      "GET /repos/{owner}/{repo}/codespaces/devcontainers",
      "GET /repos/{owner}/{repo}/codespaces/secrets",
      "GET /repos/{owner}/{repo}/collaborators",
      "GET /repos/{owner}/{repo}/comments",
      "GET /repos/{owner}/{repo}/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/commits",
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/comments",
      "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
      "GET /repos/{owner}/{repo}/commits/{ref}/check-runs",
      "GET /repos/{owner}/{repo}/commits/{ref}/check-suites",
      "GET /repos/{owner}/{repo}/commits/{ref}/status",
      "GET /repos/{owner}/{repo}/commits/{ref}/statuses",
      "GET /repos/{owner}/{repo}/contributors",
      "GET /repos/{owner}/{repo}/dependabot/alerts",
      "GET /repos/{owner}/{repo}/dependabot/secrets",
      "GET /repos/{owner}/{repo}/deployments",
      "GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses",
      "GET /repos/{owner}/{repo}/environments",
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies",
      "GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps",
      "GET /repos/{owner}/{repo}/environments/{environment_name}/secrets",
      "GET /repos/{owner}/{repo}/environments/{environment_name}/variables",
      "GET /repos/{owner}/{repo}/events",
      "GET /repos/{owner}/{repo}/forks",
      "GET /repos/{owner}/{repo}/hooks",
      "GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries",
      "GET /repos/{owner}/{repo}/invitations",
      "GET /repos/{owner}/{repo}/issues",
      "GET /repos/{owner}/{repo}/issues/comments",
      "GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/issues/events",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/comments",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/events",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/labels",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/reactions",
      "GET /repos/{owner}/{repo}/issues/{issue_number}/timeline",
      "GET /repos/{owner}/{repo}/keys",
      "GET /repos/{owner}/{repo}/labels",
      "GET /repos/{owner}/{repo}/milestones",
      "GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels",
      "GET /repos/{owner}/{repo}/notifications",
      "GET /repos/{owner}/{repo}/pages/builds",
      "GET /repos/{owner}/{repo}/projects",
      "GET /repos/{owner}/{repo}/pulls",
      "GET /repos/{owner}/{repo}/pulls/comments",
      "GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/comments",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/commits",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/files",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews",
      "GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments",
      "GET /repos/{owner}/{repo}/releases",
      "GET /repos/{owner}/{repo}/releases/{release_id}/assets",
      "GET /repos/{owner}/{repo}/releases/{release_id}/reactions",
      "GET /repos/{owner}/{repo}/rules/branches/{branch}",
      "GET /repos/{owner}/{repo}/rulesets",
      "GET /repos/{owner}/{repo}/rulesets/rule-suites",
      "GET /repos/{owner}/{repo}/secret-scanning/alerts",
      "GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations",
      "GET /repos/{owner}/{repo}/security-advisories",
      "GET /repos/{owner}/{repo}/stargazers",
      "GET /repos/{owner}/{repo}/subscribers",
      "GET /repos/{owner}/{repo}/tags",
      "GET /repos/{owner}/{repo}/teams",
      "GET /repos/{owner}/{repo}/topics",
      "GET /repositories",
      "GET /search/code",
      "GET /search/commits",
      "GET /search/issues",
      "GET /search/labels",
      "GET /search/repositories",
      "GET /search/topics",
      "GET /search/users",
      "GET /teams/{team_id}/discussions",
      "GET /teams/{team_id}/discussions/{discussion_number}/comments",
      "GET /teams/{team_id}/discussions/{discussion_number}/comments/{comment_number}/reactions",
      "GET /teams/{team_id}/discussions/{discussion_number}/reactions",
      "GET /teams/{team_id}/invitations",
      "GET /teams/{team_id}/members",
      "GET /teams/{team_id}/projects",
      "GET /teams/{team_id}/repos",
      "GET /teams/{team_id}/teams",
      "GET /user/blocks",
      "GET /user/codespaces",
      "GET /user/codespaces/secrets",
      "GET /user/emails",
      "GET /user/followers",
      "GET /user/following",
      "GET /user/gpg_keys",
      "GET /user/installations",
      "GET /user/installations/{installation_id}/repositories",
      "GET /user/issues",
      "GET /user/keys",
      "GET /user/marketplace_purchases",
      "GET /user/marketplace_purchases/stubbed",
      "GET /user/memberships/orgs",
      "GET /user/migrations",
      "GET /user/migrations/{migration_id}/repositories",
      "GET /user/orgs",
      "GET /user/packages",
      "GET /user/packages/{package_type}/{package_name}/versions",
      "GET /user/public_emails",
      "GET /user/repos",
      "GET /user/repository_invitations",
      "GET /user/social_accounts",
      "GET /user/ssh_signing_keys",
      "GET /user/starred",
      "GET /user/subscriptions",
      "GET /user/teams",
      "GET /users",
      "GET /users/{username}/events",
      "GET /users/{username}/events/orgs/{org}",
      "GET /users/{username}/events/public",
      "GET /users/{username}/followers",
      "GET /users/{username}/following",
      "GET /users/{username}/gists",
      "GET /users/{username}/gpg_keys",
      "GET /users/{username}/keys",
      "GET /users/{username}/orgs",
      "GET /users/{username}/packages",
      "GET /users/{username}/projects",
      "GET /users/{username}/received_events",
      "GET /users/{username}/received_events/public",
      "GET /users/{username}/repos",
      "GET /users/{username}/social_accounts",
      "GET /users/{username}/ssh_signing_keys",
      "GET /users/{username}/starred",
      "GET /users/{username}/subscriptions",
    ];
    function isPaginatingEndpoint(e) {
      if (typeof e === "string") {
        return A.includes(e);
      } else {
        return false;
      }
    }
    function paginateRest(e) {
      return { paginate: Object.assign(paginate.bind(null, e), { iterator: iterator.bind(null, e) }) };
    }
    paginateRest.VERSION = i;
    0 && 0;
  },
  6966: (e) => {
    var t = Object.defineProperty;
    var r = Object.getOwnPropertyDescriptor;
    var n = Object.getOwnPropertyNames;
    var o = Object.prototype.hasOwnProperty;
    var __export = (e, r) => {
      for (var n in r) t(e, n, { get: r[n], enumerable: true });
    };
    var __copyProps = (e, s, i, a) => {
      if ((s && typeof s === "object") || typeof s === "function") {
        for (let A of n(s)) if (!o.call(e, A) && A !== i) t(e, A, { get: () => s[A], enumerable: !(a = r(s, A)) || a.enumerable });
      }
      return e;
    };
    var __toCommonJS = (e) => __copyProps(t({}, "__esModule", { value: true }), e);
    var s = {};
    __export(s, { requestLog: () => requestLog });
    e.exports = __toCommonJS(s);
    var i = "4.0.1";
    function requestLog(e) {
      e.hook.wrap("request", (t, r) => {
        e.log.debug("request", r);
        const n = Date.now();
        const o = e.request.endpoint.parse(r);
        const s = o.url.replace(r.baseUrl, "");
        return t(r)
          .then((t) => {
            e.log.info(`${o.method} ${s} - ${t.status} in ${Date.now() - n}ms`);
            return t;
          })
          .catch((t) => {
            e.log.info(`${o.method} ${s} - ${t.status} in ${Date.now() - n}ms`);
            throw t;
          });
      });
    }
    requestLog.VERSION = i;
    0 && 0;
  },
  84935: (e) => {
    var t = Object.defineProperty;
    var r = Object.getOwnPropertyDescriptor;
    var n = Object.getOwnPropertyNames;
    var o = Object.prototype.hasOwnProperty;
    var __export = (e, r) => {
      for (var n in r) t(e, n, { get: r[n], enumerable: true });
    };
    var __copyProps = (e, s, i, a) => {
      if ((s && typeof s === "object") || typeof s === "function") {
        for (let A of n(s)) if (!o.call(e, A) && A !== i) t(e, A, { get: () => s[A], enumerable: !(a = r(s, A)) || a.enumerable });
      }
      return e;
    };
    var __toCommonJS = (e) => __copyProps(t({}, "__esModule", { value: true }), e);
    var s = {};
    __export(s, { legacyRestEndpointMethods: () => legacyRestEndpointMethods, restEndpointMethods: () => restEndpointMethods });
    e.exports = __toCommonJS(s);
    var i = "13.2.2";
    var a = {
      actions: {
        addCustomLabelsToSelfHostedRunnerForOrg: ["POST /orgs/{org}/actions/runners/{runner_id}/labels"],
        addCustomLabelsToSelfHostedRunnerForRepo: ["POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
        addSelectedRepoToOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
        approveWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],
        cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
        createEnvironmentVariable: ["POST /repos/{owner}/{repo}/environments/{environment_name}/variables"],
        createOrUpdateEnvironmentSecret: ["PUT /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
        createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        createOrgVariable: ["POST /orgs/{org}/actions/variables"],
        createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
        createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
        createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
        createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
        createRepoVariable: ["POST /repos/{owner}/{repo}/actions/variables"],
        createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
        deleteActionsCacheById: ["DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"],
        deleteActionsCacheByKey: ["DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"],
        deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        deleteEnvironmentSecret: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"],
        deleteEnvironmentVariable: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"],
        deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
        deleteOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}"],
        deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        deleteRepoVariable: ["DELETE /repos/{owner}/{repo}/actions/variables/{name}"],
        deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
        deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
        deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
        deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
        disableSelectedRepositoryGithubActionsOrganization: ["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],
        disableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],
        downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
        downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
        downloadWorkflowRunAttemptLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],
        downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
        enableSelectedRepositoryGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],
        enableWorkflow: ["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],
        forceCancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"],
        generateRunnerJitconfigForOrg: ["POST /orgs/{org}/actions/runners/generate-jitconfig"],
        generateRunnerJitconfigForRepo: ["POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"],
        getActionsCacheList: ["GET /repos/{owner}/{repo}/actions/caches"],
        getActionsCacheUsage: ["GET /repos/{owner}/{repo}/actions/cache/usage"],
        getActionsCacheUsageByRepoForOrg: ["GET /orgs/{org}/actions/cache/usage-by-repository"],
        getActionsCacheUsageForOrg: ["GET /orgs/{org}/actions/cache/usage"],
        getAllowedActionsOrganization: ["GET /orgs/{org}/actions/permissions/selected-actions"],
        getAllowedActionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],
        getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
        getCustomOidcSubClaimForRepo: ["GET /repos/{owner}/{repo}/actions/oidc/customization/sub"],
        getEnvironmentPublicKey: ["GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/public-key"],
        getEnvironmentSecret: ["GET /repos/{owner}/{repo}/environments/{environment_name}/secrets/{secret_name}"],
        getEnvironmentVariable: ["GET /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"],
        getGithubActionsDefaultWorkflowPermissionsOrganization: ["GET /orgs/{org}/actions/permissions/workflow"],
        getGithubActionsDefaultWorkflowPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions/workflow"],
        getGithubActionsPermissionsOrganization: ["GET /orgs/{org}/actions/permissions"],
        getGithubActionsPermissionsRepository: ["GET /repos/{owner}/{repo}/actions/permissions"],
        getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
        getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
        getOrgVariable: ["GET /orgs/{org}/actions/variables/{name}"],
        getPendingDeploymentsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
        getRepoPermissions: ["GET /repos/{owner}/{repo}/actions/permissions", {}, { renamed: ["actions", "getGithubActionsPermissionsRepository"] }],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
        getRepoVariable: ["GET /repos/{owner}/{repo}/actions/variables/{name}"],
        getReviewsForRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],
        getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
        getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
        getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
        getWorkflowAccessToRepository: ["GET /repos/{owner}/{repo}/actions/permissions/access"],
        getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
        getWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],
        getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
        getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
        listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
        listEnvironmentSecrets: ["GET /repos/{owner}/{repo}/environments/{environment_name}/secrets"],
        listEnvironmentVariables: ["GET /repos/{owner}/{repo}/environments/{environment_name}/variables"],
        listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
        listJobsForWorkflowRunAttempt: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],
        listLabelsForSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}/labels"],
        listLabelsForSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
        listOrgVariables: ["GET /orgs/{org}/actions/variables"],
        listRepoOrganizationSecrets: ["GET /repos/{owner}/{repo}/actions/organization-secrets"],
        listRepoOrganizationVariables: ["GET /repos/{owner}/{repo}/actions/organization-variables"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
        listRepoVariables: ["GET /repos/{owner}/{repo}/actions/variables"],
        listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
        listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
        listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
        listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
        listSelectedReposForOrgVariable: ["GET /orgs/{org}/actions/variables/{name}/repositories"],
        listSelectedRepositoriesEnabledGithubActionsOrganization: ["GET /orgs/{org}/actions/permissions/repositories"],
        listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
        listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
        listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
        listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
        listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
        reRunJobForWorkflowRun: ["POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"],
        reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
        reRunWorkflowFailedJobs: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"],
        removeAllCustomLabelsFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels"],
        removeAllCustomLabelsFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        removeCustomLabelFromSelfHostedRunnerForOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"],
        removeCustomLabelFromSelfHostedRunnerForRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"],
        removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
        removeSelectedRepoFromOrgVariable: ["DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],
        reviewCustomGatesForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"],
        reviewPendingDeploymentsForRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],
        setAllowedActionsOrganization: ["PUT /orgs/{org}/actions/permissions/selected-actions"],
        setAllowedActionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],
        setCustomLabelsForSelfHostedRunnerForOrg: ["PUT /orgs/{org}/actions/runners/{runner_id}/labels"],
        setCustomLabelsForSelfHostedRunnerForRepo: ["PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],
        setCustomOidcSubClaimForRepo: ["PUT /repos/{owner}/{repo}/actions/oidc/customization/sub"],
        setGithubActionsDefaultWorkflowPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions/workflow"],
        setGithubActionsDefaultWorkflowPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/workflow"],
        setGithubActionsPermissionsOrganization: ["PUT /orgs/{org}/actions/permissions"],
        setGithubActionsPermissionsRepository: ["PUT /repos/{owner}/{repo}/actions/permissions"],
        setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],
        setSelectedReposForOrgVariable: ["PUT /orgs/{org}/actions/variables/{name}/repositories"],
        setSelectedRepositoriesEnabledGithubActionsOrganization: ["PUT /orgs/{org}/actions/permissions/repositories"],
        setWorkflowAccessToRepository: ["PUT /repos/{owner}/{repo}/actions/permissions/access"],
        updateEnvironmentVariable: ["PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}"],
        updateOrgVariable: ["PATCH /orgs/{org}/actions/variables/{name}"],
        updateRepoVariable: ["PATCH /repos/{owner}/{repo}/actions/variables/{name}"],
      },
      activity: {
        checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
        deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
        deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
        getFeeds: ["GET /feeds"],
        getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
        getThread: ["GET /notifications/threads/{thread_id}"],
        getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
        listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
        listNotificationsForAuthenticatedUser: ["GET /notifications"],
        listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
        listPublicEvents: ["GET /events"],
        listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
        listPublicEventsForUser: ["GET /users/{username}/events/public"],
        listPublicOrgEvents: ["GET /orgs/{org}/events"],
        listReceivedEventsForUser: ["GET /users/{username}/received_events"],
        listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
        listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
        listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
        listReposStarredByAuthenticatedUser: ["GET /user/starred"],
        listReposStarredByUser: ["GET /users/{username}/starred"],
        listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
        listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
        listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
        listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
        markNotificationsAsRead: ["PUT /notifications"],
        markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
        markThreadAsDone: ["DELETE /notifications/threads/{thread_id}"],
        markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
        setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
        setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
        starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
        unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"],
      },
      apps: {
        addRepoToInstallation: [
          "PUT /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          { renamed: ["apps", "addRepoToInstallationForAuthenticatedUser"] },
        ],
        addRepoToInstallationForAuthenticatedUser: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
        checkToken: ["POST /applications/{client_id}/token"],
        createFromManifest: ["POST /app-manifests/{code}/conversions"],
        createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
        deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
        deleteInstallation: ["DELETE /app/installations/{installation_id}"],
        deleteToken: ["DELETE /applications/{client_id}/token"],
        getAuthenticated: ["GET /app"],
        getBySlug: ["GET /apps/{app_slug}"],
        getInstallation: ["GET /app/installations/{installation_id}"],
        getOrgInstallation: ["GET /orgs/{org}/installation"],
        getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
        getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
        getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
        getUserInstallation: ["GET /users/{username}/installation"],
        getWebhookConfigForApp: ["GET /app/hook/config"],
        getWebhookDelivery: ["GET /app/hook/deliveries/{delivery_id}"],
        listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
        listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
        listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
        listInstallationRequestsForAuthenticatedApp: ["GET /app/installation-requests"],
        listInstallations: ["GET /app/installations"],
        listInstallationsForAuthenticatedUser: ["GET /user/installations"],
        listPlans: ["GET /marketplace_listing/plans"],
        listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
        listReposAccessibleToInstallation: ["GET /installation/repositories"],
        listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
        listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
        listWebhookDeliveries: ["GET /app/hook/deliveries"],
        redeliverWebhookDelivery: ["POST /app/hook/deliveries/{delivery_id}/attempts"],
        removeRepoFromInstallation: [
          "DELETE /user/installations/{installation_id}/repositories/{repository_id}",
          {},
          { renamed: ["apps", "removeRepoFromInstallationForAuthenticatedUser"] },
        ],
        removeRepoFromInstallationForAuthenticatedUser: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
        resetToken: ["PATCH /applications/{client_id}/token"],
        revokeInstallationAccessToken: ["DELETE /installation/token"],
        scopeToken: ["POST /applications/{client_id}/token/scoped"],
        suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
        unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"],
        updateWebhookConfigForApp: ["PATCH /app/hook/config"],
      },
      billing: {
        getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
        getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
        getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
        getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
        getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
        getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"],
      },
      checks: {
        create: ["POST /repos/{owner}/{repo}/check-runs"],
        createSuite: ["POST /repos/{owner}/{repo}/check-suites"],
        get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],
        getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],
        listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],
        listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],
        listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],
        listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],
        rerequestRun: ["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],
        rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],
        setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences"],
        update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"],
      },
      codeScanning: {
        deleteAnalysis: ["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],
        getAlert: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}", {}, { renamedParameters: { alert_id: "alert_number" } }],
        getAnalysis: ["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],
        getCodeqlDatabase: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"],
        getDefaultSetup: ["GET /repos/{owner}/{repo}/code-scanning/default-setup"],
        getSarif: ["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],
        listAlertInstances: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],
        listAlertsForOrg: ["GET /orgs/{org}/code-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
        listAlertsInstances: [
          "GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",
          {},
          { renamed: ["codeScanning", "listAlertInstances"] },
        ],
        listCodeqlDatabases: ["GET /repos/{owner}/{repo}/code-scanning/codeql/databases"],
        listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
        updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
        updateDefaultSetup: ["PATCH /repos/{owner}/{repo}/code-scanning/default-setup"],
        uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"],
      },
      codesOfConduct: { getAllCodesOfConduct: ["GET /codes_of_conduct"], getConductCode: ["GET /codes_of_conduct/{key}"] },
      codespaces: {
        addRepositoryForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
        addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
        checkPermissionsForDevcontainer: ["GET /repos/{owner}/{repo}/codespaces/permissions_check"],
        codespaceMachinesForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/machines"],
        createForAuthenticatedUser: ["POST /user/codespaces"],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}"],
        createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
        createOrUpdateSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}"],
        createWithPrForAuthenticatedUser: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"],
        createWithRepoForAuthenticatedUser: ["POST /repos/{owner}/{repo}/codespaces"],
        deleteForAuthenticatedUser: ["DELETE /user/codespaces/{codespace_name}"],
        deleteFromOrganization: ["DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"],
        deleteOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],
        deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
        deleteSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}"],
        exportForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/exports"],
        getCodespacesForUserInOrg: ["GET /orgs/{org}/members/{username}/codespaces"],
        getExportDetailsForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}/exports/{export_id}"],
        getForAuthenticatedUser: ["GET /user/codespaces/{codespace_name}"],
        getOrgPublicKey: ["GET /orgs/{org}/codespaces/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}"],
        getPublicKeyForAuthenticatedUser: ["GET /user/codespaces/secrets/public-key"],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/codespaces/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],
        getSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}"],
        listDevcontainersInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/devcontainers"],
        listForAuthenticatedUser: ["GET /user/codespaces"],
        listInOrganization: ["GET /orgs/{org}/codespaces", {}, { renamedParameters: { org_id: "org" } }],
        listInRepositoryForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces"],
        listOrgSecrets: ["GET /orgs/{org}/codespaces/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/codespaces/secrets"],
        listRepositoriesForSecretForAuthenticatedUser: ["GET /user/codespaces/secrets/{secret_name}/repositories"],
        listSecretsForAuthenticatedUser: ["GET /user/codespaces/secrets"],
        listSelectedReposForOrgSecret: ["GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
        preFlightWithRepoForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/new"],
        publishForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/publish"],
        removeRepositoryForSecretForAuthenticatedUser: ["DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
        removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],
        repoMachinesForAuthenticatedUser: ["GET /repos/{owner}/{repo}/codespaces/machines"],
        setRepositoriesForSecretForAuthenticatedUser: ["PUT /user/codespaces/secrets/{secret_name}/repositories"],
        setSelectedReposForOrgSecret: ["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],
        startForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/start"],
        stopForAuthenticatedUser: ["POST /user/codespaces/{codespace_name}/stop"],
        stopInOrganization: ["POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"],
        updateForAuthenticatedUser: ["PATCH /user/codespaces/{codespace_name}"],
      },
      copilot: {
        addCopilotSeatsForTeams: ["POST /orgs/{org}/copilot/billing/selected_teams"],
        addCopilotSeatsForUsers: ["POST /orgs/{org}/copilot/billing/selected_users"],
        cancelCopilotSeatAssignmentForTeams: ["DELETE /orgs/{org}/copilot/billing/selected_teams"],
        cancelCopilotSeatAssignmentForUsers: ["DELETE /orgs/{org}/copilot/billing/selected_users"],
        getCopilotOrganizationDetails: ["GET /orgs/{org}/copilot/billing"],
        getCopilotSeatDetailsForUser: ["GET /orgs/{org}/members/{username}/copilot"],
        listCopilotSeats: ["GET /orgs/{org}/copilot/billing/seats"],
        usageMetricsForEnterprise: ["GET /enterprises/{enterprise}/copilot/usage"],
        usageMetricsForOrg: ["GET /orgs/{org}/copilot/usage"],
        usageMetricsForTeam: ["GET /orgs/{org}/team/{team_slug}/copilot/usage"],
      },
      dependabot: {
        addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
        createOrUpdateOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}"],
        createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
        deleteOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],
        deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
        getAlert: ["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
        getOrgPublicKey: ["GET /orgs/{org}/dependabot/secrets/public-key"],
        getOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}"],
        getRepoPublicKey: ["GET /repos/{owner}/{repo}/dependabot/secrets/public-key"],
        getRepoSecret: ["GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],
        listAlertsForEnterprise: ["GET /enterprises/{enterprise}/dependabot/alerts"],
        listAlertsForOrg: ["GET /orgs/{org}/dependabot/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/dependabot/alerts"],
        listOrgSecrets: ["GET /orgs/{org}/dependabot/secrets"],
        listRepoSecrets: ["GET /repos/{owner}/{repo}/dependabot/secrets"],
        listSelectedReposForOrgSecret: ["GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
        removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],
        setSelectedReposForOrgSecret: ["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],
        updateAlert: ["PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],
      },
      dependencyGraph: {
        createRepositorySnapshot: ["POST /repos/{owner}/{repo}/dependency-graph/snapshots"],
        diffRange: ["GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"],
        exportSbom: ["GET /repos/{owner}/{repo}/dependency-graph/sbom"],
      },
      emojis: { get: ["GET /emojis"] },
      gists: {
        checkIsStarred: ["GET /gists/{gist_id}/star"],
        create: ["POST /gists"],
        createComment: ["POST /gists/{gist_id}/comments"],
        delete: ["DELETE /gists/{gist_id}"],
        deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
        fork: ["POST /gists/{gist_id}/forks"],
        get: ["GET /gists/{gist_id}"],
        getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
        getRevision: ["GET /gists/{gist_id}/{sha}"],
        list: ["GET /gists"],
        listComments: ["GET /gists/{gist_id}/comments"],
        listCommits: ["GET /gists/{gist_id}/commits"],
        listForUser: ["GET /users/{username}/gists"],
        listForks: ["GET /gists/{gist_id}/forks"],
        listPublic: ["GET /gists/public"],
        listStarred: ["GET /gists/starred"],
        star: ["PUT /gists/{gist_id}/star"],
        unstar: ["DELETE /gists/{gist_id}/star"],
        update: ["PATCH /gists/{gist_id}"],
        updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"],
      },
      git: {
        createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
        createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
        createRef: ["POST /repos/{owner}/{repo}/git/refs"],
        createTag: ["POST /repos/{owner}/{repo}/git/tags"],
        createTree: ["POST /repos/{owner}/{repo}/git/trees"],
        deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
        getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
        getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
        getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
        getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
        getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
        listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
        updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"],
      },
      gitignore: { getAllTemplates: ["GET /gitignore/templates"], getTemplate: ["GET /gitignore/templates/{name}"] },
      interactions: {
        getRestrictionsForAuthenticatedUser: ["GET /user/interaction-limits"],
        getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits"],
        getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits"],
        getRestrictionsForYourPublicRepos: ["GET /user/interaction-limits", {}, { renamed: ["interactions", "getRestrictionsForAuthenticatedUser"] }],
        removeRestrictionsForAuthenticatedUser: ["DELETE /user/interaction-limits"],
        removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits"],
        removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits"],
        removeRestrictionsForYourPublicRepos: ["DELETE /user/interaction-limits", {}, { renamed: ["interactions", "removeRestrictionsForAuthenticatedUser"] }],
        setRestrictionsForAuthenticatedUser: ["PUT /user/interaction-limits"],
        setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits"],
        setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits"],
        setRestrictionsForYourPublicRepos: ["PUT /user/interaction-limits", {}, { renamed: ["interactions", "setRestrictionsForAuthenticatedUser"] }],
      },
      issues: {
        addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
        addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
        checkUserCanBeAssignedToIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"],
        create: ["POST /repos/{owner}/{repo}/issues"],
        createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        createLabel: ["POST /repos/{owner}/{repo}/labels"],
        createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
        deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
        deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
        get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
        getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
        getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
        getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
        list: ["GET /issues"],
        listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
        listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
        listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
        listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
        listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
        listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],
        listForAuthenticatedUser: ["GET /user/issues"],
        listForOrg: ["GET /orgs/{org}/issues"],
        listForRepo: ["GET /repos/{owner}/{repo}/issues"],
        listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
        listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
        listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
        lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
        removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
        setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
        unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
        update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
        updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
        updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
        updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"],
      },
      licenses: { get: ["GET /licenses/{license}"], getAllCommonlyUsed: ["GET /licenses"], getForRepo: ["GET /repos/{owner}/{repo}/license"] },
      markdown: { render: ["POST /markdown"], renderRaw: ["POST /markdown/raw", { headers: { "content-type": "text/plain; charset=utf-8" } }] },
      meta: { get: ["GET /meta"], getAllVersions: ["GET /versions"], getOctocat: ["GET /octocat"], getZen: ["GET /zen"], root: ["GET /"] },
      migrations: {
        deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive"],
        deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive"],
        downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive"],
        getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive"],
        getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}"],
        getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}"],
        listForAuthenticatedUser: ["GET /user/migrations"],
        listForOrg: ["GET /orgs/{org}/migrations"],
        listReposForAuthenticatedUser: ["GET /user/migrations/{migration_id}/repositories"],
        listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories"],
        listReposForUser: ["GET /user/migrations/{migration_id}/repositories", {}, { renamed: ["migrations", "listReposForAuthenticatedUser"] }],
        startForAuthenticatedUser: ["POST /user/migrations"],
        startForOrg: ["POST /orgs/{org}/migrations"],
        unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],
        unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"],
      },
      oidc: {
        getOidcCustomSubTemplateForOrg: ["GET /orgs/{org}/actions/oidc/customization/sub"],
        updateOidcCustomSubTemplateForOrg: ["PUT /orgs/{org}/actions/oidc/customization/sub"],
      },
      orgs: {
        addSecurityManagerTeam: ["PUT /orgs/{org}/security-managers/teams/{team_slug}"],
        assignTeamToOrgRole: ["PUT /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
        assignUserToOrgRole: ["PUT /orgs/{org}/organization-roles/users/{username}/{role_id}"],
        blockUser: ["PUT /orgs/{org}/blocks/{username}"],
        cancelInvitation: ["DELETE /orgs/{org}/invitations/{invitation_id}"],
        checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
        checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
        checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
        convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
        createCustomOrganizationRole: ["POST /orgs/{org}/organization-roles"],
        createInvitation: ["POST /orgs/{org}/invitations"],
        createOrUpdateCustomProperties: ["PATCH /orgs/{org}/properties/schema"],
        createOrUpdateCustomPropertiesValuesForRepos: ["PATCH /orgs/{org}/properties/values"],
        createOrUpdateCustomProperty: ["PUT /orgs/{org}/properties/schema/{custom_property_name}"],
        createWebhook: ["POST /orgs/{org}/hooks"],
        delete: ["DELETE /orgs/{org}"],
        deleteCustomOrganizationRole: ["DELETE /orgs/{org}/organization-roles/{role_id}"],
        deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
        enableOrDisableSecurityProductOnAllOrgRepos: ["POST /orgs/{org}/{security_product}/{enablement}"],
        get: ["GET /orgs/{org}"],
        getAllCustomProperties: ["GET /orgs/{org}/properties/schema"],
        getCustomProperty: ["GET /orgs/{org}/properties/schema/{custom_property_name}"],
        getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
        getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
        getOrgRole: ["GET /orgs/{org}/organization-roles/{role_id}"],
        getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
        getWebhookConfigForOrg: ["GET /orgs/{org}/hooks/{hook_id}/config"],
        getWebhookDelivery: ["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],
        list: ["GET /organizations"],
        listAppInstallations: ["GET /orgs/{org}/installations"],
        listBlockedUsers: ["GET /orgs/{org}/blocks"],
        listCustomPropertiesValuesForRepos: ["GET /orgs/{org}/properties/values"],
        listFailedInvitations: ["GET /orgs/{org}/failed_invitations"],
        listForAuthenticatedUser: ["GET /user/orgs"],
        listForUser: ["GET /users/{username}/orgs"],
        listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
        listMembers: ["GET /orgs/{org}/members"],
        listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
        listOrgRoleTeams: ["GET /orgs/{org}/organization-roles/{role_id}/teams"],
        listOrgRoleUsers: ["GET /orgs/{org}/organization-roles/{role_id}/users"],
        listOrgRoles: ["GET /orgs/{org}/organization-roles"],
        listOrganizationFineGrainedPermissions: ["GET /orgs/{org}/organization-fine-grained-permissions"],
        listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
        listPatGrantRepositories: ["GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"],
        listPatGrantRequestRepositories: ["GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"],
        listPatGrantRequests: ["GET /orgs/{org}/personal-access-token-requests"],
        listPatGrants: ["GET /orgs/{org}/personal-access-tokens"],
        listPendingInvitations: ["GET /orgs/{org}/invitations"],
        listPublicMembers: ["GET /orgs/{org}/public_members"],
        listSecurityManagerTeams: ["GET /orgs/{org}/security-managers"],
        listWebhookDeliveries: ["GET /orgs/{org}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /orgs/{org}/hooks"],
        patchCustomOrganizationRole: ["PATCH /orgs/{org}/organization-roles/{role_id}"],
        pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: ["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
        removeCustomProperty: ["DELETE /orgs/{org}/properties/schema/{custom_property_name}"],
        removeMember: ["DELETE /orgs/{org}/members/{username}"],
        removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
        removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
        removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
        removeSecurityManagerTeam: ["DELETE /orgs/{org}/security-managers/teams/{team_slug}"],
        reviewPatGrantRequest: ["POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"],
        reviewPatGrantRequestsInBulk: ["POST /orgs/{org}/personal-access-token-requests"],
        revokeAllOrgRolesTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}"],
        revokeAllOrgRolesUser: ["DELETE /orgs/{org}/organization-roles/users/{username}"],
        revokeOrgRoleTeam: ["DELETE /orgs/{org}/organization-roles/teams/{team_slug}/{role_id}"],
        revokeOrgRoleUser: ["DELETE /orgs/{org}/organization-roles/users/{username}/{role_id}"],
        setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
        setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
        unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
        update: ["PATCH /orgs/{org}"],
        updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
        updatePatAccess: ["POST /orgs/{org}/personal-access-tokens/{pat_id}"],
        updatePatAccesses: ["POST /orgs/{org}/personal-access-tokens"],
        updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"],
        updateWebhookConfigForOrg: ["PATCH /orgs/{org}/hooks/{hook_id}/config"],
      },
      packages: {
        deletePackageForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}"],
        deletePackageForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],
        deletePackageForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}"],
        deletePackageVersionForAuthenticatedUser: ["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        deletePackageVersionForOrg: ["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        deletePackageVersionForUser: ["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        getAllPackageVersionsForAPackageOwnedByAnOrg: [
          "GET /orgs/{org}/packages/{package_type}/{package_name}/versions",
          {},
          { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByOrg"] },
        ],
        getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser: [
          "GET /user/packages/{package_type}/{package_name}/versions",
          {},
          { renamed: ["packages", "getAllPackageVersionsForPackageOwnedByAuthenticatedUser"] },
        ],
        getAllPackageVersionsForPackageOwnedByAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions"],
        getAllPackageVersionsForPackageOwnedByOrg: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],
        getAllPackageVersionsForPackageOwnedByUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions"],
        getPackageForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}"],
        getPackageForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}"],
        getPackageForUser: ["GET /users/{username}/packages/{package_type}/{package_name}"],
        getPackageVersionForAuthenticatedUser: ["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        getPackageVersionForOrganization: ["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        getPackageVersionForUser: ["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],
        listDockerMigrationConflictingPackagesForAuthenticatedUser: ["GET /user/docker/conflicts"],
        listDockerMigrationConflictingPackagesForOrganization: ["GET /orgs/{org}/docker/conflicts"],
        listDockerMigrationConflictingPackagesForUser: ["GET /users/{username}/docker/conflicts"],
        listPackagesForAuthenticatedUser: ["GET /user/packages"],
        listPackagesForOrganization: ["GET /orgs/{org}/packages"],
        listPackagesForUser: ["GET /users/{username}/packages"],
        restorePackageForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/restore{?token}"],
        restorePackageForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],
        restorePackageForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],
        restorePackageVersionForAuthenticatedUser: ["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
        restorePackageVersionForOrg: ["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
        restorePackageVersionForUser: ["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],
      },
      projects: {
        addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}"],
        createCard: ["POST /projects/columns/{column_id}/cards"],
        createColumn: ["POST /projects/{project_id}/columns"],
        createForAuthenticatedUser: ["POST /user/projects"],
        createForOrg: ["POST /orgs/{org}/projects"],
        createForRepo: ["POST /repos/{owner}/{repo}/projects"],
        delete: ["DELETE /projects/{project_id}"],
        deleteCard: ["DELETE /projects/columns/cards/{card_id}"],
        deleteColumn: ["DELETE /projects/columns/{column_id}"],
        get: ["GET /projects/{project_id}"],
        getCard: ["GET /projects/columns/cards/{card_id}"],
        getColumn: ["GET /projects/columns/{column_id}"],
        getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission"],
        listCards: ["GET /projects/columns/{column_id}/cards"],
        listCollaborators: ["GET /projects/{project_id}/collaborators"],
        listColumns: ["GET /projects/{project_id}/columns"],
        listForOrg: ["GET /orgs/{org}/projects"],
        listForRepo: ["GET /repos/{owner}/{repo}/projects"],
        listForUser: ["GET /users/{username}/projects"],
        moveCard: ["POST /projects/columns/cards/{card_id}/moves"],
        moveColumn: ["POST /projects/columns/{column_id}/moves"],
        removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}"],
        update: ["PATCH /projects/{project_id}"],
        updateCard: ["PATCH /projects/columns/cards/{card_id}"],
        updateColumn: ["PATCH /projects/columns/{column_id}"],
      },
      pulls: {
        checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        create: ["POST /repos/{owner}/{repo}/pulls"],
        createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
        createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
        deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
        get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
        getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
        list: ["GET /repos/{owner}/{repo}/pulls"],
        listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
        listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
        listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
        listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
        listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
        listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
        merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
        removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
        submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
        update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
        updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],
        updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
        updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
      },
      rateLimit: { get: ["GET /rate_limit"] },
      reactions: {
        createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
        createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
        createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
        createForRelease: ["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],
        createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
        createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
        deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],
        deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],
        deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],
        deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],
        deleteForRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"],
        deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],
        deleteForTeamDiscussionComment: [
          "DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}",
        ],
        listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],
        listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],
        listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],
        listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],
        listForRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}/reactions"],
        listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],
        listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],
      },
      repos: {
        acceptInvitation: ["PATCH /user/repository_invitations/{invitation_id}", {}, { renamed: ["repos", "acceptInvitationForAuthenticatedUser"] }],
        acceptInvitationForAuthenticatedUser: ["PATCH /user/repository_invitations/{invitation_id}"],
        addAppAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, { mapToData: "apps" }],
        addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
        addStatusCheckContexts: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, { mapToData: "contexts" }],
        addTeamAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, { mapToData: "teams" }],
        addUserAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, { mapToData: "users" }],
        cancelPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}/cancel"],
        checkAutomatedSecurityFixes: ["GET /repos/{owner}/{repo}/automated-security-fixes"],
        checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
        checkPrivateVulnerabilityReporting: ["GET /repos/{owner}/{repo}/private-vulnerability-reporting"],
        checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts"],
        codeownersErrors: ["GET /repos/{owner}/{repo}/codeowners/errors"],
        compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
        compareCommitsWithBasehead: ["GET /repos/{owner}/{repo}/compare/{basehead}"],
        createAutolink: ["POST /repos/{owner}/{repo}/autolinks"],
        createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
        createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
        createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
        createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
        createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
        createDeploymentBranchPolicy: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
        createDeploymentProtectionRule: ["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
        createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
        createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
        createForAuthenticatedUser: ["POST /user/repos"],
        createFork: ["POST /repos/{owner}/{repo}/forks"],
        createInOrg: ["POST /orgs/{org}/repos"],
        createOrUpdateCustomPropertiesValues: ["PATCH /repos/{owner}/{repo}/properties/values"],
        createOrUpdateEnvironment: ["PUT /repos/{owner}/{repo}/environments/{environment_name}"],
        createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
        createOrgRuleset: ["POST /orgs/{org}/rulesets"],
        createPagesDeployment: ["POST /repos/{owner}/{repo}/pages/deployments"],
        createPagesSite: ["POST /repos/{owner}/{repo}/pages"],
        createRelease: ["POST /repos/{owner}/{repo}/releases"],
        createRepoRuleset: ["POST /repos/{owner}/{repo}/rulesets"],
        createTagProtection: ["POST /repos/{owner}/{repo}/tags/protection"],
        createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate"],
        createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
        declineInvitation: ["DELETE /user/repository_invitations/{invitation_id}", {}, { renamed: ["repos", "declineInvitationForAuthenticatedUser"] }],
        declineInvitationForAuthenticatedUser: ["DELETE /user/repository_invitations/{invitation_id}"],
        delete: ["DELETE /repos/{owner}/{repo}"],
        deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
        deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        deleteAnEnvironment: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],
        deleteAutolink: ["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
        deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
        deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
        deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
        deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
        deleteDeploymentBranchPolicy: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
        deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
        deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
        deleteOrgRuleset: ["DELETE /orgs/{org}/rulesets/{ruleset_id}"],
        deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages"],
        deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
        deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        deleteRepoRuleset: ["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        deleteTagProtection: ["DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"],
        deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
        disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes"],
        disableDeploymentProtectionRule: ["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
        disablePrivateVulnerabilityReporting: ["DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"],
        disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],
        downloadArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}", {}, { renamed: ["repos", "downloadZipballArchive"] }],
        downloadTarballArchive: ["GET /repos/{owner}/{repo}/tarball/{ref}"],
        downloadZipballArchive: ["GET /repos/{owner}/{repo}/zipball/{ref}"],
        enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes"],
        enablePrivateVulnerabilityReporting: ["PUT /repos/{owner}/{repo}/private-vulnerability-reporting"],
        enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts"],
        generateReleaseNotes: ["POST /repos/{owner}/{repo}/releases/generate-notes"],
        get: ["GET /repos/{owner}/{repo}"],
        getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
        getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        getAllDeploymentProtectionRules: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],
        getAllEnvironments: ["GET /repos/{owner}/{repo}/environments"],
        getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
        getAllTopics: ["GET /repos/{owner}/{repo}/topics"],
        getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
        getAutolink: ["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],
        getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
        getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
        getBranchRules: ["GET /repos/{owner}/{repo}/rules/branches/{branch}"],
        getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
        getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
        getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
        getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
        getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
        getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
        getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
        getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],
        getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile"],
        getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
        getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
        getCustomDeploymentProtectionRule: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],
        getCustomPropertiesValues: ["GET /repos/{owner}/{repo}/properties/values"],
        getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
        getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
        getDeploymentBranchPolicy: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
        getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
        getEnvironment: ["GET /repos/{owner}/{repo}/environments/{environment_name}"],
        getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
        getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
        getOrgRuleSuite: ["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],
        getOrgRuleSuites: ["GET /orgs/{org}/rulesets/rule-suites"],
        getOrgRuleset: ["GET /orgs/{org}/rulesets/{ruleset_id}"],
        getOrgRulesets: ["GET /orgs/{org}/rulesets"],
        getPages: ["GET /repos/{owner}/{repo}/pages"],
        getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
        getPagesDeployment: ["GET /repos/{owner}/{repo}/pages/deployments/{pages_deployment_id}"],
        getPagesHealthCheck: ["GET /repos/{owner}/{repo}/pages/health"],
        getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
        getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
        getReadme: ["GET /repos/{owner}/{repo}/readme"],
        getReadmeInDirectory: ["GET /repos/{owner}/{repo}/readme/{dir}"],
        getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
        getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
        getRepoRuleSuite: ["GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"],
        getRepoRuleSuites: ["GET /repos/{owner}/{repo}/rulesets/rule-suites"],
        getRepoRuleset: ["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        getRepoRulesets: ["GET /repos/{owner}/{repo}/rulesets"],
        getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
        getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
        getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
        getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
        getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
        getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
        getWebhookConfigForRepo: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],
        getWebhookDelivery: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],
        listActivities: ["GET /repos/{owner}/{repo}/activity"],
        listAutolinks: ["GET /repos/{owner}/{repo}/autolinks"],
        listBranches: ["GET /repos/{owner}/{repo}/branches"],
        listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],
        listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
        listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
        listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
        listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
        listCommits: ["GET /repos/{owner}/{repo}/commits"],
        listContributors: ["GET /repos/{owner}/{repo}/contributors"],
        listCustomDeploymentRuleIntegrations: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"],
        listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
        listDeploymentBranchPolicies: ["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],
        listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
        listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
        listForAuthenticatedUser: ["GET /user/repos"],
        listForOrg: ["GET /orgs/{org}/repos"],
        listForUser: ["GET /users/{username}/repos"],
        listForks: ["GET /repos/{owner}/{repo}/forks"],
        listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
        listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
        listLanguages: ["GET /repos/{owner}/{repo}/languages"],
        listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
        listPublic: ["GET /repositories"],
        listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],
        listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
        listReleases: ["GET /repos/{owner}/{repo}/releases"],
        listTagProtection: ["GET /repos/{owner}/{repo}/tags/protection"],
        listTags: ["GET /repos/{owner}/{repo}/tags"],
        listTeams: ["GET /repos/{owner}/{repo}/teams"],
        listWebhookDeliveries: ["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],
        listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
        merge: ["POST /repos/{owner}/{repo}/merges"],
        mergeUpstream: ["POST /repos/{owner}/{repo}/merge-upstream"],
        pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
        redeliverWebhookDelivery: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],
        removeAppAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, { mapToData: "apps" }],
        removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
        removeStatusCheckContexts: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, { mapToData: "contexts" }],
        removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        removeTeamAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, { mapToData: "teams" }],
        removeUserAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, { mapToData: "users" }],
        renameBranch: ["POST /repos/{owner}/{repo}/branches/{branch}/rename"],
        replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics"],
        requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
        setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
        setAppAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, { mapToData: "apps" }],
        setStatusCheckContexts: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, { mapToData: "contexts" }],
        setTeamAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, { mapToData: "teams" }],
        setUserAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, { mapToData: "users" }],
        testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
        transfer: ["POST /repos/{owner}/{repo}/transfer"],
        update: ["PATCH /repos/{owner}/{repo}"],
        updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
        updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
        updateDeploymentBranchPolicy: ["PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],
        updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
        updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
        updateOrgRuleset: ["PUT /orgs/{org}/rulesets/{ruleset_id}"],
        updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
        updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
        updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
        updateRepoRuleset: ["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],
        updateStatusCheckPotection: [
          "PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",
          {},
          { renamed: ["repos", "updateStatusCheckProtection"] },
        ],
        updateStatusCheckProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
        updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
        updateWebhookConfigForRepo: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],
        uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", { baseUrl: "https://uploads.github.com" }],
      },
      search: {
        code: ["GET /search/code"],
        commits: ["GET /search/commits"],
        issuesAndPullRequests: ["GET /search/issues"],
        labels: ["GET /search/labels"],
        repos: ["GET /search/repositories"],
        topics: ["GET /search/topics"],
        users: ["GET /search/users"],
      },
      secretScanning: {
        getAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
        listAlertsForEnterprise: ["GET /enterprises/{enterprise}/secret-scanning/alerts"],
        listAlertsForOrg: ["GET /orgs/{org}/secret-scanning/alerts"],
        listAlertsForRepo: ["GET /repos/{owner}/{repo}/secret-scanning/alerts"],
        listLocationsForAlert: ["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"],
        updateAlert: ["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],
      },
      securityAdvisories: {
        createFork: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/forks"],
        createPrivateVulnerabilityReport: ["POST /repos/{owner}/{repo}/security-advisories/reports"],
        createRepositoryAdvisory: ["POST /repos/{owner}/{repo}/security-advisories"],
        createRepositoryAdvisoryCveRequest: ["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"],
        getGlobalAdvisory: ["GET /advisories/{ghsa_id}"],
        getRepositoryAdvisory: ["GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"],
        listGlobalAdvisories: ["GET /advisories"],
        listOrgRepositoryAdvisories: ["GET /orgs/{org}/security-advisories"],
        listRepositoryAdvisories: ["GET /repos/{owner}/{repo}/security-advisories"],
        updateRepositoryAdvisory: ["PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"],
      },
      teams: {
        addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
        addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
        checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        create: ["POST /orgs/{org}/teams"],
        createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
        createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
        deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
        getByName: ["GET /orgs/{org}/teams/{team_slug}"],
        getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        list: ["GET /orgs/{org}/teams"],
        listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
        listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
        listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
        listForAuthenticatedUser: ["GET /user/teams"],
        listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
        listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
        listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects"],
        listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
        removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
        removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
        removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
        updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
        updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
        updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"],
      },
      users: {
        addEmailForAuthenticated: ["POST /user/emails", {}, { renamed: ["users", "addEmailForAuthenticatedUser"] }],
        addEmailForAuthenticatedUser: ["POST /user/emails"],
        addSocialAccountForAuthenticatedUser: ["POST /user/social_accounts"],
        block: ["PUT /user/blocks/{username}"],
        checkBlocked: ["GET /user/blocks/{username}"],
        checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
        checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
        createGpgKeyForAuthenticated: ["POST /user/gpg_keys", {}, { renamed: ["users", "createGpgKeyForAuthenticatedUser"] }],
        createGpgKeyForAuthenticatedUser: ["POST /user/gpg_keys"],
        createPublicSshKeyForAuthenticated: ["POST /user/keys", {}, { renamed: ["users", "createPublicSshKeyForAuthenticatedUser"] }],
        createPublicSshKeyForAuthenticatedUser: ["POST /user/keys"],
        createSshSigningKeyForAuthenticatedUser: ["POST /user/ssh_signing_keys"],
        deleteEmailForAuthenticated: ["DELETE /user/emails", {}, { renamed: ["users", "deleteEmailForAuthenticatedUser"] }],
        deleteEmailForAuthenticatedUser: ["DELETE /user/emails"],
        deleteGpgKeyForAuthenticated: ["DELETE /user/gpg_keys/{gpg_key_id}", {}, { renamed: ["users", "deleteGpgKeyForAuthenticatedUser"] }],
        deleteGpgKeyForAuthenticatedUser: ["DELETE /user/gpg_keys/{gpg_key_id}"],
        deletePublicSshKeyForAuthenticated: ["DELETE /user/keys/{key_id}", {}, { renamed: ["users", "deletePublicSshKeyForAuthenticatedUser"] }],
        deletePublicSshKeyForAuthenticatedUser: ["DELETE /user/keys/{key_id}"],
        deleteSocialAccountForAuthenticatedUser: ["DELETE /user/social_accounts"],
        deleteSshSigningKeyForAuthenticatedUser: ["DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"],
        follow: ["PUT /user/following/{username}"],
        getAuthenticated: ["GET /user"],
        getByUsername: ["GET /users/{username}"],
        getContextForUser: ["GET /users/{username}/hovercard"],
        getGpgKeyForAuthenticated: ["GET /user/gpg_keys/{gpg_key_id}", {}, { renamed: ["users", "getGpgKeyForAuthenticatedUser"] }],
        getGpgKeyForAuthenticatedUser: ["GET /user/gpg_keys/{gpg_key_id}"],
        getPublicSshKeyForAuthenticated: ["GET /user/keys/{key_id}", {}, { renamed: ["users", "getPublicSshKeyForAuthenticatedUser"] }],
        getPublicSshKeyForAuthenticatedUser: ["GET /user/keys/{key_id}"],
        getSshSigningKeyForAuthenticatedUser: ["GET /user/ssh_signing_keys/{ssh_signing_key_id}"],
        list: ["GET /users"],
        listBlockedByAuthenticated: ["GET /user/blocks", {}, { renamed: ["users", "listBlockedByAuthenticatedUser"] }],
        listBlockedByAuthenticatedUser: ["GET /user/blocks"],
        listEmailsForAuthenticated: ["GET /user/emails", {}, { renamed: ["users", "listEmailsForAuthenticatedUser"] }],
        listEmailsForAuthenticatedUser: ["GET /user/emails"],
        listFollowedByAuthenticated: ["GET /user/following", {}, { renamed: ["users", "listFollowedByAuthenticatedUser"] }],
        listFollowedByAuthenticatedUser: ["GET /user/following"],
        listFollowersForAuthenticatedUser: ["GET /user/followers"],
        listFollowersForUser: ["GET /users/{username}/followers"],
        listFollowingForUser: ["GET /users/{username}/following"],
        listGpgKeysForAuthenticated: ["GET /user/gpg_keys", {}, { renamed: ["users", "listGpgKeysForAuthenticatedUser"] }],
        listGpgKeysForAuthenticatedUser: ["GET /user/gpg_keys"],
        listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
        listPublicEmailsForAuthenticated: ["GET /user/public_emails", {}, { renamed: ["users", "listPublicEmailsForAuthenticatedUser"] }],
        listPublicEmailsForAuthenticatedUser: ["GET /user/public_emails"],
        listPublicKeysForUser: ["GET /users/{username}/keys"],
        listPublicSshKeysForAuthenticated: ["GET /user/keys", {}, { renamed: ["users", "listPublicSshKeysForAuthenticatedUser"] }],
        listPublicSshKeysForAuthenticatedUser: ["GET /user/keys"],
        listSocialAccountsForAuthenticatedUser: ["GET /user/social_accounts"],
        listSocialAccountsForUser: ["GET /users/{username}/social_accounts"],
        listSshSigningKeysForAuthenticatedUser: ["GET /user/ssh_signing_keys"],
        listSshSigningKeysForUser: ["GET /users/{username}/ssh_signing_keys"],
        setPrimaryEmailVisibilityForAuthenticated: [
          "PATCH /user/email/visibility",
          {},
          { renamed: ["users", "setPrimaryEmailVisibilityForAuthenticatedUser"] },
        ],
        setPrimaryEmailVisibilityForAuthenticatedUser: ["PATCH /user/email/visibility"],
        unblock: ["DELETE /user/blocks/{username}"],
        unfollow: ["DELETE /user/following/{username}"],
        updateAuthenticated: ["PATCH /user"],
      },
    };
    var A = a;
    var c = new Map();
    for (const [e, t] of Object.entries(A)) {
      for (const [r, n] of Object.entries(t)) {
        const [t, o, s] = n;
        const [i, a] = t.split(/ /);
        const A = Object.assign({ method: i, url: a }, o);
        if (!c.has(e)) {
          c.set(e, new Map());
        }
        c.get(e).set(r, { scope: e, methodName: r, endpointDefaults: A, decorations: s });
      }
    }
    var u = {
      has({ scope: e }, t) {
        return c.get(e).has(t);
      },
      getOwnPropertyDescriptor(e, t) {
        return { value: this.get(e, t), configurable: true, writable: true, enumerable: true };
      },
      defineProperty(e, t, r) {
        Object.defineProperty(e.cache, t, r);
        return true;
      },
      deleteProperty(e, t) {
        delete e.cache[t];
        return true;
      },
      ownKeys({ scope: e }) {
        return [...c.get(e).keys()];
      },
      set(e, t, r) {
        return (e.cache[t] = r);
      },
      get({ octokit: e, scope: t, cache: r }, n) {
        if (r[n]) {
          return r[n];
        }
        const o = c.get(t).get(n);
        if (!o) {
          return void 0;
        }
        const { endpointDefaults: s, decorations: i } = o;
        if (i) {
          r[n] = decorate(e, t, n, s, i);
        } else {
          r[n] = e.request.defaults(s);
        }
        return r[n];
      },
    };
    function endpointsToMethods(e) {
      const t = {};
      for (const r of c.keys()) {
        t[r] = new Proxy({ octokit: e, scope: r, cache: {} }, u);
      }
      return t;
    }
    function decorate(e, t, r, n, o) {
      const s = e.request.defaults(n);
      function withDecorations(...n) {
        let i = s.endpoint.merge(...n);
        if (o.mapToData) {
          i = Object.assign({}, i, { data: i[o.mapToData], [o.mapToData]: void 0 });
          return s(i);
        }
        if (o.renamed) {
          const [n, s] = o.renamed;
          e.log.warn(`octokit.${t}.${r}() has been renamed to octokit.${n}.${s}()`);
        }
        if (o.deprecated) {
          e.log.warn(o.deprecated);
        }
        if (o.renamedParameters) {
          const i = s.endpoint.merge(...n);
          for (const [n, s] of Object.entries(o.renamedParameters)) {
            if (n in i) {
              e.log.warn(`"${n}" parameter is deprecated for "octokit.${t}.${r}()". Use "${s}" instead`);
              if (!(s in i)) {
                i[s] = i[n];
              }
              delete i[n];
            }
          }
          return s(i);
        }
        return s(...n);
      }
      return Object.assign(withDecorations, s);
    }
    function restEndpointMethods(e) {
      const t = endpointsToMethods(e);
      return { rest: t };
    }
    restEndpointMethods.VERSION = i;
    function legacyRestEndpointMethods(e) {
      const t = endpointsToMethods(e);
      return { ...t, rest: t };
    }
    legacyRestEndpointMethods.VERSION = i;
    0 && 0;
  },
  93708: (e, t, r) => {
    var n = Object.create;
    var o = Object.defineProperty;
    var s = Object.getOwnPropertyDescriptor;
    var i = Object.getOwnPropertyNames;
    var a = Object.getPrototypeOf;
    var A = Object.prototype.hasOwnProperty;
    var __export = (e, t) => {
      for (var r in t) o(e, r, { get: t[r], enumerable: true });
    };
    var __copyProps = (e, t, r, n) => {
      if ((t && typeof t === "object") || typeof t === "function") {
        for (let a of i(t)) if (!A.call(e, a) && a !== r) o(e, a, { get: () => t[a], enumerable: !(n = s(t, a)) || n.enumerable });
      }
      return e;
    };
    var __toESM = (e, t, r) => ((r = e != null ? n(a(e)) : {}), __copyProps(t || !e || !e.__esModule ? o(r, "default", { value: e, enumerable: true }) : r, e));
    var __toCommonJS = (e) => __copyProps(o({}, "__esModule", { value: true }), e);
    var c = {};
    __export(c, { RequestError: () => g });
    e.exports = __toCommonJS(c);
    var u = r(14150);
    var l = __toESM(r(55560));
    var p = (0, l.default)((e) => console.warn(e));
    var d = (0, l.default)((e) => console.warn(e));
    var g = class extends Error {
      constructor(e, t, r) {
        super(e);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "HttpError";
        this.status = t;
        let n;
        if ("headers" in r && typeof r.headers !== "undefined") {
          n = r.headers;
        }
        if ("response" in r) {
          this.response = r.response;
          n = r.response.headers;
        }
        const o = Object.assign({}, r.request);
        if (r.request.headers.authorization) {
          o.headers = Object.assign({}, r.request.headers, { authorization: r.request.headers.authorization.replace(/ .*$/, " [REDACTED]") });
        }
        o.url = o.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
        this.request = o;
        Object.defineProperty(this, "code", {
          get() {
            p(new u.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
            return t;
          },
        });
        Object.defineProperty(this, "headers", {
          get() {
            d(new u.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`."));
            return n || {};
          },
        });
      }
    };
    0 && 0;
  },
  66255: (e, t, r) => {
    var n = Object.defineProperty;
    var o = Object.getOwnPropertyDescriptor;
    var s = Object.getOwnPropertyNames;
    var i = Object.prototype.hasOwnProperty;
    var __export = (e, t) => {
      for (var r in t) n(e, r, { get: t[r], enumerable: true });
    };
    var __copyProps = (e, t, r, a) => {
      if ((t && typeof t === "object") || typeof t === "function") {
        for (let A of s(t)) if (!i.call(e, A) && A !== r) n(e, A, { get: () => t[A], enumerable: !(a = o(t, A)) || a.enumerable });
      }
      return e;
    };
    var __toCommonJS = (e) => __copyProps(n({}, "__esModule", { value: true }), e);
    var a = {};
    __export(a, { request: () => p });
    e.exports = __toCommonJS(a);
    var A = r(54471);
    var c = r(33843);
    var u = "8.4.0";
    function isPlainObject(e) {
      if (typeof e !== "object" || e === null) return false;
      if (Object.prototype.toString.call(e) !== "[object Object]") return false;
      const t = Object.getPrototypeOf(e);
      if (t === null) return true;
      const r = Object.prototype.hasOwnProperty.call(t, "constructor") && t.constructor;
      return typeof r === "function" && r instanceof r && Function.prototype.call(r) === Function.prototype.call(e);
    }
    var l = r(93708);
    function getBufferResponse(e) {
      return e.arrayBuffer();
    }
    function fetchWrapper(e) {
      var t, r, n, o;
      const s = e.request && e.request.log ? e.request.log : console;
      const i = ((t = e.request) == null ? void 0 : t.parseSuccessResponseBody) !== false;
      if (isPlainObject(e.body) || Array.isArray(e.body)) {
        e.body = JSON.stringify(e.body);
      }
      let a = {};
      let A;
      let c;
      let { fetch: u } = globalThis;
      if ((r = e.request) == null ? void 0 : r.fetch) {
        u = e.request.fetch;
      }
      if (!u) {
        throw new Error(
          "fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing"
        );
      }
      return u(e.url, {
        method: e.method,
        body: e.body,
        redirect: (n = e.request) == null ? void 0 : n.redirect,
        headers: e.headers,
        signal: (o = e.request) == null ? void 0 : o.signal,
        ...(e.body && { duplex: "half" }),
      })
        .then(async (t) => {
          c = t.url;
          A = t.status;
          for (const e of t.headers) {
            a[e[0]] = e[1];
          }
          if ("deprecation" in a) {
            const t = a.link && a.link.match(/<([^>]+)>; rel="deprecation"/);
            const r = t && t.pop();
            s.warn(`[@octokit/request] "${e.method} ${e.url}" is deprecated. It is scheduled to be removed on ${a.sunset}${r ? `. See ${r}` : ""}`);
          }
          if (A === 204 || A === 205) {
            return;
          }
          if (e.method === "HEAD") {
            if (A < 400) {
              return;
            }
            throw new l.RequestError(t.statusText, A, { response: { url: c, status: A, headers: a, data: void 0 }, request: e });
          }
          if (A === 304) {
            throw new l.RequestError("Not modified", A, { response: { url: c, status: A, headers: a, data: await getResponseData(t) }, request: e });
          }
          if (A >= 400) {
            const r = await getResponseData(t);
            const n = new l.RequestError(toErrorMessage(r), A, { response: { url: c, status: A, headers: a, data: r }, request: e });
            throw n;
          }
          return i ? await getResponseData(t) : t.body;
        })
        .then((e) => ({ status: A, url: c, headers: a, data: e }))
        .catch((t) => {
          if (t instanceof l.RequestError) throw t;
          else if (t.name === "AbortError") throw t;
          let r = t.message;
          if (t.name === "TypeError" && "cause" in t) {
            if (t.cause instanceof Error) {
              r = t.cause.message;
            } else if (typeof t.cause === "string") {
              r = t.cause;
            }
          }
          throw new l.RequestError(r, 500, { request: e });
        });
    }
    async function getResponseData(e) {
      const t = e.headers.get("content-type");
      if (/application\/json/.test(t)) {
        return e
          .json()
          .catch(() => e.text())
          .catch(() => "");
      }
      if (!t || /^text\/|charset=utf-8$/.test(t)) {
        return e.text();
      }
      return getBufferResponse(e);
    }
    function toErrorMessage(e) {
      if (typeof e === "string") return e;
      let t;
      if ("documentation_url" in e) {
        t = ` - ${e.documentation_url}`;
      } else {
        t = "";
      }
      if ("message" in e) {
        if (Array.isArray(e.errors)) {
          return `${e.message}: ${e.errors.map(JSON.stringify).join(", ")}${t}`;
        }
        return `${e.message}${t}`;
      }
      return `Unknown error: ${JSON.stringify(e)}`;
    }
    function withDefaults(e, t) {
      const r = e.defaults(t);
      const newApi = function (e, t) {
        const n = r.merge(e, t);
        if (!n.request || !n.request.hook) {
          return fetchWrapper(r.parse(n));
        }
        const request2 = (e, t) => fetchWrapper(r.parse(r.merge(e, t)));
        Object.assign(request2, { endpoint: r, defaults: withDefaults.bind(null, r) });
        return n.request.hook(request2, n);
      };
      return Object.assign(newApi, { endpoint: r, defaults: withDefaults.bind(null, r) });
    }
    var p = withDefaults(A.endpoint, { headers: { "user-agent": `octokit-request.js/${u} ${(0, c.getUserAgent)()}` } });
    0 && 0;
  },
  65772: (e, t, r) => {
    var n = Object.defineProperty;
    var o = Object.getOwnPropertyDescriptor;
    var s = Object.getOwnPropertyNames;
    var i = Object.prototype.hasOwnProperty;
    var __export = (e, t) => {
      for (var r in t) n(e, r, { get: t[r], enumerable: true });
    };
    var __copyProps = (e, t, r, a) => {
      if ((t && typeof t === "object") || typeof t === "function") {
        for (let A of s(t)) if (!i.call(e, A) && A !== r) n(e, A, { get: () => t[A], enumerable: !(a = o(t, A)) || a.enumerable });
      }
      return e;
    };
    var __toCommonJS = (e) => __copyProps(n({}, "__esModule", { value: true }), e);
    var a = {};
    __export(a, { Octokit: () => d });
    e.exports = __toCommonJS(a);
    var A = r(61897);
    var c = r(6966);
    var u = r(38082);
    var l = r(84935);
    var p = "20.1.1";
    var d = A.Octokit.plugin(c.requestLog, l.legacyRestEndpointMethods, u.paginateRest).defaults({ userAgent: `octokit-rest.js/${p}` });
    0 && 0;
  },
  75364: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TypeCompiler = t.Policy = t.TypeCompilerTypeGuardError = t.TypeCompilerUnknownTypeError = t.TypeCheck = void 0;
    const n = r(50038);
    const o = r(65507);
    const s = r(82129);
    const i = r(26113);
    const a = r(40886);
    const A = r(7210);
    const c = r(97034);
    const u = r(51786);
    const l = r(73373);
    const p = r(82486);
    const d = r(54025);
    const g = r(17479);
    const m = r(70384);
    class TypeCheck {
      constructor(e, t, r, o) {
        this.schema = e;
        this.references = t;
        this.checkFunc = r;
        this.code = o;
        this.hasTransform = (0, n.HasTransform)(e, t);
      }
      Code() {
        return this.code;
      }
      Errors(e) {
        return (0, o.Errors)(this.schema, this.references, e);
      }
      Check(e) {
        return this.checkFunc(e);
      }
      Decode(e) {
        if (!this.checkFunc(e)) throw new n.TransformDecodeCheckError(this.schema, e, this.Errors(e).First());
        return this.hasTransform ? (0, n.TransformDecode)(this.schema, this.references, e) : e;
      }
      Encode(e) {
        const t = this.hasTransform ? (0, n.TransformEncode)(this.schema, this.references, e) : e;
        if (!this.checkFunc(t)) throw new n.TransformEncodeCheckError(this.schema, e, this.Errors(e).First());
        return t;
      }
    }
    t.TypeCheck = TypeCheck;
    var h;
    (function (e) {
      function DollarSign(e) {
        return e === 36;
      }
      e.DollarSign = DollarSign;
      function IsUnderscore(e) {
        return e === 95;
      }
      e.IsUnderscore = IsUnderscore;
      function IsAlpha(e) {
        return (e >= 65 && e <= 90) || (e >= 97 && e <= 122);
      }
      e.IsAlpha = IsAlpha;
      function IsNumeric(e) {
        return e >= 48 && e <= 57;
      }
      e.IsNumeric = IsNumeric;
    })(h || (h = {}));
    var E;
    (function (e) {
      function IsFirstCharacterNumeric(e) {
        if (e.length === 0) return false;
        return h.IsNumeric(e.charCodeAt(0));
      }
      function IsAccessor(e) {
        if (IsFirstCharacterNumeric(e)) return false;
        for (let t = 0; t < e.length; t++) {
          const r = e.charCodeAt(t);
          const n = h.IsAlpha(r) || h.IsNumeric(r) || h.DollarSign(r) || h.IsUnderscore(r);
          if (!n) return false;
        }
        return true;
      }
      function EscapeHyphen(e) {
        return e.replace(/'/g, "\\'");
      }
      function Encode(e, t) {
        return IsAccessor(t) ? `${e}.${t}` : `${e}['${EscapeHyphen(t)}']`;
      }
      e.Encode = Encode;
    })(E || (E = {}));
    var I;
    (function (e) {
      function Encode(e) {
        const t = [];
        for (let r = 0; r < e.length; r++) {
          const n = e.charCodeAt(r);
          if (h.IsNumeric(n) || h.IsAlpha(n)) {
            t.push(e.charAt(r));
          } else {
            t.push(`_${n}_`);
          }
        }
        return t.join("").replace(/__/g, "_");
      }
      e.Encode = Encode;
    })(I || (I = {}));
    var y;
    (function (e) {
      function Escape(e) {
        return e.replace(/'/g, "\\'");
      }
      e.Escape = Escape;
    })(y || (y = {}));
    class TypeCompilerUnknownTypeError extends i.TypeBoxError {
      constructor(e) {
        super("Unknown type");
        this.schema = e;
      }
    }
    t.TypeCompilerUnknownTypeError = TypeCompilerUnknownTypeError;
    class TypeCompilerTypeGuardError extends i.TypeBoxError {
      constructor(e) {
        super("Preflight validation check failed to guard for the given schema");
        this.schema = e;
      }
    }
    t.TypeCompilerTypeGuardError = TypeCompilerTypeGuardError;
    var C;
    (function (e) {
      function IsExactOptionalProperty(e, t, r) {
        return s.TypeSystemPolicy.ExactOptionalPropertyTypes ? `('${t}' in ${e} ? ${r} : true)` : `(${E.Encode(e, t)} !== undefined ? ${r} : true)`;
      }
      e.IsExactOptionalProperty = IsExactOptionalProperty;
      function IsObjectLike(e) {
        return !s.TypeSystemPolicy.AllowArrayObject
          ? `(typeof ${e} === 'object' && ${e} !== null && !Array.isArray(${e}))`
          : `(typeof ${e} === 'object' && ${e} !== null)`;
      }
      e.IsObjectLike = IsObjectLike;
      function IsRecordLike(e) {
        return !s.TypeSystemPolicy.AllowArrayObject
          ? `(typeof ${e} === 'object' && ${e} !== null && !Array.isArray(${e}) && !(${e} instanceof Date) && !(${e} instanceof Uint8Array))`
          : `(typeof ${e} === 'object' && ${e} !== null && !(${e} instanceof Date) && !(${e} instanceof Uint8Array))`;
      }
      e.IsRecordLike = IsRecordLike;
      function IsNumberLike(e) {
        return s.TypeSystemPolicy.AllowNaN ? `typeof ${e} === 'number'` : `Number.isFinite(${e})`;
      }
      e.IsNumberLike = IsNumberLike;
      function IsVoidLike(e) {
        return s.TypeSystemPolicy.AllowNullVoid ? `(${e} === undefined || ${e} === null)` : `${e} === undefined`;
      }
      e.IsVoidLike = IsVoidLike;
    })(C || (t.Policy = C = {}));
    var b;
    (function (e) {
      function IsAnyOrUnknown(e) {
        return e[c.Kind] === "Any" || e[c.Kind] === "Unknown";
      }
      function* FromAny(e, t, r) {
        yield "true";
      }
      function* FromArray(e, t, r) {
        yield `Array.isArray(${r})`;
        const [n, o] = [CreateParameter("value", "any"), CreateParameter("acc", "number")];
        if ((0, g.IsNumber)(e.maxItems)) yield `${r}.length <= ${e.maxItems}`;
        if ((0, g.IsNumber)(e.minItems)) yield `${r}.length >= ${e.minItems}`;
        const s = CreateExpression(e.items, t, "value");
        yield `${r}.every((${n}) => ${s})`;
        if ((0, m.IsSchema)(e.contains) || (0, g.IsNumber)(e.minContains) || (0, g.IsNumber)(e.maxContains)) {
          const s = (0, m.IsSchema)(e.contains) ? e.contains : (0, d.Never)();
          const i = CreateExpression(s, t, "value");
          const a = (0, g.IsNumber)(e.minContains) ? [`(count >= ${e.minContains})`] : [];
          const A = (0, g.IsNumber)(e.maxContains) ? [`(count <= ${e.maxContains})`] : [];
          const c = `const count = value.reduce((${o}, ${n}) => ${i} ? acc + 1 : acc, 0)`;
          const u = [`(count > 0)`, ...a, ...A].join(" && ");
          yield `((${n}) => { ${c}; return ${u}})(${r})`;
        }
        if (e.uniqueItems === true) {
          const e = `const hashed = hash(element); if(set.has(hashed)) { return false } else { set.add(hashed) } } return true`;
          const t = `const set = new Set(); for(const element of value) { ${e} }`;
          yield `((${n}) => { ${t} )(${r})`;
        }
      }
      function* FromAsyncIterator(e, t, r) {
        yield `(typeof value === 'object' && Symbol.asyncIterator in ${r})`;
      }
      function* FromBigInt(e, t, r) {
        yield `(typeof ${r} === 'bigint')`;
        if ((0, g.IsBigInt)(e.exclusiveMaximum)) yield `${r} < BigInt(${e.exclusiveMaximum})`;
        if ((0, g.IsBigInt)(e.exclusiveMinimum)) yield `${r} > BigInt(${e.exclusiveMinimum})`;
        if ((0, g.IsBigInt)(e.maximum)) yield `${r} <= BigInt(${e.maximum})`;
        if ((0, g.IsBigInt)(e.minimum)) yield `${r} >= BigInt(${e.minimum})`;
        if ((0, g.IsBigInt)(e.multipleOf)) yield `(${r} % BigInt(${e.multipleOf})) === 0`;
      }
      function* FromBoolean(e, t, r) {
        yield `(typeof ${r} === 'boolean')`;
      }
      function* FromConstructor(e, t, r) {
        yield* Visit(e.returns, t, `${r}.prototype`);
      }
      function* FromDate(e, t, r) {
        yield `(${r} instanceof Date) && Number.isFinite(${r}.getTime())`;
        if ((0, g.IsNumber)(e.exclusiveMaximumTimestamp)) yield `${r}.getTime() < ${e.exclusiveMaximumTimestamp}`;
        if ((0, g.IsNumber)(e.exclusiveMinimumTimestamp)) yield `${r}.getTime() > ${e.exclusiveMinimumTimestamp}`;
        if ((0, g.IsNumber)(e.maximumTimestamp)) yield `${r}.getTime() <= ${e.maximumTimestamp}`;
        if ((0, g.IsNumber)(e.minimumTimestamp)) yield `${r}.getTime() >= ${e.minimumTimestamp}`;
        if ((0, g.IsNumber)(e.multipleOfTimestamp)) yield `(${r}.getTime() % ${e.multipleOfTimestamp}) === 0`;
      }
      function* FromFunction(e, t, r) {
        yield `(typeof ${r} === 'function')`;
      }
      function* FromInteger(e, t, r) {
        yield `Number.isInteger(${r})`;
        if ((0, g.IsNumber)(e.exclusiveMaximum)) yield `${r} < ${e.exclusiveMaximum}`;
        if ((0, g.IsNumber)(e.exclusiveMinimum)) yield `${r} > ${e.exclusiveMinimum}`;
        if ((0, g.IsNumber)(e.maximum)) yield `${r} <= ${e.maximum}`;
        if ((0, g.IsNumber)(e.minimum)) yield `${r} >= ${e.minimum}`;
        if ((0, g.IsNumber)(e.multipleOf)) yield `(${r} % ${e.multipleOf}) === 0`;
      }
      function* FromIntersect(e, t, r) {
        const n = e.allOf.map((e) => CreateExpression(e, t, r)).join(" && ");
        if (e.unevaluatedProperties === false) {
          const t = CreateVariable(`${new RegExp((0, l.KeyOfPattern)(e))};`);
          const o = `Object.getOwnPropertyNames(${r}).every(key => ${t}.test(key))`;
          yield `(${n} && ${o})`;
        } else if ((0, m.IsSchema)(e.unevaluatedProperties)) {
          const o = CreateVariable(`${new RegExp((0, l.KeyOfPattern)(e))};`);
          const s = `Object.getOwnPropertyNames(${r}).every(key => ${o}.test(key) || ${CreateExpression(e.unevaluatedProperties, t, `${r}[key]`)})`;
          yield `(${n} && ${s})`;
        } else {
          yield `(${n})`;
        }
      }
      function* FromIterator(e, t, r) {
        yield `(typeof value === 'object' && Symbol.iterator in ${r})`;
      }
      function* FromLiteral(e, t, r) {
        if (typeof e.const === "number" || typeof e.const === "boolean") {
          yield `(${r} === ${e.const})`;
        } else {
          yield `(${r} === '${y.Escape(e.const)}')`;
        }
      }
      function* FromNever(e, t, r) {
        yield `false`;
      }
      function* FromNot(e, t, r) {
        const n = CreateExpression(e.not, t, r);
        yield `(!${n})`;
      }
      function* FromNull(e, t, r) {
        yield `(${r} === null)`;
      }
      function* FromNumber(e, t, r) {
        yield C.IsNumberLike(r);
        if ((0, g.IsNumber)(e.exclusiveMaximum)) yield `${r} < ${e.exclusiveMaximum}`;
        if ((0, g.IsNumber)(e.exclusiveMinimum)) yield `${r} > ${e.exclusiveMinimum}`;
        if ((0, g.IsNumber)(e.maximum)) yield `${r} <= ${e.maximum}`;
        if ((0, g.IsNumber)(e.minimum)) yield `${r} >= ${e.minimum}`;
        if ((0, g.IsNumber)(e.multipleOf)) yield `(${r} % ${e.multipleOf}) === 0`;
      }
      function* FromObject(e, t, r) {
        yield C.IsObjectLike(r);
        if ((0, g.IsNumber)(e.minProperties)) yield `Object.getOwnPropertyNames(${r}).length >= ${e.minProperties}`;
        if ((0, g.IsNumber)(e.maxProperties)) yield `Object.getOwnPropertyNames(${r}).length <= ${e.maxProperties}`;
        const n = Object.getOwnPropertyNames(e.properties);
        for (const o of n) {
          const n = E.Encode(r, o);
          const s = e.properties[o];
          if (e.required && e.required.includes(o)) {
            yield* Visit(s, t, n);
            if ((0, p.ExtendsUndefinedCheck)(s) || IsAnyOrUnknown(s)) yield `('${o}' in ${r})`;
          } else {
            const e = CreateExpression(s, t, n);
            yield C.IsExactOptionalProperty(r, o, e);
          }
        }
        if (e.additionalProperties === false) {
          if (e.required && e.required.length === n.length) {
            yield `Object.getOwnPropertyNames(${r}).length === ${n.length}`;
          } else {
            const e = `[${n.map((e) => `'${e}'`).join(", ")}]`;
            yield `Object.getOwnPropertyNames(${r}).every(key => ${e}.includes(key))`;
          }
        }
        if (typeof e.additionalProperties === "object") {
          const o = CreateExpression(e.additionalProperties, t, `${r}[key]`);
          const s = `[${n.map((e) => `'${e}'`).join(", ")}]`;
          yield `(Object.getOwnPropertyNames(${r}).every(key => ${s}.includes(key) || ${o}))`;
        }
      }
      function* FromPromise(e, t, r) {
        yield `(typeof value === 'object' && typeof ${r}.then === 'function')`;
      }
      function* FromRecord(e, t, r) {
        yield C.IsRecordLike(r);
        if ((0, g.IsNumber)(e.minProperties)) yield `Object.getOwnPropertyNames(${r}).length >= ${e.minProperties}`;
        if ((0, g.IsNumber)(e.maxProperties)) yield `Object.getOwnPropertyNames(${r}).length <= ${e.maxProperties}`;
        const [n, o] = Object.entries(e.patternProperties)[0];
        const s = CreateVariable(`${new RegExp(n)}`);
        const i = CreateExpression(o, t, "value");
        const a = (0, m.IsSchema)(e.additionalProperties)
          ? CreateExpression(e.additionalProperties, t, r)
          : e.additionalProperties === false
            ? "false"
            : "true";
        const A = `(${s}.test(key) ? ${i} : ${a})`;
        yield `(Object.entries(${r}).every(([key, value]) => ${A}))`;
      }
      function* FromRef(e, r, n) {
        const o = (0, a.Deref)(e, r);
        if (t.functions.has(e.$ref)) return yield `${CreateFunctionName(e.$ref)}(${n})`;
        yield* Visit(o, r, n);
      }
      function* FromRegExp(e, t, r) {
        const n = CreateVariable(`${new RegExp(e.source, e.flags)};`);
        yield `(typeof ${r} === 'string')`;
        if ((0, g.IsNumber)(e.maxLength)) yield `${r}.length <= ${e.maxLength}`;
        if ((0, g.IsNumber)(e.minLength)) yield `${r}.length >= ${e.minLength}`;
        yield `${n}.test(${r})`;
      }
      function* FromString(e, t, r) {
        yield `(typeof ${r} === 'string')`;
        if ((0, g.IsNumber)(e.maxLength)) yield `${r}.length <= ${e.maxLength}`;
        if ((0, g.IsNumber)(e.minLength)) yield `${r}.length >= ${e.minLength}`;
        if (e.pattern !== undefined) {
          const t = CreateVariable(`${new RegExp(e.pattern)};`);
          yield `${t}.test(${r})`;
        }
        if (e.format !== undefined) {
          yield `format('${e.format}', ${r})`;
        }
      }
      function* FromSymbol(e, t, r) {
        yield `(typeof ${r} === 'symbol')`;
      }
      function* FromTemplateLiteral(e, t, r) {
        yield `(typeof ${r} === 'string')`;
        const n = CreateVariable(`${new RegExp(e.pattern)};`);
        yield `${n}.test(${r})`;
      }
      function* FromThis(e, t, r) {
        yield `${CreateFunctionName(e.$ref)}(${r})`;
      }
      function* FromTuple(e, t, r) {
        yield `Array.isArray(${r})`;
        if (e.items === undefined) return yield `${r}.length === 0`;
        yield `(${r}.length === ${e.maxItems})`;
        for (let n = 0; n < e.items.length; n++) {
          const o = CreateExpression(e.items[n], t, `${r}[${n}]`);
          yield `${o}`;
        }
      }
      function* FromUndefined(e, t, r) {
        yield `${r} === undefined`;
      }
      function* FromUnion(e, t, r) {
        const n = e.anyOf.map((e) => CreateExpression(e, t, r));
        yield `(${n.join(" || ")})`;
      }
      function* FromUint8Array(e, t, r) {
        yield `${r} instanceof Uint8Array`;
        if ((0, g.IsNumber)(e.maxByteLength)) yield `(${r}.length <= ${e.maxByteLength})`;
        if ((0, g.IsNumber)(e.minByteLength)) yield `(${r}.length >= ${e.minByteLength})`;
      }
      function* FromUnknown(e, t, r) {
        yield "true";
      }
      function* FromVoid(e, t, r) {
        yield C.IsVoidLike(r);
      }
      function* FromKind(e, r, n) {
        const o = t.instances.size;
        t.instances.set(o, e);
        yield `kind('${e[c.Kind]}', ${o}, ${n})`;
      }
      function* Visit(e, r, n, o = true) {
        const s = (0, g.IsString)(e.$id) ? [...r, e] : r;
        const i = e;
        if (o && (0, g.IsString)(e.$id)) {
          const o = CreateFunctionName(e.$id);
          if (t.functions.has(o)) {
            return yield `${o}(${n})`;
          } else {
            const s = CreateFunction(o, e, r, "value", false);
            t.functions.set(o, s);
            return yield `${o}(${n})`;
          }
        }
        switch (i[c.Kind]) {
          case "Any":
            return yield* FromAny(i, s, n);
          case "Array":
            return yield* FromArray(i, s, n);
          case "AsyncIterator":
            return yield* FromAsyncIterator(i, s, n);
          case "BigInt":
            return yield* FromBigInt(i, s, n);
          case "Boolean":
            return yield* FromBoolean(i, s, n);
          case "Constructor":
            return yield* FromConstructor(i, s, n);
          case "Date":
            return yield* FromDate(i, s, n);
          case "Function":
            return yield* FromFunction(i, s, n);
          case "Integer":
            return yield* FromInteger(i, s, n);
          case "Intersect":
            return yield* FromIntersect(i, s, n);
          case "Iterator":
            return yield* FromIterator(i, s, n);
          case "Literal":
            return yield* FromLiteral(i, s, n);
          case "Never":
            return yield* FromNever(i, s, n);
          case "Not":
            return yield* FromNot(i, s, n);
          case "Null":
            return yield* FromNull(i, s, n);
          case "Number":
            return yield* FromNumber(i, s, n);
          case "Object":
            return yield* FromObject(i, s, n);
          case "Promise":
            return yield* FromPromise(i, s, n);
          case "Record":
            return yield* FromRecord(i, s, n);
          case "Ref":
            return yield* FromRef(i, s, n);
          case "RegExp":
            return yield* FromRegExp(i, s, n);
          case "String":
            return yield* FromString(i, s, n);
          case "Symbol":
            return yield* FromSymbol(i, s, n);
          case "TemplateLiteral":
            return yield* FromTemplateLiteral(i, s, n);
          case "This":
            return yield* FromThis(i, s, n);
          case "Tuple":
            return yield* FromTuple(i, s, n);
          case "Undefined":
            return yield* FromUndefined(i, s, n);
          case "Union":
            return yield* FromUnion(i, s, n);
          case "Uint8Array":
            return yield* FromUint8Array(i, s, n);
          case "Unknown":
            return yield* FromUnknown(i, s, n);
          case "Void":
            return yield* FromVoid(i, s, n);
          default:
            if (!u.TypeRegistry.Has(i[c.Kind])) throw new TypeCompilerUnknownTypeError(e);
            return yield* FromKind(i, s, n);
        }
      }
      const t = { language: "javascript", functions: new Map(), variables: new Map(), instances: new Map() };
      function CreateExpression(e, t, r, n = true) {
        return `(${[...Visit(e, t, r, n)].join(" && ")})`;
      }
      function CreateFunctionName(e) {
        return `check_${I.Encode(e)}`;
      }
      function CreateVariable(e) {
        const r = `local_${t.variables.size}`;
        t.variables.set(r, `const ${r} = ${e}`);
        return r;
      }
      function CreateFunction(e, t, r, n, o = true) {
        const [s, i] = ["\n", (e) => "".padStart(e, " ")];
        const a = CreateParameter("value", "any");
        const A = CreateReturns("boolean");
        const c = [...Visit(t, r, n, o)].map((e) => `${i(4)}${e}`).join(` &&${s}`);
        return `function ${e}(${a})${A} {${s}${i(2)}return (${s}${c}${s}${i(2)})\n}`;
      }
      function CreateParameter(e, r) {
        const n = t.language === "typescript" ? `: ${r}` : "";
        return `${e}${n}`;
      }
      function CreateReturns(e) {
        return t.language === "typescript" ? `: ${e}` : "";
      }
      function Build(e, r, n) {
        const o = CreateFunction("check", e, r, "value");
        const s = CreateParameter("value", "any");
        const i = CreateReturns("boolean");
        const a = [...t.functions.values()];
        const A = [...t.variables.values()];
        const c = (0, g.IsString)(e.$id) ? `return function check(${s})${i} {\n  return ${CreateFunctionName(e.$id)}(value)\n}` : `return ${o}`;
        return [...A, ...a, c].join("\n");
      }
      function Code(...e) {
        const r = { language: "javascript" };
        const [n, o, s] =
          e.length === 2 && (0, g.IsArray)(e[1])
            ? [e[0], e[1], r]
            : e.length === 2 && !(0, g.IsArray)(e[1])
              ? [e[0], [], e[1]]
              : e.length === 3
                ? [e[0], e[1], e[2]]
                : e.length === 1
                  ? [e[0], [], r]
                  : [null, [], r];
        t.language = s.language;
        t.variables.clear();
        t.functions.clear();
        t.instances.clear();
        if (!(0, m.IsSchema)(n)) throw new TypeCompilerTypeGuardError(n);
        for (const e of o) if (!(0, m.IsSchema)(e)) throw new TypeCompilerTypeGuardError(e);
        return Build(n, o, s);
      }
      e.Code = Code;
      function Compile(e, r = []) {
        const n = Code(e, r, { language: "javascript" });
        const o = globalThis.Function("kind", "format", "hash", n);
        const s = new Map(t.instances);
        function typeRegistryFunction(e, t, r) {
          if (!u.TypeRegistry.Has(e) || !s.has(t)) return false;
          const n = u.TypeRegistry.Get(e);
          const o = s.get(t);
          return n(o, r);
        }
        function formatRegistryFunction(e, t) {
          if (!u.FormatRegistry.Has(e)) return false;
          const r = u.FormatRegistry.Get(e);
          return r(t);
        }
        function hashFunction(e) {
          return (0, A.Hash)(e);
        }
        const i = o(typeRegistryFunction, formatRegistryFunction, hashFunction);
        return new TypeCheck(e, r, i, n);
      }
      e.Compile = Compile;
    })(b || (t.TypeCompiler = b = {}));
  },
  25269: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.ValueErrorIterator = t.ValueErrorType = void 0;
    var s = r(65507);
    Object.defineProperty(t, "ValueErrorType", {
      enumerable: true,
      get: function () {
        return s.ValueErrorType;
      },
    });
    Object.defineProperty(t, "ValueErrorIterator", {
      enumerable: true,
      get: function () {
        return s.ValueErrorIterator;
      },
    });
    o(r(75364), t);
  },
  91660: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Errors = t.ValueErrorIterator = t.ValueErrorsUnknownTypeError = t.ValueErrorType = void 0;
    const n = r(82129);
    const o = r(73373);
    const s = r(51786);
    const i = r(82486);
    const a = r(84039);
    const A = r(26113);
    const c = r(40886);
    const u = r(7210);
    const l = r(97034);
    const p = r(54025);
    const d = r(17479);
    var g;
    (function (e) {
      e[(e["ArrayContains"] = 0)] = "ArrayContains";
      e[(e["ArrayMaxContains"] = 1)] = "ArrayMaxContains";
      e[(e["ArrayMaxItems"] = 2)] = "ArrayMaxItems";
      e[(e["ArrayMinContains"] = 3)] = "ArrayMinContains";
      e[(e["ArrayMinItems"] = 4)] = "ArrayMinItems";
      e[(e["ArrayUniqueItems"] = 5)] = "ArrayUniqueItems";
      e[(e["Array"] = 6)] = "Array";
      e[(e["AsyncIterator"] = 7)] = "AsyncIterator";
      e[(e["BigIntExclusiveMaximum"] = 8)] = "BigIntExclusiveMaximum";
      e[(e["BigIntExclusiveMinimum"] = 9)] = "BigIntExclusiveMinimum";
      e[(e["BigIntMaximum"] = 10)] = "BigIntMaximum";
      e[(e["BigIntMinimum"] = 11)] = "BigIntMinimum";
      e[(e["BigIntMultipleOf"] = 12)] = "BigIntMultipleOf";
      e[(e["BigInt"] = 13)] = "BigInt";
      e[(e["Boolean"] = 14)] = "Boolean";
      e[(e["DateExclusiveMaximumTimestamp"] = 15)] = "DateExclusiveMaximumTimestamp";
      e[(e["DateExclusiveMinimumTimestamp"] = 16)] = "DateExclusiveMinimumTimestamp";
      e[(e["DateMaximumTimestamp"] = 17)] = "DateMaximumTimestamp";
      e[(e["DateMinimumTimestamp"] = 18)] = "DateMinimumTimestamp";
      e[(e["DateMultipleOfTimestamp"] = 19)] = "DateMultipleOfTimestamp";
      e[(e["Date"] = 20)] = "Date";
      e[(e["Function"] = 21)] = "Function";
      e[(e["IntegerExclusiveMaximum"] = 22)] = "IntegerExclusiveMaximum";
      e[(e["IntegerExclusiveMinimum"] = 23)] = "IntegerExclusiveMinimum";
      e[(e["IntegerMaximum"] = 24)] = "IntegerMaximum";
      e[(e["IntegerMinimum"] = 25)] = "IntegerMinimum";
      e[(e["IntegerMultipleOf"] = 26)] = "IntegerMultipleOf";
      e[(e["Integer"] = 27)] = "Integer";
      e[(e["IntersectUnevaluatedProperties"] = 28)] = "IntersectUnevaluatedProperties";
      e[(e["Intersect"] = 29)] = "Intersect";
      e[(e["Iterator"] = 30)] = "Iterator";
      e[(e["Kind"] = 31)] = "Kind";
      e[(e["Literal"] = 32)] = "Literal";
      e[(e["Never"] = 33)] = "Never";
      e[(e["Not"] = 34)] = "Not";
      e[(e["Null"] = 35)] = "Null";
      e[(e["NumberExclusiveMaximum"] = 36)] = "NumberExclusiveMaximum";
      e[(e["NumberExclusiveMinimum"] = 37)] = "NumberExclusiveMinimum";
      e[(e["NumberMaximum"] = 38)] = "NumberMaximum";
      e[(e["NumberMinimum"] = 39)] = "NumberMinimum";
      e[(e["NumberMultipleOf"] = 40)] = "NumberMultipleOf";
      e[(e["Number"] = 41)] = "Number";
      e[(e["ObjectAdditionalProperties"] = 42)] = "ObjectAdditionalProperties";
      e[(e["ObjectMaxProperties"] = 43)] = "ObjectMaxProperties";
      e[(e["ObjectMinProperties"] = 44)] = "ObjectMinProperties";
      e[(e["ObjectRequiredProperty"] = 45)] = "ObjectRequiredProperty";
      e[(e["Object"] = 46)] = "Object";
      e[(e["Promise"] = 47)] = "Promise";
      e[(e["RegExp"] = 48)] = "RegExp";
      e[(e["StringFormatUnknown"] = 49)] = "StringFormatUnknown";
      e[(e["StringFormat"] = 50)] = "StringFormat";
      e[(e["StringMaxLength"] = 51)] = "StringMaxLength";
      e[(e["StringMinLength"] = 52)] = "StringMinLength";
      e[(e["StringPattern"] = 53)] = "StringPattern";
      e[(e["String"] = 54)] = "String";
      e[(e["Symbol"] = 55)] = "Symbol";
      e[(e["TupleLength"] = 56)] = "TupleLength";
      e[(e["Tuple"] = 57)] = "Tuple";
      e[(e["Uint8ArrayMaxByteLength"] = 58)] = "Uint8ArrayMaxByteLength";
      e[(e["Uint8ArrayMinByteLength"] = 59)] = "Uint8ArrayMinByteLength";
      e[(e["Uint8Array"] = 60)] = "Uint8Array";
      e[(e["Undefined"] = 61)] = "Undefined";
      e[(e["Union"] = 62)] = "Union";
      e[(e["Void"] = 63)] = "Void";
    })(g || (t.ValueErrorType = g = {}));
    class ValueErrorsUnknownTypeError extends A.TypeBoxError {
      constructor(e) {
        super("Unknown type");
        this.schema = e;
      }
    }
    t.ValueErrorsUnknownTypeError = ValueErrorsUnknownTypeError;
    function EscapeKey(e) {
      return e.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    function IsDefined(e) {
      return e !== undefined;
    }
    class ValueErrorIterator {
      constructor(e) {
        this.iterator = e;
      }
      [Symbol.iterator]() {
        return this.iterator;
      }
      First() {
        const e = this.iterator.next();
        return e.done ? undefined : e.value;
      }
    }
    t.ValueErrorIterator = ValueErrorIterator;
    function Create(e, t, r, n) {
      return { type: e, schema: t, path: r, value: n, message: (0, a.GetErrorFunction)()({ errorType: e, path: r, schema: t, value: n }) };
    }
    function* FromAny(e, t, r, n) {}
    function* FromArray(e, t, r, n) {
      if (!(0, d.IsArray)(n)) {
        return yield Create(g.Array, e, r, n);
      }
      if (IsDefined(e.minItems) && !(n.length >= e.minItems)) {
        yield Create(g.ArrayMinItems, e, r, n);
      }
      if (IsDefined(e.maxItems) && !(n.length <= e.maxItems)) {
        yield Create(g.ArrayMaxItems, e, r, n);
      }
      for (let o = 0; o < n.length; o++) {
        yield* Visit(e.items, t, `${r}/${o}`, n[o]);
      }
      if (
        e.uniqueItems === true &&
        !(function () {
          const e = new Set();
          for (const t of n) {
            const r = (0, u.Hash)(t);
            if (e.has(r)) {
              return false;
            } else {
              e.add(r);
            }
          }
          return true;
        })()
      ) {
        yield Create(g.ArrayUniqueItems, e, r, n);
      }
      if (!(IsDefined(e.contains) || IsDefined(e.minContains) || IsDefined(e.maxContains))) {
        return;
      }
      const o = IsDefined(e.contains) ? e.contains : (0, p.Never)();
      const s = n.reduce((e, n, s) => (Visit(o, t, `${r}${s}`, n).next().done === true ? e + 1 : e), 0);
      if (s === 0) {
        yield Create(g.ArrayContains, e, r, n);
      }
      if ((0, d.IsNumber)(e.minContains) && s < e.minContains) {
        yield Create(g.ArrayMinContains, e, r, n);
      }
      if ((0, d.IsNumber)(e.maxContains) && s > e.maxContains) {
        yield Create(g.ArrayMaxContains, e, r, n);
      }
    }
    function* FromAsyncIterator(e, t, r, n) {
      if (!(0, d.IsAsyncIterator)(n)) yield Create(g.AsyncIterator, e, r, n);
    }
    function* FromBigInt(e, t, r, n) {
      if (!(0, d.IsBigInt)(n)) return yield Create(g.BigInt, e, r, n);
      if (IsDefined(e.exclusiveMaximum) && !(n < e.exclusiveMaximum)) {
        yield Create(g.BigIntExclusiveMaximum, e, r, n);
      }
      if (IsDefined(e.exclusiveMinimum) && !(n > e.exclusiveMinimum)) {
        yield Create(g.BigIntExclusiveMinimum, e, r, n);
      }
      if (IsDefined(e.maximum) && !(n <= e.maximum)) {
        yield Create(g.BigIntMaximum, e, r, n);
      }
      if (IsDefined(e.minimum) && !(n >= e.minimum)) {
        yield Create(g.BigIntMinimum, e, r, n);
      }
      if (IsDefined(e.multipleOf) && !(n % e.multipleOf === BigInt(0))) {
        yield Create(g.BigIntMultipleOf, e, r, n);
      }
    }
    function* FromBoolean(e, t, r, n) {
      if (!(0, d.IsBoolean)(n)) yield Create(g.Boolean, e, r, n);
    }
    function* FromConstructor(e, t, r, n) {
      yield* Visit(e.returns, t, r, n.prototype);
    }
    function* FromDate(e, t, r, n) {
      if (!(0, d.IsDate)(n)) return yield Create(g.Date, e, r, n);
      if (IsDefined(e.exclusiveMaximumTimestamp) && !(n.getTime() < e.exclusiveMaximumTimestamp)) {
        yield Create(g.DateExclusiveMaximumTimestamp, e, r, n);
      }
      if (IsDefined(e.exclusiveMinimumTimestamp) && !(n.getTime() > e.exclusiveMinimumTimestamp)) {
        yield Create(g.DateExclusiveMinimumTimestamp, e, r, n);
      }
      if (IsDefined(e.maximumTimestamp) && !(n.getTime() <= e.maximumTimestamp)) {
        yield Create(g.DateMaximumTimestamp, e, r, n);
      }
      if (IsDefined(e.minimumTimestamp) && !(n.getTime() >= e.minimumTimestamp)) {
        yield Create(g.DateMinimumTimestamp, e, r, n);
      }
      if (IsDefined(e.multipleOfTimestamp) && !(n.getTime() % e.multipleOfTimestamp === 0)) {
        yield Create(g.DateMultipleOfTimestamp, e, r, n);
      }
    }
    function* FromFunction(e, t, r, n) {
      if (!(0, d.IsFunction)(n)) yield Create(g.Function, e, r, n);
    }
    function* FromInteger(e, t, r, n) {
      if (!(0, d.IsInteger)(n)) return yield Create(g.Integer, e, r, n);
      if (IsDefined(e.exclusiveMaximum) && !(n < e.exclusiveMaximum)) {
        yield Create(g.IntegerExclusiveMaximum, e, r, n);
      }
      if (IsDefined(e.exclusiveMinimum) && !(n > e.exclusiveMinimum)) {
        yield Create(g.IntegerExclusiveMinimum, e, r, n);
      }
      if (IsDefined(e.maximum) && !(n <= e.maximum)) {
        yield Create(g.IntegerMaximum, e, r, n);
      }
      if (IsDefined(e.minimum) && !(n >= e.minimum)) {
        yield Create(g.IntegerMinimum, e, r, n);
      }
      if (IsDefined(e.multipleOf) && !(n % e.multipleOf === 0)) {
        yield Create(g.IntegerMultipleOf, e, r, n);
      }
    }
    function* FromIntersect(e, t, r, n) {
      for (const o of e.allOf) {
        const s = Visit(o, t, r, n).next();
        if (!s.done) {
          yield Create(g.Intersect, e, r, n);
          yield s.value;
        }
      }
      if (e.unevaluatedProperties === false) {
        const t = new RegExp((0, o.KeyOfPattern)(e));
        for (const o of Object.getOwnPropertyNames(n)) {
          if (!t.test(o)) {
            yield Create(g.IntersectUnevaluatedProperties, e, `${r}/${o}`, n);
          }
        }
      }
      if (typeof e.unevaluatedProperties === "object") {
        const s = new RegExp((0, o.KeyOfPattern)(e));
        for (const o of Object.getOwnPropertyNames(n)) {
          if (!s.test(o)) {
            const s = Visit(e.unevaluatedProperties, t, `${r}/${o}`, n[o]).next();
            if (!s.done) yield s.value;
          }
        }
      }
    }
    function* FromIterator(e, t, r, n) {
      if (!(0, d.IsIterator)(n)) yield Create(g.Iterator, e, r, n);
    }
    function* FromLiteral(e, t, r, n) {
      if (!(n === e.const)) yield Create(g.Literal, e, r, n);
    }
    function* FromNever(e, t, r, n) {
      yield Create(g.Never, e, r, n);
    }
    function* FromNot(e, t, r, n) {
      if (Visit(e.not, t, r, n).next().done === true) yield Create(g.Not, e, r, n);
    }
    function* FromNull(e, t, r, n) {
      if (!(0, d.IsNull)(n)) yield Create(g.Null, e, r, n);
    }
    function* FromNumber(e, t, r, o) {
      if (!n.TypeSystemPolicy.IsNumberLike(o)) return yield Create(g.Number, e, r, o);
      if (IsDefined(e.exclusiveMaximum) && !(o < e.exclusiveMaximum)) {
        yield Create(g.NumberExclusiveMaximum, e, r, o);
      }
      if (IsDefined(e.exclusiveMinimum) && !(o > e.exclusiveMinimum)) {
        yield Create(g.NumberExclusiveMinimum, e, r, o);
      }
      if (IsDefined(e.maximum) && !(o <= e.maximum)) {
        yield Create(g.NumberMaximum, e, r, o);
      }
      if (IsDefined(e.minimum) && !(o >= e.minimum)) {
        yield Create(g.NumberMinimum, e, r, o);
      }
      if (IsDefined(e.multipleOf) && !(o % e.multipleOf === 0)) {
        yield Create(g.NumberMultipleOf, e, r, o);
      }
    }
    function* FromObject(e, t, r, o) {
      if (!n.TypeSystemPolicy.IsObjectLike(o)) return yield Create(g.Object, e, r, o);
      if (IsDefined(e.minProperties) && !(Object.getOwnPropertyNames(o).length >= e.minProperties)) {
        yield Create(g.ObjectMinProperties, e, r, o);
      }
      if (IsDefined(e.maxProperties) && !(Object.getOwnPropertyNames(o).length <= e.maxProperties)) {
        yield Create(g.ObjectMaxProperties, e, r, o);
      }
      const s = Array.isArray(e.required) ? e.required : [];
      const a = Object.getOwnPropertyNames(e.properties);
      const A = Object.getOwnPropertyNames(o);
      for (const t of s) {
        if (A.includes(t)) continue;
        yield Create(g.ObjectRequiredProperty, e.properties[t], `${r}/${EscapeKey(t)}`, undefined);
      }
      if (e.additionalProperties === false) {
        for (const t of A) {
          if (!a.includes(t)) {
            yield Create(g.ObjectAdditionalProperties, e, `${r}/${EscapeKey(t)}`, o[t]);
          }
        }
      }
      if (typeof e.additionalProperties === "object") {
        for (const n of A) {
          if (a.includes(n)) continue;
          yield* Visit(e.additionalProperties, t, `${r}/${EscapeKey(n)}`, o[n]);
        }
      }
      for (const s of a) {
        const a = e.properties[s];
        if (e.required && e.required.includes(s)) {
          yield* Visit(a, t, `${r}/${EscapeKey(s)}`, o[s]);
          if ((0, i.ExtendsUndefinedCheck)(e) && !(s in o)) {
            yield Create(g.ObjectRequiredProperty, a, `${r}/${EscapeKey(s)}`, undefined);
          }
        } else {
          if (n.TypeSystemPolicy.IsExactOptionalProperty(o, s)) {
            yield* Visit(a, t, `${r}/${EscapeKey(s)}`, o[s]);
          }
        }
      }
    }
    function* FromPromise(e, t, r, n) {
      if (!(0, d.IsPromise)(n)) yield Create(g.Promise, e, r, n);
    }
    function* FromRecord(e, t, r, o) {
      if (!n.TypeSystemPolicy.IsRecordLike(o)) return yield Create(g.Object, e, r, o);
      if (IsDefined(e.minProperties) && !(Object.getOwnPropertyNames(o).length >= e.minProperties)) {
        yield Create(g.ObjectMinProperties, e, r, o);
      }
      if (IsDefined(e.maxProperties) && !(Object.getOwnPropertyNames(o).length <= e.maxProperties)) {
        yield Create(g.ObjectMaxProperties, e, r, o);
      }
      const [s, i] = Object.entries(e.patternProperties)[0];
      const a = new RegExp(s);
      for (const [e, n] of Object.entries(o)) {
        if (a.test(e)) yield* Visit(i, t, `${r}/${EscapeKey(e)}`, n);
      }
      if (typeof e.additionalProperties === "object") {
        for (const [n, s] of Object.entries(o)) {
          if (!a.test(n)) yield* Visit(e.additionalProperties, t, `${r}/${EscapeKey(n)}`, s);
        }
      }
      if (e.additionalProperties === false) {
        for (const [t, n] of Object.entries(o)) {
          if (a.test(t)) continue;
          return yield Create(g.ObjectAdditionalProperties, e, `${r}/${EscapeKey(t)}`, n);
        }
      }
    }
    function* FromRef(e, t, r, n) {
      yield* Visit((0, c.Deref)(e, t), t, r, n);
    }
    function* FromRegExp(e, t, r, n) {
      if (!(0, d.IsString)(n)) return yield Create(g.String, e, r, n);
      if (IsDefined(e.minLength) && !(n.length >= e.minLength)) {
        yield Create(g.StringMinLength, e, r, n);
      }
      if (IsDefined(e.maxLength) && !(n.length <= e.maxLength)) {
        yield Create(g.StringMaxLength, e, r, n);
      }
      const o = new RegExp(e.source, e.flags);
      if (!o.test(n)) {
        return yield Create(g.RegExp, e, r, n);
      }
    }
    function* FromString(e, t, r, n) {
      if (!(0, d.IsString)(n)) return yield Create(g.String, e, r, n);
      if (IsDefined(e.minLength) && !(n.length >= e.minLength)) {
        yield Create(g.StringMinLength, e, r, n);
      }
      if (IsDefined(e.maxLength) && !(n.length <= e.maxLength)) {
        yield Create(g.StringMaxLength, e, r, n);
      }
      if ((0, d.IsString)(e.pattern)) {
        const t = new RegExp(e.pattern);
        if (!t.test(n)) {
          yield Create(g.StringPattern, e, r, n);
        }
      }
      if ((0, d.IsString)(e.format)) {
        if (!s.FormatRegistry.Has(e.format)) {
          yield Create(g.StringFormatUnknown, e, r, n);
        } else {
          const t = s.FormatRegistry.Get(e.format);
          if (!t(n)) {
            yield Create(g.StringFormat, e, r, n);
          }
        }
      }
    }
    function* FromSymbol(e, t, r, n) {
      if (!(0, d.IsSymbol)(n)) yield Create(g.Symbol, e, r, n);
    }
    function* FromTemplateLiteral(e, t, r, n) {
      if (!(0, d.IsString)(n)) return yield Create(g.String, e, r, n);
      const o = new RegExp(e.pattern);
      if (!o.test(n)) {
        yield Create(g.StringPattern, e, r, n);
      }
    }
    function* FromThis(e, t, r, n) {
      yield* Visit((0, c.Deref)(e, t), t, r, n);
    }
    function* FromTuple(e, t, r, n) {
      if (!(0, d.IsArray)(n)) return yield Create(g.Tuple, e, r, n);
      if (e.items === undefined && !(n.length === 0)) {
        return yield Create(g.TupleLength, e, r, n);
      }
      if (!(n.length === e.maxItems)) {
        return yield Create(g.TupleLength, e, r, n);
      }
      if (!e.items) {
        return;
      }
      for (let o = 0; o < e.items.length; o++) {
        yield* Visit(e.items[o], t, `${r}/${o}`, n[o]);
      }
    }
    function* FromUndefined(e, t, r, n) {
      if (!(0, d.IsUndefined)(n)) yield Create(g.Undefined, e, r, n);
    }
    function* FromUnion(e, t, r, n) {
      let o = 0;
      for (const s of e.anyOf) {
        const e = [...Visit(s, t, r, n)];
        if (e.length === 0) return;
        o += e.length;
      }
      if (o > 0) {
        yield Create(g.Union, e, r, n);
      }
    }
    function* FromUint8Array(e, t, r, n) {
      if (!(0, d.IsUint8Array)(n)) return yield Create(g.Uint8Array, e, r, n);
      if (IsDefined(e.maxByteLength) && !(n.length <= e.maxByteLength)) {
        yield Create(g.Uint8ArrayMaxByteLength, e, r, n);
      }
      if (IsDefined(e.minByteLength) && !(n.length >= e.minByteLength)) {
        yield Create(g.Uint8ArrayMinByteLength, e, r, n);
      }
    }
    function* FromUnknown(e, t, r, n) {}
    function* FromVoid(e, t, r, o) {
      if (!n.TypeSystemPolicy.IsVoidLike(o)) yield Create(g.Void, e, r, o);
    }
    function* FromKind(e, t, r, n) {
      const o = s.TypeRegistry.Get(e[l.Kind]);
      if (!o(e, n)) yield Create(g.Kind, e, r, n);
    }
    function* Visit(e, t, r, n) {
      const o = IsDefined(e.$id) ? [...t, e] : t;
      const i = e;
      switch (i[l.Kind]) {
        case "Any":
          return yield* FromAny(i, o, r, n);
        case "Array":
          return yield* FromArray(i, o, r, n);
        case "AsyncIterator":
          return yield* FromAsyncIterator(i, o, r, n);
        case "BigInt":
          return yield* FromBigInt(i, o, r, n);
        case "Boolean":
          return yield* FromBoolean(i, o, r, n);
        case "Constructor":
          return yield* FromConstructor(i, o, r, n);
        case "Date":
          return yield* FromDate(i, o, r, n);
        case "Function":
          return yield* FromFunction(i, o, r, n);
        case "Integer":
          return yield* FromInteger(i, o, r, n);
        case "Intersect":
          return yield* FromIntersect(i, o, r, n);
        case "Iterator":
          return yield* FromIterator(i, o, r, n);
        case "Literal":
          return yield* FromLiteral(i, o, r, n);
        case "Never":
          return yield* FromNever(i, o, r, n);
        case "Not":
          return yield* FromNot(i, o, r, n);
        case "Null":
          return yield* FromNull(i, o, r, n);
        case "Number":
          return yield* FromNumber(i, o, r, n);
        case "Object":
          return yield* FromObject(i, o, r, n);
        case "Promise":
          return yield* FromPromise(i, o, r, n);
        case "Record":
          return yield* FromRecord(i, o, r, n);
        case "Ref":
          return yield* FromRef(i, o, r, n);
        case "RegExp":
          return yield* FromRegExp(i, o, r, n);
        case "String":
          return yield* FromString(i, o, r, n);
        case "Symbol":
          return yield* FromSymbol(i, o, r, n);
        case "TemplateLiteral":
          return yield* FromTemplateLiteral(i, o, r, n);
        case "This":
          return yield* FromThis(i, o, r, n);
        case "Tuple":
          return yield* FromTuple(i, o, r, n);
        case "Undefined":
          return yield* FromUndefined(i, o, r, n);
        case "Union":
          return yield* FromUnion(i, o, r, n);
        case "Uint8Array":
          return yield* FromUint8Array(i, o, r, n);
        case "Unknown":
          return yield* FromUnknown(i, o, r, n);
        case "Void":
          return yield* FromVoid(i, o, r, n);
        default:
          if (!s.TypeRegistry.Has(i[l.Kind])) throw new ValueErrorsUnknownTypeError(e);
          return yield* FromKind(i, o, r, n);
      }
    }
    function Errors(...e) {
      const t = e.length === 3 ? Visit(e[0], e[1], "", e[2]) : Visit(e[0], [], "", e[1]);
      return new ValueErrorIterator(t);
    }
    t.Errors = Errors;
  },
  84039: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.GetErrorFunction = t.SetErrorFunction = t.DefaultErrorFunction = void 0;
    const n = r(97034);
    const o = r(91660);
    function DefaultErrorFunction(e) {
      switch (e.errorType) {
        case o.ValueErrorType.ArrayContains:
          return "Expected array to contain at least one matching value";
        case o.ValueErrorType.ArrayMaxContains:
          return `Expected array to contain no more than ${e.schema.maxContains} matching values`;
        case o.ValueErrorType.ArrayMinContains:
          return `Expected array to contain at least ${e.schema.minContains} matching values`;
        case o.ValueErrorType.ArrayMaxItems:
          return `Expected array length to be less or equal to ${e.schema.maxItems}`;
        case o.ValueErrorType.ArrayMinItems:
          return `Expected array length to be greater or equal to ${e.schema.minItems}`;
        case o.ValueErrorType.ArrayUniqueItems:
          return "Expected array elements to be unique";
        case o.ValueErrorType.Array:
          return "Expected array";
        case o.ValueErrorType.AsyncIterator:
          return "Expected AsyncIterator";
        case o.ValueErrorType.BigIntExclusiveMaximum:
          return `Expected bigint to be less than ${e.schema.exclusiveMaximum}`;
        case o.ValueErrorType.BigIntExclusiveMinimum:
          return `Expected bigint to be greater than ${e.schema.exclusiveMinimum}`;
        case o.ValueErrorType.BigIntMaximum:
          return `Expected bigint to be less or equal to ${e.schema.maximum}`;
        case o.ValueErrorType.BigIntMinimum:
          return `Expected bigint to be greater or equal to ${e.schema.minimum}`;
        case o.ValueErrorType.BigIntMultipleOf:
          return `Expected bigint to be a multiple of ${e.schema.multipleOf}`;
        case o.ValueErrorType.BigInt:
          return "Expected bigint";
        case o.ValueErrorType.Boolean:
          return "Expected boolean";
        case o.ValueErrorType.DateExclusiveMinimumTimestamp:
          return `Expected Date timestamp to be greater than ${e.schema.exclusiveMinimumTimestamp}`;
        case o.ValueErrorType.DateExclusiveMaximumTimestamp:
          return `Expected Date timestamp to be less than ${e.schema.exclusiveMaximumTimestamp}`;
        case o.ValueErrorType.DateMinimumTimestamp:
          return `Expected Date timestamp to be greater or equal to ${e.schema.minimumTimestamp}`;
        case o.ValueErrorType.DateMaximumTimestamp:
          return `Expected Date timestamp to be less or equal to ${e.schema.maximumTimestamp}`;
        case o.ValueErrorType.DateMultipleOfTimestamp:
          return `Expected Date timestamp to be a multiple of ${e.schema.multipleOfTimestamp}`;
        case o.ValueErrorType.Date:
          return "Expected Date";
        case o.ValueErrorType.Function:
          return "Expected function";
        case o.ValueErrorType.IntegerExclusiveMaximum:
          return `Expected integer to be less than ${e.schema.exclusiveMaximum}`;
        case o.ValueErrorType.IntegerExclusiveMinimum:
          return `Expected integer to be greater than ${e.schema.exclusiveMinimum}`;
        case o.ValueErrorType.IntegerMaximum:
          return `Expected integer to be less or equal to ${e.schema.maximum}`;
        case o.ValueErrorType.IntegerMinimum:
          return `Expected integer to be greater or equal to ${e.schema.minimum}`;
        case o.ValueErrorType.IntegerMultipleOf:
          return `Expected integer to be a multiple of ${e.schema.multipleOf}`;
        case o.ValueErrorType.Integer:
          return "Expected integer";
        case o.ValueErrorType.IntersectUnevaluatedProperties:
          return "Unexpected property";
        case o.ValueErrorType.Intersect:
          return "Expected all values to match";
        case o.ValueErrorType.Iterator:
          return "Expected Iterator";
        case o.ValueErrorType.Literal:
          return `Expected ${typeof e.schema.const === "string" ? `'${e.schema.const}'` : e.schema.const}`;
        case o.ValueErrorType.Never:
          return "Never";
        case o.ValueErrorType.Not:
          return "Value should not match";
        case o.ValueErrorType.Null:
          return "Expected null";
        case o.ValueErrorType.NumberExclusiveMaximum:
          return `Expected number to be less than ${e.schema.exclusiveMaximum}`;
        case o.ValueErrorType.NumberExclusiveMinimum:
          return `Expected number to be greater than ${e.schema.exclusiveMinimum}`;
        case o.ValueErrorType.NumberMaximum:
          return `Expected number to be less or equal to ${e.schema.maximum}`;
        case o.ValueErrorType.NumberMinimum:
          return `Expected number to be greater or equal to ${e.schema.minimum}`;
        case o.ValueErrorType.NumberMultipleOf:
          return `Expected number to be a multiple of ${e.schema.multipleOf}`;
        case o.ValueErrorType.Number:
          return "Expected number";
        case o.ValueErrorType.Object:
          return "Expected object";
        case o.ValueErrorType.ObjectAdditionalProperties:
          return "Unexpected property";
        case o.ValueErrorType.ObjectMaxProperties:
          return `Expected object to have no more than ${e.schema.maxProperties} properties`;
        case o.ValueErrorType.ObjectMinProperties:
          return `Expected object to have at least ${e.schema.minProperties} properties`;
        case o.ValueErrorType.ObjectRequiredProperty:
          return "Required property";
        case o.ValueErrorType.Promise:
          return "Expected Promise";
        case o.ValueErrorType.RegExp:
          return "Expected string to match regular expression";
        case o.ValueErrorType.StringFormatUnknown:
          return `Unknown format '${e.schema.format}'`;
        case o.ValueErrorType.StringFormat:
          return `Expected string to match '${e.schema.format}' format`;
        case o.ValueErrorType.StringMaxLength:
          return `Expected string length less or equal to ${e.schema.maxLength}`;
        case o.ValueErrorType.StringMinLength:
          return `Expected string length greater or equal to ${e.schema.minLength}`;
        case o.ValueErrorType.StringPattern:
          return `Expected string to match '${e.schema.pattern}'`;
        case o.ValueErrorType.String:
          return "Expected string";
        case o.ValueErrorType.Symbol:
          return "Expected symbol";
        case o.ValueErrorType.TupleLength:
          return `Expected tuple to have ${e.schema.maxItems || 0} elements`;
        case o.ValueErrorType.Tuple:
          return "Expected tuple";
        case o.ValueErrorType.Uint8ArrayMaxByteLength:
          return `Expected byte length less or equal to ${e.schema.maxByteLength}`;
        case o.ValueErrorType.Uint8ArrayMinByteLength:
          return `Expected byte length greater or equal to ${e.schema.minByteLength}`;
        case o.ValueErrorType.Uint8Array:
          return "Expected Uint8Array";
        case o.ValueErrorType.Undefined:
          return "Expected undefined";
        case o.ValueErrorType.Union:
          return "Expected union value";
        case o.ValueErrorType.Void:
          return "Expected void";
        case o.ValueErrorType.Kind:
          return `Expected kind '${e.schema[n.Kind]}'`;
        default:
          return "Unknown error type";
      }
    }
    t.DefaultErrorFunction = DefaultErrorFunction;
    let s = DefaultErrorFunction;
    function SetErrorFunction(e) {
      s = e;
    }
    t.SetErrorFunction = SetErrorFunction;
    function GetErrorFunction() {
      return s;
    }
    t.GetErrorFunction = GetErrorFunction;
  },
  65507: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(91660), t);
    o(r(84039), t);
  },
  14019: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(91769), t);
    o(r(26113), t);
    o(r(64754), t);
    o(r(57782), t);
    o(r(94354), t);
    o(r(51786), t);
    o(r(12760), t);
    o(r(97034), t);
    o(r(36813), t);
    o(r(17186), t);
    o(r(68092), t);
    o(r(85164), t);
    o(r(13278), t);
    o(r(64515), t);
    o(r(80788), t);
    o(r(19236), t);
    o(r(16939), t);
    o(r(58562), t);
    o(r(49305), t);
    o(r(911), t);
    o(r(98056), t);
    o(r(41153), t);
    o(r(94850), t);
    o(r(69682), t);
    o(r(29857), t);
    o(r(86918), t);
    o(r(26277), t);
    o(r(4949), t);
    o(r(62746), t);
    o(r(35907), t);
    o(r(30568), t);
    o(r(73373), t);
    o(r(98076), t);
    o(r(41094), t);
    o(r(54025), t);
    o(r(1078), t);
    o(r(50468), t);
    o(r(85544), t);
    o(r(62094), t);
    o(r(88932), t);
    o(r(38425), t);
    o(r(30449), t);
    o(r(53345), t);
    o(r(40640), t);
    o(r(70062), t);
    o(r(40675), t);
    o(r(78946), t);
    o(r(30420), t);
    o(r(33107), t);
    o(r(80470), t);
    o(r(26936), t);
    o(r(42744), t);
    o(r(83003), t);
    o(r(32970), t);
    o(r(68954), t);
    o(r(60343), t);
    o(r(23556), t);
    o(r(81688), t);
    o(r(2129), t);
    o(r(26609), t);
    o(r(67575), t);
    o(r(7521), t);
    o(r(45760), t);
    o(r(96231), t);
    o(r(69100), t);
    o(r(51897), t);
    o(r(23339), t);
    o(r(81947), t);
    o(r(68237), t);
  },
  82129: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(17755), t);
    o(r(15912), t);
  },
  17755: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TypeSystemPolicy = void 0;
    const n = r(17479);
    var o;
    (function (e) {
      e.ExactOptionalPropertyTypes = false;
      e.AllowArrayObject = false;
      e.AllowNaN = false;
      e.AllowNullVoid = false;
      function IsExactOptionalProperty(t, r) {
        return e.ExactOptionalPropertyTypes ? r in t : t[r] !== undefined;
      }
      e.IsExactOptionalProperty = IsExactOptionalProperty;
      function IsObjectLike(t) {
        const r = (0, n.IsObject)(t);
        return e.AllowArrayObject ? r : r && !(0, n.IsArray)(t);
      }
      e.IsObjectLike = IsObjectLike;
      function IsRecordLike(e) {
        return IsObjectLike(e) && !(e instanceof Date) && !(e instanceof Uint8Array);
      }
      e.IsRecordLike = IsRecordLike;
      function IsNumberLike(t) {
        return e.AllowNaN ? (0, n.IsNumber)(t) : Number.isFinite(t);
      }
      e.IsNumberLike = IsNumberLike;
      function IsVoidLike(t) {
        const r = (0, n.IsUndefined)(t);
        return e.AllowNullVoid ? r || t === null : r;
      }
      e.IsVoidLike = IsVoidLike;
    })(o || (t.TypeSystemPolicy = o = {}));
  },
  15912: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TypeSystem = t.TypeSystemDuplicateFormat = t.TypeSystemDuplicateTypeKind = void 0;
    const n = r(51786);
    const o = r(23339);
    const s = r(97034);
    const i = r(26113);
    class TypeSystemDuplicateTypeKind extends i.TypeBoxError {
      constructor(e) {
        super(`Duplicate type kind '${e}' detected`);
      }
    }
    t.TypeSystemDuplicateTypeKind = TypeSystemDuplicateTypeKind;
    class TypeSystemDuplicateFormat extends i.TypeBoxError {
      constructor(e) {
        super(`Duplicate string format '${e}' detected`);
      }
    }
    t.TypeSystemDuplicateFormat = TypeSystemDuplicateFormat;
    var a;
    (function (e) {
      function Type(e, t) {
        if (n.TypeRegistry.Has(e)) throw new TypeSystemDuplicateTypeKind(e);
        n.TypeRegistry.Set(e, t);
        return (t = {}) => (0, o.Unsafe)({ ...t, [s.Kind]: e });
      }
      e.Type = Type;
      function Format(e, t) {
        if (n.FormatRegistry.Has(e)) throw new TypeSystemDuplicateFormat(e);
        n.FormatRegistry.Set(e, t);
        return e;
      }
      e.Format = Format;
    })(a || (t.TypeSystem = a = {}));
  },
  57815: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Any = void 0;
    const n = r(97034);
    function Any(e = {}) {
      return { ...e, [n.Kind]: "Any" };
    }
    t.Any = Any;
  },
  36813: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(57815), t);
  },
  45311: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Array = void 0;
    const n = r(38100);
    const o = r(97034);
    function Array(e, t = {}) {
      return { ...t, [o.Kind]: "Array", type: "array", items: (0, n.CloneType)(e) };
    }
    t.Array = Array;
  },
  17186: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(45311), t);
  },
  15007: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.AsyncIterator = void 0;
    const n = r(97034);
    const o = r(38100);
    function AsyncIterator(e, t = {}) {
      return { ...t, [n.Kind]: "AsyncIterator", type: "AsyncIterator", items: (0, o.CloneType)(e) };
    }
    t.AsyncIterator = AsyncIterator;
  },
  68092: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(15007), t);
  },
  68263: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Awaited = void 0;
    const n = r(62746);
    const o = r(69100);
    const s = r(38100);
    const i = r(96994);
    function FromRest(e) {
      return e.map((e) => AwaitedResolve(e));
    }
    function FromIntersect(e) {
      return (0, n.Intersect)(FromRest(e));
    }
    function FromUnion(e) {
      return (0, o.Union)(FromRest(e));
    }
    function FromPromise(e) {
      return AwaitedResolve(e);
    }
    function AwaitedResolve(e) {
      return (0, i.IsIntersect)(e) ? FromIntersect(e.allOf) : (0, i.IsUnion)(e) ? FromUnion(e.anyOf) : (0, i.IsPromise)(e) ? FromPromise(e.item) : e;
    }
    function Awaited(e, t = {}) {
      return (0, s.CloneType)(AwaitedResolve(e), t);
    }
    t.Awaited = Awaited;
  },
  85164: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(68263), t);
  },
  9495: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.BigInt = void 0;
    const n = r(97034);
    function BigInt(e = {}) {
      return { ...e, [n.Kind]: "BigInt", type: "bigint" };
    }
    t.BigInt = BigInt;
  },
  13278: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(9495), t);
  },
  53715: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Boolean = void 0;
    const n = r(97034);
    function Boolean(e = {}) {
      return { ...e, [n.Kind]: "Boolean", type: "boolean" };
    }
    t.Boolean = Boolean;
  },
  64515: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(53715), t);
  },
  91769: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(38100), t);
    o(r(80387), t);
  },
  38100: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.CloneType = t.CloneRest = void 0;
    const n = r(80387);
    function CloneRest(e) {
      return e.map((e) => CloneType(e));
    }
    t.CloneRest = CloneRest;
    function CloneType(e, t = {}) {
      return { ...(0, n.Clone)(e), ...t };
    }
    t.CloneType = CloneType;
  },
  80387: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Clone = void 0;
    const n = r(13415);
    function ArrayType(e) {
      return e.map((e) => Visit(e));
    }
    function DateType(e) {
      return new Date(e.getTime());
    }
    function Uint8ArrayType(e) {
      return new Uint8Array(e);
    }
    function RegExpType(e) {
      return new RegExp(e.source, e.flags);
    }
    function ObjectType(e) {
      const t = {};
      for (const r of Object.getOwnPropertyNames(e)) {
        t[r] = Visit(e[r]);
      }
      for (const r of Object.getOwnPropertySymbols(e)) {
        t[r] = Visit(e[r]);
      }
      return t;
    }
    function Visit(e) {
      return n.IsArray(e)
        ? ArrayType(e)
        : n.IsDate(e)
          ? DateType(e)
          : n.IsUint8Array(e)
            ? Uint8ArrayType(e)
            : n.IsRegExp(e)
              ? RegExpType(e)
              : n.IsObject(e)
                ? ObjectType(e)
                : e;
    }
    function Clone(e) {
      return Visit(e);
    }
    t.Clone = Clone;
  },
  67263: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Composite = void 0;
    const n = r(62746);
    const o = r(86918);
    const s = r(73373);
    const i = r(62094);
    const a = r(12760);
    const A = r(96994);
    function CompositeKeys(e) {
      const t = [];
      for (const r of e) t.push(...(0, s.KeyOfPropertyKeys)(r));
      return (0, a.SetDistinct)(t);
    }
    function FilterNever(e) {
      return e.filter((e) => !(0, A.IsNever)(e));
    }
    function CompositeProperty(e, t) {
      const r = [];
      for (const n of e) r.push(...(0, o.IndexFromPropertyKeys)(n, [t]));
      return FilterNever(r);
    }
    function CompositeProperties(e, t) {
      const r = {};
      for (const o of t) {
        r[o] = (0, n.IntersectEvaluated)(CompositeProperty(e, o));
      }
      return r;
    }
    function Composite(e, t = {}) {
      const r = CompositeKeys(e);
      const n = CompositeProperties(e, r);
      const o = (0, i.Object)(n, t);
      return o;
    }
    t.Composite = Composite;
  },
  80788: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(67263), t);
  },
  54191: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Const = void 0;
    const n = r(36813);
    const o = r(13278);
    const s = r(49305);
    const i = r(29857);
    const a = r(98076);
    const A = r(50468);
    const c = r(62094);
    const u = r(2129);
    const l = r(7521);
    const p = r(40675);
    const d = r(96231);
    const g = r(45760);
    const m = r(51897);
    const h = r(91769);
    const E = r(13415);
    function FromArray(e) {
      return e.map((e) => FromValue(e, false));
    }
    function FromProperties(e) {
      const t = {};
      for (const r of globalThis.Object.getOwnPropertyNames(e)) t[r] = (0, p.Readonly)(FromValue(e[r], false));
      return t;
    }
    function ConditionalReadonly(e, t) {
      return t === true ? e : (0, p.Readonly)(e);
    }
    function FromValue(e, t) {
      return (0, E.IsAsyncIterator)(e)
        ? ConditionalReadonly((0, n.Any)(), t)
        : (0, E.IsIterator)(e)
          ? ConditionalReadonly((0, n.Any)(), t)
          : (0, E.IsArray)(e)
            ? (0, p.Readonly)((0, l.Tuple)(FromArray(e)))
            : (0, E.IsUint8Array)(e)
              ? (0, g.Uint8Array)()
              : (0, E.IsDate)(e)
                ? (0, s.Date)()
                : (0, E.IsObject)(e)
                  ? ConditionalReadonly((0, c.Object)(FromProperties(e)), t)
                  : (0, E.IsFunction)(e)
                    ? ConditionalReadonly((0, i.Function)([], (0, m.Unknown)()), t)
                    : (0, E.IsUndefined)(e)
                      ? (0, d.Undefined)()
                      : (0, E.IsNull)(e)
                        ? (0, A.Null)()
                        : (0, E.IsSymbol)(e)
                          ? (0, u.Symbol)()
                          : (0, E.IsBigInt)(e)
                            ? (0, o.BigInt)()
                            : (0, E.IsNumber)(e)
                              ? (0, a.Literal)(e)
                              : (0, E.IsBoolean)(e)
                                ? (0, a.Literal)(e)
                                : (0, E.IsString)(e)
                                  ? (0, a.Literal)(e)
                                  : (0, c.Object)({});
    }
    function Const(e, t = {}) {
      return (0, h.CloneType)(FromValue(e, true), t);
    }
    t.Const = Const;
  },
  19236: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(54191), t);
  },
  96127: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ConstructorParameters = void 0;
    const n = r(7521);
    const o = r(38100);
    function ConstructorParameters(e, t = {}) {
      return (0, n.Tuple)((0, o.CloneRest)(e.parameters), { ...t });
    }
    t.ConstructorParameters = ConstructorParameters;
  },
  58562: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(96127), t);
  },
  89035: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Constructor = void 0;
    const n = r(38100);
    const o = r(97034);
    function Constructor(e, t, r) {
      return { ...r, [o.Kind]: "Constructor", type: "Constructor", parameters: (0, n.CloneRest)(e), returns: (0, n.CloneType)(t) };
    }
    t.Constructor = Constructor;
  },
  16939: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(89035), t);
  },
  7617: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Date = void 0;
    const n = r(97034);
    function Date(e = {}) {
      return { ...e, [n.Kind]: "Date", type: "Date" };
    }
    t.Date = Date;
  },
  49305: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(7617), t);
  },
  79911: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Deref = void 0;
    const n = r(38100);
    const o = r(83889);
    const s = r(13415);
    const i = r(96994);
    function FromRest(e, t) {
      return e.map((e) => Deref(e, t));
    }
    function FromProperties(e, t) {
      const r = {};
      for (const n of globalThis.Object.getOwnPropertyNames(e)) {
        r[n] = Deref(e[n], t);
      }
      return r;
    }
    function FromConstructor(e, t) {
      e.parameters = FromRest(e.parameters, t);
      e.returns = Deref(e.returns, t);
      return e;
    }
    function FromFunction(e, t) {
      e.parameters = FromRest(e.parameters, t);
      e.returns = Deref(e.returns, t);
      return e;
    }
    function FromIntersect(e, t) {
      e.allOf = FromRest(e.allOf, t);
      return e;
    }
    function FromUnion(e, t) {
      e.anyOf = FromRest(e.anyOf, t);
      return e;
    }
    function FromTuple(e, t) {
      if ((0, s.IsUndefined)(e.items)) return e;
      e.items = FromRest(e.items, t);
      return e;
    }
    function FromArray(e, t) {
      e.items = Deref(e.items, t);
      return e;
    }
    function FromObject(e, t) {
      e.properties = FromProperties(e.properties, t);
      return e;
    }
    function FromPromise(e, t) {
      e.item = Deref(e.item, t);
      return e;
    }
    function FromAsyncIterator(e, t) {
      e.items = Deref(e.items, t);
      return e;
    }
    function FromIterator(e, t) {
      e.items = Deref(e.items, t);
      return e;
    }
    function FromRef(e, t) {
      const r = t.find((t) => t.$id === e.$ref);
      if (r === undefined) throw Error(`Unable to dereference schema with $id ${e.$ref}`);
      const n = (0, o.Discard)(r, ["$id"]);
      return Deref(n, t);
    }
    function DerefResolve(e, t) {
      return (0, i.IsConstructor)(e)
        ? FromConstructor(e, t)
        : (0, i.IsFunction)(e)
          ? FromFunction(e, t)
          : (0, i.IsIntersect)(e)
            ? FromIntersect(e, t)
            : (0, i.IsUnion)(e)
              ? FromUnion(e, t)
              : (0, i.IsTuple)(e)
                ? FromTuple(e, t)
                : (0, i.IsArray)(e)
                  ? FromArray(e, t)
                  : (0, i.IsObject)(e)
                    ? FromObject(e, t)
                    : (0, i.IsPromise)(e)
                      ? FromPromise(e, t)
                      : (0, i.IsAsyncIterator)(e)
                        ? FromAsyncIterator(e, t)
                        : (0, i.IsIterator)(e)
                          ? FromIterator(e, t)
                          : (0, i.IsRef)(e)
                            ? FromRef(e, t)
                            : e;
    }
    function Deref(e, t) {
      return DerefResolve((0, n.CloneType)(e), (0, n.CloneRest)(t));
    }
    t.Deref = Deref;
  },
  911: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(79911), t);
  },
  8147: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Discard = void 0;
    function DiscardKey(e, t) {
      const { [t]: r, ...n } = e;
      return n;
    }
    function Discard(e, t) {
      return t.reduce((e, t) => DiscardKey(e, t), e);
    }
    t.Discard = Discard;
  },
  83889: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(8147), t);
  },
  77991: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Enum = void 0;
    const n = r(98076);
    const o = r(97034);
    const s = r(69100);
    const i = r(13415);
    function Enum(e, t = {}) {
      if ((0, i.IsUndefined)(e)) throw new Error("Enum undefined or empty");
      const r = globalThis.Object.getOwnPropertyNames(e)
        .filter((e) => isNaN(e))
        .map((t) => e[t]);
      const a = [...new Set(r)];
      const A = a.map((e) => (0, n.Literal)(e));
      return (0, s.Union)(A, { ...t, [o.Hint]: "Enum" });
    }
    t.Enum = Enum;
  },
  98056: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(77991), t);
  },
  85523: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TypeBoxError = void 0;
    class TypeBoxError extends Error {
      constructor(e) {
        super(e);
      }
    }
    t.TypeBoxError = TypeBoxError;
  },
  26113: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(85523), t);
  },
  92094: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ExcludeFromMappedResult = void 0;
    const n = r(41094);
    const o = r(63651);
    function FromProperties(e, t) {
      const r = {};
      for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = (0, o.Exclude)(e[n], t);
      return r;
    }
    function FromMappedResult(e, t) {
      return FromProperties(e.properties, t);
    }
    function ExcludeFromMappedResult(e, t) {
      const r = FromMappedResult(e, t);
      return (0, n.MappedResult)(r);
    }
    t.ExcludeFromMappedResult = ExcludeFromMappedResult;
  },
  9505: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ExcludeFromTemplateLiteral = void 0;
    const n = r(63651);
    const o = r(26609);
    function ExcludeFromTemplateLiteral(e, t) {
      return (0, n.Exclude)((0, o.TemplateLiteralToUnion)(e), t);
    }
    t.ExcludeFromTemplateLiteral = ExcludeFromTemplateLiteral;
  },
  63651: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Exclude = void 0;
    const n = r(69100);
    const o = r(54025);
    const s = r(94850);
    const i = r(38100);
    const a = r(92094);
    const A = r(9505);
    const c = r(96994);
    function ExcludeRest(e, t) {
      const r = e.filter((e) => (0, s.ExtendsCheck)(e, t) === s.ExtendsResult.False);
      return r.length === 1 ? r[0] : (0, n.Union)(r);
    }
    function Exclude(e, t, r = {}) {
      if ((0, c.IsTemplateLiteral)(e)) return (0, i.CloneType)((0, A.ExcludeFromTemplateLiteral)(e, t), r);
      if ((0, c.IsMappedResult)(e)) return (0, i.CloneType)((0, a.ExcludeFromMappedResult)(e, t), r);
      return (0, i.CloneType)((0, c.IsUnion)(e) ? ExcludeRest(e.anyOf, t) : (0, s.ExtendsCheck)(e, t) !== s.ExtendsResult.False ? (0, o.Never)() : e, r);
    }
    t.Exclude = Exclude;
  },
  41153: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(92094), t);
    o(r(9505), t);
    o(r(63651), t);
  },
  18410: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ExtendsCheck = t.ExtendsResult = t.ExtendsResolverError = void 0;
    const n = r(36813);
    const o = r(29857);
    const s = r(85544);
    const i = r(81688);
    const a = r(51897);
    const A = r(26609);
    const c = r(94354);
    const u = r(97034);
    const l = r(26113);
    const p = r(64754);
    class ExtendsResolverError extends l.TypeBoxError {}
    t.ExtendsResolverError = ExtendsResolverError;
    var d;
    (function (e) {
      e[(e["Union"] = 0)] = "Union";
      e[(e["True"] = 1)] = "True";
      e[(e["False"] = 2)] = "False";
    })(d || (t.ExtendsResult = d = {}));
    function IntoBooleanResult(e) {
      return e === d.False ? e : d.True;
    }
    function Throw(e) {
      throw new ExtendsResolverError(e);
    }
    function IsStructuralRight(e) {
      return p.TypeGuard.IsNever(e) || p.TypeGuard.IsIntersect(e) || p.TypeGuard.IsUnion(e) || p.TypeGuard.IsUnknown(e) || p.TypeGuard.IsAny(e);
    }
    function StructuralRight(e, t) {
      return p.TypeGuard.IsNever(t)
        ? FromNeverRight(e, t)
        : p.TypeGuard.IsIntersect(t)
          ? FromIntersectRight(e, t)
          : p.TypeGuard.IsUnion(t)
            ? FromUnionRight(e, t)
            : p.TypeGuard.IsUnknown(t)
              ? FromUnknownRight(e, t)
              : p.TypeGuard.IsAny(t)
                ? FromAnyRight(e, t)
                : Throw("StructuralRight");
    }
    function FromAnyRight(e, t) {
      return d.True;
    }
    function FromAny(e, t) {
      return p.TypeGuard.IsIntersect(t)
        ? FromIntersectRight(e, t)
        : p.TypeGuard.IsUnion(t) && t.anyOf.some((e) => p.TypeGuard.IsAny(e) || p.TypeGuard.IsUnknown(e))
          ? d.True
          : p.TypeGuard.IsUnion(t)
            ? d.Union
            : p.TypeGuard.IsUnknown(t)
              ? d.True
              : p.TypeGuard.IsAny(t)
                ? d.True
                : d.Union;
    }
    function FromArrayRight(e, t) {
      return p.TypeGuard.IsUnknown(e) ? d.False : p.TypeGuard.IsAny(e) ? d.Union : p.TypeGuard.IsNever(e) ? d.True : d.False;
    }
    function FromArray(e, t) {
      return p.TypeGuard.IsObject(t) && IsObjectArrayLike(t)
        ? d.True
        : IsStructuralRight(t)
          ? StructuralRight(e, t)
          : !p.TypeGuard.IsArray(t)
            ? d.False
            : IntoBooleanResult(Visit(e.items, t.items));
    }
    function FromAsyncIterator(e, t) {
      return IsStructuralRight(t) ? StructuralRight(e, t) : !p.TypeGuard.IsAsyncIterator(t) ? d.False : IntoBooleanResult(Visit(e.items, t.items));
    }
    function FromBigInt(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : p.TypeGuard.IsRecord(t)
            ? FromRecordRight(e, t)
            : p.TypeGuard.IsBigInt(t)
              ? d.True
              : d.False;
    }
    function FromBooleanRight(e, t) {
      return p.TypeGuard.IsLiteralBoolean(e) ? d.True : p.TypeGuard.IsBoolean(e) ? d.True : d.False;
    }
    function FromBoolean(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : p.TypeGuard.IsRecord(t)
            ? FromRecordRight(e, t)
            : p.TypeGuard.IsBoolean(t)
              ? d.True
              : d.False;
    }
    function FromConstructor(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : !p.TypeGuard.IsConstructor(t)
            ? d.False
            : e.parameters.length > t.parameters.length
              ? d.False
              : !e.parameters.every((e, r) => IntoBooleanResult(Visit(t.parameters[r], e)) === d.True)
                ? d.False
                : IntoBooleanResult(Visit(e.returns, t.returns));
    }
    function FromDate(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : p.TypeGuard.IsRecord(t)
            ? FromRecordRight(e, t)
            : p.TypeGuard.IsDate(t)
              ? d.True
              : d.False;
    }
    function FromFunction(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : !p.TypeGuard.IsFunction(t)
            ? d.False
            : e.parameters.length > t.parameters.length
              ? d.False
              : !e.parameters.every((e, r) => IntoBooleanResult(Visit(t.parameters[r], e)) === d.True)
                ? d.False
                : IntoBooleanResult(Visit(e.returns, t.returns));
    }
    function FromIntegerRight(e, t) {
      return p.TypeGuard.IsLiteral(e) && p.ValueGuard.IsNumber(e.const) ? d.True : p.TypeGuard.IsNumber(e) || p.TypeGuard.IsInteger(e) ? d.True : d.False;
    }
    function FromInteger(e, t) {
      return p.TypeGuard.IsInteger(t) || p.TypeGuard.IsNumber(t)
        ? d.True
        : IsStructuralRight(t)
          ? StructuralRight(e, t)
          : p.TypeGuard.IsObject(t)
            ? FromObjectRight(e, t)
            : p.TypeGuard.IsRecord(t)
              ? FromRecordRight(e, t)
              : d.False;
    }
    function FromIntersectRight(e, t) {
      return t.allOf.every((t) => Visit(e, t) === d.True) ? d.True : d.False;
    }
    function FromIntersect(e, t) {
      return e.allOf.some((e) => Visit(e, t) === d.True) ? d.True : d.False;
    }
    function FromIterator(e, t) {
      return IsStructuralRight(t) ? StructuralRight(e, t) : !p.TypeGuard.IsIterator(t) ? d.False : IntoBooleanResult(Visit(e.items, t.items));
    }
    function FromLiteral(e, t) {
      return p.TypeGuard.IsLiteral(t) && t.const === e.const
        ? d.True
        : IsStructuralRight(t)
          ? StructuralRight(e, t)
          : p.TypeGuard.IsObject(t)
            ? FromObjectRight(e, t)
            : p.TypeGuard.IsRecord(t)
              ? FromRecordRight(e, t)
              : p.TypeGuard.IsString(t)
                ? FromStringRight(e, t)
                : p.TypeGuard.IsNumber(t)
                  ? FromNumberRight(e, t)
                  : p.TypeGuard.IsInteger(t)
                    ? FromIntegerRight(e, t)
                    : p.TypeGuard.IsBoolean(t)
                      ? FromBooleanRight(e, t)
                      : d.False;
    }
    function FromNeverRight(e, t) {
      return d.False;
    }
    function FromNever(e, t) {
      return d.True;
    }
    function UnwrapTNot(e) {
      let [t, r] = [e, 0];
      while (true) {
        if (!p.TypeGuard.IsNot(t)) break;
        t = t.not;
        r += 1;
      }
      return r % 2 === 0 ? t : (0, a.Unknown)();
    }
    function FromNot(e, t) {
      return p.TypeGuard.IsNot(e) ? Visit(UnwrapTNot(e), t) : p.TypeGuard.IsNot(t) ? Visit(e, UnwrapTNot(t)) : Throw("Invalid fallthrough for Not");
    }
    function FromNull(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : p.TypeGuard.IsRecord(t)
            ? FromRecordRight(e, t)
            : p.TypeGuard.IsNull(t)
              ? d.True
              : d.False;
    }
    function FromNumberRight(e, t) {
      return p.TypeGuard.IsLiteralNumber(e) ? d.True : p.TypeGuard.IsNumber(e) || p.TypeGuard.IsInteger(e) ? d.True : d.False;
    }
    function FromNumber(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : p.TypeGuard.IsRecord(t)
            ? FromRecordRight(e, t)
            : p.TypeGuard.IsInteger(t) || p.TypeGuard.IsNumber(t)
              ? d.True
              : d.False;
    }
    function IsObjectPropertyCount(e, t) {
      return Object.getOwnPropertyNames(e.properties).length === t;
    }
    function IsObjectStringLike(e) {
      return IsObjectArrayLike(e);
    }
    function IsObjectSymbolLike(e) {
      return (
        IsObjectPropertyCount(e, 0) ||
        (IsObjectPropertyCount(e, 1) &&
          "description" in e.properties &&
          p.TypeGuard.IsUnion(e.properties.description) &&
          e.properties.description.anyOf.length === 2 &&
          ((p.TypeGuard.IsString(e.properties.description.anyOf[0]) && p.TypeGuard.IsUndefined(e.properties.description.anyOf[1])) ||
            (p.TypeGuard.IsString(e.properties.description.anyOf[1]) && p.TypeGuard.IsUndefined(e.properties.description.anyOf[0]))))
      );
    }
    function IsObjectNumberLike(e) {
      return IsObjectPropertyCount(e, 0);
    }
    function IsObjectBooleanLike(e) {
      return IsObjectPropertyCount(e, 0);
    }
    function IsObjectBigIntLike(e) {
      return IsObjectPropertyCount(e, 0);
    }
    function IsObjectDateLike(e) {
      return IsObjectPropertyCount(e, 0);
    }
    function IsObjectUint8ArrayLike(e) {
      return IsObjectArrayLike(e);
    }
    function IsObjectFunctionLike(e) {
      const t = (0, s.Number)();
      return (
        IsObjectPropertyCount(e, 0) ||
        (IsObjectPropertyCount(e, 1) && "length" in e.properties && IntoBooleanResult(Visit(e.properties["length"], t)) === d.True)
      );
    }
    function IsObjectConstructorLike(e) {
      return IsObjectPropertyCount(e, 0);
    }
    function IsObjectArrayLike(e) {
      const t = (0, s.Number)();
      return (
        IsObjectPropertyCount(e, 0) ||
        (IsObjectPropertyCount(e, 1) && "length" in e.properties && IntoBooleanResult(Visit(e.properties["length"], t)) === d.True)
      );
    }
    function IsObjectPromiseLike(e) {
      const t = (0, o.Function)([(0, n.Any)()], (0, n.Any)());
      return (
        IsObjectPropertyCount(e, 0) || (IsObjectPropertyCount(e, 1) && "then" in e.properties && IntoBooleanResult(Visit(e.properties["then"], t)) === d.True)
      );
    }
    function Property(e, t) {
      return Visit(e, t) === d.False ? d.False : p.TypeGuard.IsOptional(e) && !p.TypeGuard.IsOptional(t) ? d.False : d.True;
    }
    function FromObjectRight(e, t) {
      return p.TypeGuard.IsUnknown(e)
        ? d.False
        : p.TypeGuard.IsAny(e)
          ? d.Union
          : p.TypeGuard.IsNever(e) ||
              (p.TypeGuard.IsLiteralString(e) && IsObjectStringLike(t)) ||
              (p.TypeGuard.IsLiteralNumber(e) && IsObjectNumberLike(t)) ||
              (p.TypeGuard.IsLiteralBoolean(e) && IsObjectBooleanLike(t)) ||
              (p.TypeGuard.IsSymbol(e) && IsObjectSymbolLike(t)) ||
              (p.TypeGuard.IsBigInt(e) && IsObjectBigIntLike(t)) ||
              (p.TypeGuard.IsString(e) && IsObjectStringLike(t)) ||
              (p.TypeGuard.IsSymbol(e) && IsObjectSymbolLike(t)) ||
              (p.TypeGuard.IsNumber(e) && IsObjectNumberLike(t)) ||
              (p.TypeGuard.IsInteger(e) && IsObjectNumberLike(t)) ||
              (p.TypeGuard.IsBoolean(e) && IsObjectBooleanLike(t)) ||
              (p.TypeGuard.IsUint8Array(e) && IsObjectUint8ArrayLike(t)) ||
              (p.TypeGuard.IsDate(e) && IsObjectDateLike(t)) ||
              (p.TypeGuard.IsConstructor(e) && IsObjectConstructorLike(t)) ||
              (p.TypeGuard.IsFunction(e) && IsObjectFunctionLike(t))
            ? d.True
            : p.TypeGuard.IsRecord(e) && p.TypeGuard.IsString(RecordKey(e))
              ? (() => (t[u.Hint] === "Record" ? d.True : d.False))()
              : p.TypeGuard.IsRecord(e) && p.TypeGuard.IsNumber(RecordKey(e))
                ? (() => (IsObjectPropertyCount(t, 0) ? d.True : d.False))()
                : d.False;
    }
    function FromObject(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsRecord(t)
          ? FromRecordRight(e, t)
          : !p.TypeGuard.IsObject(t)
            ? d.False
            : (() => {
                for (const r of Object.getOwnPropertyNames(t.properties)) {
                  if (!(r in e.properties) && !p.TypeGuard.IsOptional(t.properties[r])) {
                    return d.False;
                  }
                  if (p.TypeGuard.IsOptional(t.properties[r])) {
                    return d.True;
                  }
                  if (Property(e.properties[r], t.properties[r]) === d.False) {
                    return d.False;
                  }
                }
                return d.True;
              })();
    }
    function FromPromise(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t) && IsObjectPromiseLike(t)
          ? d.True
          : !p.TypeGuard.IsPromise(t)
            ? d.False
            : IntoBooleanResult(Visit(e.item, t.item));
    }
    function RecordKey(e) {
      return c.PatternNumberExact in e.patternProperties
        ? (0, s.Number)()
        : c.PatternStringExact in e.patternProperties
          ? (0, i.String)()
          : Throw("Unknown record key pattern");
    }
    function RecordValue(e) {
      return c.PatternNumberExact in e.patternProperties
        ? e.patternProperties[c.PatternNumberExact]
        : c.PatternStringExact in e.patternProperties
          ? e.patternProperties[c.PatternStringExact]
          : Throw("Unable to get record value schema");
    }
    function FromRecordRight(e, t) {
      const [r, n] = [RecordKey(t), RecordValue(t)];
      return p.TypeGuard.IsLiteralString(e) && p.TypeGuard.IsNumber(r) && IntoBooleanResult(Visit(e, n)) === d.True
        ? d.True
        : p.TypeGuard.IsUint8Array(e) && p.TypeGuard.IsNumber(r)
          ? Visit(e, n)
          : p.TypeGuard.IsString(e) && p.TypeGuard.IsNumber(r)
            ? Visit(e, n)
            : p.TypeGuard.IsArray(e) && p.TypeGuard.IsNumber(r)
              ? Visit(e, n)
              : p.TypeGuard.IsObject(e)
                ? (() => {
                    for (const t of Object.getOwnPropertyNames(e.properties)) {
                      if (Property(n, e.properties[t]) === d.False) {
                        return d.False;
                      }
                    }
                    return d.True;
                  })()
                : d.False;
    }
    function FromRecord(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : !p.TypeGuard.IsRecord(t)
            ? d.False
            : Visit(RecordValue(e), RecordValue(t));
    }
    function FromRegExp(e, t) {
      const r = p.TypeGuard.IsRegExp(e) ? (0, i.String)() : e;
      const n = p.TypeGuard.IsRegExp(t) ? (0, i.String)() : t;
      return Visit(r, n);
    }
    function FromStringRight(e, t) {
      return p.TypeGuard.IsLiteral(e) && p.ValueGuard.IsString(e.const) ? d.True : p.TypeGuard.IsString(e) ? d.True : d.False;
    }
    function FromString(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : p.TypeGuard.IsRecord(t)
            ? FromRecordRight(e, t)
            : p.TypeGuard.IsString(t)
              ? d.True
              : d.False;
    }
    function FromSymbol(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : p.TypeGuard.IsRecord(t)
            ? FromRecordRight(e, t)
            : p.TypeGuard.IsSymbol(t)
              ? d.True
              : d.False;
    }
    function FromTemplateLiteral(e, t) {
      return p.TypeGuard.IsTemplateLiteral(e)
        ? Visit((0, A.TemplateLiteralToUnion)(e), t)
        : p.TypeGuard.IsTemplateLiteral(t)
          ? Visit(e, (0, A.TemplateLiteralToUnion)(t))
          : Throw("Invalid fallthrough for TemplateLiteral");
    }
    function IsArrayOfTuple(e, t) {
      return p.TypeGuard.IsArray(t) && e.items !== undefined && e.items.every((e) => Visit(e, t.items) === d.True);
    }
    function FromTupleRight(e, t) {
      return p.TypeGuard.IsNever(e) ? d.True : p.TypeGuard.IsUnknown(e) ? d.False : p.TypeGuard.IsAny(e) ? d.Union : d.False;
    }
    function FromTuple(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t) && IsObjectArrayLike(t)
          ? d.True
          : p.TypeGuard.IsArray(t) && IsArrayOfTuple(e, t)
            ? d.True
            : !p.TypeGuard.IsTuple(t)
              ? d.False
              : (p.ValueGuard.IsUndefined(e.items) && !p.ValueGuard.IsUndefined(t.items)) ||
                  (!p.ValueGuard.IsUndefined(e.items) && p.ValueGuard.IsUndefined(t.items))
                ? d.False
                : p.ValueGuard.IsUndefined(e.items) && !p.ValueGuard.IsUndefined(t.items)
                  ? d.True
                  : e.items.every((e, r) => Visit(e, t.items[r]) === d.True)
                    ? d.True
                    : d.False;
    }
    function FromUint8Array(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : p.TypeGuard.IsRecord(t)
            ? FromRecordRight(e, t)
            : p.TypeGuard.IsUint8Array(t)
              ? d.True
              : d.False;
    }
    function FromUndefined(e, t) {
      return IsStructuralRight(t)
        ? StructuralRight(e, t)
        : p.TypeGuard.IsObject(t)
          ? FromObjectRight(e, t)
          : p.TypeGuard.IsRecord(t)
            ? FromRecordRight(e, t)
            : p.TypeGuard.IsVoid(t)
              ? FromVoidRight(e, t)
              : p.TypeGuard.IsUndefined(t)
                ? d.True
                : d.False;
    }
    function FromUnionRight(e, t) {
      return t.anyOf.some((t) => Visit(e, t) === d.True) ? d.True : d.False;
    }
    function FromUnion(e, t) {
      return e.anyOf.every((e) => Visit(e, t) === d.True) ? d.True : d.False;
    }
    function FromUnknownRight(e, t) {
      return d.True;
    }
    function FromUnknown(e, t) {
      return p.TypeGuard.IsNever(t)
        ? FromNeverRight(e, t)
        : p.TypeGuard.IsIntersect(t)
          ? FromIntersectRight(e, t)
          : p.TypeGuard.IsUnion(t)
            ? FromUnionRight(e, t)
            : p.TypeGuard.IsAny(t)
              ? FromAnyRight(e, t)
              : p.TypeGuard.IsString(t)
                ? FromStringRight(e, t)
                : p.TypeGuard.IsNumber(t)
                  ? FromNumberRight(e, t)
                  : p.TypeGuard.IsInteger(t)
                    ? FromIntegerRight(e, t)
                    : p.TypeGuard.IsBoolean(t)
                      ? FromBooleanRight(e, t)
                      : p.TypeGuard.IsArray(t)
                        ? FromArrayRight(e, t)
                        : p.TypeGuard.IsTuple(t)
                          ? FromTupleRight(e, t)
                          : p.TypeGuard.IsObject(t)
                            ? FromObjectRight(e, t)
                            : p.TypeGuard.IsUnknown(t)
                              ? d.True
                              : d.False;
    }
    function FromVoidRight(e, t) {
      return p.TypeGuard.IsUndefined(e) ? d.True : p.TypeGuard.IsUndefined(e) ? d.True : d.False;
    }
    function FromVoid(e, t) {
      return p.TypeGuard.IsIntersect(t)
        ? FromIntersectRight(e, t)
        : p.TypeGuard.IsUnion(t)
          ? FromUnionRight(e, t)
          : p.TypeGuard.IsUnknown(t)
            ? FromUnknownRight(e, t)
            : p.TypeGuard.IsAny(t)
              ? FromAnyRight(e, t)
              : p.TypeGuard.IsObject(t)
                ? FromObjectRight(e, t)
                : p.TypeGuard.IsVoid(t)
                  ? d.True
                  : d.False;
    }
    function Visit(e, t) {
      return p.TypeGuard.IsTemplateLiteral(e) || p.TypeGuard.IsTemplateLiteral(t)
        ? FromTemplateLiteral(e, t)
        : p.TypeGuard.IsRegExp(e) || p.TypeGuard.IsRegExp(t)
          ? FromRegExp(e, t)
          : p.TypeGuard.IsNot(e) || p.TypeGuard.IsNot(t)
            ? FromNot(e, t)
            : p.TypeGuard.IsAny(e)
              ? FromAny(e, t)
              : p.TypeGuard.IsArray(e)
                ? FromArray(e, t)
                : p.TypeGuard.IsBigInt(e)
                  ? FromBigInt(e, t)
                  : p.TypeGuard.IsBoolean(e)
                    ? FromBoolean(e, t)
                    : p.TypeGuard.IsAsyncIterator(e)
                      ? FromAsyncIterator(e, t)
                      : p.TypeGuard.IsConstructor(e)
                        ? FromConstructor(e, t)
                        : p.TypeGuard.IsDate(e)
                          ? FromDate(e, t)
                          : p.TypeGuard.IsFunction(e)
                            ? FromFunction(e, t)
                            : p.TypeGuard.IsInteger(e)
                              ? FromInteger(e, t)
                              : p.TypeGuard.IsIntersect(e)
                                ? FromIntersect(e, t)
                                : p.TypeGuard.IsIterator(e)
                                  ? FromIterator(e, t)
                                  : p.TypeGuard.IsLiteral(e)
                                    ? FromLiteral(e, t)
                                    : p.TypeGuard.IsNever(e)
                                      ? FromNever(e, t)
                                      : p.TypeGuard.IsNull(e)
                                        ? FromNull(e, t)
                                        : p.TypeGuard.IsNumber(e)
                                          ? FromNumber(e, t)
                                          : p.TypeGuard.IsObject(e)
                                            ? FromObject(e, t)
                                            : p.TypeGuard.IsRecord(e)
                                              ? FromRecord(e, t)
                                              : p.TypeGuard.IsString(e)
                                                ? FromString(e, t)
                                                : p.TypeGuard.IsSymbol(e)
                                                  ? FromSymbol(e, t)
                                                  : p.TypeGuard.IsTuple(e)
                                                    ? FromTuple(e, t)
                                                    : p.TypeGuard.IsPromise(e)
                                                      ? FromPromise(e, t)
                                                      : p.TypeGuard.IsUint8Array(e)
                                                        ? FromUint8Array(e, t)
                                                        : p.TypeGuard.IsUndefined(e)
                                                          ? FromUndefined(e, t)
                                                          : p.TypeGuard.IsUnion(e)
                                                            ? FromUnion(e, t)
                                                            : p.TypeGuard.IsUnknown(e)
                                                              ? FromUnknown(e, t)
                                                              : p.TypeGuard.IsVoid(e)
                                                                ? FromVoid(e, t)
                                                                : Throw(`Unknown left type operand '${e[u.Kind]}'`);
    }
    function ExtendsCheck(e, t) {
      return Visit(e, t);
    }
    t.ExtendsCheck = ExtendsCheck;
  },
  83948: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ExtendsFromMappedKey = void 0;
    const n = r(41094);
    const o = r(98076);
    const s = r(34263);
    function FromPropertyKey(e, t, r, n, i) {
      return { [e]: (0, s.Extends)((0, o.Literal)(e), t, r, n, i) };
    }
    function FromPropertyKeys(e, t, r, n, o) {
      return e.reduce((e, s) => ({ ...e, ...FromPropertyKey(s, t, r, n, o) }), {});
    }
    function FromMappedKey(e, t, r, n, o) {
      return FromPropertyKeys(e.keys, t, r, n, o);
    }
    function ExtendsFromMappedKey(e, t, r, o, s) {
      const i = FromMappedKey(e, t, r, o, s);
      return (0, n.MappedResult)(i);
    }
    t.ExtendsFromMappedKey = ExtendsFromMappedKey;
  },
  80338: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ExtendsFromMappedResult = void 0;
    const n = r(41094);
    const o = r(34263);
    function FromProperties(e, t, r, n, s) {
      const i = {};
      for (const a of globalThis.Object.getOwnPropertyNames(e)) i[a] = (0, o.Extends)(e[a], t, r, n, s);
      return i;
    }
    function FromMappedResult(e, t, r, n, o) {
      return FromProperties(e.properties, t, r, n, o);
    }
    function ExtendsFromMappedResult(e, t, r, o, s) {
      const i = FromMappedResult(e, t, r, o, s);
      return (0, n.MappedResult)(i);
    }
    t.ExtendsFromMappedResult = ExtendsFromMappedResult;
  },
  82486: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ExtendsUndefinedCheck = void 0;
    const n = r(97034);
    function Intersect(e) {
      return e.allOf.every((e) => ExtendsUndefinedCheck(e));
    }
    function Union(e) {
      return e.anyOf.some((e) => ExtendsUndefinedCheck(e));
    }
    function Not(e) {
      return !ExtendsUndefinedCheck(e.not);
    }
    function ExtendsUndefinedCheck(e) {
      return e[n.Kind] === "Intersect"
        ? Intersect(e)
        : e[n.Kind] === "Union"
          ? Union(e)
          : e[n.Kind] === "Not"
            ? Not(e)
            : e[n.Kind] === "Undefined"
              ? true
              : false;
    }
    t.ExtendsUndefinedCheck = ExtendsUndefinedCheck;
  },
  34263: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Extends = void 0;
    const n = r(69100);
    const o = r(18410);
    const s = r(38100);
    const i = r(83948);
    const a = r(80338);
    const A = r(96994);
    function ExtendsResolve(e, t, r, s) {
      const i = (0, o.ExtendsCheck)(e, t);
      return i === o.ExtendsResult.Union ? (0, n.Union)([r, s]) : i === o.ExtendsResult.True ? r : s;
    }
    function Extends(e, t, r, n, o = {}) {
      return (0, A.IsMappedResult)(e)
        ? (0, a.ExtendsFromMappedResult)(e, t, r, n, o)
        : (0, A.IsMappedKey)(e)
          ? (0, s.CloneType)((0, i.ExtendsFromMappedKey)(e, t, r, n, o))
          : (0, s.CloneType)(ExtendsResolve(e, t, r, n), o);
    }
    t.Extends = Extends;
  },
  94850: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(18410), t);
    o(r(83948), t);
    o(r(80338), t);
    o(r(82486), t);
    o(r(34263), t);
  },
  70826: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ExtractFromMappedResult = void 0;
    const n = r(41094);
    const o = r(4847);
    function FromProperties(e, t) {
      const r = {};
      for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = (0, o.Extract)(e[n], t);
      return r;
    }
    function FromMappedResult(e, t) {
      return FromProperties(e.properties, t);
    }
    function ExtractFromMappedResult(e, t) {
      const r = FromMappedResult(e, t);
      return (0, n.MappedResult)(r);
    }
    t.ExtractFromMappedResult = ExtractFromMappedResult;
  },
  50253: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ExtractFromTemplateLiteral = void 0;
    const n = r(4847);
    const o = r(26609);
    function ExtractFromTemplateLiteral(e, t) {
      return (0, n.Extract)((0, o.TemplateLiteralToUnion)(e), t);
    }
    t.ExtractFromTemplateLiteral = ExtractFromTemplateLiteral;
  },
  4847: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Extract = void 0;
    const n = r(69100);
    const o = r(54025);
    const s = r(94850);
    const i = r(38100);
    const a = r(70826);
    const A = r(50253);
    const c = r(96994);
    function ExtractRest(e, t) {
      const r = e.filter((e) => (0, s.ExtendsCheck)(e, t) !== s.ExtendsResult.False);
      return r.length === 1 ? r[0] : (0, n.Union)(r);
    }
    function Extract(e, t, r = {}) {
      if ((0, c.IsTemplateLiteral)(e)) return (0, i.CloneType)((0, A.ExtractFromTemplateLiteral)(e, t), r);
      if ((0, c.IsMappedResult)(e)) return (0, i.CloneType)((0, a.ExtractFromMappedResult)(e, t), r);
      return (0, i.CloneType)((0, c.IsUnion)(e) ? ExtractRest(e.anyOf, t) : (0, s.ExtendsCheck)(e, t) !== s.ExtendsResult.False ? e : (0, o.Never)(), r);
    }
    t.Extract = Extract;
  },
  69682: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(70826), t);
    o(r(50253), t);
    o(r(4847), t);
  },
  93649: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Function = void 0;
    const n = r(38100);
    const o = r(97034);
    function Function(e, t, r) {
      return { ...r, [o.Kind]: "Function", type: "Function", parameters: (0, n.CloneRest)(e), returns: (0, n.CloneType)(t) };
    }
    t.Function = Function;
  },
  29857: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(93649), t);
  },
  64754: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ValueGuard = t.TypeGuard = t.KindGuard = void 0;
    t.KindGuard = r(96994);
    t.TypeGuard = r(70384);
    t.ValueGuard = r(13415);
  },
  96994: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.IsSchema =
      t.IsKind =
      t.IsVoid =
      t.IsUnsafe =
      t.IsUnknown =
      t.IsUint8Array =
      t.IsUnion =
      t.IsUndefined =
      t.IsTuple =
      t.IsTransform =
      t.IsThis =
      t.IsTemplateLiteral =
      t.IsSymbol =
      t.IsString =
      t.IsRegExp =
      t.IsRef =
      t.IsRecursive =
      t.IsRecord =
      t.IsPromise =
      t.IsObject =
      t.IsNumber =
      t.IsNull =
      t.IsNot =
      t.IsNever =
      t.IsMappedResult =
      t.IsMappedKey =
      t.IsLiteral =
      t.IsLiteralBoolean =
      t.IsLiteralNumber =
      t.IsLiteralString =
      t.IsKindOf =
      t.IsIterator =
      t.IsIntersect =
      t.IsProperties =
      t.IsInteger =
      t.IsFunction =
      t.IsDate =
      t.IsConstructor =
      t.IsBoolean =
      t.IsBigInt =
      t.IsAsyncIterator =
      t.IsArray =
      t.IsAny =
      t.IsOptional =
      t.IsReadonly =
        void 0;
    const n = r(13415);
    const o = r(97034);
    function IsReadonly(e) {
      return n.IsObject(e) && e[o.ReadonlyKind] === "Readonly";
    }
    t.IsReadonly = IsReadonly;
    function IsOptional(e) {
      return n.IsObject(e) && e[o.OptionalKind] === "Optional";
    }
    t.IsOptional = IsOptional;
    function IsAny(e) {
      return IsKindOf(e, "Any");
    }
    t.IsAny = IsAny;
    function IsArray(e) {
      return IsKindOf(e, "Array");
    }
    t.IsArray = IsArray;
    function IsAsyncIterator(e) {
      return IsKindOf(e, "AsyncIterator");
    }
    t.IsAsyncIterator = IsAsyncIterator;
    function IsBigInt(e) {
      return IsKindOf(e, "BigInt");
    }
    t.IsBigInt = IsBigInt;
    function IsBoolean(e) {
      return IsKindOf(e, "Boolean");
    }
    t.IsBoolean = IsBoolean;
    function IsConstructor(e) {
      return IsKindOf(e, "Constructor");
    }
    t.IsConstructor = IsConstructor;
    function IsDate(e) {
      return IsKindOf(e, "Date");
    }
    t.IsDate = IsDate;
    function IsFunction(e) {
      return IsKindOf(e, "Function");
    }
    t.IsFunction = IsFunction;
    function IsInteger(e) {
      return IsKindOf(e, "Integer");
    }
    t.IsInteger = IsInteger;
    function IsProperties(e) {
      return n.IsObject(e);
    }
    t.IsProperties = IsProperties;
    function IsIntersect(e) {
      return IsKindOf(e, "Intersect");
    }
    t.IsIntersect = IsIntersect;
    function IsIterator(e) {
      return IsKindOf(e, "Iterator");
    }
    t.IsIterator = IsIterator;
    function IsKindOf(e, t) {
      return n.IsObject(e) && o.Kind in e && e[o.Kind] === t;
    }
    t.IsKindOf = IsKindOf;
    function IsLiteralString(e) {
      return IsLiteral(e) && n.IsString(e.const);
    }
    t.IsLiteralString = IsLiteralString;
    function IsLiteralNumber(e) {
      return IsLiteral(e) && n.IsNumber(e.const);
    }
    t.IsLiteralNumber = IsLiteralNumber;
    function IsLiteralBoolean(e) {
      return IsLiteral(e) && n.IsBoolean(e.const);
    }
    t.IsLiteralBoolean = IsLiteralBoolean;
    function IsLiteral(e) {
      return IsKindOf(e, "Literal");
    }
    t.IsLiteral = IsLiteral;
    function IsMappedKey(e) {
      return IsKindOf(e, "MappedKey");
    }
    t.IsMappedKey = IsMappedKey;
    function IsMappedResult(e) {
      return IsKindOf(e, "MappedResult");
    }
    t.IsMappedResult = IsMappedResult;
    function IsNever(e) {
      return IsKindOf(e, "Never");
    }
    t.IsNever = IsNever;
    function IsNot(e) {
      return IsKindOf(e, "Not");
    }
    t.IsNot = IsNot;
    function IsNull(e) {
      return IsKindOf(e, "Null");
    }
    t.IsNull = IsNull;
    function IsNumber(e) {
      return IsKindOf(e, "Number");
    }
    t.IsNumber = IsNumber;
    function IsObject(e) {
      return IsKindOf(e, "Object");
    }
    t.IsObject = IsObject;
    function IsPromise(e) {
      return IsKindOf(e, "Promise");
    }
    t.IsPromise = IsPromise;
    function IsRecord(e) {
      return IsKindOf(e, "Record");
    }
    t.IsRecord = IsRecord;
    function IsRecursive(e) {
      return n.IsObject(e) && o.Hint in e && e[o.Hint] === "Recursive";
    }
    t.IsRecursive = IsRecursive;
    function IsRef(e) {
      return IsKindOf(e, "Ref");
    }
    t.IsRef = IsRef;
    function IsRegExp(e) {
      return IsKindOf(e, "RegExp");
    }
    t.IsRegExp = IsRegExp;
    function IsString(e) {
      return IsKindOf(e, "String");
    }
    t.IsString = IsString;
    function IsSymbol(e) {
      return IsKindOf(e, "Symbol");
    }
    t.IsSymbol = IsSymbol;
    function IsTemplateLiteral(e) {
      return IsKindOf(e, "TemplateLiteral");
    }
    t.IsTemplateLiteral = IsTemplateLiteral;
    function IsThis(e) {
      return IsKindOf(e, "This");
    }
    t.IsThis = IsThis;
    function IsTransform(e) {
      return n.IsObject(e) && o.TransformKind in e;
    }
    t.IsTransform = IsTransform;
    function IsTuple(e) {
      return IsKindOf(e, "Tuple");
    }
    t.IsTuple = IsTuple;
    function IsUndefined(e) {
      return IsKindOf(e, "Undefined");
    }
    t.IsUndefined = IsUndefined;
    function IsUnion(e) {
      return IsKindOf(e, "Union");
    }
    t.IsUnion = IsUnion;
    function IsUint8Array(e) {
      return IsKindOf(e, "Uint8Array");
    }
    t.IsUint8Array = IsUint8Array;
    function IsUnknown(e) {
      return IsKindOf(e, "Unknown");
    }
    t.IsUnknown = IsUnknown;
    function IsUnsafe(e) {
      return IsKindOf(e, "Unsafe");
    }
    t.IsUnsafe = IsUnsafe;
    function IsVoid(e) {
      return IsKindOf(e, "Void");
    }
    t.IsVoid = IsVoid;
    function IsKind(e) {
      return n.IsObject(e) && o.Kind in e && n.IsString(e[o.Kind]);
    }
    t.IsKind = IsKind;
    function IsSchema(e) {
      return (
        IsAny(e) ||
        IsArray(e) ||
        IsBoolean(e) ||
        IsBigInt(e) ||
        IsAsyncIterator(e) ||
        IsConstructor(e) ||
        IsDate(e) ||
        IsFunction(e) ||
        IsInteger(e) ||
        IsIntersect(e) ||
        IsIterator(e) ||
        IsLiteral(e) ||
        IsMappedKey(e) ||
        IsMappedResult(e) ||
        IsNever(e) ||
        IsNot(e) ||
        IsNull(e) ||
        IsNumber(e) ||
        IsObject(e) ||
        IsPromise(e) ||
        IsRecord(e) ||
        IsRef(e) ||
        IsRegExp(e) ||
        IsString(e) ||
        IsSymbol(e) ||
        IsTemplateLiteral(e) ||
        IsThis(e) ||
        IsTuple(e) ||
        IsUndefined(e) ||
        IsUnion(e) ||
        IsUint8Array(e) ||
        IsUnknown(e) ||
        IsUnsafe(e) ||
        IsVoid(e) ||
        IsKind(e)
      );
    }
    t.IsSchema = IsSchema;
  },
  70384: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.IsSchema =
      t.IsKind =
      t.IsVoid =
      t.IsUnsafe =
      t.IsUnknown =
      t.IsUint8Array =
      t.IsUnion =
      t.IsUnionLiteral =
      t.IsUndefined =
      t.IsTuple =
      t.IsTransform =
      t.IsThis =
      t.IsTemplateLiteral =
      t.IsSymbol =
      t.IsString =
      t.IsRegExp =
      t.IsRef =
      t.IsRecursive =
      t.IsRecord =
      t.IsPromise =
      t.IsObject =
      t.IsNumber =
      t.IsNull =
      t.IsNot =
      t.IsNever =
      t.IsMappedResult =
      t.IsMappedKey =
      t.IsLiteralValue =
      t.IsLiteral =
      t.IsLiteralBoolean =
      t.IsLiteralNumber =
      t.IsLiteralString =
      t.IsKindOf =
      t.IsIterator =
      t.IsIntersect =
      t.IsProperties =
      t.IsInteger =
      t.IsFunction =
      t.IsDate =
      t.IsConstructor =
      t.IsBoolean =
      t.IsBigInt =
      t.IsAsyncIterator =
      t.IsArray =
      t.IsAny =
      t.IsOptional =
      t.IsReadonly =
      t.TypeGuardUnknownTypeError =
        void 0;
    const n = r(13415);
    const o = r(97034);
    const s = r(26113);
    class TypeGuardUnknownTypeError extends s.TypeBoxError {}
    t.TypeGuardUnknownTypeError = TypeGuardUnknownTypeError;
    const i = [
      "Any",
      "Array",
      "AsyncIterator",
      "BigInt",
      "Boolean",
      "Constructor",
      "Date",
      "Enum",
      "Function",
      "Integer",
      "Intersect",
      "Iterator",
      "Literal",
      "MappedKey",
      "MappedResult",
      "Not",
      "Null",
      "Number",
      "Object",
      "Promise",
      "Record",
      "Ref",
      "RegExp",
      "String",
      "Symbol",
      "TemplateLiteral",
      "This",
      "Tuple",
      "Undefined",
      "Union",
      "Uint8Array",
      "Unknown",
      "Void",
    ];
    function IsPattern(e) {
      try {
        new RegExp(e);
        return true;
      } catch {
        return false;
      }
    }
    function IsControlCharacterFree(e) {
      if (!n.IsString(e)) return false;
      for (let t = 0; t < e.length; t++) {
        const r = e.charCodeAt(t);
        if ((r >= 7 && r <= 13) || r === 27 || r === 127) {
          return false;
        }
      }
      return true;
    }
    function IsAdditionalProperties(e) {
      return IsOptionalBoolean(e) || IsSchema(e);
    }
    function IsOptionalBigInt(e) {
      return n.IsUndefined(e) || n.IsBigInt(e);
    }
    function IsOptionalNumber(e) {
      return n.IsUndefined(e) || n.IsNumber(e);
    }
    function IsOptionalBoolean(e) {
      return n.IsUndefined(e) || n.IsBoolean(e);
    }
    function IsOptionalString(e) {
      return n.IsUndefined(e) || n.IsString(e);
    }
    function IsOptionalPattern(e) {
      return n.IsUndefined(e) || (n.IsString(e) && IsControlCharacterFree(e) && IsPattern(e));
    }
    function IsOptionalFormat(e) {
      return n.IsUndefined(e) || (n.IsString(e) && IsControlCharacterFree(e));
    }
    function IsOptionalSchema(e) {
      return n.IsUndefined(e) || IsSchema(e);
    }
    function IsReadonly(e) {
      return n.IsObject(e) && e[o.ReadonlyKind] === "Readonly";
    }
    t.IsReadonly = IsReadonly;
    function IsOptional(e) {
      return n.IsObject(e) && e[o.OptionalKind] === "Optional";
    }
    t.IsOptional = IsOptional;
    function IsAny(e) {
      return IsKindOf(e, "Any") && IsOptionalString(e.$id);
    }
    t.IsAny = IsAny;
    function IsArray(e) {
      return (
        IsKindOf(e, "Array") &&
        e.type === "array" &&
        IsOptionalString(e.$id) &&
        IsSchema(e.items) &&
        IsOptionalNumber(e.minItems) &&
        IsOptionalNumber(e.maxItems) &&
        IsOptionalBoolean(e.uniqueItems) &&
        IsOptionalSchema(e.contains) &&
        IsOptionalNumber(e.minContains) &&
        IsOptionalNumber(e.maxContains)
      );
    }
    t.IsArray = IsArray;
    function IsAsyncIterator(e) {
      return IsKindOf(e, "AsyncIterator") && e.type === "AsyncIterator" && IsOptionalString(e.$id) && IsSchema(e.items);
    }
    t.IsAsyncIterator = IsAsyncIterator;
    function IsBigInt(e) {
      return (
        IsKindOf(e, "BigInt") &&
        e.type === "bigint" &&
        IsOptionalString(e.$id) &&
        IsOptionalBigInt(e.exclusiveMaximum) &&
        IsOptionalBigInt(e.exclusiveMinimum) &&
        IsOptionalBigInt(e.maximum) &&
        IsOptionalBigInt(e.minimum) &&
        IsOptionalBigInt(e.multipleOf)
      );
    }
    t.IsBigInt = IsBigInt;
    function IsBoolean(e) {
      return IsKindOf(e, "Boolean") && e.type === "boolean" && IsOptionalString(e.$id);
    }
    t.IsBoolean = IsBoolean;
    function IsConstructor(e) {
      return (
        IsKindOf(e, "Constructor") &&
        e.type === "Constructor" &&
        IsOptionalString(e.$id) &&
        n.IsArray(e.parameters) &&
        e.parameters.every((e) => IsSchema(e)) &&
        IsSchema(e.returns)
      );
    }
    t.IsConstructor = IsConstructor;
    function IsDate(e) {
      return (
        IsKindOf(e, "Date") &&
        e.type === "Date" &&
        IsOptionalString(e.$id) &&
        IsOptionalNumber(e.exclusiveMaximumTimestamp) &&
        IsOptionalNumber(e.exclusiveMinimumTimestamp) &&
        IsOptionalNumber(e.maximumTimestamp) &&
        IsOptionalNumber(e.minimumTimestamp) &&
        IsOptionalNumber(e.multipleOfTimestamp)
      );
    }
    t.IsDate = IsDate;
    function IsFunction(e) {
      return (
        IsKindOf(e, "Function") &&
        e.type === "Function" &&
        IsOptionalString(e.$id) &&
        n.IsArray(e.parameters) &&
        e.parameters.every((e) => IsSchema(e)) &&
        IsSchema(e.returns)
      );
    }
    t.IsFunction = IsFunction;
    function IsInteger(e) {
      return (
        IsKindOf(e, "Integer") &&
        e.type === "integer" &&
        IsOptionalString(e.$id) &&
        IsOptionalNumber(e.exclusiveMaximum) &&
        IsOptionalNumber(e.exclusiveMinimum) &&
        IsOptionalNumber(e.maximum) &&
        IsOptionalNumber(e.minimum) &&
        IsOptionalNumber(e.multipleOf)
      );
    }
    t.IsInteger = IsInteger;
    function IsProperties(e) {
      return n.IsObject(e) && Object.entries(e).every(([e, t]) => IsControlCharacterFree(e) && IsSchema(t));
    }
    t.IsProperties = IsProperties;
    function IsIntersect(e) {
      return (
        IsKindOf(e, "Intersect") &&
        (n.IsString(e.type) && e.type !== "object" ? false : true) &&
        n.IsArray(e.allOf) &&
        e.allOf.every((e) => IsSchema(e) && !IsTransform(e)) &&
        IsOptionalString(e.type) &&
        (IsOptionalBoolean(e.unevaluatedProperties) || IsOptionalSchema(e.unevaluatedProperties)) &&
        IsOptionalString(e.$id)
      );
    }
    t.IsIntersect = IsIntersect;
    function IsIterator(e) {
      return IsKindOf(e, "Iterator") && e.type === "Iterator" && IsOptionalString(e.$id) && IsSchema(e.items);
    }
    t.IsIterator = IsIterator;
    function IsKindOf(e, t) {
      return n.IsObject(e) && o.Kind in e && e[o.Kind] === t;
    }
    t.IsKindOf = IsKindOf;
    function IsLiteralString(e) {
      return IsLiteral(e) && n.IsString(e.const);
    }
    t.IsLiteralString = IsLiteralString;
    function IsLiteralNumber(e) {
      return IsLiteral(e) && n.IsNumber(e.const);
    }
    t.IsLiteralNumber = IsLiteralNumber;
    function IsLiteralBoolean(e) {
      return IsLiteral(e) && n.IsBoolean(e.const);
    }
    t.IsLiteralBoolean = IsLiteralBoolean;
    function IsLiteral(e) {
      return IsKindOf(e, "Literal") && IsOptionalString(e.$id) && IsLiteralValue(e.const);
    }
    t.IsLiteral = IsLiteral;
    function IsLiteralValue(e) {
      return n.IsBoolean(e) || n.IsNumber(e) || n.IsString(e);
    }
    t.IsLiteralValue = IsLiteralValue;
    function IsMappedKey(e) {
      return IsKindOf(e, "MappedKey") && n.IsArray(e.keys) && e.keys.every((e) => n.IsNumber(e) || n.IsString(e));
    }
    t.IsMappedKey = IsMappedKey;
    function IsMappedResult(e) {
      return IsKindOf(e, "MappedResult") && IsProperties(e.properties);
    }
    t.IsMappedResult = IsMappedResult;
    function IsNever(e) {
      return IsKindOf(e, "Never") && n.IsObject(e.not) && Object.getOwnPropertyNames(e.not).length === 0;
    }
    t.IsNever = IsNever;
    function IsNot(e) {
      return IsKindOf(e, "Not") && IsSchema(e.not);
    }
    t.IsNot = IsNot;
    function IsNull(e) {
      return IsKindOf(e, "Null") && e.type === "null" && IsOptionalString(e.$id);
    }
    t.IsNull = IsNull;
    function IsNumber(e) {
      return (
        IsKindOf(e, "Number") &&
        e.type === "number" &&
        IsOptionalString(e.$id) &&
        IsOptionalNumber(e.exclusiveMaximum) &&
        IsOptionalNumber(e.exclusiveMinimum) &&
        IsOptionalNumber(e.maximum) &&
        IsOptionalNumber(e.minimum) &&
        IsOptionalNumber(e.multipleOf)
      );
    }
    t.IsNumber = IsNumber;
    function IsObject(e) {
      return (
        IsKindOf(e, "Object") &&
        e.type === "object" &&
        IsOptionalString(e.$id) &&
        IsProperties(e.properties) &&
        IsAdditionalProperties(e.additionalProperties) &&
        IsOptionalNumber(e.minProperties) &&
        IsOptionalNumber(e.maxProperties)
      );
    }
    t.IsObject = IsObject;
    function IsPromise(e) {
      return IsKindOf(e, "Promise") && e.type === "Promise" && IsOptionalString(e.$id) && IsSchema(e.item);
    }
    t.IsPromise = IsPromise;
    function IsRecord(e) {
      return (
        IsKindOf(e, "Record") &&
        e.type === "object" &&
        IsOptionalString(e.$id) &&
        IsAdditionalProperties(e.additionalProperties) &&
        n.IsObject(e.patternProperties) &&
        ((e) => {
          const t = Object.getOwnPropertyNames(e.patternProperties);
          return t.length === 1 && IsPattern(t[0]) && n.IsObject(e.patternProperties) && IsSchema(e.patternProperties[t[0]]);
        })(e)
      );
    }
    t.IsRecord = IsRecord;
    function IsRecursive(e) {
      return n.IsObject(e) && o.Hint in e && e[o.Hint] === "Recursive";
    }
    t.IsRecursive = IsRecursive;
    function IsRef(e) {
      return IsKindOf(e, "Ref") && IsOptionalString(e.$id) && n.IsString(e.$ref);
    }
    t.IsRef = IsRef;
    function IsRegExp(e) {
      return (
        IsKindOf(e, "RegExp") &&
        IsOptionalString(e.$id) &&
        n.IsString(e.source) &&
        n.IsString(e.flags) &&
        IsOptionalNumber(e.maxLength) &&
        IsOptionalNumber(e.minLength)
      );
    }
    t.IsRegExp = IsRegExp;
    function IsString(e) {
      return (
        IsKindOf(e, "String") &&
        e.type === "string" &&
        IsOptionalString(e.$id) &&
        IsOptionalNumber(e.minLength) &&
        IsOptionalNumber(e.maxLength) &&
        IsOptionalPattern(e.pattern) &&
        IsOptionalFormat(e.format)
      );
    }
    t.IsString = IsString;
    function IsSymbol(e) {
      return IsKindOf(e, "Symbol") && e.type === "symbol" && IsOptionalString(e.$id);
    }
    t.IsSymbol = IsSymbol;
    function IsTemplateLiteral(e) {
      return IsKindOf(e, "TemplateLiteral") && e.type === "string" && n.IsString(e.pattern) && e.pattern[0] === "^" && e.pattern[e.pattern.length - 1] === "$";
    }
    t.IsTemplateLiteral = IsTemplateLiteral;
    function IsThis(e) {
      return IsKindOf(e, "This") && IsOptionalString(e.$id) && n.IsString(e.$ref);
    }
    t.IsThis = IsThis;
    function IsTransform(e) {
      return n.IsObject(e) && o.TransformKind in e;
    }
    t.IsTransform = IsTransform;
    function IsTuple(e) {
      return (
        IsKindOf(e, "Tuple") &&
        e.type === "array" &&
        IsOptionalString(e.$id) &&
        n.IsNumber(e.minItems) &&
        n.IsNumber(e.maxItems) &&
        e.minItems === e.maxItems &&
        ((n.IsUndefined(e.items) && n.IsUndefined(e.additionalItems) && e.minItems === 0) || (n.IsArray(e.items) && e.items.every((e) => IsSchema(e))))
      );
    }
    t.IsTuple = IsTuple;
    function IsUndefined(e) {
      return IsKindOf(e, "Undefined") && e.type === "undefined" && IsOptionalString(e.$id);
    }
    t.IsUndefined = IsUndefined;
    function IsUnionLiteral(e) {
      return IsUnion(e) && e.anyOf.every((e) => IsLiteralString(e) || IsLiteralNumber(e));
    }
    t.IsUnionLiteral = IsUnionLiteral;
    function IsUnion(e) {
      return IsKindOf(e, "Union") && IsOptionalString(e.$id) && n.IsObject(e) && n.IsArray(e.anyOf) && e.anyOf.every((e) => IsSchema(e));
    }
    t.IsUnion = IsUnion;
    function IsUint8Array(e) {
      return (
        IsKindOf(e, "Uint8Array") &&
        e.type === "Uint8Array" &&
        IsOptionalString(e.$id) &&
        IsOptionalNumber(e.minByteLength) &&
        IsOptionalNumber(e.maxByteLength)
      );
    }
    t.IsUint8Array = IsUint8Array;
    function IsUnknown(e) {
      return IsKindOf(e, "Unknown") && IsOptionalString(e.$id);
    }
    t.IsUnknown = IsUnknown;
    function IsUnsafe(e) {
      return IsKindOf(e, "Unsafe");
    }
    t.IsUnsafe = IsUnsafe;
    function IsVoid(e) {
      return IsKindOf(e, "Void") && e.type === "void" && IsOptionalString(e.$id);
    }
    t.IsVoid = IsVoid;
    function IsKind(e) {
      return n.IsObject(e) && o.Kind in e && n.IsString(e[o.Kind]) && !i.includes(e[o.Kind]);
    }
    t.IsKind = IsKind;
    function IsSchema(e) {
      return (
        n.IsObject(e) &&
        (IsAny(e) ||
          IsArray(e) ||
          IsBoolean(e) ||
          IsBigInt(e) ||
          IsAsyncIterator(e) ||
          IsConstructor(e) ||
          IsDate(e) ||
          IsFunction(e) ||
          IsInteger(e) ||
          IsIntersect(e) ||
          IsIterator(e) ||
          IsLiteral(e) ||
          IsMappedKey(e) ||
          IsMappedResult(e) ||
          IsNever(e) ||
          IsNot(e) ||
          IsNull(e) ||
          IsNumber(e) ||
          IsObject(e) ||
          IsPromise(e) ||
          IsRecord(e) ||
          IsRef(e) ||
          IsRegExp(e) ||
          IsString(e) ||
          IsSymbol(e) ||
          IsTemplateLiteral(e) ||
          IsThis(e) ||
          IsTuple(e) ||
          IsUndefined(e) ||
          IsUnion(e) ||
          IsUint8Array(e) ||
          IsUnknown(e) ||
          IsUnsafe(e) ||
          IsVoid(e) ||
          IsKind(e))
      );
    }
    t.IsSchema = IsSchema;
  },
  13415: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.IsUndefined =
      t.IsUint8Array =
      t.IsSymbol =
      t.IsString =
      t.IsRegExp =
      t.IsObject =
      t.IsNumber =
      t.IsNull =
      t.IsIterator =
      t.IsFunction =
      t.IsDate =
      t.IsBoolean =
      t.IsBigInt =
      t.IsArray =
      t.IsAsyncIterator =
        void 0;
    function IsAsyncIterator(e) {
      return IsObject(e) && !IsArray(e) && !IsUint8Array(e) && Symbol.asyncIterator in e;
    }
    t.IsAsyncIterator = IsAsyncIterator;
    function IsArray(e) {
      return Array.isArray(e);
    }
    t.IsArray = IsArray;
    function IsBigInt(e) {
      return typeof e === "bigint";
    }
    t.IsBigInt = IsBigInt;
    function IsBoolean(e) {
      return typeof e === "boolean";
    }
    t.IsBoolean = IsBoolean;
    function IsDate(e) {
      return e instanceof globalThis.Date;
    }
    t.IsDate = IsDate;
    function IsFunction(e) {
      return typeof e === "function";
    }
    t.IsFunction = IsFunction;
    function IsIterator(e) {
      return IsObject(e) && !IsArray(e) && !IsUint8Array(e) && Symbol.iterator in e;
    }
    t.IsIterator = IsIterator;
    function IsNull(e) {
      return e === null;
    }
    t.IsNull = IsNull;
    function IsNumber(e) {
      return typeof e === "number";
    }
    t.IsNumber = IsNumber;
    function IsObject(e) {
      return typeof e === "object" && e !== null;
    }
    t.IsObject = IsObject;
    function IsRegExp(e) {
      return e instanceof globalThis.RegExp;
    }
    t.IsRegExp = IsRegExp;
    function IsString(e) {
      return typeof e === "string";
    }
    t.IsString = IsString;
    function IsSymbol(e) {
      return typeof e === "symbol";
    }
    t.IsSymbol = IsSymbol;
    function IsUint8Array(e) {
      return e instanceof globalThis.Uint8Array;
    }
    t.IsUint8Array = IsUint8Array;
    function IsUndefined(e) {
      return e === undefined;
    }
    t.IsUndefined = IsUndefined;
  },
  87943: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Increment = void 0;
    function Increment(e) {
      return (parseInt(e) + 1).toString();
    }
    t.Increment = Increment;
  },
  57782: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(87943), t);
  },
  86918: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(66904), t);
    o(r(80494), t);
    o(r(65774), t);
    o(r(11795), t);
  },
  66904: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.IndexFromMappedKey = void 0;
    const n = r(11795);
    const o = r(41094);
    function MappedIndexPropertyKey(e, t, r) {
      return { [t]: (0, n.Index)(e, [t], r) };
    }
    function MappedIndexPropertyKeys(e, t, r) {
      return t.reduce((t, n) => ({ ...t, ...MappedIndexPropertyKey(e, n, r) }), {});
    }
    function MappedIndexProperties(e, t, r) {
      return MappedIndexPropertyKeys(e, t.keys, r);
    }
    function IndexFromMappedKey(e, t, r) {
      const n = MappedIndexProperties(e, t, r);
      return (0, o.MappedResult)(n);
    }
    t.IndexFromMappedKey = IndexFromMappedKey;
  },
  80494: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.IndexFromMappedResult = void 0;
    const n = r(41094);
    const o = r(65774);
    const s = r(86918);
    function FromProperties(e, t, r) {
      const n = {};
      for (const i of Object.getOwnPropertyNames(t)) {
        n[i] = (0, s.Index)(e, (0, o.IndexPropertyKeys)(t[i]), r);
      }
      return n;
    }
    function FromMappedResult(e, t, r) {
      return FromProperties(e, t.properties, r);
    }
    function IndexFromMappedResult(e, t, r) {
      const o = FromMappedResult(e, t, r);
      return (0, n.MappedResult)(o);
    }
    t.IndexFromMappedResult = IndexFromMappedResult;
  },
  65774: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.IndexPropertyKeys = void 0;
    const n = r(26609);
    const o = r(96994);
    function FromTemplateLiteral(e) {
      const t = (0, n.TemplateLiteralGenerate)(e);
      return t.map((e) => e.toString());
    }
    function FromUnion(e) {
      const t = [];
      for (const r of e) t.push(...IndexPropertyKeys(r));
      return t;
    }
    function FromLiteral(e) {
      return [e.toString()];
    }
    function IndexPropertyKeys(e) {
      return [
        ...new Set(
          (0, o.IsTemplateLiteral)(e)
            ? FromTemplateLiteral(e)
            : (0, o.IsUnion)(e)
              ? FromUnion(e.anyOf)
              : (0, o.IsLiteral)(e)
                ? FromLiteral(e.const)
                : (0, o.IsNumber)(e)
                  ? ["[number]"]
                  : (0, o.IsInteger)(e)
                    ? ["[number]"]
                    : []
        ),
      ];
    }
    t.IndexPropertyKeys = IndexPropertyKeys;
  },
  11795: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Index = t.IndexFromPropertyKeys = t.IndexFromPropertyKey = void 0;
    const n = r(54025);
    const o = r(62746);
    const s = r(69100);
    const i = r(38100);
    const a = r(65774);
    const A = r(66904);
    const c = r(80494);
    const u = r(96994);
    function FromRest(e, t) {
      return e.map((e) => IndexFromPropertyKey(e, t));
    }
    function FromIntersectRest(e) {
      return e.filter((e) => !(0, u.IsNever)(e));
    }
    function FromIntersect(e, t) {
      return (0, o.IntersectEvaluated)(FromIntersectRest(FromRest(e, t)));
    }
    function FromUnionRest(e) {
      return e.some((e) => (0, u.IsNever)(e)) ? [] : e;
    }
    function FromUnion(e, t) {
      return (0, s.UnionEvaluated)(FromUnionRest(FromRest(e, t)));
    }
    function FromTuple(e, t) {
      return t in e ? e[t] : t === "[number]" ? (0, s.UnionEvaluated)(e) : (0, n.Never)();
    }
    function FromArray(e, t) {
      return t === "[number]" ? e : (0, n.Never)();
    }
    function FromProperty(e, t) {
      return t in e ? e[t] : (0, n.Never)();
    }
    function IndexFromPropertyKey(e, t) {
      return (0, u.IsIntersect)(e)
        ? FromIntersect(e.allOf, t)
        : (0, u.IsUnion)(e)
          ? FromUnion(e.anyOf, t)
          : (0, u.IsTuple)(e)
            ? FromTuple(e.items ?? [], t)
            : (0, u.IsArray)(e)
              ? FromArray(e.items, t)
              : (0, u.IsObject)(e)
                ? FromProperty(e.properties, t)
                : (0, n.Never)();
    }
    t.IndexFromPropertyKey = IndexFromPropertyKey;
    function IndexFromPropertyKeys(e, t) {
      return t.map((t) => IndexFromPropertyKey(e, t));
    }
    t.IndexFromPropertyKeys = IndexFromPropertyKeys;
    function FromSchema(e, t) {
      return (0, s.UnionEvaluated)(IndexFromPropertyKeys(e, t));
    }
    function Index(e, t, r = {}) {
      return (0, u.IsMappedResult)(t)
        ? (0, i.CloneType)((0, c.IndexFromMappedResult)(e, t, r))
        : (0, u.IsMappedKey)(t)
          ? (0, i.CloneType)((0, A.IndexFromMappedKey)(e, t, r))
          : (0, u.IsSchema)(t)
            ? (0, i.CloneType)(FromSchema(e, (0, a.IndexPropertyKeys)(t)), r)
            : (0, i.CloneType)(FromSchema(e, t), r);
    }
    t.Index = Index;
  },
  26277: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(79659), t);
  },
  79659: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.InstanceType = void 0;
    const n = r(38100);
    function InstanceType(e, t = {}) {
      return (0, n.CloneType)(e.returns, t);
    }
    t.InstanceType = InstanceType;
  },
  4949: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(76295), t);
  },
  76295: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Integer = void 0;
    const n = r(97034);
    function Integer(e = {}) {
      return { ...e, [n.Kind]: "Integer", type: "integer" };
    }
    t.Integer = Integer;
  },
  62746: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(89995), t);
    o(r(35212), t);
    o(r(26015), t);
  },
  57604: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.IntersectCreate = void 0;
    const n = r(97034);
    const o = r(38100);
    const s = r(96994);
    function IntersectCreate(e, t) {
      const r = e.every((e) => (0, s.IsObject)(e));
      const i = (0, s.IsSchema)(t.unevaluatedProperties) ? { unevaluatedProperties: (0, o.CloneType)(t.unevaluatedProperties) } : {};
      return t.unevaluatedProperties === false || (0, s.IsSchema)(t.unevaluatedProperties) || r
        ? { ...t, ...i, [n.Kind]: "Intersect", type: "object", allOf: (0, o.CloneRest)(e) }
        : { ...t, ...i, [n.Kind]: "Intersect", allOf: (0, o.CloneRest)(e) };
    }
    t.IntersectCreate = IntersectCreate;
  },
  89995: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.IntersectEvaluated = void 0;
    const n = r(97034);
    const o = r(38100);
    const s = r(83889);
    const i = r(54025);
    const a = r(38425);
    const A = r(57604);
    const c = r(96994);
    function IsIntersectOptional(e) {
      return e.every((e) => (0, c.IsOptional)(e));
    }
    function RemoveOptionalFromType(e) {
      return (0, s.Discard)(e, [n.OptionalKind]);
    }
    function RemoveOptionalFromRest(e) {
      return e.map((e) => ((0, c.IsOptional)(e) ? RemoveOptionalFromType(e) : e));
    }
    function ResolveIntersect(e, t) {
      return IsIntersectOptional(e)
        ? (0, a.Optional)((0, A.IntersectCreate)(RemoveOptionalFromRest(e), t))
        : (0, A.IntersectCreate)(RemoveOptionalFromRest(e), t);
    }
    function IntersectEvaluated(e, t = {}) {
      if (e.length === 0) return (0, i.Never)(t);
      if (e.length === 1) return (0, o.CloneType)(e[0], t);
      if (e.some((e) => (0, c.IsTransform)(e))) throw new Error("Cannot intersect transform types");
      return ResolveIntersect(e, t);
    }
    t.IntersectEvaluated = IntersectEvaluated;
  },
  35212: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    const n = r(97034);
  },
  26015: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Intersect = void 0;
    const n = r(38100);
    const o = r(54025);
    const s = r(57604);
    const i = r(96994);
    function Intersect(e, t = {}) {
      if (e.length === 0) return (0, o.Never)(t);
      if (e.length === 1) return (0, n.CloneType)(e[0], t);
      if (e.some((e) => (0, i.IsTransform)(e))) throw new Error("Cannot intersect transform types");
      return (0, s.IntersectCreate)(e, t);
    }
    t.Intersect = Intersect;
  },
  15400: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Capitalize = void 0;
    const n = r(39015);
    function Capitalize(e, t = {}) {
      return (0, n.Intrinsic)(e, "Capitalize", t);
    }
    t.Capitalize = Capitalize;
  },
  30568: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(15400), t);
    o(r(71804), t);
    o(r(39015), t);
    o(r(13161), t);
    o(r(57019), t);
    o(r(80968), t);
  },
  71804: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.IntrinsicFromMappedKey = void 0;
    const n = r(41094);
    const o = r(39015);
    const s = r(98076);
    function MappedIntrinsicPropertyKey(e, t, r) {
      return { [e]: (0, o.Intrinsic)((0, s.Literal)(e), t, r) };
    }
    function MappedIntrinsicPropertyKeys(e, t, r) {
      return e.reduce((e, n) => ({ ...e, ...MappedIntrinsicPropertyKey(n, t, r) }), {});
    }
    function MappedIntrinsicProperties(e, t, r) {
      return MappedIntrinsicPropertyKeys(e["keys"], t, r);
    }
    function IntrinsicFromMappedKey(e, t, r) {
      const o = MappedIntrinsicProperties(e, t, r);
      return (0, n.MappedResult)(o);
    }
    t.IntrinsicFromMappedKey = IntrinsicFromMappedKey;
  },
  39015: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Intrinsic = void 0;
    const n = r(26609);
    const o = r(71804);
    const s = r(98076);
    const i = r(69100);
    const a = r(96994);
    function ApplyUncapitalize(e) {
      const [t, r] = [e.slice(0, 1), e.slice(1)];
      return [t.toLowerCase(), r].join("");
    }
    function ApplyCapitalize(e) {
      const [t, r] = [e.slice(0, 1), e.slice(1)];
      return [t.toUpperCase(), r].join("");
    }
    function ApplyUppercase(e) {
      return e.toUpperCase();
    }
    function ApplyLowercase(e) {
      return e.toLowerCase();
    }
    function FromTemplateLiteral(e, t, r) {
      const o = (0, n.TemplateLiteralParseExact)(e.pattern);
      const a = (0, n.IsTemplateLiteralExpressionFinite)(o);
      if (!a) return { ...e, pattern: FromLiteralValue(e.pattern, t) };
      const A = [...(0, n.TemplateLiteralExpressionGenerate)(o)];
      const c = A.map((e) => (0, s.Literal)(e));
      const u = FromRest(c, t);
      const l = (0, i.Union)(u);
      return (0, n.TemplateLiteral)([l], r);
    }
    function FromLiteralValue(e, t) {
      return typeof e === "string"
        ? t === "Uncapitalize"
          ? ApplyUncapitalize(e)
          : t === "Capitalize"
            ? ApplyCapitalize(e)
            : t === "Uppercase"
              ? ApplyUppercase(e)
              : t === "Lowercase"
                ? ApplyLowercase(e)
                : e
        : e.toString();
    }
    function FromRest(e, t) {
      return e.map((e) => Intrinsic(e, t));
    }
    function Intrinsic(e, t, r = {}) {
      return (0, a.IsMappedKey)(e)
        ? (0, o.IntrinsicFromMappedKey)(e, t, r)
        : (0, a.IsTemplateLiteral)(e)
          ? FromTemplateLiteral(e, t, e)
          : (0, a.IsUnion)(e)
            ? (0, i.Union)(FromRest(e.anyOf, t), r)
            : (0, a.IsLiteral)(e)
              ? (0, s.Literal)(FromLiteralValue(e.const, t), r)
              : e;
    }
    t.Intrinsic = Intrinsic;
  },
  13161: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Lowercase = void 0;
    const n = r(39015);
    function Lowercase(e, t = {}) {
      return (0, n.Intrinsic)(e, "Lowercase", t);
    }
    t.Lowercase = Lowercase;
  },
  57019: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Uncapitalize = void 0;
    const n = r(39015);
    function Uncapitalize(e, t = {}) {
      return (0, n.Intrinsic)(e, "Uncapitalize", t);
    }
    t.Uncapitalize = Uncapitalize;
  },
  80968: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Uppercase = void 0;
    const n = r(39015);
    function Uppercase(e, t = {}) {
      return (0, n.Intrinsic)(e, "Uppercase", t);
    }
    t.Uppercase = Uppercase;
  },
  35907: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(78493), t);
  },
  78493: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Iterator = void 0;
    const n = r(38100);
    const o = r(97034);
    function Iterator(e, t = {}) {
      return { ...t, [o.Kind]: "Iterator", type: "Iterator", items: (0, n.CloneType)(e) };
    }
    t.Iterator = Iterator;
  },
  73373: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(19642), t);
    o(r(740), t);
    o(r(33930), t);
    o(r(36895), t);
  },
  19642: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.KeyOfFromMappedResult = void 0;
    const n = r(41094);
    const o = r(36895);
    function FromProperties(e, t) {
      const r = {};
      for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = (0, o.KeyOf)(e[n], t);
      return r;
    }
    function FromMappedResult(e, t) {
      return FromProperties(e.properties, t);
    }
    function KeyOfFromMappedResult(e, t) {
      const r = FromMappedResult(e, t);
      return (0, n.MappedResult)(r);
    }
    t.KeyOfFromMappedResult = KeyOfFromMappedResult;
  },
  740: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.KeyOfPropertyEntries = void 0;
    const n = r(11795);
    const o = r(33930);
    function KeyOfPropertyEntries(e) {
      const t = (0, o.KeyOfPropertyKeys)(e);
      const r = (0, n.IndexFromPropertyKeys)(e, t);
      return t.map((e, n) => [t[n], r[n]]);
    }
    t.KeyOfPropertyEntries = KeyOfPropertyEntries;
  },
  33930: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.KeyOfPattern = t.KeyOfPropertyKeys = void 0;
    const n = r(12760);
    const o = r(96994);
    function FromRest(e) {
      const t = [];
      for (const r of e) t.push(KeyOfPropertyKeys(r));
      return t;
    }
    function FromIntersect(e) {
      const t = FromRest(e);
      const r = (0, n.SetUnionMany)(t);
      return r;
    }
    function FromUnion(e) {
      const t = FromRest(e);
      const r = (0, n.SetIntersectMany)(t);
      return r;
    }
    function FromTuple(e) {
      return e.map((e, t) => t.toString());
    }
    function FromArray(e) {
      return ["[number]"];
    }
    function FromProperties(e) {
      return globalThis.Object.getOwnPropertyNames(e);
    }
    function FromPatternProperties(e) {
      if (!s) return [];
      const t = globalThis.Object.getOwnPropertyNames(e);
      return t.map((e) => (e[0] === "^" && e[e.length - 1] === "$" ? e.slice(1, e.length - 1) : e));
    }
    function KeyOfPropertyKeys(e) {
      return (0, o.IsIntersect)(e)
        ? FromIntersect(e.allOf)
        : (0, o.IsUnion)(e)
          ? FromUnion(e.anyOf)
          : (0, o.IsTuple)(e)
            ? FromTuple(e.items ?? [])
            : (0, o.IsArray)(e)
              ? FromArray(e.items)
              : (0, o.IsObject)(e)
                ? FromProperties(e.properties)
                : (0, o.IsRecord)(e)
                  ? FromPatternProperties(e.patternProperties)
                  : [];
    }
    t.KeyOfPropertyKeys = KeyOfPropertyKeys;
    let s = false;
    function KeyOfPattern(e) {
      s = true;
      const t = KeyOfPropertyKeys(e);
      s = false;
      const r = t.map((e) => `(${e})`);
      return `^(${r.join("|")})$`;
    }
    t.KeyOfPattern = KeyOfPattern;
  },
  36895: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.KeyOf = t.KeyOfPropertyKeysToRest = void 0;
    const n = r(98076);
    const o = r(85544);
    const s = r(33930);
    const i = r(69100);
    const a = r(38100);
    const A = r(19642);
    const c = r(96994);
    function KeyOfPropertyKeysToRest(e) {
      return e.map((e) => (e === "[number]" ? (0, o.Number)() : (0, n.Literal)(e)));
    }
    t.KeyOfPropertyKeysToRest = KeyOfPropertyKeysToRest;
    function KeyOf(e, t = {}) {
      if ((0, c.IsMappedResult)(e)) {
        return (0, A.KeyOfFromMappedResult)(e, t);
      } else {
        const r = (0, s.KeyOfPropertyKeys)(e);
        const n = KeyOfPropertyKeysToRest(r);
        const o = (0, i.UnionEvaluated)(n);
        return (0, a.CloneType)(o, t);
      }
    }
    t.KeyOf = KeyOf;
  },
  98076: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(31591), t);
  },
  31591: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Literal = void 0;
    const n = r(97034);
    function Literal(e, t = {}) {
      return { ...t, [n.Kind]: "Literal", const: e, type: typeof e };
    }
    t.Literal = Literal;
  },
  41094: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(35613), t);
    o(r(67517), t);
    o(r(90467), t);
  },
  35613: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.MappedKey = void 0;
    const n = r(97034);
    function MappedKey(e) {
      return { [n.Kind]: "MappedKey", keys: e };
    }
    t.MappedKey = MappedKey;
  },
  67517: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.MappedResult = void 0;
    const n = r(97034);
    function MappedResult(e) {
      return { [n.Kind]: "MappedResult", properties: e };
    }
    t.MappedResult = MappedResult;
  },
  90467: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Mapped = t.MappedFunctionReturnType = void 0;
    const n = r(97034);
    const o = r(38100);
    const s = r(83889);
    const i = r(17186);
    const a = r(68092);
    const A = r(16939);
    const c = r(29857);
    const u = r(86918);
    const l = r(62746);
    const p = r(35907);
    const d = r(98076);
    const g = r(62094);
    const m = r(38425);
    const h = r(70062);
    const E = r(40675);
    const I = r(7521);
    const y = r(69100);
    const C = r(12760);
    const b = r(67517);
    const Q = r(96994);
    function FromMappedResult(e, t) {
      return e in t ? FromSchemaType(e, t[e]) : (0, b.MappedResult)(t);
    }
    function MappedKeyToKnownMappedResultProperties(e) {
      return { [e]: (0, d.Literal)(e) };
    }
    function MappedKeyToUnknownMappedResultProperties(e) {
      const t = {};
      for (const r of e) t[r] = (0, d.Literal)(r);
      return t;
    }
    function MappedKeyToMappedResultProperties(e, t) {
      return (0, C.SetIncludes)(t, e) ? MappedKeyToKnownMappedResultProperties(e) : MappedKeyToUnknownMappedResultProperties(t);
    }
    function FromMappedKey(e, t) {
      const r = MappedKeyToMappedResultProperties(e, t);
      return FromMappedResult(e, r);
    }
    function FromRest(e, t) {
      return t.map((t) => FromSchemaType(e, t));
    }
    function FromProperties(e, t) {
      const r = {};
      for (const n of globalThis.Object.getOwnPropertyNames(t)) r[n] = FromSchemaType(e, t[n]);
      return r;
    }
    function FromSchemaType(e, t) {
      return (0, Q.IsOptional)(t)
        ? (0, m.Optional)(FromSchemaType(e, (0, s.Discard)(t, [n.OptionalKind])))
        : (0, Q.IsReadonly)(t)
          ? (0, E.Readonly)(FromSchemaType(e, (0, s.Discard)(t, [n.ReadonlyKind])))
          : (0, Q.IsMappedResult)(t)
            ? FromMappedResult(e, t.properties)
            : (0, Q.IsMappedKey)(t)
              ? FromMappedKey(e, t.keys)
              : (0, Q.IsConstructor)(t)
                ? (0, A.Constructor)(FromRest(e, t.parameters), FromSchemaType(e, t.returns))
                : (0, Q.IsFunction)(t)
                  ? (0, c.Function)(FromRest(e, t.parameters), FromSchemaType(e, t.returns))
                  : (0, Q.IsAsyncIterator)(t)
                    ? (0, a.AsyncIterator)(FromSchemaType(e, t.items))
                    : (0, Q.IsIterator)(t)
                      ? (0, p.Iterator)(FromSchemaType(e, t.items))
                      : (0, Q.IsIntersect)(t)
                        ? (0, l.Intersect)(FromRest(e, t.allOf))
                        : (0, Q.IsUnion)(t)
                          ? (0, y.Union)(FromRest(e, t.anyOf))
                          : (0, Q.IsTuple)(t)
                            ? (0, I.Tuple)(FromRest(e, t.items ?? []))
                            : (0, Q.IsObject)(t)
                              ? (0, g.Object)(FromProperties(e, t.properties))
                              : (0, Q.IsArray)(t)
                                ? (0, i.Array)(FromSchemaType(e, t.items))
                                : (0, Q.IsPromise)(t)
                                  ? (0, h.Promise)(FromSchemaType(e, t.item))
                                  : t;
    }
    function MappedFunctionReturnType(e, t) {
      const r = {};
      for (const n of e) r[n] = FromSchemaType(n, t);
      return r;
    }
    t.MappedFunctionReturnType = MappedFunctionReturnType;
    function Mapped(e, t, r = {}) {
      const s = (0, Q.IsSchema)(e) ? (0, u.IndexPropertyKeys)(e) : e;
      const i = t({ [n.Kind]: "MappedKey", keys: s });
      const a = MappedFunctionReturnType(s, i);
      return (0, o.CloneType)((0, g.Object)(a), r);
    }
    t.Mapped = Mapped;
  },
  54025: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(29867), t);
  },
  29867: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Never = void 0;
    const n = r(97034);
    function Never(e = {}) {
      return { ...e, [n.Kind]: "Never", not: {} };
    }
    t.Never = Never;
  },
  1078: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(8559), t);
  },
  8559: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Not = void 0;
    const n = r(38100);
    const o = r(97034);
    function Not(e, t) {
      return { ...t, [o.Kind]: "Not", not: (0, n.CloneType)(e) };
    }
    t.Not = Not;
  },
  50468: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(3007), t);
  },
  3007: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Null = void 0;
    const n = r(97034);
    function Null(e = {}) {
      return { ...e, [n.Kind]: "Null", type: "null" };
    }
    t.Null = Null;
  },
  85544: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(14151), t);
  },
  14151: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Number = void 0;
    const n = r(97034);
    function Number(e = {}) {
      return { ...e, [n.Kind]: "Number", type: "number" };
    }
    t.Number = Number;
  },
  62094: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(14211), t);
  },
  14211: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Object = void 0;
    const n = r(38100);
    const o = r(97034);
    const s = r(96994);
    function _Object(e, t = {}) {
      const r = globalThis.Object.getOwnPropertyNames(e);
      const i = r.filter((t) => (0, s.IsOptional)(e[t]));
      const a = r.filter((e) => !i.includes(e));
      const A = (0, s.IsSchema)(t.additionalProperties) ? { additionalProperties: (0, n.CloneType)(t.additionalProperties) } : {};
      const c = {};
      for (const t of r) c[t] = (0, n.CloneType)(e[t]);
      return a.length > 0
        ? { ...t, ...A, [o.Kind]: "Object", type: "object", properties: c, required: a }
        : { ...t, ...A, [o.Kind]: "Object", type: "object", properties: c };
    }
    t.Object = _Object;
  },
  88932: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(99308), t);
    o(r(39602), t);
    o(r(33143), t);
  },
  99308: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.OmitFromMappedKey = void 0;
    const n = r(41094);
    const o = r(33143);
    function FromPropertyKey(e, t, r) {
      return { [t]: (0, o.Omit)(e, [t], r) };
    }
    function FromPropertyKeys(e, t, r) {
      return t.reduce((t, n) => ({ ...t, ...FromPropertyKey(e, n, r) }), {});
    }
    function FromMappedKey(e, t, r) {
      return FromPropertyKeys(e, t.keys, r);
    }
    function OmitFromMappedKey(e, t, r) {
      const o = FromMappedKey(e, t, r);
      return (0, n.MappedResult)(o);
    }
    t.OmitFromMappedKey = OmitFromMappedKey;
  },
  39602: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.OmitFromMappedResult = void 0;
    const n = r(41094);
    const o = r(33143);
    function FromProperties(e, t, r) {
      const n = {};
      for (const s of globalThis.Object.getOwnPropertyNames(e)) n[s] = (0, o.Omit)(e[s], t, r);
      return n;
    }
    function FromMappedResult(e, t, r) {
      return FromProperties(e.properties, t, r);
    }
    function OmitFromMappedResult(e, t, r) {
      const o = FromMappedResult(e, t, r);
      return (0, n.MappedResult)(o);
    }
    t.OmitFromMappedResult = OmitFromMappedResult;
  },
  33143: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Omit = void 0;
    const n = r(62746);
    const o = r(69100);
    const s = r(62094);
    const i = r(86918);
    const a = r(83889);
    const A = r(97034);
    const c = r(38100);
    const u = r(99308);
    const l = r(39602);
    const p = r(96994);
    function FromIntersect(e, t) {
      return e.map((e) => OmitResolve(e, t));
    }
    function FromUnion(e, t) {
      return e.map((e) => OmitResolve(e, t));
    }
    function FromProperty(e, t) {
      const { [t]: r, ...n } = e;
      return n;
    }
    function FromProperties(e, t) {
      return t.reduce((e, t) => FromProperty(e, t), e);
    }
    function OmitResolve(e, t) {
      return (0, p.IsIntersect)(e)
        ? (0, n.Intersect)(FromIntersect(e.allOf, t))
        : (0, p.IsUnion)(e)
          ? (0, o.Union)(FromUnion(e.anyOf, t))
          : (0, p.IsObject)(e)
            ? (0, s.Object)(FromProperties(e.properties, t))
            : (0, s.Object)({});
    }
    function Omit(e, t, r = {}) {
      if ((0, p.IsMappedKey)(t)) return (0, u.OmitFromMappedKey)(e, t, r);
      if ((0, p.IsMappedResult)(e)) return (0, l.OmitFromMappedResult)(e, t, r);
      const n = (0, p.IsSchema)(t) ? (0, i.IndexPropertyKeys)(t) : t;
      const o = (0, a.Discard)(e, [A.TransformKind, "$id", "required"]);
      const s = (0, c.CloneType)(OmitResolve(e, n), r);
      return { ...o, ...s };
    }
    t.Omit = Omit;
  },
  38425: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(63984), t);
    o(r(15405), t);
  },
  63984: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.OptionalFromMappedResult = void 0;
    const n = r(41094);
    const o = r(15405);
    function FromProperties(e, t) {
      const r = {};
      for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = (0, o.Optional)(e[n], t);
      return r;
    }
    function FromMappedResult(e, t) {
      return FromProperties(e.properties, t);
    }
    function OptionalFromMappedResult(e, t) {
      const r = FromMappedResult(e, t);
      return (0, n.MappedResult)(r);
    }
    t.OptionalFromMappedResult = OptionalFromMappedResult;
  },
  15405: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Optional = void 0;
    const n = r(97034);
    const o = r(38100);
    const s = r(83889);
    const i = r(63984);
    const a = r(96994);
    function RemoveOptional(e) {
      return (0, s.Discard)((0, o.CloneType)(e), [n.OptionalKind]);
    }
    function AddOptional(e) {
      return { ...(0, o.CloneType)(e), [n.OptionalKind]: "Optional" };
    }
    function OptionalWithFlag(e, t) {
      return t === false ? RemoveOptional(e) : AddOptional(e);
    }
    function Optional(e, t) {
      const r = t ?? true;
      return (0, a.IsMappedResult)(e) ? (0, i.OptionalFromMappedResult)(e, r) : OptionalWithFlag(e, r);
    }
    t.Optional = Optional;
  },
  30449: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(92853), t);
  },
  92853: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Parameters = void 0;
    const n = r(7521);
    const o = r(38100);
    function Parameters(e, t = {}) {
      return (0, n.Tuple)((0, o.CloneRest)(e.parameters), { ...t });
    }
    t.Parameters = Parameters;
  },
  53345: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(16438), t);
    o(r(34523), t);
  },
  16438: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.PartialFromMappedResult = void 0;
    const n = r(41094);
    const o = r(34523);
    function FromProperties(e, t) {
      const r = {};
      for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = (0, o.Partial)(e[n], t);
      return r;
    }
    function FromMappedResult(e, t) {
      return FromProperties(e.properties, t);
    }
    function PartialFromMappedResult(e, t) {
      const r = FromMappedResult(e, t);
      return (0, n.MappedResult)(r);
    }
    t.PartialFromMappedResult = PartialFromMappedResult;
  },
  34523: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Partial = void 0;
    const n = r(38425);
    const o = r(62094);
    const s = r(62746);
    const i = r(69100);
    const a = r(83889);
    const A = r(97034);
    const c = r(38100);
    const u = r(16438);
    const l = r(96994);
    function FromRest(e) {
      return e.map((e) => PartialResolve(e));
    }
    function FromProperties(e) {
      const t = {};
      for (const r of globalThis.Object.getOwnPropertyNames(e)) t[r] = (0, n.Optional)(e[r]);
      return t;
    }
    function PartialResolve(e) {
      return (0, l.IsIntersect)(e)
        ? (0, s.Intersect)(FromRest(e.allOf))
        : (0, l.IsUnion)(e)
          ? (0, i.Union)(FromRest(e.anyOf))
          : (0, l.IsObject)(e)
            ? (0, o.Object)(FromProperties(e.properties))
            : (0, o.Object)({});
    }
    function Partial(e, t = {}) {
      if ((0, l.IsMappedResult)(e)) return (0, u.PartialFromMappedResult)(e, t);
      const r = (0, a.Discard)(e, [A.TransformKind, "$id", "required"]);
      const n = (0, c.CloneType)(PartialResolve(e), t);
      return { ...r, ...n };
    }
    t.Partial = Partial;
  },
  94354: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(74327), t);
  },
  74327: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.PatternStringExact = t.PatternNumberExact = t.PatternBooleanExact = t.PatternString = t.PatternNumber = t.PatternBoolean = void 0;
    t.PatternBoolean = "(true|false)";
    t.PatternNumber = "(0|[1-9][0-9]*)";
    t.PatternString = "(.*)";
    t.PatternBooleanExact = `^${t.PatternBoolean}$`;
    t.PatternNumberExact = `^${t.PatternNumber}$`;
    t.PatternStringExact = `^${t.PatternString}$`;
  },
  40640: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(72748), t);
    o(r(4882), t);
    o(r(65911), t);
  },
  72748: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.PickFromMappedKey = void 0;
    const n = r(41094);
    const o = r(65911);
    function FromPropertyKey(e, t, r) {
      return { [t]: (0, o.Pick)(e, [t], r) };
    }
    function FromPropertyKeys(e, t, r) {
      return t.reduce((t, n) => ({ ...t, ...FromPropertyKey(e, n, r) }), {});
    }
    function FromMappedKey(e, t, r) {
      return FromPropertyKeys(e, t.keys, r);
    }
    function PickFromMappedKey(e, t, r) {
      const o = FromMappedKey(e, t, r);
      return (0, n.MappedResult)(o);
    }
    t.PickFromMappedKey = PickFromMappedKey;
  },
  4882: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.PickFromMappedResult = void 0;
    const n = r(41094);
    const o = r(65911);
    function FromProperties(e, t, r) {
      const n = {};
      for (const s of globalThis.Object.getOwnPropertyNames(e)) n[s] = (0, o.Pick)(e[s], t, r);
      return n;
    }
    function FromMappedResult(e, t, r) {
      return FromProperties(e.properties, t, r);
    }
    function PickFromMappedResult(e, t, r) {
      const o = FromMappedResult(e, t, r);
      return (0, n.MappedResult)(o);
    }
    t.PickFromMappedResult = PickFromMappedResult;
  },
  65911: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Pick = void 0;
    const n = r(62746);
    const o = r(69100);
    const s = r(62094);
    const i = r(86918);
    const a = r(83889);
    const A = r(97034);
    const c = r(38100);
    const u = r(72748);
    const l = r(4882);
    const p = r(96994);
    function FromIntersect(e, t) {
      return e.map((e) => PickResolve(e, t));
    }
    function FromUnion(e, t) {
      return e.map((e) => PickResolve(e, t));
    }
    function FromProperties(e, t) {
      const r = {};
      for (const n of t) if (n in e) r[n] = e[n];
      return r;
    }
    function PickResolve(e, t) {
      return (0, p.IsIntersect)(e)
        ? (0, n.Intersect)(FromIntersect(e.allOf, t))
        : (0, p.IsUnion)(e)
          ? (0, o.Union)(FromUnion(e.anyOf, t))
          : (0, p.IsObject)(e)
            ? (0, s.Object)(FromProperties(e.properties, t))
            : (0, s.Object)({});
    }
    function Pick(e, t, r = {}) {
      if ((0, p.IsMappedKey)(t)) return (0, u.PickFromMappedKey)(e, t, r);
      if ((0, p.IsMappedResult)(e)) return (0, l.PickFromMappedResult)(e, t, r);
      const n = (0, p.IsSchema)(t) ? (0, i.IndexPropertyKeys)(t) : t;
      const o = (0, a.Discard)(e, [A.TransformKind, "$id", "required"]);
      const s = (0, c.CloneType)(PickResolve(e, n), r);
      return { ...o, ...s };
    }
    t.Pick = Pick;
  },
  70062: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(35675), t);
  },
  35675: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Promise = void 0;
    const n = r(38100);
    const o = r(97034);
    function Promise(e, t = {}) {
      return { ...t, [o.Kind]: "Promise", type: "Promise", item: (0, n.CloneType)(e) };
    }
    t.Promise = Promise;
  },
  78946: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(84127), t);
  },
  84127: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ReadonlyOptional = void 0;
    const n = r(40675);
    const o = r(38425);
    function ReadonlyOptional(e) {
      return (0, n.Readonly)((0, o.Optional)(e));
    }
    t.ReadonlyOptional = ReadonlyOptional;
  },
  40675: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(94180), t);
    o(r(90401), t);
  },
  94180: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ReadonlyFromMappedResult = void 0;
    const n = r(41094);
    const o = r(90401);
    function FromProperties(e, t) {
      const r = {};
      for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = (0, o.Readonly)(e[n], t);
      return r;
    }
    function FromMappedResult(e, t) {
      return FromProperties(e.properties, t);
    }
    function ReadonlyFromMappedResult(e, t) {
      const r = FromMappedResult(e, t);
      return (0, n.MappedResult)(r);
    }
    t.ReadonlyFromMappedResult = ReadonlyFromMappedResult;
  },
  90401: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Readonly = void 0;
    const n = r(97034);
    const o = r(38100);
    const s = r(83889);
    const i = r(94180);
    const a = r(96994);
    function RemoveReadonly(e) {
      return (0, s.Discard)((0, o.CloneType)(e), [n.ReadonlyKind]);
    }
    function AddReadonly(e) {
      return { ...(0, o.CloneType)(e), [n.ReadonlyKind]: "Readonly" };
    }
    function ReadonlyWithFlag(e, t) {
      return t === false ? RemoveReadonly(e) : AddReadonly(e);
    }
    function Readonly(e, t) {
      const r = t ?? true;
      return (0, a.IsMappedResult)(e) ? (0, i.ReadonlyFromMappedResult)(e, r) : ReadonlyWithFlag(e, r);
    }
    t.Readonly = Readonly;
  },
  30420: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(98167), t);
  },
  98167: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Record = void 0;
    const n = r(62094);
    const o = r(54025);
    const s = r(69100);
    const i = r(26609);
    const a = r(94354);
    const A = r(86918);
    const c = r(97034);
    const u = r(38100);
    const l = r(13415);
    const p = r(96994);
    function RecordCreateFromPattern(e, t, r) {
      return { ...r, [c.Kind]: "Record", type: "object", patternProperties: { [e]: (0, u.CloneType)(t) } };
    }
    function RecordCreateFromKeys(e, t, r) {
      const o = {};
      for (const r of e) o[r] = (0, u.CloneType)(t);
      return (0, n.Object)(o, { ...r, [c.Hint]: "Record" });
    }
    function FromTemplateLiteralKey(e, t, r) {
      return (0, i.IsTemplateLiteralFinite)(e) ? RecordCreateFromKeys((0, A.IndexPropertyKeys)(e), t, r) : RecordCreateFromPattern(e.pattern, t, r);
    }
    function FromUnionKey(e, t, r) {
      return RecordCreateFromKeys((0, A.IndexPropertyKeys)((0, s.Union)(e)), t, r);
    }
    function FromLiteralKey(e, t, r) {
      return RecordCreateFromKeys([e.toString()], t, r);
    }
    function FromRegExpKey(e, t, r) {
      return RecordCreateFromPattern(e.source, t, r);
    }
    function FromStringKey(e, t, r) {
      const n = (0, l.IsUndefined)(e.pattern) ? a.PatternStringExact : e.pattern;
      return RecordCreateFromPattern(n, t, r);
    }
    function FromIntegerKey(e, t, r) {
      return RecordCreateFromPattern(a.PatternNumberExact, t, r);
    }
    function FromNumberKey(e, t, r) {
      return RecordCreateFromPattern(a.PatternNumberExact, t, r);
    }
    function Record(e, t, r = {}) {
      return (0, p.IsUnion)(e)
        ? FromUnionKey(e.anyOf, t, r)
        : (0, p.IsTemplateLiteral)(e)
          ? FromTemplateLiteralKey(e, t, r)
          : (0, p.IsLiteral)(e)
            ? FromLiteralKey(e.const, t, r)
            : (0, p.IsInteger)(e)
              ? FromIntegerKey(e, t, r)
              : (0, p.IsNumber)(e)
                ? FromNumberKey(e, t, r)
                : (0, p.IsRegExp)(e)
                  ? FromRegExpKey(e, t, r)
                  : (0, p.IsString)(e)
                    ? FromStringKey(e, t, r)
                    : (0, o.Never)(r);
    }
    t.Record = Record;
  },
  33107: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(13475), t);
  },
  13475: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Recursive = void 0;
    const n = r(38100);
    const o = r(13415);
    const s = r(97034);
    let i = 0;
    function Recursive(e, t = {}) {
      if ((0, o.IsUndefined)(t.$id)) t.$id = `T${i++}`;
      const r = e({ [s.Kind]: "This", $ref: `${t.$id}` });
      r.$id = t.$id;
      return (0, n.CloneType)({ ...t, [s.Hint]: "Recursive", ...r });
    }
    t.Recursive = Recursive;
  },
  80470: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(27735), t);
  },
  27735: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Ref = void 0;
    const n = r(97034);
    const o = r(13415);
    function Ref(e, t = {}) {
      if ((0, o.IsString)(e)) return { ...t, [n.Kind]: "Ref", $ref: e };
      if ((0, o.IsUndefined)(e.$id)) throw new Error("Reference target type must specify an $id");
      return { ...t, [n.Kind]: "Ref", $ref: e.$id };
    }
    t.Ref = Ref;
  },
  26936: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(99383), t);
  },
  99383: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.RegExp = void 0;
    const n = r(13415);
    const o = r(97034);
    function RegExp(e, t = {}) {
      const r = (0, n.IsString)(e) ? new globalThis.RegExp(e) : e;
      return { ...t, [o.Kind]: "RegExp", type: "RegExp", source: r.source, flags: r.flags };
    }
    t.RegExp = RegExp;
  },
  56315: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Get = t.Set = t.Has = t.Delete = t.Clear = t.Entries = void 0;
    const r = new Map();
    function Entries() {
      return new Map(r);
    }
    t.Entries = Entries;
    function Clear() {
      return r.clear();
    }
    t.Clear = Clear;
    function Delete(e) {
      return r.delete(e);
    }
    t.Delete = Delete;
    function Has(e) {
      return r.has(e);
    }
    t.Has = Has;
    function Set(e, t) {
      r.set(e, t);
    }
    t.Set = Set;
    function Get(e) {
      return r.get(e);
    }
    t.Get = Get;
  },
  51786: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TypeRegistry = t.FormatRegistry = void 0;
    t.FormatRegistry = r(56315);
    t.TypeRegistry = r(1912);
  },
  1912: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Get = t.Set = t.Has = t.Delete = t.Clear = t.Entries = void 0;
    const r = new Map();
    function Entries() {
      return new Map(r);
    }
    t.Entries = Entries;
    function Clear() {
      return r.clear();
    }
    t.Clear = Clear;
    function Delete(e) {
      return r.delete(e);
    }
    t.Delete = Delete;
    function Has(e) {
      return r.has(e);
    }
    t.Has = Has;
    function Set(e, t) {
      r.set(e, t);
    }
    t.Set = Set;
    function Get(e) {
      return r.get(e);
    }
    t.Get = Get;
  },
  42744: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(24722), t);
    o(r(78775), t);
  },
  24722: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.RequiredFromMappedResult = void 0;
    const n = r(41094);
    const o = r(78775);
    function FromProperties(e, t) {
      const r = {};
      for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = (0, o.Required)(e[n], t);
      return r;
    }
    function FromMappedResult(e, t) {
      return FromProperties(e.properties, t);
    }
    function RequiredFromMappedResult(e, t) {
      const r = FromMappedResult(e, t);
      return (0, n.MappedResult)(r);
    }
    t.RequiredFromMappedResult = RequiredFromMappedResult;
  },
  78775: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Required = void 0;
    const n = r(62746);
    const o = r(69100);
    const s = r(62094);
    const i = r(97034);
    const a = r(38100);
    const A = r(83889);
    const c = r(24722);
    const u = r(96994);
    function FromRest(e) {
      return e.map((e) => RequiredResolve(e));
    }
    function FromProperties(e) {
      const t = {};
      for (const r of globalThis.Object.getOwnPropertyNames(e)) t[r] = (0, A.Discard)(e[r], [i.OptionalKind]);
      return t;
    }
    function RequiredResolve(e) {
      return (0, u.IsIntersect)(e)
        ? (0, n.Intersect)(FromRest(e.allOf))
        : (0, u.IsUnion)(e)
          ? (0, o.Union)(FromRest(e.anyOf))
          : (0, u.IsObject)(e)
            ? (0, s.Object)(FromProperties(e.properties))
            : (0, s.Object)({});
    }
    function Required(e, t = {}) {
      if ((0, u.IsMappedResult)(e)) {
        return (0, c.RequiredFromMappedResult)(e, t);
      } else {
        const r = (0, A.Discard)(e, [i.TransformKind, "$id", "required"]);
        const n = (0, a.CloneType)(RequiredResolve(e), t);
        return { ...r, ...n };
      }
    }
    t.Required = Required;
  },
  83003: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(48881), t);
  },
  48881: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Rest = void 0;
    const n = r(38100);
    const o = r(96994);
    function RestResolve(e) {
      return (0, o.IsIntersect)(e)
        ? (0, n.CloneRest)(e.allOf)
        : (0, o.IsUnion)(e)
          ? (0, n.CloneRest)(e.anyOf)
          : (0, o.IsTuple)(e)
            ? (0, n.CloneRest)(e.items ?? [])
            : [];
    }
    function Rest(e) {
      return (0, n.CloneRest)(RestResolve(e));
    }
    t.Rest = Rest;
  },
  32970: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(11243), t);
  },
  11243: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ReturnType = void 0;
    const n = r(38100);
    function ReturnType(e, t = {}) {
      return (0, n.CloneType)(e.returns, t);
    }
    t.ReturnType = ReturnType;
  },
  13523: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
  },
  68954: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(13523), t);
    o(r(53283), t);
  },
  53283: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    const n = r(97034);
  },
  12760: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(85944), t);
  },
  85944: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.SetUnionMany = t.SetIntersectMany = t.SetComplement = t.SetUnion = t.SetIntersect = t.SetDistinct = t.SetIsSubset = t.SetIncludes = void 0;
    function SetIncludes(e, t) {
      return e.includes(t);
    }
    t.SetIncludes = SetIncludes;
    function SetIsSubset(e, t) {
      return e.every((e) => SetIncludes(t, e));
    }
    t.SetIsSubset = SetIsSubset;
    function SetDistinct(e) {
      return [...new Set(e)];
    }
    t.SetDistinct = SetDistinct;
    function SetIntersect(e, t) {
      return e.filter((e) => t.includes(e));
    }
    t.SetIntersect = SetIntersect;
    function SetUnion(e, t) {
      return [...e, ...t];
    }
    t.SetUnion = SetUnion;
    function SetComplement(e, t) {
      return e.filter((e) => !t.includes(e));
    }
    t.SetComplement = SetComplement;
    function SetIntersectManyResolve(e, t) {
      return e.reduce((e, t) => SetIntersect(e, t), t);
    }
    function SetIntersectMany(e) {
      return e.length === 1 ? e[0] : e.length > 1 ? SetIntersectManyResolve(e.slice(1), e[0]) : [];
    }
    t.SetIntersectMany = SetIntersectMany;
    function SetUnionMany(e) {
      const t = [];
      for (const r of e) t.push(...r);
      return t;
    }
    t.SetUnionMany = SetUnionMany;
  },
  60343: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(917), t);
  },
  917: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
  },
  23556: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(69295), t);
  },
  69295: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Strict = void 0;
    function Strict(e) {
      return JSON.parse(JSON.stringify(e));
    }
    t.Strict = Strict;
  },
  81688: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(14695), t);
  },
  14695: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.String = void 0;
    const n = r(97034);
    function String(e = {}) {
      return { ...e, [n.Kind]: "String", type: "string" };
    }
    t.String = String;
  },
  2129: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(86445), t);
  },
  86445: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Symbol = void 0;
    const n = r(97034);
    function Symbol(e) {
      return { ...e, [n.Kind]: "Symbol", type: "symbol" };
    }
    t.Symbol = Symbol;
  },
  97034: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(22311), t);
  },
  22311: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Kind = t.Hint = t.OptionalKind = t.ReadonlyKind = t.TransformKind = void 0;
    t.TransformKind = Symbol.for("TypeBox.Transform");
    t.ReadonlyKind = Symbol.for("TypeBox.Readonly");
    t.OptionalKind = Symbol.for("TypeBox.Optional");
    t.Hint = Symbol.for("TypeBox.Hint");
    t.Kind = Symbol.for("TypeBox.Kind");
  },
  75930: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.IsTemplateLiteralFinite = t.IsTemplateLiteralExpressionFinite = t.TemplateLiteralFiniteError = void 0;
    const n = r(75430);
    const o = r(26113);
    class TemplateLiteralFiniteError extends o.TypeBoxError {}
    t.TemplateLiteralFiniteError = TemplateLiteralFiniteError;
    function IsNumberExpression(e) {
      return (
        e.type === "or" &&
        e.expr.length === 2 &&
        e.expr[0].type === "const" &&
        e.expr[0].const === "0" &&
        e.expr[1].type === "const" &&
        e.expr[1].const === "[1-9][0-9]*"
      );
    }
    function IsBooleanExpression(e) {
      return (
        e.type === "or" &&
        e.expr.length === 2 &&
        e.expr[0].type === "const" &&
        e.expr[0].const === "true" &&
        e.expr[1].type === "const" &&
        e.expr[1].const === "false"
      );
    }
    function IsStringExpression(e) {
      return e.type === "const" && e.const === ".*";
    }
    function IsTemplateLiteralExpressionFinite(e) {
      return IsNumberExpression(e) || IsStringExpression(e)
        ? false
        : IsBooleanExpression(e)
          ? true
          : e.type === "and"
            ? e.expr.every((e) => IsTemplateLiteralExpressionFinite(e))
            : e.type === "or"
              ? e.expr.every((e) => IsTemplateLiteralExpressionFinite(e))
              : e.type === "const"
                ? true
                : (() => {
                    throw new TemplateLiteralFiniteError(`Unknown expression type`);
                  })();
    }
    t.IsTemplateLiteralExpressionFinite = IsTemplateLiteralExpressionFinite;
    function IsTemplateLiteralFinite(e) {
      const t = (0, n.TemplateLiteralParseExact)(e.pattern);
      return IsTemplateLiteralExpressionFinite(t);
    }
    t.IsTemplateLiteralFinite = IsTemplateLiteralFinite;
  },
  85670: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TemplateLiteralGenerate = t.TemplateLiteralExpressionGenerate = t.TemplateLiteralGenerateError = void 0;
    const n = r(75930);
    const o = r(75430);
    const s = r(26113);
    class TemplateLiteralGenerateError extends s.TypeBoxError {}
    t.TemplateLiteralGenerateError = TemplateLiteralGenerateError;
    function* GenerateReduce(e) {
      if (e.length === 1) return yield* e[0];
      for (const t of e[0]) {
        for (const r of GenerateReduce(e.slice(1))) {
          yield `${t}${r}`;
        }
      }
    }
    function* GenerateAnd(e) {
      return yield* GenerateReduce(e.expr.map((e) => [...TemplateLiteralExpressionGenerate(e)]));
    }
    function* GenerateOr(e) {
      for (const t of e.expr) yield* TemplateLiteralExpressionGenerate(t);
    }
    function* GenerateConst(e) {
      return yield e.const;
    }
    function* TemplateLiteralExpressionGenerate(e) {
      return e.type === "and"
        ? yield* GenerateAnd(e)
        : e.type === "or"
          ? yield* GenerateOr(e)
          : e.type === "const"
            ? yield* GenerateConst(e)
            : (() => {
                throw new TemplateLiteralGenerateError("Unknown expression");
              })();
    }
    t.TemplateLiteralExpressionGenerate = TemplateLiteralExpressionGenerate;
    function TemplateLiteralGenerate(e) {
      const t = (0, o.TemplateLiteralParseExact)(e.pattern);
      return (0, n.IsTemplateLiteralExpressionFinite)(t) ? [...TemplateLiteralExpressionGenerate(t)] : [];
    }
    t.TemplateLiteralGenerate = TemplateLiteralGenerate;
  },
  26609: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(75930), t);
    o(r(85670), t);
    o(r(98094), t);
    o(r(75430), t);
    o(r(85855), t);
    o(r(27522), t);
    o(r(4181), t);
  },
  75430: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TemplateLiteralParseExact = t.TemplateLiteralParse = t.TemplateLiteralParserError = void 0;
    const n = r(26113);
    class TemplateLiteralParserError extends n.TypeBoxError {}
    t.TemplateLiteralParserError = TemplateLiteralParserError;
    function Unescape(e) {
      return e.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
    }
    function IsNonEscaped(e, t, r) {
      return e[t] === r && e.charCodeAt(t - 1) !== 92;
    }
    function IsOpenParen(e, t) {
      return IsNonEscaped(e, t, "(");
    }
    function IsCloseParen(e, t) {
      return IsNonEscaped(e, t, ")");
    }
    function IsSeparator(e, t) {
      return IsNonEscaped(e, t, "|");
    }
    function IsGroup(e) {
      if (!(IsOpenParen(e, 0) && IsCloseParen(e, e.length - 1))) return false;
      let t = 0;
      for (let r = 0; r < e.length; r++) {
        if (IsOpenParen(e, r)) t += 1;
        if (IsCloseParen(e, r)) t -= 1;
        if (t === 0 && r !== e.length - 1) return false;
      }
      return true;
    }
    function InGroup(e) {
      return e.slice(1, e.length - 1);
    }
    function IsPrecedenceOr(e) {
      let t = 0;
      for (let r = 0; r < e.length; r++) {
        if (IsOpenParen(e, r)) t += 1;
        if (IsCloseParen(e, r)) t -= 1;
        if (IsSeparator(e, r) && t === 0) return true;
      }
      return false;
    }
    function IsPrecedenceAnd(e) {
      for (let t = 0; t < e.length; t++) {
        if (IsOpenParen(e, t)) return true;
      }
      return false;
    }
    function Or(e) {
      let [t, r] = [0, 0];
      const n = [];
      for (let o = 0; o < e.length; o++) {
        if (IsOpenParen(e, o)) t += 1;
        if (IsCloseParen(e, o)) t -= 1;
        if (IsSeparator(e, o) && t === 0) {
          const t = e.slice(r, o);
          if (t.length > 0) n.push(TemplateLiteralParse(t));
          r = o + 1;
        }
      }
      const o = e.slice(r);
      if (o.length > 0) n.push(TemplateLiteralParse(o));
      if (n.length === 0) return { type: "const", const: "" };
      if (n.length === 1) return n[0];
      return { type: "or", expr: n };
    }
    function And(e) {
      function Group(e, t) {
        if (!IsOpenParen(e, t)) throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
        let r = 0;
        for (let n = t; n < e.length; n++) {
          if (IsOpenParen(e, n)) r += 1;
          if (IsCloseParen(e, n)) r -= 1;
          if (r === 0) return [t, n];
        }
        throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
      }
      function Range(e, t) {
        for (let r = t; r < e.length; r++) {
          if (IsOpenParen(e, r)) return [t, r];
        }
        return [t, e.length];
      }
      const t = [];
      for (let r = 0; r < e.length; r++) {
        if (IsOpenParen(e, r)) {
          const [n, o] = Group(e, r);
          const s = e.slice(n, o + 1);
          t.push(TemplateLiteralParse(s));
          r = o;
        } else {
          const [n, o] = Range(e, r);
          const s = e.slice(n, o);
          if (s.length > 0) t.push(TemplateLiteralParse(s));
          r = o - 1;
        }
      }
      return t.length === 0 ? { type: "const", const: "" } : t.length === 1 ? t[0] : { type: "and", expr: t };
    }
    function TemplateLiteralParse(e) {
      return IsGroup(e) ? TemplateLiteralParse(InGroup(e)) : IsPrecedenceOr(e) ? Or(e) : IsPrecedenceAnd(e) ? And(e) : { type: "const", const: Unescape(e) };
    }
    t.TemplateLiteralParse = TemplateLiteralParse;
    function TemplateLiteralParseExact(e) {
      return TemplateLiteralParse(e.slice(1, e.length - 1));
    }
    t.TemplateLiteralParseExact = TemplateLiteralParseExact;
  },
  85855: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TemplateLiteralPattern = t.TemplateLiteralPatternError = void 0;
    const n = r(94354);
    const o = r(97034);
    const s = r(26113);
    const i = r(96994);
    class TemplateLiteralPatternError extends s.TypeBoxError {}
    t.TemplateLiteralPatternError = TemplateLiteralPatternError;
    function Escape(e) {
      return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }
    function Visit(e, t) {
      return (0, i.IsTemplateLiteral)(e)
        ? e.pattern.slice(1, e.pattern.length - 1)
        : (0, i.IsUnion)(e)
          ? `(${e.anyOf.map((e) => Visit(e, t)).join("|")})`
          : (0, i.IsNumber)(e)
            ? `${t}${n.PatternNumber}`
            : (0, i.IsInteger)(e)
              ? `${t}${n.PatternNumber}`
              : (0, i.IsBigInt)(e)
                ? `${t}${n.PatternNumber}`
                : (0, i.IsString)(e)
                  ? `${t}${n.PatternString}`
                  : (0, i.IsLiteral)(e)
                    ? `${t}${Escape(e.const.toString())}`
                    : (0, i.IsBoolean)(e)
                      ? `${t}${n.PatternBoolean}`
                      : (() => {
                          throw new TemplateLiteralPatternError(`Unexpected Kind '${e[o.Kind]}'`);
                        })();
    }
    function TemplateLiteralPattern(e) {
      return `^${e.map((e) => Visit(e, "")).join("")}$`;
    }
    t.TemplateLiteralPattern = TemplateLiteralPattern;
  },
  98094: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TemplateLiteralSyntax = void 0;
    const n = r(98076);
    const o = r(64515);
    const s = r(13278);
    const i = r(85544);
    const a = r(81688);
    const A = r(69100);
    const c = r(54025);
    function* FromUnion(e) {
      const t = e.trim().replace(/"|'/g, "");
      return t === "boolean"
        ? yield (0, o.Boolean)()
        : t === "number"
          ? yield (0, i.Number)()
          : t === "bigint"
            ? yield (0, s.BigInt)()
            : t === "string"
              ? yield (0, a.String)()
              : yield (() => {
                  const e = t.split("|").map((e) => (0, n.Literal)(e.trim()));
                  return e.length === 0 ? (0, c.Never)() : e.length === 1 ? e[0] : (0, A.UnionEvaluated)(e);
                })();
    }
    function* FromTerminal(e) {
      if (e[1] !== "{") {
        const t = (0, n.Literal)("$");
        const r = FromSyntax(e.slice(1));
        return yield* [t, ...r];
      }
      for (let t = 2; t < e.length; t++) {
        if (e[t] === "}") {
          const r = FromUnion(e.slice(2, t));
          const n = FromSyntax(e.slice(t + 1));
          return yield* [...r, ...n];
        }
      }
      yield (0, n.Literal)(e);
    }
    function* FromSyntax(e) {
      for (let t = 0; t < e.length; t++) {
        if (e[t] === "$") {
          const r = (0, n.Literal)(e.slice(0, t));
          const o = FromTerminal(e.slice(t));
          return yield* [r, ...o];
        }
      }
      yield (0, n.Literal)(e);
    }
    function TemplateLiteralSyntax(e) {
      return [...FromSyntax(e)];
    }
    t.TemplateLiteralSyntax = TemplateLiteralSyntax;
  },
  4181: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TemplateLiteral = void 0;
    const n = r(98094);
    const o = r(85855);
    const s = r(13415);
    const i = r(97034);
    function TemplateLiteral(e, t = {}) {
      const r = (0, s.IsString)(e) ? (0, o.TemplateLiteralPattern)((0, n.TemplateLiteralSyntax)(e)) : (0, o.TemplateLiteralPattern)(e);
      return { ...t, [i.Kind]: "TemplateLiteral", type: "string", pattern: r };
    }
    t.TemplateLiteral = TemplateLiteral;
  },
  27522: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TemplateLiteralToUnion = void 0;
    const n = r(69100);
    const o = r(98076);
    const s = r(85670);
    function TemplateLiteralToUnion(e) {
      const t = (0, s.TemplateLiteralGenerate)(e);
      const r = t.map((e) => (0, o.Literal)(e));
      return (0, n.UnionEvaluated)(r);
    }
    t.TemplateLiteralToUnion = TemplateLiteralToUnion;
  },
  67575: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(79399), t);
  },
  79399: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Transform = t.TransformEncodeBuilder = t.TransformDecodeBuilder = void 0;
    const n = r(97034);
    const o = r(38100);
    const s = r(96994);
    class TransformDecodeBuilder {
      constructor(e) {
        this.schema = e;
      }
      Decode(e) {
        return new TransformEncodeBuilder(this.schema, e);
      }
    }
    t.TransformDecodeBuilder = TransformDecodeBuilder;
    class TransformEncodeBuilder {
      constructor(e, t) {
        this.schema = e;
        this.decode = t;
      }
      EncodeTransform(e, t) {
        const Encode = (r) => t[n.TransformKind].Encode(e(r));
        const Decode = (e) => this.decode(t[n.TransformKind].Decode(e));
        const r = { Encode: Encode, Decode: Decode };
        return { ...t, [n.TransformKind]: r };
      }
      EncodeSchema(e, t) {
        const r = { Decode: this.decode, Encode: e };
        return { ...t, [n.TransformKind]: r };
      }
      Encode(e) {
        const t = (0, o.CloneType)(this.schema);
        return (0, s.IsTransform)(t) ? this.EncodeTransform(e, t) : this.EncodeSchema(e, t);
      }
    }
    t.TransformEncodeBuilder = TransformEncodeBuilder;
    function Transform(e) {
      return new TransformDecodeBuilder(e);
    }
    t.Transform = Transform;
  },
  7521: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(65667), t);
  },
  65667: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Tuple = void 0;
    const n = r(38100);
    const o = r(97034);
    function Tuple(e, t = {}) {
      const [r, s, i] = [false, e.length, e.length];
      return e.length > 0
        ? { ...t, [o.Kind]: "Tuple", type: "array", items: (0, n.CloneRest)(e), additionalItems: r, minItems: s, maxItems: i }
        : { ...t, [o.Kind]: "Tuple", type: "array", minItems: s, maxItems: i };
    }
    t.Tuple = Tuple;
  },
  68237: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Type = t.JavaScriptTypeBuilder = t.JsonTypeBuilder = void 0;
    var n = r(86959);
    Object.defineProperty(t, "JsonTypeBuilder", {
      enumerable: true,
      get: function () {
        return n.JsonTypeBuilder;
      },
    });
    const o = r(17505);
    const s = r(18158);
    Object.defineProperty(t, "JavaScriptTypeBuilder", {
      enumerable: true,
      get: function () {
        return s.JavaScriptTypeBuilder;
      },
    });
    const i = o;
    t.Type = i;
  },
  18158: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.JavaScriptTypeBuilder = void 0;
    const n = r(86959);
    const o = r(68092);
    const s = r(85164);
    const i = r(13278);
    const a = r(16939);
    const A = r(58562);
    const c = r(49305);
    const u = r(29857);
    const l = r(26277);
    const p = r(35907);
    const d = r(30449);
    const g = r(70062);
    const m = r(26936);
    const h = r(32970);
    const E = r(2129);
    const I = r(45760);
    const y = r(96231);
    const C = r(81947);
    class JavaScriptTypeBuilder extends n.JsonTypeBuilder {
      AsyncIterator(e, t = {}) {
        return (0, o.AsyncIterator)(e, t);
      }
      Awaited(e, t = {}) {
        return (0, s.Awaited)(e, t);
      }
      BigInt(e = {}) {
        return (0, i.BigInt)(e);
      }
      ConstructorParameters(e, t = {}) {
        return (0, A.ConstructorParameters)(e, t);
      }
      Constructor(e, t, r) {
        return (0, a.Constructor)(e, t, r);
      }
      Date(e = {}) {
        return (0, c.Date)(e);
      }
      Function(e, t, r) {
        return (0, u.Function)(e, t, r);
      }
      InstanceType(e, t = {}) {
        return (0, l.InstanceType)(e, t);
      }
      Iterator(e, t = {}) {
        return (0, p.Iterator)(e, t);
      }
      Parameters(e, t = {}) {
        return (0, d.Parameters)(e, t);
      }
      Promise(e, t = {}) {
        return (0, g.Promise)(e, t);
      }
      RegExp(e, t = {}) {
        return (0, m.RegExp)(e, t);
      }
      ReturnType(e, t = {}) {
        return (0, h.ReturnType)(e, t);
      }
      Symbol(e) {
        return (0, E.Symbol)(e);
      }
      Undefined(e = {}) {
        return (0, y.Undefined)(e);
      }
      Uint8Array(e = {}) {
        return (0, I.Uint8Array)(e);
      }
      Void(e = {}) {
        return (0, C.Void)(e);
      }
    }
    t.JavaScriptTypeBuilder = JavaScriptTypeBuilder;
  },
  86959: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.JsonTypeBuilder = void 0;
    const n = r(36813);
    const o = r(17186);
    const s = r(64515);
    const i = r(80788);
    const a = r(19236);
    const A = r(911);
    const c = r(98056);
    const u = r(41153);
    const l = r(94850);
    const p = r(69682);
    const d = r(86918);
    const g = r(4949);
    const m = r(62746);
    const h = r(30568);
    const E = r(73373);
    const I = r(98076);
    const y = r(41094);
    const C = r(54025);
    const b = r(1078);
    const Q = r(50468);
    const B = r(85544);
    const T = r(62094);
    const v = r(88932);
    const w = r(38425);
    const _ = r(53345);
    const R = r(40640);
    const O = r(40675);
    const F = r(78946);
    const D = r(30420);
    const k = r(33107);
    const S = r(80470);
    const N = r(42744);
    const P = r(83003);
    const L = r(23556);
    const U = r(81688);
    const M = r(26609);
    const G = r(67575);
    const x = r(7521);
    const j = r(69100);
    const V = r(51897);
    const H = r(23339);
    class JsonTypeBuilder {
      Strict(e) {
        return (0, L.Strict)(e);
      }
      ReadonlyOptional(e) {
        return (0, F.ReadonlyOptional)(e);
      }
      Readonly(e, t) {
        return (0, O.Readonly)(e, t ?? true);
      }
      Optional(e, t) {
        return (0, w.Optional)(e, t ?? true);
      }
      Any(e = {}) {
        return (0, n.Any)(e);
      }
      Array(e, t = {}) {
        return (0, o.Array)(e, t);
      }
      Boolean(e = {}) {
        return (0, s.Boolean)(e);
      }
      Capitalize(e, t = {}) {
        return (0, h.Capitalize)(e, t);
      }
      Composite(e, t) {
        return (0, i.Composite)(e, t);
      }
      Const(e, t = {}) {
        return (0, a.Const)(e, t);
      }
      Deref(e, t) {
        return (0, A.Deref)(e, t);
      }
      Enum(e, t = {}) {
        return (0, c.Enum)(e, t);
      }
      Exclude(e, t, r = {}) {
        return (0, u.Exclude)(e, t, r);
      }
      Extends(e, t, r, n, o = {}) {
        return (0, l.Extends)(e, t, r, n, o);
      }
      Extract(e, t, r = {}) {
        return (0, p.Extract)(e, t, r);
      }
      Index(e, t, r = {}) {
        return (0, d.Index)(e, t, r);
      }
      Integer(e = {}) {
        return (0, g.Integer)(e);
      }
      Intersect(e, t = {}) {
        return (0, m.Intersect)(e, t);
      }
      KeyOf(e, t = {}) {
        return (0, E.KeyOf)(e, t);
      }
      Literal(e, t = {}) {
        return (0, I.Literal)(e, t);
      }
      Lowercase(e, t = {}) {
        return (0, h.Lowercase)(e, t);
      }
      Mapped(e, t, r = {}) {
        return (0, y.Mapped)(e, t, r);
      }
      Never(e = {}) {
        return (0, C.Never)(e);
      }
      Not(e, t) {
        return (0, b.Not)(e, t);
      }
      Null(e = {}) {
        return (0, Q.Null)(e);
      }
      Number(e = {}) {
        return (0, B.Number)(e);
      }
      Object(e, t = {}) {
        return (0, T.Object)(e, t);
      }
      Omit(e, t, r = {}) {
        return (0, v.Omit)(e, t, r);
      }
      Partial(e, t = {}) {
        return (0, _.Partial)(e, t);
      }
      Pick(e, t, r = {}) {
        return (0, R.Pick)(e, t, r);
      }
      Record(e, t, r = {}) {
        return (0, D.Record)(e, t, r);
      }
      Recursive(e, t = {}) {
        return (0, k.Recursive)(e, t);
      }
      Ref(e, t = {}) {
        return (0, S.Ref)(e, t);
      }
      Required(e, t = {}) {
        return (0, N.Required)(e, t);
      }
      Rest(e) {
        return (0, P.Rest)(e);
      }
      String(e = {}) {
        return (0, U.String)(e);
      }
      TemplateLiteral(e, t = {}) {
        return (0, M.TemplateLiteral)(e, t);
      }
      Transform(e) {
        return (0, G.Transform)(e);
      }
      Tuple(e, t = {}) {
        return (0, x.Tuple)(e, t);
      }
      Uncapitalize(e, t = {}) {
        return (0, h.Uncapitalize)(e, t);
      }
      Union(e, t = {}) {
        return (0, j.Union)(e, t);
      }
      Unknown(e = {}) {
        return (0, V.Unknown)(e);
      }
      Unsafe(e = {}) {
        return (0, H.Unsafe)(e);
      }
      Uppercase(e, t = {}) {
        return (0, h.Uppercase)(e, t);
      }
    }
    t.JsonTypeBuilder = JsonTypeBuilder;
  },
  17505: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Strict =
      t.ReturnType =
      t.Rest =
      t.Required =
      t.RegExp =
      t.Ref =
      t.Recursive =
      t.Record =
      t.ReadonlyOptional =
      t.Readonly =
      t.Promise =
      t.Pick =
      t.Partial =
      t.Parameters =
      t.Optional =
      t.Omit =
      t.Object =
      t.Number =
      t.Null =
      t.Not =
      t.Never =
      t.Mapped =
      t.Literal =
      t.KeyOf =
      t.Iterator =
      t.Uppercase =
      t.Lowercase =
      t.Uncapitalize =
      t.Capitalize =
      t.Intersect =
      t.Integer =
      t.InstanceType =
      t.Index =
      t.Function =
      t.Extract =
      t.Extends =
      t.Exclude =
      t.Enum =
      t.Deref =
      t.Date =
      t.ConstructorParameters =
      t.Constructor =
      t.Const =
      t.Composite =
      t.Boolean =
      t.BigInt =
      t.Awaited =
      t.AsyncIterator =
      t.Array =
      t.Any =
        void 0;
    t.Void = t.Unsafe = t.Unknown = t.Union = t.Undefined = t.Uint8Array = t.Tuple = t.Transform = t.TemplateLiteral = t.Symbol = t.String = void 0;
    var n = r(36813);
    Object.defineProperty(t, "Any", {
      enumerable: true,
      get: function () {
        return n.Any;
      },
    });
    var o = r(17186);
    Object.defineProperty(t, "Array", {
      enumerable: true,
      get: function () {
        return o.Array;
      },
    });
    var s = r(68092);
    Object.defineProperty(t, "AsyncIterator", {
      enumerable: true,
      get: function () {
        return s.AsyncIterator;
      },
    });
    var i = r(85164);
    Object.defineProperty(t, "Awaited", {
      enumerable: true,
      get: function () {
        return i.Awaited;
      },
    });
    var a = r(13278);
    Object.defineProperty(t, "BigInt", {
      enumerable: true,
      get: function () {
        return a.BigInt;
      },
    });
    var A = r(64515);
    Object.defineProperty(t, "Boolean", {
      enumerable: true,
      get: function () {
        return A.Boolean;
      },
    });
    var c = r(80788);
    Object.defineProperty(t, "Composite", {
      enumerable: true,
      get: function () {
        return c.Composite;
      },
    });
    var u = r(19236);
    Object.defineProperty(t, "Const", {
      enumerable: true,
      get: function () {
        return u.Const;
      },
    });
    var l = r(16939);
    Object.defineProperty(t, "Constructor", {
      enumerable: true,
      get: function () {
        return l.Constructor;
      },
    });
    var p = r(58562);
    Object.defineProperty(t, "ConstructorParameters", {
      enumerable: true,
      get: function () {
        return p.ConstructorParameters;
      },
    });
    var d = r(49305);
    Object.defineProperty(t, "Date", {
      enumerable: true,
      get: function () {
        return d.Date;
      },
    });
    var g = r(911);
    Object.defineProperty(t, "Deref", {
      enumerable: true,
      get: function () {
        return g.Deref;
      },
    });
    var m = r(98056);
    Object.defineProperty(t, "Enum", {
      enumerable: true,
      get: function () {
        return m.Enum;
      },
    });
    var h = r(41153);
    Object.defineProperty(t, "Exclude", {
      enumerable: true,
      get: function () {
        return h.Exclude;
      },
    });
    var E = r(94850);
    Object.defineProperty(t, "Extends", {
      enumerable: true,
      get: function () {
        return E.Extends;
      },
    });
    var I = r(69682);
    Object.defineProperty(t, "Extract", {
      enumerable: true,
      get: function () {
        return I.Extract;
      },
    });
    var y = r(29857);
    Object.defineProperty(t, "Function", {
      enumerable: true,
      get: function () {
        return y.Function;
      },
    });
    var C = r(86918);
    Object.defineProperty(t, "Index", {
      enumerable: true,
      get: function () {
        return C.Index;
      },
    });
    var b = r(26277);
    Object.defineProperty(t, "InstanceType", {
      enumerable: true,
      get: function () {
        return b.InstanceType;
      },
    });
    var Q = r(4949);
    Object.defineProperty(t, "Integer", {
      enumerable: true,
      get: function () {
        return Q.Integer;
      },
    });
    var B = r(62746);
    Object.defineProperty(t, "Intersect", {
      enumerable: true,
      get: function () {
        return B.Intersect;
      },
    });
    var T = r(30568);
    Object.defineProperty(t, "Capitalize", {
      enumerable: true,
      get: function () {
        return T.Capitalize;
      },
    });
    Object.defineProperty(t, "Uncapitalize", {
      enumerable: true,
      get: function () {
        return T.Uncapitalize;
      },
    });
    Object.defineProperty(t, "Lowercase", {
      enumerable: true,
      get: function () {
        return T.Lowercase;
      },
    });
    Object.defineProperty(t, "Uppercase", {
      enumerable: true,
      get: function () {
        return T.Uppercase;
      },
    });
    var v = r(35907);
    Object.defineProperty(t, "Iterator", {
      enumerable: true,
      get: function () {
        return v.Iterator;
      },
    });
    var w = r(73373);
    Object.defineProperty(t, "KeyOf", {
      enumerable: true,
      get: function () {
        return w.KeyOf;
      },
    });
    var _ = r(98076);
    Object.defineProperty(t, "Literal", {
      enumerable: true,
      get: function () {
        return _.Literal;
      },
    });
    var R = r(41094);
    Object.defineProperty(t, "Mapped", {
      enumerable: true,
      get: function () {
        return R.Mapped;
      },
    });
    var O = r(54025);
    Object.defineProperty(t, "Never", {
      enumerable: true,
      get: function () {
        return O.Never;
      },
    });
    var F = r(1078);
    Object.defineProperty(t, "Not", {
      enumerable: true,
      get: function () {
        return F.Not;
      },
    });
    var D = r(50468);
    Object.defineProperty(t, "Null", {
      enumerable: true,
      get: function () {
        return D.Null;
      },
    });
    var k = r(85544);
    Object.defineProperty(t, "Number", {
      enumerable: true,
      get: function () {
        return k.Number;
      },
    });
    var S = r(62094);
    Object.defineProperty(t, "Object", {
      enumerable: true,
      get: function () {
        return S.Object;
      },
    });
    var N = r(88932);
    Object.defineProperty(t, "Omit", {
      enumerable: true,
      get: function () {
        return N.Omit;
      },
    });
    var P = r(38425);
    Object.defineProperty(t, "Optional", {
      enumerable: true,
      get: function () {
        return P.Optional;
      },
    });
    var L = r(30449);
    Object.defineProperty(t, "Parameters", {
      enumerable: true,
      get: function () {
        return L.Parameters;
      },
    });
    var U = r(53345);
    Object.defineProperty(t, "Partial", {
      enumerable: true,
      get: function () {
        return U.Partial;
      },
    });
    var M = r(40640);
    Object.defineProperty(t, "Pick", {
      enumerable: true,
      get: function () {
        return M.Pick;
      },
    });
    var G = r(70062);
    Object.defineProperty(t, "Promise", {
      enumerable: true,
      get: function () {
        return G.Promise;
      },
    });
    var x = r(40675);
    Object.defineProperty(t, "Readonly", {
      enumerable: true,
      get: function () {
        return x.Readonly;
      },
    });
    var j = r(78946);
    Object.defineProperty(t, "ReadonlyOptional", {
      enumerable: true,
      get: function () {
        return j.ReadonlyOptional;
      },
    });
    var V = r(30420);
    Object.defineProperty(t, "Record", {
      enumerable: true,
      get: function () {
        return V.Record;
      },
    });
    var H = r(33107);
    Object.defineProperty(t, "Recursive", {
      enumerable: true,
      get: function () {
        return H.Recursive;
      },
    });
    var Y = r(80470);
    Object.defineProperty(t, "Ref", {
      enumerable: true,
      get: function () {
        return Y.Ref;
      },
    });
    var K = r(26936);
    Object.defineProperty(t, "RegExp", {
      enumerable: true,
      get: function () {
        return K.RegExp;
      },
    });
    var q = r(42744);
    Object.defineProperty(t, "Required", {
      enumerable: true,
      get: function () {
        return q.Required;
      },
    });
    var J = r(83003);
    Object.defineProperty(t, "Rest", {
      enumerable: true,
      get: function () {
        return J.Rest;
      },
    });
    var W = r(32970);
    Object.defineProperty(t, "ReturnType", {
      enumerable: true,
      get: function () {
        return W.ReturnType;
      },
    });
    var $ = r(23556);
    Object.defineProperty(t, "Strict", {
      enumerable: true,
      get: function () {
        return $.Strict;
      },
    });
    var z = r(81688);
    Object.defineProperty(t, "String", {
      enumerable: true,
      get: function () {
        return z.String;
      },
    });
    var Z = r(2129);
    Object.defineProperty(t, "Symbol", {
      enumerable: true,
      get: function () {
        return Z.Symbol;
      },
    });
    var X = r(26609);
    Object.defineProperty(t, "TemplateLiteral", {
      enumerable: true,
      get: function () {
        return X.TemplateLiteral;
      },
    });
    var ee = r(67575);
    Object.defineProperty(t, "Transform", {
      enumerable: true,
      get: function () {
        return ee.Transform;
      },
    });
    var te = r(7521);
    Object.defineProperty(t, "Tuple", {
      enumerable: true,
      get: function () {
        return te.Tuple;
      },
    });
    var re = r(45760);
    Object.defineProperty(t, "Uint8Array", {
      enumerable: true,
      get: function () {
        return re.Uint8Array;
      },
    });
    var ne = r(96231);
    Object.defineProperty(t, "Undefined", {
      enumerable: true,
      get: function () {
        return ne.Undefined;
      },
    });
    var oe = r(69100);
    Object.defineProperty(t, "Union", {
      enumerable: true,
      get: function () {
        return oe.Union;
      },
    });
    var se = r(51897);
    Object.defineProperty(t, "Unknown", {
      enumerable: true,
      get: function () {
        return se.Unknown;
      },
    });
    var ie = r(23339);
    Object.defineProperty(t, "Unsafe", {
      enumerable: true,
      get: function () {
        return ie.Unsafe;
      },
    });
    var ae = r(81947);
    Object.defineProperty(t, "Void", {
      enumerable: true,
      get: function () {
        return ae.Void;
      },
    });
  },
  45760: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(2039), t);
  },
  2039: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Uint8Array = void 0;
    const n = r(97034);
    function Uint8Array(e = {}) {
      return { ...e, [n.Kind]: "Uint8Array", type: "Uint8Array" };
    }
    t.Uint8Array = Uint8Array;
  },
  96231: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(20479), t);
  },
  20479: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Undefined = void 0;
    const n = r(97034);
    function Undefined(e = {}) {
      return { ...e, [n.Kind]: "Undefined", type: "undefined" };
    }
    t.Undefined = Undefined;
  },
  69100: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(24083), t);
    o(r(75396), t);
    o(r(28519), t);
  },
  98252: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UnionCreate = void 0;
    const n = r(38100);
    const o = r(97034);
    function UnionCreate(e, t) {
      return { ...t, [o.Kind]: "Union", anyOf: (0, n.CloneRest)(e) };
    }
    t.UnionCreate = UnionCreate;
  },
  24083: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.UnionEvaluated = void 0;
    const n = r(97034);
    const o = r(38100);
    const s = r(83889);
    const i = r(54025);
    const a = r(38425);
    const A = r(98252);
    const c = r(96994);
    function IsUnionOptional(e) {
      return e.some((e) => (0, c.IsOptional)(e));
    }
    function RemoveOptionalFromRest(e) {
      return e.map((e) => ((0, c.IsOptional)(e) ? RemoveOptionalFromType(e) : e));
    }
    function RemoveOptionalFromType(e) {
      return (0, s.Discard)(e, [n.OptionalKind]);
    }
    function ResolveUnion(e, t) {
      return IsUnionOptional(e) ? (0, a.Optional)((0, A.UnionCreate)(RemoveOptionalFromRest(e), t)) : (0, A.UnionCreate)(RemoveOptionalFromRest(e), t);
    }
    function UnionEvaluated(e, t = {}) {
      return e.length === 0 ? (0, i.Never)(t) : e.length === 1 ? (0, o.CloneType)(e[0], t) : ResolveUnion(e, t);
    }
    t.UnionEvaluated = UnionEvaluated;
  },
  75396: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    const n = r(97034);
  },
  28519: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Union = void 0;
    const n = r(54025);
    const o = r(38100);
    const s = r(98252);
    function Union(e, t = {}) {
      return e.length === 0 ? (0, n.Never)(t) : e.length === 1 ? (0, o.CloneType)(e[0], t) : (0, s.UnionCreate)(e, t);
    }
    t.Union = Union;
  },
  51897: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(66303), t);
  },
  66303: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Unknown = void 0;
    const n = r(97034);
    function Unknown(e = {}) {
      return { ...e, [n.Kind]: "Unknown" };
    }
    t.Unknown = Unknown;
  },
  23339: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(1361), t);
  },
  1361: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Unsafe = void 0;
    const n = r(97034);
    function Unsafe(e = {}) {
      return { ...e, [n.Kind]: e[n.Kind] ?? "Unsafe" };
    }
    t.Unsafe = Unsafe;
  },
  81947: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(14093), t);
  },
  14093: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Void = void 0;
    const n = r(97034);
    function Void(e = {}) {
      return { ...e, [n.Kind]: "Void", type: "void" };
    }
    t.Void = Void;
  },
  85874: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Cast = t.ValueCastError = void 0;
    const n = r(17479);
    const o = r(26113);
    const s = r(97034);
    const i = r(18050);
    const a = r(33742);
    const A = r(21683);
    const c = r(40886);
    class ValueCastError extends o.TypeBoxError {
      constructor(e, t) {
        super(t);
        this.schema = e;
      }
    }
    t.ValueCastError = ValueCastError;
    function ScoreUnion(e, t, r) {
      if (e[s.Kind] === "Object" && typeof r === "object" && !(0, n.IsNull)(r)) {
        const n = e;
        const o = Object.getOwnPropertyNames(r);
        const i = Object.entries(n.properties);
        const [A, c] = [1 / i.length, i.length];
        return i.reduce((e, [n, i]) => {
          const u = i[s.Kind] === "Literal" && i.const === r[n] ? c : 0;
          const l = (0, a.Check)(i, t, r[n]) ? A : 0;
          const p = o.includes(n) ? A : 0;
          return e + (u + l + p);
        }, 0);
      } else {
        return (0, a.Check)(e, t, r) ? 1 : 0;
      }
    }
    function SelectUnion(e, t, r) {
      const n = e.anyOf.map((e) => (0, c.Deref)(e, t));
      let [o, s] = [n[0], 0];
      for (const e of n) {
        const n = ScoreUnion(e, t, r);
        if (n > s) {
          o = e;
          s = n;
        }
      }
      return o;
    }
    function CastUnion(e, t, r) {
      if ("default" in e) {
        return typeof r === "function" ? e.default : (0, A.Clone)(e.default);
      } else {
        const n = SelectUnion(e, t, r);
        return Cast(n, t, r);
      }
    }
    function DefaultClone(e, t, r) {
      return (0, a.Check)(e, t, r) ? (0, A.Clone)(r) : (0, i.Create)(e, t);
    }
    function Default(e, t, r) {
      return (0, a.Check)(e, t, r) ? r : (0, i.Create)(e, t);
    }
    function FromArray(e, t, r) {
      if ((0, a.Check)(e, t, r)) return (0, A.Clone)(r);
      const o = (0, n.IsArray)(r) ? (0, A.Clone)(r) : (0, i.Create)(e, t);
      const s = (0, n.IsNumber)(e.minItems) && o.length < e.minItems ? [...o, ...Array.from({ length: e.minItems - o.length }, () => null)] : o;
      const c = (0, n.IsNumber)(e.maxItems) && s.length > e.maxItems ? s.slice(0, e.maxItems) : s;
      const u = c.map((r) => Visit(e.items, t, r));
      if (e.uniqueItems !== true) return u;
      const l = [...new Set(u)];
      if (!(0, a.Check)(e, t, l)) throw new ValueCastError(e, "Array cast produced invalid data due to uniqueItems constraint");
      return l;
    }
    function FromConstructor(e, t, r) {
      if ((0, a.Check)(e, t, r)) return (0, i.Create)(e, t);
      const n = new Set(e.returns.required || []);
      const result = function () {};
      for (const [o, s] of Object.entries(e.returns.properties)) {
        if (!n.has(o) && r.prototype[o] === undefined) continue;
        result.prototype[o] = Visit(s, t, r.prototype[o]);
      }
      return result;
    }
    function FromIntersect(e, t, r) {
      const o = (0, i.Create)(e, t);
      const s = (0, n.IsStandardObject)(o) && (0, n.IsStandardObject)(r) ? { ...o, ...r } : r;
      return (0, a.Check)(e, t, s) ? s : (0, i.Create)(e, t);
    }
    function FromNever(e, t, r) {
      throw new ValueCastError(e, "Never types cannot be cast");
    }
    function FromObject(e, t, r) {
      if ((0, a.Check)(e, t, r)) return r;
      if (r === null || typeof r !== "object") return (0, i.Create)(e, t);
      const n = new Set(e.required || []);
      const o = {};
      for (const [s, i] of Object.entries(e.properties)) {
        if (!n.has(s) && r[s] === undefined) continue;
        o[s] = Visit(i, t, r[s]);
      }
      if (typeof e.additionalProperties === "object") {
        const n = Object.getOwnPropertyNames(e.properties);
        for (const s of Object.getOwnPropertyNames(r)) {
          if (n.includes(s)) continue;
          o[s] = Visit(e.additionalProperties, t, r[s]);
        }
      }
      return o;
    }
    function FromRecord(e, t, r) {
      if ((0, a.Check)(e, t, r)) return (0, A.Clone)(r);
      if (r === null || typeof r !== "object" || Array.isArray(r) || r instanceof Date) return (0, i.Create)(e, t);
      const n = Object.getOwnPropertyNames(e.patternProperties)[0];
      const o = e.patternProperties[n];
      const s = {};
      for (const [e, n] of Object.entries(r)) {
        s[e] = Visit(o, t, n);
      }
      return s;
    }
    function FromRef(e, t, r) {
      return Visit((0, c.Deref)(e, t), t, r);
    }
    function FromThis(e, t, r) {
      return Visit((0, c.Deref)(e, t), t, r);
    }
    function FromTuple(e, t, r) {
      if ((0, a.Check)(e, t, r)) return (0, A.Clone)(r);
      if (!(0, n.IsArray)(r)) return (0, i.Create)(e, t);
      if (e.items === undefined) return [];
      return e.items.map((e, n) => Visit(e, t, r[n]));
    }
    function FromUnion(e, t, r) {
      return (0, a.Check)(e, t, r) ? (0, A.Clone)(r) : CastUnion(e, t, r);
    }
    function Visit(e, t, r) {
      const o = (0, n.IsString)(e.$id) ? [...t, e] : t;
      const i = e;
      switch (e[s.Kind]) {
        case "Array":
          return FromArray(i, o, r);
        case "Constructor":
          return FromConstructor(i, o, r);
        case "Intersect":
          return FromIntersect(i, o, r);
        case "Never":
          return FromNever(i, o, r);
        case "Object":
          return FromObject(i, o, r);
        case "Record":
          return FromRecord(i, o, r);
        case "Ref":
          return FromRef(i, o, r);
        case "This":
          return FromThis(i, o, r);
        case "Tuple":
          return FromTuple(i, o, r);
        case "Union":
          return FromUnion(i, o, r);
        case "Date":
        case "Symbol":
        case "Uint8Array":
          return DefaultClone(e, t, r);
        default:
          return Default(i, o, r);
      }
    }
    function Cast(...e) {
      return e.length === 3 ? Visit(e[0], e[1], e[2]) : Visit(e[0], [], e[1]);
    }
    t.Cast = Cast;
  },
  46097: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(85874), t);
  },
  85410: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Check = t.ValueCheckUnknownTypeError = void 0;
    const n = r(82129);
    const o = r(40886);
    const s = r(7210);
    const i = r(97034);
    const a = r(73373);
    const A = r(94850);
    const c = r(51786);
    const u = r(26113);
    const l = r(54025);
    const p = r(17479);
    const d = r(70384);
    class ValueCheckUnknownTypeError extends u.TypeBoxError {
      constructor(e) {
        super(`Unknown type`);
        this.schema = e;
      }
    }
    t.ValueCheckUnknownTypeError = ValueCheckUnknownTypeError;
    function IsAnyOrUnknown(e) {
      return e[i.Kind] === "Any" || e[i.Kind] === "Unknown";
    }
    function IsDefined(e) {
      return e !== undefined;
    }
    function FromAny(e, t, r) {
      return true;
    }
    function FromArray(e, t, r) {
      if (!(0, p.IsArray)(r)) return false;
      if (IsDefined(e.minItems) && !(r.length >= e.minItems)) {
        return false;
      }
      if (IsDefined(e.maxItems) && !(r.length <= e.maxItems)) {
        return false;
      }
      if (!r.every((r) => Visit(e.items, t, r))) {
        return false;
      }
      if (
        e.uniqueItems === true &&
        !(function () {
          const e = new Set();
          for (const t of r) {
            const r = (0, s.Hash)(t);
            if (e.has(r)) {
              return false;
            } else {
              e.add(r);
            }
          }
          return true;
        })()
      ) {
        return false;
      }
      if (!(IsDefined(e.contains) || (0, p.IsNumber)(e.minContains) || (0, p.IsNumber)(e.maxContains))) {
        return true;
      }
      const n = IsDefined(e.contains) ? e.contains : (0, l.Never)();
      const o = r.reduce((e, r) => (Visit(n, t, r) ? e + 1 : e), 0);
      if (o === 0) {
        return false;
      }
      if ((0, p.IsNumber)(e.minContains) && o < e.minContains) {
        return false;
      }
      if ((0, p.IsNumber)(e.maxContains) && o > e.maxContains) {
        return false;
      }
      return true;
    }
    function FromAsyncIterator(e, t, r) {
      return (0, p.IsAsyncIterator)(r);
    }
    function FromBigInt(e, t, r) {
      if (!(0, p.IsBigInt)(r)) return false;
      if (IsDefined(e.exclusiveMaximum) && !(r < e.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined(e.exclusiveMinimum) && !(r > e.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined(e.maximum) && !(r <= e.maximum)) {
        return false;
      }
      if (IsDefined(e.minimum) && !(r >= e.minimum)) {
        return false;
      }
      if (IsDefined(e.multipleOf) && !(r % e.multipleOf === BigInt(0))) {
        return false;
      }
      return true;
    }
    function FromBoolean(e, t, r) {
      return (0, p.IsBoolean)(r);
    }
    function FromConstructor(e, t, r) {
      return Visit(e.returns, t, r.prototype);
    }
    function FromDate(e, t, r) {
      if (!(0, p.IsDate)(r)) return false;
      if (IsDefined(e.exclusiveMaximumTimestamp) && !(r.getTime() < e.exclusiveMaximumTimestamp)) {
        return false;
      }
      if (IsDefined(e.exclusiveMinimumTimestamp) && !(r.getTime() > e.exclusiveMinimumTimestamp)) {
        return false;
      }
      if (IsDefined(e.maximumTimestamp) && !(r.getTime() <= e.maximumTimestamp)) {
        return false;
      }
      if (IsDefined(e.minimumTimestamp) && !(r.getTime() >= e.minimumTimestamp)) {
        return false;
      }
      if (IsDefined(e.multipleOfTimestamp) && !(r.getTime() % e.multipleOfTimestamp === 0)) {
        return false;
      }
      return true;
    }
    function FromFunction(e, t, r) {
      return (0, p.IsFunction)(r);
    }
    function FromInteger(e, t, r) {
      if (!(0, p.IsInteger)(r)) {
        return false;
      }
      if (IsDefined(e.exclusiveMaximum) && !(r < e.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined(e.exclusiveMinimum) && !(r > e.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined(e.maximum) && !(r <= e.maximum)) {
        return false;
      }
      if (IsDefined(e.minimum) && !(r >= e.minimum)) {
        return false;
      }
      if (IsDefined(e.multipleOf) && !(r % e.multipleOf === 0)) {
        return false;
      }
      return true;
    }
    function FromIntersect(e, t, r) {
      const n = e.allOf.every((e) => Visit(e, t, r));
      if (e.unevaluatedProperties === false) {
        const t = new RegExp((0, a.KeyOfPattern)(e));
        const o = Object.getOwnPropertyNames(r).every((e) => t.test(e));
        return n && o;
      } else if ((0, d.IsSchema)(e.unevaluatedProperties)) {
        const o = new RegExp((0, a.KeyOfPattern)(e));
        const s = Object.getOwnPropertyNames(r).every((n) => o.test(n) || Visit(e.unevaluatedProperties, t, r[n]));
        return n && s;
      } else {
        return n;
      }
    }
    function FromIterator(e, t, r) {
      return (0, p.IsIterator)(r);
    }
    function FromLiteral(e, t, r) {
      return r === e.const;
    }
    function FromNever(e, t, r) {
      return false;
    }
    function FromNot(e, t, r) {
      return !Visit(e.not, t, r);
    }
    function FromNull(e, t, r) {
      return (0, p.IsNull)(r);
    }
    function FromNumber(e, t, r) {
      if (!n.TypeSystemPolicy.IsNumberLike(r)) return false;
      if (IsDefined(e.exclusiveMaximum) && !(r < e.exclusiveMaximum)) {
        return false;
      }
      if (IsDefined(e.exclusiveMinimum) && !(r > e.exclusiveMinimum)) {
        return false;
      }
      if (IsDefined(e.minimum) && !(r >= e.minimum)) {
        return false;
      }
      if (IsDefined(e.maximum) && !(r <= e.maximum)) {
        return false;
      }
      if (IsDefined(e.multipleOf) && !(r % e.multipleOf === 0)) {
        return false;
      }
      return true;
    }
    function FromObject(e, t, r) {
      if (!n.TypeSystemPolicy.IsObjectLike(r)) return false;
      if (IsDefined(e.minProperties) && !(Object.getOwnPropertyNames(r).length >= e.minProperties)) {
        return false;
      }
      if (IsDefined(e.maxProperties) && !(Object.getOwnPropertyNames(r).length <= e.maxProperties)) {
        return false;
      }
      const o = Object.getOwnPropertyNames(e.properties);
      for (const s of o) {
        const o = e.properties[s];
        if (e.required && e.required.includes(s)) {
          if (!Visit(o, t, r[s])) {
            return false;
          }
          if (((0, A.ExtendsUndefinedCheck)(o) || IsAnyOrUnknown(o)) && !(s in r)) {
            return false;
          }
        } else {
          if (n.TypeSystemPolicy.IsExactOptionalProperty(r, s) && !Visit(o, t, r[s])) {
            return false;
          }
        }
      }
      if (e.additionalProperties === false) {
        const t = Object.getOwnPropertyNames(r);
        if (e.required && e.required.length === o.length && t.length === o.length) {
          return true;
        } else {
          return t.every((e) => o.includes(e));
        }
      } else if (typeof e.additionalProperties === "object") {
        const n = Object.getOwnPropertyNames(r);
        return n.every((n) => o.includes(n) || Visit(e.additionalProperties, t, r[n]));
      } else {
        return true;
      }
    }
    function FromPromise(e, t, r) {
      return (0, p.IsPromise)(r);
    }
    function FromRecord(e, t, r) {
      if (!n.TypeSystemPolicy.IsRecordLike(r)) {
        return false;
      }
      if (IsDefined(e.minProperties) && !(Object.getOwnPropertyNames(r).length >= e.minProperties)) {
        return false;
      }
      if (IsDefined(e.maxProperties) && !(Object.getOwnPropertyNames(r).length <= e.maxProperties)) {
        return false;
      }
      const [o, s] = Object.entries(e.patternProperties)[0];
      const i = new RegExp(o);
      const a = Object.entries(r).every(([e, r]) => (i.test(e) ? Visit(s, t, r) : true));
      const A =
        typeof e.additionalProperties === "object" ? Object.entries(r).every(([r, n]) => (!i.test(r) ? Visit(e.additionalProperties, t, n) : true)) : true;
      const c = e.additionalProperties === false ? Object.getOwnPropertyNames(r).every((e) => i.test(e)) : true;
      return a && A && c;
    }
    function FromRef(e, t, r) {
      return Visit((0, o.Deref)(e, t), t, r);
    }
    function FromRegExp(e, t, r) {
      const n = new RegExp(e.source, e.flags);
      if (IsDefined(e.minLength)) {
        if (!(r.length >= e.minLength)) return false;
      }
      if (IsDefined(e.maxLength)) {
        if (!(r.length <= e.maxLength)) return false;
      }
      return n.test(r);
    }
    function FromString(e, t, r) {
      if (!(0, p.IsString)(r)) {
        return false;
      }
      if (IsDefined(e.minLength)) {
        if (!(r.length >= e.minLength)) return false;
      }
      if (IsDefined(e.maxLength)) {
        if (!(r.length <= e.maxLength)) return false;
      }
      if (IsDefined(e.pattern)) {
        const t = new RegExp(e.pattern);
        if (!t.test(r)) return false;
      }
      if (IsDefined(e.format)) {
        if (!c.FormatRegistry.Has(e.format)) return false;
        const t = c.FormatRegistry.Get(e.format);
        return t(r);
      }
      return true;
    }
    function FromSymbol(e, t, r) {
      return (0, p.IsSymbol)(r);
    }
    function FromTemplateLiteral(e, t, r) {
      return (0, p.IsString)(r) && new RegExp(e.pattern).test(r);
    }
    function FromThis(e, t, r) {
      return Visit((0, o.Deref)(e, t), t, r);
    }
    function FromTuple(e, t, r) {
      if (!(0, p.IsArray)(r)) {
        return false;
      }
      if (e.items === undefined && !(r.length === 0)) {
        return false;
      }
      if (!(r.length === e.maxItems)) {
        return false;
      }
      if (!e.items) {
        return true;
      }
      for (let n = 0; n < e.items.length; n++) {
        if (!Visit(e.items[n], t, r[n])) return false;
      }
      return true;
    }
    function FromUndefined(e, t, r) {
      return (0, p.IsUndefined)(r);
    }
    function FromUnion(e, t, r) {
      return e.anyOf.some((e) => Visit(e, t, r));
    }
    function FromUint8Array(e, t, r) {
      if (!(0, p.IsUint8Array)(r)) {
        return false;
      }
      if (IsDefined(e.maxByteLength) && !(r.length <= e.maxByteLength)) {
        return false;
      }
      if (IsDefined(e.minByteLength) && !(r.length >= e.minByteLength)) {
        return false;
      }
      return true;
    }
    function FromUnknown(e, t, r) {
      return true;
    }
    function FromVoid(e, t, r) {
      return n.TypeSystemPolicy.IsVoidLike(r);
    }
    function FromKind(e, t, r) {
      if (!c.TypeRegistry.Has(e[i.Kind])) return false;
      const n = c.TypeRegistry.Get(e[i.Kind]);
      return n(e, r);
    }
    function Visit(e, t, r) {
      const n = IsDefined(e.$id) ? [...t, e] : t;
      const o = e;
      switch (o[i.Kind]) {
        case "Any":
          return FromAny(o, n, r);
        case "Array":
          return FromArray(o, n, r);
        case "AsyncIterator":
          return FromAsyncIterator(o, n, r);
        case "BigInt":
          return FromBigInt(o, n, r);
        case "Boolean":
          return FromBoolean(o, n, r);
        case "Constructor":
          return FromConstructor(o, n, r);
        case "Date":
          return FromDate(o, n, r);
        case "Function":
          return FromFunction(o, n, r);
        case "Integer":
          return FromInteger(o, n, r);
        case "Intersect":
          return FromIntersect(o, n, r);
        case "Iterator":
          return FromIterator(o, n, r);
        case "Literal":
          return FromLiteral(o, n, r);
        case "Never":
          return FromNever(o, n, r);
        case "Not":
          return FromNot(o, n, r);
        case "Null":
          return FromNull(o, n, r);
        case "Number":
          return FromNumber(o, n, r);
        case "Object":
          return FromObject(o, n, r);
        case "Promise":
          return FromPromise(o, n, r);
        case "Record":
          return FromRecord(o, n, r);
        case "Ref":
          return FromRef(o, n, r);
        case "RegExp":
          return FromRegExp(o, n, r);
        case "String":
          return FromString(o, n, r);
        case "Symbol":
          return FromSymbol(o, n, r);
        case "TemplateLiteral":
          return FromTemplateLiteral(o, n, r);
        case "This":
          return FromThis(o, n, r);
        case "Tuple":
          return FromTuple(o, n, r);
        case "Undefined":
          return FromUndefined(o, n, r);
        case "Union":
          return FromUnion(o, n, r);
        case "Uint8Array":
          return FromUint8Array(o, n, r);
        case "Unknown":
          return FromUnknown(o, n, r);
        case "Void":
          return FromVoid(o, n, r);
        default:
          if (!c.TypeRegistry.Has(o[i.Kind])) throw new ValueCheckUnknownTypeError(o);
          return FromKind(o, n, r);
      }
    }
    function Check(...e) {
      return e.length === 3 ? Visit(e[0], e[1], e[2]) : Visit(e[0], [], e[1]);
    }
    t.Check = Check;
  },
  33742: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(85410), t);
  },
  40338: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Clean = void 0;
    const n = r(73373);
    const o = r(33742);
    const s = r(21683);
    const i = r(40886);
    const a = r(97034);
    const A = r(17479);
    const c = r(70384);
    function IsCheckable(e) {
      return (0, c.IsSchema)(e) && e[a.Kind] !== "Unsafe";
    }
    function FromArray(e, t, r) {
      if (!(0, A.IsArray)(r)) return r;
      return r.map((r) => Visit(e.items, t, r));
    }
    function FromIntersect(e, t, r) {
      const i = e.unevaluatedProperties;
      const a = e.allOf.map((e) => Visit(e, t, (0, s.Clone)(r)));
      const u = a.reduce((e, t) => ((0, A.IsObject)(t) ? { ...e, ...t } : t), {});
      if (!(0, A.IsObject)(r) || !(0, A.IsObject)(u) || !(0, c.IsSchema)(i)) return u;
      const l = (0, n.KeyOfPropertyKeys)(e);
      for (const e of Object.getOwnPropertyNames(r)) {
        if (l.includes(e)) continue;
        if ((0, o.Check)(i, t, r[e])) {
          u[e] = Visit(i, t, r[e]);
        }
      }
      return u;
    }
    function FromObject(e, t, r) {
      if (!(0, A.IsObject)(r) || (0, A.IsArray)(r)) return r;
      const n = e.additionalProperties;
      for (const s of Object.getOwnPropertyNames(r)) {
        if (s in e.properties) {
          r[s] = Visit(e.properties[s], t, r[s]);
          continue;
        }
        if ((0, c.IsSchema)(n) && (0, o.Check)(n, t, r[s])) {
          r[s] = Visit(n, t, r[s]);
          continue;
        }
        delete r[s];
      }
      return r;
    }
    function FromRecord(e, t, r) {
      if (!(0, A.IsObject)(r)) return r;
      const n = e.additionalProperties;
      const s = Object.getOwnPropertyNames(r);
      const [i, a] = Object.entries(e.patternProperties)[0];
      const u = new RegExp(i);
      for (const e of s) {
        if (u.test(e)) {
          r[e] = Visit(a, t, r[e]);
          continue;
        }
        if ((0, c.IsSchema)(n) && (0, o.Check)(n, t, r[e])) {
          r[e] = Visit(n, t, r[e]);
          continue;
        }
        delete r[e];
      }
      return r;
    }
    function FromRef(e, t, r) {
      return Visit((0, i.Deref)(e, t), t, r);
    }
    function FromThis(e, t, r) {
      return Visit((0, i.Deref)(e, t), t, r);
    }
    function FromTuple(e, t, r) {
      if (!(0, A.IsArray)(r)) return r;
      if ((0, A.IsUndefined)(e.items)) return [];
      const n = Math.min(r.length, e.items.length);
      for (let o = 0; o < n; o++) {
        r[o] = Visit(e.items[o], t, r[o]);
      }
      return r.length > n ? r.slice(0, n) : r;
    }
    function FromUnion(e, t, r) {
      for (const n of e.anyOf) {
        if (IsCheckable(n) && (0, o.Check)(n, t, r)) {
          return Visit(n, t, r);
        }
      }
      return r;
    }
    function Visit(e, t, r) {
      const n = (0, A.IsString)(e.$id) ? [...t, e] : t;
      const o = e;
      switch (o[a.Kind]) {
        case "Array":
          return FromArray(o, n, r);
        case "Intersect":
          return FromIntersect(o, n, r);
        case "Object":
          return FromObject(o, n, r);
        case "Record":
          return FromRecord(o, n, r);
        case "Ref":
          return FromRef(o, n, r);
        case "This":
          return FromThis(o, n, r);
        case "Tuple":
          return FromTuple(o, n, r);
        case "Union":
          return FromUnion(o, n, r);
        default:
          return r;
      }
    }
    function Clean(...e) {
      return e.length === 3 ? Visit(e[0], e[1], e[2]) : Visit(e[0], [], e[1]);
    }
    t.Clean = Clean;
  },
  6115: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(40338), t);
  },
  13366: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Clone = void 0;
    const n = r(17479);
    function ObjectType(e) {
      const t = {};
      for (const r of Object.getOwnPropertyNames(e)) {
        t[r] = Clone(e[r]);
      }
      for (const r of Object.getOwnPropertySymbols(e)) {
        t[r] = Clone(e[r]);
      }
      return t;
    }
    function ArrayType(e) {
      return e.map((e) => Clone(e));
    }
    function TypedArrayType(e) {
      return e.slice();
    }
    function DateType(e) {
      return new Date(e.toISOString());
    }
    function ValueType(e) {
      return e;
    }
    function Clone(e) {
      if ((0, n.IsArray)(e)) return ArrayType(e);
      if ((0, n.IsDate)(e)) return DateType(e);
      if ((0, n.IsStandardObject)(e)) return ObjectType(e);
      if ((0, n.IsTypedArray)(e)) return TypedArrayType(e);
      if ((0, n.IsValueType)(e)) return ValueType(e);
      throw new Error("ValueClone: Unable to clone value");
    }
    t.Clone = Clone;
  },
  21683: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(13366), t);
  },
  68594: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Convert = void 0;
    const n = r(21683);
    const o = r(33742);
    const s = r(40886);
    const i = r(97034);
    const a = r(17479);
    function IsStringNumeric(e) {
      return (0, a.IsString)(e) && !isNaN(e) && !isNaN(parseFloat(e));
    }
    function IsValueToString(e) {
      return (0, a.IsBigInt)(e) || (0, a.IsBoolean)(e) || (0, a.IsNumber)(e);
    }
    function IsValueTrue(e) {
      return (
        e === true ||
        ((0, a.IsNumber)(e) && e === 1) ||
        ((0, a.IsBigInt)(e) && e === BigInt("1")) ||
        ((0, a.IsString)(e) && (e.toLowerCase() === "true" || e === "1"))
      );
    }
    function IsValueFalse(e) {
      return (
        e === false ||
        ((0, a.IsNumber)(e) && (e === 0 || Object.is(e, -0))) ||
        ((0, a.IsBigInt)(e) && e === BigInt("0")) ||
        ((0, a.IsString)(e) && (e.toLowerCase() === "false" || e === "0" || e === "-0"))
      );
    }
    function IsTimeStringWithTimeZone(e) {
      return (0, a.IsString)(e) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(e);
    }
    function IsTimeStringWithoutTimeZone(e) {
      return (0, a.IsString)(e) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(e);
    }
    function IsDateTimeStringWithTimeZone(e) {
      return (0, a.IsString)(e) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(e);
    }
    function IsDateTimeStringWithoutTimeZone(e) {
      return (0, a.IsString)(e) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(e);
    }
    function IsDateString(e) {
      return (0, a.IsString)(e) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(e);
    }
    function TryConvertLiteralString(e, t) {
      const r = TryConvertString(e);
      return r === t ? r : e;
    }
    function TryConvertLiteralNumber(e, t) {
      const r = TryConvertNumber(e);
      return r === t ? r : e;
    }
    function TryConvertLiteralBoolean(e, t) {
      const r = TryConvertBoolean(e);
      return r === t ? r : e;
    }
    function TryConvertLiteral(e, t) {
      return (0, a.IsString)(e.const)
        ? TryConvertLiteralString(t, e.const)
        : (0, a.IsNumber)(e.const)
          ? TryConvertLiteralNumber(t, e.const)
          : (0, a.IsBoolean)(e.const)
            ? TryConvertLiteralBoolean(t, e.const)
            : (0, n.Clone)(t);
    }
    function TryConvertBoolean(e) {
      return IsValueTrue(e) ? true : IsValueFalse(e) ? false : e;
    }
    function TryConvertBigInt(e) {
      return IsStringNumeric(e) ? BigInt(parseInt(e)) : (0, a.IsNumber)(e) ? BigInt(e | 0) : IsValueFalse(e) ? BigInt(0) : IsValueTrue(e) ? BigInt(1) : e;
    }
    function TryConvertString(e) {
      return IsValueToString(e) ? e.toString() : (0, a.IsSymbol)(e) && e.description !== undefined ? e.description.toString() : e;
    }
    function TryConvertNumber(e) {
      return IsStringNumeric(e) ? parseFloat(e) : IsValueTrue(e) ? 1 : IsValueFalse(e) ? 0 : e;
    }
    function TryConvertInteger(e) {
      return IsStringNumeric(e) ? parseInt(e) : (0, a.IsNumber)(e) ? e | 0 : IsValueTrue(e) ? 1 : IsValueFalse(e) ? 0 : e;
    }
    function TryConvertNull(e) {
      return (0, a.IsString)(e) && e.toLowerCase() === "null" ? null : e;
    }
    function TryConvertUndefined(e) {
      return (0, a.IsString)(e) && e === "undefined" ? undefined : e;
    }
    function TryConvertDate(e) {
      return (0, a.IsDate)(e)
        ? e
        : (0, a.IsNumber)(e)
          ? new Date(e)
          : IsValueTrue(e)
            ? new Date(1)
            : IsValueFalse(e)
              ? new Date(0)
              : IsStringNumeric(e)
                ? new Date(parseInt(e))
                : IsTimeStringWithoutTimeZone(e)
                  ? new Date(`1970-01-01T${e}.000Z`)
                  : IsTimeStringWithTimeZone(e)
                    ? new Date(`1970-01-01T${e}`)
                    : IsDateTimeStringWithoutTimeZone(e)
                      ? new Date(`${e}.000Z`)
                      : IsDateTimeStringWithTimeZone(e)
                        ? new Date(e)
                        : IsDateString(e)
                          ? new Date(`${e}T00:00:00.000Z`)
                          : e;
    }
    function Default(e) {
      return e;
    }
    function FromArray(e, t, r) {
      const n = (0, a.IsArray)(r) ? r : [r];
      return n.map((r) => Visit(e.items, t, r));
    }
    function FromBigInt(e, t, r) {
      return TryConvertBigInt(r);
    }
    function FromBoolean(e, t, r) {
      return TryConvertBoolean(r);
    }
    function FromDate(e, t, r) {
      return TryConvertDate(r);
    }
    function FromInteger(e, t, r) {
      return TryConvertInteger(r);
    }
    function FromIntersect(e, t, r) {
      return e.allOf.reduce((e, r) => Visit(r, t, e), r);
    }
    function FromLiteral(e, t, r) {
      return TryConvertLiteral(e, r);
    }
    function FromNull(e, t, r) {
      return TryConvertNull(r);
    }
    function FromNumber(e, t, r) {
      return TryConvertNumber(r);
    }
    function FromObject(e, t, r) {
      const n = (0, a.IsObject)(r);
      if (!n) return r;
      const o = {};
      for (const n of Object.keys(r)) {
        o[n] = (0, a.HasPropertyKey)(e.properties, n) ? Visit(e.properties[n], t, r[n]) : r[n];
      }
      return o;
    }
    function FromRecord(e, t, r) {
      const n = Object.getOwnPropertyNames(e.patternProperties)[0];
      const o = e.patternProperties[n];
      const s = {};
      for (const [e, n] of Object.entries(r)) {
        s[e] = Visit(o, t, n);
      }
      return s;
    }
    function FromRef(e, t, r) {
      return Visit((0, s.Deref)(e, t), t, r);
    }
    function FromString(e, t, r) {
      return TryConvertString(r);
    }
    function FromSymbol(e, t, r) {
      return (0, a.IsString)(r) || (0, a.IsNumber)(r) ? Symbol(r) : r;
    }
    function FromThis(e, t, r) {
      return Visit((0, s.Deref)(e, t), t, r);
    }
    function FromTuple(e, t, r) {
      const n = (0, a.IsArray)(r) && !(0, a.IsUndefined)(e.items);
      if (!n) return r;
      return r.map((r, n) => (n < e.items.length ? Visit(e.items[n], t, r) : r));
    }
    function FromUndefined(e, t, r) {
      return TryConvertUndefined(r);
    }
    function FromUnion(e, t, r) {
      for (const n of e.anyOf) {
        const e = Visit(n, t, r);
        if (!(0, o.Check)(n, t, e)) continue;
        return e;
      }
      return r;
    }
    function Visit(e, t, r) {
      const n = (0, a.IsString)(e.$id) ? [...t, e] : t;
      const o = e;
      switch (e[i.Kind]) {
        case "Array":
          return FromArray(o, n, r);
        case "BigInt":
          return FromBigInt(o, n, r);
        case "Boolean":
          return FromBoolean(o, n, r);
        case "Date":
          return FromDate(o, n, r);
        case "Integer":
          return FromInteger(o, n, r);
        case "Intersect":
          return FromIntersect(o, n, r);
        case "Literal":
          return FromLiteral(o, n, r);
        case "Null":
          return FromNull(o, n, r);
        case "Number":
          return FromNumber(o, n, r);
        case "Object":
          return FromObject(o, n, r);
        case "Record":
          return FromRecord(o, n, r);
        case "Ref":
          return FromRef(o, n, r);
        case "String":
          return FromString(o, n, r);
        case "Symbol":
          return FromSymbol(o, n, r);
        case "This":
          return FromThis(o, n, r);
        case "Tuple":
          return FromTuple(o, n, r);
        case "Undefined":
          return FromUndefined(o, n, r);
        case "Union":
          return FromUnion(o, n, r);
        default:
          return Default(r);
      }
    }
    function Convert(...e) {
      return e.length === 3 ? Visit(e[0], e[1], e[2]) : Visit(e[0], [], e[1]);
    }
    t.Convert = Convert;
  },
  41241: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(68594), t);
  },
  51744: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Create = t.ValueCreateError = void 0;
    const n = r(17479);
    const o = r(33742);
    const s = r(21683);
    const i = r(40886);
    const a = r(26609);
    const A = r(94354);
    const c = r(51786);
    const u = r(97034);
    const l = r(26113);
    class ValueCreateError extends l.TypeBoxError {
      constructor(e, t) {
        super(t);
        this.schema = e;
      }
    }
    t.ValueCreateError = ValueCreateError;
    function FromDefault(e) {
      return typeof e === "function" ? e : (0, s.Clone)(e);
    }
    function FromAny(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return {};
      }
    }
    function FromArray(e, t) {
      if (e.uniqueItems === true && !(0, n.HasPropertyKey)(e, "default")) {
        throw new ValueCreateError(e, "Array with the uniqueItems constraint requires a default value");
      } else if ("contains" in e && !(0, n.HasPropertyKey)(e, "default")) {
        throw new ValueCreateError(e, "Array with the contains constraint requires a default value");
      } else if ("default" in e) {
        return FromDefault(e.default);
      } else if (e.minItems !== undefined) {
        return Array.from({ length: e.minItems }).map((r) => Visit(e.items, t));
      } else {
        return [];
      }
    }
    function FromAsyncIterator(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return (async function* () {})();
      }
    }
    function FromBigInt(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return BigInt(0);
      }
    }
    function FromBoolean(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return false;
      }
    }
    function FromConstructor(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        const r = Visit(e.returns, t);
        if (typeof r === "object" && !Array.isArray(r)) {
          return class {
            constructor() {
              for (const [e, t] of Object.entries(r)) {
                const r = this;
                r[e] = t;
              }
            }
          };
        } else {
          return class {};
        }
      }
    }
    function FromDate(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else if (e.minimumTimestamp !== undefined) {
        return new Date(e.minimumTimestamp);
      } else {
        return new Date();
      }
    }
    function FromFunction(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return () => Visit(e.returns, t);
      }
    }
    function FromInteger(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else if (e.minimum !== undefined) {
        return e.minimum;
      } else {
        return 0;
      }
    }
    function FromIntersect(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        const r = e.allOf.reduce((e, r) => {
          const n = Visit(r, t);
          return typeof n === "object" ? { ...e, ...n } : n;
        }, {});
        if (!(0, o.Check)(e, t, r)) throw new ValueCreateError(e, "Intersect produced invalid value. Consider using a default value.");
        return r;
      }
    }
    function FromIterator(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return (function* () {})();
      }
    }
    function FromLiteral(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return e.const;
      }
    }
    function FromNever(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        throw new ValueCreateError(e, "Never types cannot be created. Consider using a default value.");
      }
    }
    function FromNot(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        throw new ValueCreateError(e, "Not types must have a default value");
      }
    }
    function FromNull(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return null;
      }
    }
    function FromNumber(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else if (e.minimum !== undefined) {
        return e.minimum;
      } else {
        return 0;
      }
    }
    function FromObject(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        const r = new Set(e.required);
        const n = {};
        for (const [o, s] of Object.entries(e.properties)) {
          if (!r.has(o)) continue;
          n[o] = Visit(s, t);
        }
        return n;
      }
    }
    function FromPromise(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return Promise.resolve(Visit(e.item, t));
      }
    }
    function FromRecord(e, t) {
      const [r, o] = Object.entries(e.patternProperties)[0];
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else if (!(r === A.PatternStringExact || r === A.PatternNumberExact)) {
        const e = r.slice(1, r.length - 1).split("|");
        const n = {};
        for (const r of e) n[r] = Visit(o, t);
        return n;
      } else {
        return {};
      }
    }
    function FromRef(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return Visit((0, i.Deref)(e, t), t);
      }
    }
    function FromRegExp(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        throw new ValueCreateError(e, "RegExp types cannot be created. Consider using a default value.");
      }
    }
    function FromString(e, t) {
      if (e.pattern !== undefined) {
        if (!(0, n.HasPropertyKey)(e, "default")) {
          throw new ValueCreateError(e, "String types with patterns must specify a default value");
        } else {
          return FromDefault(e.default);
        }
      } else if (e.format !== undefined) {
        if (!(0, n.HasPropertyKey)(e, "default")) {
          throw new ValueCreateError(e, "String types with formats must specify a default value");
        } else {
          return FromDefault(e.default);
        }
      } else {
        if ((0, n.HasPropertyKey)(e, "default")) {
          return FromDefault(e.default);
        } else if (e.minLength !== undefined) {
          return Array.from({ length: e.minLength })
            .map(() => " ")
            .join("");
        } else {
          return "";
        }
      }
    }
    function FromSymbol(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else if ("value" in e) {
        return Symbol.for(e.value);
      } else {
        return Symbol();
      }
    }
    function FromTemplateLiteral(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      }
      if (!(0, a.IsTemplateLiteralFinite)(e))
        throw new ValueCreateError(e, "Can only create template literals that produce a finite variants. Consider using a default value.");
      const r = (0, a.TemplateLiteralGenerate)(e);
      return r[0];
    }
    function FromThis(e, t) {
      if (d++ > p) throw new ValueCreateError(e, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return Visit((0, i.Deref)(e, t), t);
      }
    }
    function FromTuple(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      }
      if (e.items === undefined) {
        return [];
      } else {
        return Array.from({ length: e.minItems }).map((r, n) => Visit(e.items[n], t));
      }
    }
    function FromUndefined(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return undefined;
      }
    }
    function FromUnion(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else if (e.anyOf.length === 0) {
        throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
      } else {
        return Visit(e.anyOf[0], t);
      }
    }
    function FromUint8Array(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else if (e.minByteLength !== undefined) {
        return new Uint8Array(e.minByteLength);
      } else {
        return new Uint8Array(0);
      }
    }
    function FromUnknown(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return {};
      }
    }
    function FromVoid(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        return void 0;
      }
    }
    function FromKind(e, t) {
      if ((0, n.HasPropertyKey)(e, "default")) {
        return FromDefault(e.default);
      } else {
        throw new Error("User defined types must specify a default value");
      }
    }
    function Visit(e, t) {
      const r = (0, n.IsString)(e.$id) ? [...t, e] : t;
      const o = e;
      switch (o[u.Kind]) {
        case "Any":
          return FromAny(o, r);
        case "Array":
          return FromArray(o, r);
        case "AsyncIterator":
          return FromAsyncIterator(o, r);
        case "BigInt":
          return FromBigInt(o, r);
        case "Boolean":
          return FromBoolean(o, r);
        case "Constructor":
          return FromConstructor(o, r);
        case "Date":
          return FromDate(o, r);
        case "Function":
          return FromFunction(o, r);
        case "Integer":
          return FromInteger(o, r);
        case "Intersect":
          return FromIntersect(o, r);
        case "Iterator":
          return FromIterator(o, r);
        case "Literal":
          return FromLiteral(o, r);
        case "Never":
          return FromNever(o, r);
        case "Not":
          return FromNot(o, r);
        case "Null":
          return FromNull(o, r);
        case "Number":
          return FromNumber(o, r);
        case "Object":
          return FromObject(o, r);
        case "Promise":
          return FromPromise(o, r);
        case "Record":
          return FromRecord(o, r);
        case "Ref":
          return FromRef(o, r);
        case "RegExp":
          return FromRegExp(o, r);
        case "String":
          return FromString(o, r);
        case "Symbol":
          return FromSymbol(o, r);
        case "TemplateLiteral":
          return FromTemplateLiteral(o, r);
        case "This":
          return FromThis(o, r);
        case "Tuple":
          return FromTuple(o, r);
        case "Undefined":
          return FromUndefined(o, r);
        case "Union":
          return FromUnion(o, r);
        case "Uint8Array":
          return FromUint8Array(o, r);
        case "Unknown":
          return FromUnknown(o, r);
        case "Void":
          return FromVoid(o, r);
        default:
          if (!c.TypeRegistry.Has(o[u.Kind])) throw new ValueCreateError(o, "Unknown type");
          return FromKind(o, r);
      }
    }
    const p = 512;
    let d = 0;
    function Create(...e) {
      d = 0;
      return e.length === 2 ? Visit(e[0], e[1]) : Visit(e[0], []);
    }
    t.Create = Create;
  },
  18050: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(51744), t);
  },
  28766: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Default = void 0;
    const n = r(33742);
    const o = r(21683);
    const s = r(40886);
    const i = r(97034);
    const a = r(17479);
    const A = r(70384);
    function ValueOrDefault(e, t) {
      return t === undefined && "default" in e ? (0, o.Clone)(e.default) : t;
    }
    function IsCheckable(e) {
      return (0, A.IsSchema)(e) && e[i.Kind] !== "Unsafe";
    }
    function IsDefaultSchema(e) {
      return (0, A.IsSchema)(e) && "default" in e;
    }
    function FromArray(e, t, r) {
      const n = ValueOrDefault(e, r);
      if (!(0, a.IsArray)(n)) return n;
      for (let r = 0; r < n.length; r++) {
        n[r] = Visit(e.items, t, n[r]);
      }
      return n;
    }
    function FromIntersect(e, t, r) {
      const n = ValueOrDefault(e, r);
      return e.allOf.reduce((e, r) => {
        const o = Visit(r, t, n);
        return (0, a.IsObject)(o) ? { ...e, ...o } : o;
      }, {});
    }
    function FromObject(e, t, r) {
      const n = ValueOrDefault(e, r);
      if (!(0, a.IsObject)(n)) return n;
      const o = e.additionalProperties;
      const s = Object.getOwnPropertyNames(e.properties);
      for (const r of s) {
        if (!IsDefaultSchema(e.properties[r])) continue;
        n[r] = Visit(e.properties[r], t, n[r]);
      }
      if (!IsDefaultSchema(o)) return n;
      for (const e of Object.getOwnPropertyNames(n)) {
        if (s.includes(e)) continue;
        n[e] = Visit(o, t, n[e]);
      }
      return n;
    }
    function FromRecord(e, t, r) {
      const n = ValueOrDefault(e, r);
      if (!(0, a.IsObject)(n)) return n;
      const o = e.additionalProperties;
      const [s, i] = Object.entries(e.patternProperties)[0];
      const A = new RegExp(s);
      for (const e of Object.getOwnPropertyNames(n)) {
        if (!(A.test(e) && IsDefaultSchema(i))) continue;
        n[e] = Visit(i, t, n[e]);
      }
      if (!IsDefaultSchema(o)) return n;
      for (const e of Object.getOwnPropertyNames(n)) {
        if (A.test(e)) continue;
        n[e] = Visit(o, t, n[e]);
      }
      return n;
    }
    function FromRef(e, t, r) {
      return Visit((0, s.Deref)(e, t), t, ValueOrDefault(e, r));
    }
    function FromThis(e, t, r) {
      return Visit((0, s.Deref)(e, t), t, r);
    }
    function FromTuple(e, t, r) {
      const n = ValueOrDefault(e, r);
      if (!(0, a.IsArray)(n) || (0, a.IsUndefined)(e.items)) return n;
      const [o, s] = [e.items, Math.max(e.items.length, n.length)];
      for (let e = 0; e < s; e++) {
        if (e < o.length) n[e] = Visit(o[e], t, n[e]);
      }
      return n;
    }
    function FromUnion(e, t, r) {
      const o = ValueOrDefault(e, r);
      for (const r of e.anyOf) {
        const e = Visit(r, t, o);
        if (IsCheckable(r) && (0, n.Check)(r, e)) {
          return e;
        }
      }
      return o;
    }
    function Visit(e, t, r) {
      const n = (0, a.IsString)(e.$id) ? [...t, e] : t;
      const o = e;
      switch (o[i.Kind]) {
        case "Array":
          return FromArray(o, n, r);
        case "Intersect":
          return FromIntersect(o, n, r);
        case "Object":
          return FromObject(o, n, r);
        case "Record":
          return FromRecord(o, n, r);
        case "Ref":
          return FromRef(o, n, r);
        case "This":
          return FromThis(o, n, r);
        case "Tuple":
          return FromTuple(o, n, r);
        case "Union":
          return FromUnion(o, n, r);
        default:
          return ValueOrDefault(o, r);
      }
    }
    function Default(...e) {
      return e.length === 3 ? Visit(e[0], e[1], e[2]) : Visit(e[0], [], e[1]);
    }
    t.Default = Default;
  },
  97659: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(28766), t);
  },
  67126: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Patch = t.Diff = t.ValueDeltaSymbolError = t.ValueDeltaError = t.Edit = t.Delete = t.Update = t.Insert = void 0;
    const n = r(17479);
    const o = r(23079);
    const s = r(21683);
    const i = r(26113);
    const a = r(98076);
    const A = r(62094);
    const c = r(81688);
    const u = r(51897);
    const l = r(69100);
    t.Insert = (0, A.Object)({ type: (0, a.Literal)("insert"), path: (0, c.String)(), value: (0, u.Unknown)() });
    t.Update = (0, A.Object)({ type: (0, a.Literal)("update"), path: (0, c.String)(), value: (0, u.Unknown)() });
    t.Delete = (0, A.Object)({ type: (0, a.Literal)("delete"), path: (0, c.String)() });
    t.Edit = (0, l.Union)([t.Insert, t.Update, t.Delete]);
    class ValueDeltaError extends i.TypeBoxError {
      constructor(e, t) {
        super(t);
        this.value = e;
      }
    }
    t.ValueDeltaError = ValueDeltaError;
    class ValueDeltaSymbolError extends ValueDeltaError {
      constructor(e) {
        super(e, "Cannot diff objects with symbol keys");
        this.value = e;
      }
    }
    t.ValueDeltaSymbolError = ValueDeltaSymbolError;
    function CreateUpdate(e, t) {
      return { type: "update", path: e, value: t };
    }
    function CreateInsert(e, t) {
      return { type: "insert", path: e, value: t };
    }
    function CreateDelete(e) {
      return { type: "delete", path: e };
    }
    function* ObjectType(e, t, r) {
      if (!(0, n.IsStandardObject)(r)) return yield CreateUpdate(e, r);
      const o = [...globalThis.Object.keys(t), ...globalThis.Object.getOwnPropertySymbols(t)];
      const s = [...globalThis.Object.keys(r), ...globalThis.Object.getOwnPropertySymbols(r)];
      for (const t of o) {
        if ((0, n.IsSymbol)(t)) throw new ValueDeltaSymbolError(t);
        if ((0, n.IsUndefined)(r[t]) && s.includes(t)) yield CreateUpdate(`${e}/${globalThis.String(t)}`, undefined);
      }
      for (const o of s) {
        if ((0, n.IsUndefined)(t[o]) || (0, n.IsUndefined)(r[o])) continue;
        if ((0, n.IsSymbol)(o)) throw new ValueDeltaSymbolError(o);
        yield* Visit(`${e}/${globalThis.String(o)}`, t[o], r[o]);
      }
      for (const o of s) {
        if ((0, n.IsSymbol)(o)) throw new ValueDeltaSymbolError(o);
        if ((0, n.IsUndefined)(t[o])) yield CreateInsert(`${e}/${globalThis.String(o)}`, r[o]);
      }
      for (const t of o.reverse()) {
        if ((0, n.IsSymbol)(t)) throw new ValueDeltaSymbolError(t);
        if ((0, n.IsUndefined)(r[t]) && !s.includes(t)) yield CreateDelete(`${e}/${globalThis.String(t)}`);
      }
    }
    function* ArrayType(e, t, r) {
      if (!(0, n.IsArray)(r)) return yield CreateUpdate(e, r);
      for (let n = 0; n < Math.min(t.length, r.length); n++) {
        yield* Visit(`${e}/${n}`, t[n], r[n]);
      }
      for (let n = 0; n < r.length; n++) {
        if (n < t.length) continue;
        yield CreateInsert(`${e}/${n}`, r[n]);
      }
      for (let n = t.length - 1; n >= 0; n--) {
        if (n < r.length) continue;
        yield CreateDelete(`${e}/${n}`);
      }
    }
    function* TypedArrayType(e, t, r) {
      if (
        !(0, n.IsTypedArray)(r) ||
        t.length !== r.length ||
        globalThis.Object.getPrototypeOf(t).constructor.name !== globalThis.Object.getPrototypeOf(r).constructor.name
      )
        return yield CreateUpdate(e, r);
      for (let n = 0; n < Math.min(t.length, r.length); n++) {
        yield* Visit(`${e}/${n}`, t[n], r[n]);
      }
    }
    function* ValueType(e, t, r) {
      if (t === r) return;
      yield CreateUpdate(e, r);
    }
    function* Visit(e, t, r) {
      if ((0, n.IsStandardObject)(t)) return yield* ObjectType(e, t, r);
      if ((0, n.IsArray)(t)) return yield* ArrayType(e, t, r);
      if ((0, n.IsTypedArray)(t)) return yield* TypedArrayType(e, t, r);
      if ((0, n.IsValueType)(t)) return yield* ValueType(e, t, r);
      throw new ValueDeltaError(t, "Unable to create diff edits for unknown value");
    }
    function Diff(e, t) {
      return [...Visit("", e, t)];
    }
    t.Diff = Diff;
    function IsRootUpdate(e) {
      return e.length > 0 && e[0].path === "" && e[0].type === "update";
    }
    function IsIdentity(e) {
      return e.length === 0;
    }
    function Patch(e, t) {
      if (IsRootUpdate(t)) {
        return (0, s.Clone)(t[0].value);
      }
      if (IsIdentity(t)) {
        return (0, s.Clone)(e);
      }
      const r = (0, s.Clone)(e);
      for (const e of t) {
        switch (e.type) {
          case "insert": {
            o.ValuePointer.Set(r, e.path, e.value);
            break;
          }
          case "update": {
            o.ValuePointer.Set(r, e.path, e.value);
            break;
          }
          case "delete": {
            o.ValuePointer.Delete(r, e.path);
            break;
          }
        }
      }
      return r;
    }
    t.Patch = Patch;
  },
  8124: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(67126), t);
  },
  85298: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Deref = t.TypeDereferenceError = void 0;
    const n = r(26113);
    const o = r(97034);
    class TypeDereferenceError extends n.TypeBoxError {
      constructor(e) {
        super(`Unable to dereference schema with $id '${e.$id}'`);
        this.schema = e;
      }
    }
    t.TypeDereferenceError = TypeDereferenceError;
    function Resolve(e, t) {
      const r = t.find((t) => t.$id === e.$ref);
      if (r === undefined) throw new TypeDereferenceError(e);
      return Deref(r, t);
    }
    function Deref(e, t) {
      return e[o.Kind] === "This" || e[o.Kind] === "Ref" ? Resolve(e, t) : e;
    }
    t.Deref = Deref;
  },
  40886: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(85298), t);
  },
  60586: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Equal = void 0;
    const n = r(17479);
    function ObjectType(e, t) {
      if (!(0, n.IsStandardObject)(t)) return false;
      const r = [...Object.keys(e), ...Object.getOwnPropertySymbols(e)];
      const o = [...Object.keys(t), ...Object.getOwnPropertySymbols(t)];
      if (r.length !== o.length) return false;
      return r.every((r) => Equal(e[r], t[r]));
    }
    function DateType(e, t) {
      return (0, n.IsDate)(t) && e.getTime() === t.getTime();
    }
    function ArrayType(e, t) {
      if (!(0, n.IsArray)(t) || e.length !== t.length) return false;
      return e.every((e, r) => Equal(e, t[r]));
    }
    function TypedArrayType(e, t) {
      if (!(0, n.IsTypedArray)(t) || e.length !== t.length || Object.getPrototypeOf(e).constructor.name !== Object.getPrototypeOf(t).constructor.name)
        return false;
      return e.every((e, r) => Equal(e, t[r]));
    }
    function ValueType(e, t) {
      return e === t;
    }
    function Equal(e, t) {
      if ((0, n.IsStandardObject)(e)) return ObjectType(e, t);
      if ((0, n.IsDate)(e)) return DateType(e, t);
      if ((0, n.IsTypedArray)(e)) return TypedArrayType(e, t);
      if ((0, n.IsArray)(e)) return ArrayType(e, t);
      if ((0, n.IsValueType)(e)) return ValueType(e, t);
      throw new Error("ValueEquals: Unable to compare value");
    }
    t.Equal = Equal;
  },
  46186: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(60586), t);
  },
  1850: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.IsValueType =
      t.IsSymbol =
      t.IsFunction =
      t.IsString =
      t.IsBigInt =
      t.IsInteger =
      t.IsNumber =
      t.IsBoolean =
      t.IsNull =
      t.IsUndefined =
      t.IsArray =
      t.IsObject =
      t.HasPropertyKey =
      t.IsBigUint64Array =
      t.IsBigInt64Array =
      t.IsFloat64Array =
      t.IsFloat32Array =
      t.IsUint32Array =
      t.IsInt32Array =
      t.IsUint16Array =
      t.IsInt16Array =
      t.IsUint8ClampedArray =
      t.IsUint8Array =
      t.IsInt8Array =
      t.IsTypedArray =
      t.IsRegExp =
      t.IsSet =
      t.IsMap =
      t.IsDate =
      t.IsPromise =
      t.IsInstanceObject =
      t.IsStandardObject =
      t.IsIterator =
      t.IsAsyncIterator =
        void 0;
    function IsAsyncIterator(e) {
      return IsObject(e) && Symbol.asyncIterator in e;
    }
    t.IsAsyncIterator = IsAsyncIterator;
    function IsIterator(e) {
      return IsObject(e) && Symbol.iterator in e;
    }
    t.IsIterator = IsIterator;
    function IsStandardObject(e) {
      return IsObject(e) && (Object.getPrototypeOf(e) === Object.prototype || Object.getPrototypeOf(e) === null);
    }
    t.IsStandardObject = IsStandardObject;
    function IsInstanceObject(e) {
      return IsObject(e) && !IsArray(e) && IsFunction(e.constructor) && e.constructor.name !== "Object";
    }
    t.IsInstanceObject = IsInstanceObject;
    function IsPromise(e) {
      return e instanceof Promise;
    }
    t.IsPromise = IsPromise;
    function IsDate(e) {
      return e instanceof Date && Number.isFinite(e.getTime());
    }
    t.IsDate = IsDate;
    function IsMap(e) {
      return e instanceof globalThis.Map;
    }
    t.IsMap = IsMap;
    function IsSet(e) {
      return e instanceof globalThis.Set;
    }
    t.IsSet = IsSet;
    function IsRegExp(e) {
      return e instanceof globalThis.RegExp;
    }
    t.IsRegExp = IsRegExp;
    function IsTypedArray(e) {
      return ArrayBuffer.isView(e);
    }
    t.IsTypedArray = IsTypedArray;
    function IsInt8Array(e) {
      return e instanceof globalThis.Int8Array;
    }
    t.IsInt8Array = IsInt8Array;
    function IsUint8Array(e) {
      return e instanceof globalThis.Uint8Array;
    }
    t.IsUint8Array = IsUint8Array;
    function IsUint8ClampedArray(e) {
      return e instanceof globalThis.Uint8ClampedArray;
    }
    t.IsUint8ClampedArray = IsUint8ClampedArray;
    function IsInt16Array(e) {
      return e instanceof globalThis.Int16Array;
    }
    t.IsInt16Array = IsInt16Array;
    function IsUint16Array(e) {
      return e instanceof globalThis.Uint16Array;
    }
    t.IsUint16Array = IsUint16Array;
    function IsInt32Array(e) {
      return e instanceof globalThis.Int32Array;
    }
    t.IsInt32Array = IsInt32Array;
    function IsUint32Array(e) {
      return e instanceof globalThis.Uint32Array;
    }
    t.IsUint32Array = IsUint32Array;
    function IsFloat32Array(e) {
      return e instanceof globalThis.Float32Array;
    }
    t.IsFloat32Array = IsFloat32Array;
    function IsFloat64Array(e) {
      return e instanceof globalThis.Float64Array;
    }
    t.IsFloat64Array = IsFloat64Array;
    function IsBigInt64Array(e) {
      return e instanceof globalThis.BigInt64Array;
    }
    t.IsBigInt64Array = IsBigInt64Array;
    function IsBigUint64Array(e) {
      return e instanceof globalThis.BigUint64Array;
    }
    t.IsBigUint64Array = IsBigUint64Array;
    function HasPropertyKey(e, t) {
      return t in e;
    }
    t.HasPropertyKey = HasPropertyKey;
    function IsObject(e) {
      return e !== null && typeof e === "object";
    }
    t.IsObject = IsObject;
    function IsArray(e) {
      return Array.isArray(e) && !ArrayBuffer.isView(e);
    }
    t.IsArray = IsArray;
    function IsUndefined(e) {
      return e === undefined;
    }
    t.IsUndefined = IsUndefined;
    function IsNull(e) {
      return e === null;
    }
    t.IsNull = IsNull;
    function IsBoolean(e) {
      return typeof e === "boolean";
    }
    t.IsBoolean = IsBoolean;
    function IsNumber(e) {
      return typeof e === "number";
    }
    t.IsNumber = IsNumber;
    function IsInteger(e) {
      return Number.isInteger(e);
    }
    t.IsInteger = IsInteger;
    function IsBigInt(e) {
      return typeof e === "bigint";
    }
    t.IsBigInt = IsBigInt;
    function IsString(e) {
      return typeof e === "string";
    }
    t.IsString = IsString;
    function IsFunction(e) {
      return typeof e === "function";
    }
    t.IsFunction = IsFunction;
    function IsSymbol(e) {
      return typeof e === "symbol";
    }
    t.IsSymbol = IsSymbol;
    function IsValueType(e) {
      return IsBigInt(e) || IsBoolean(e) || IsNull(e) || IsNumber(e) || IsString(e) || IsSymbol(e) || IsUndefined(e);
    }
    t.IsValueType = IsValueType;
  },
  17479: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(1850), t);
  },
  83760: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Hash = t.ValueHashError = void 0;
    const n = r(17479);
    const o = r(26113);
    class ValueHashError extends o.TypeBoxError {
      constructor(e) {
        super(`Unable to hash value`);
        this.value = e;
      }
    }
    t.ValueHashError = ValueHashError;
    var s;
    (function (e) {
      e[(e["Undefined"] = 0)] = "Undefined";
      e[(e["Null"] = 1)] = "Null";
      e[(e["Boolean"] = 2)] = "Boolean";
      e[(e["Number"] = 3)] = "Number";
      e[(e["String"] = 4)] = "String";
      e[(e["Object"] = 5)] = "Object";
      e[(e["Array"] = 6)] = "Array";
      e[(e["Date"] = 7)] = "Date";
      e[(e["Uint8Array"] = 8)] = "Uint8Array";
      e[(e["Symbol"] = 9)] = "Symbol";
      e[(e["BigInt"] = 10)] = "BigInt";
    })(s || (s = {}));
    let i = BigInt("14695981039346656037");
    const [a, A] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
    const c = Array.from({ length: 256 }).map((e, t) => BigInt(t));
    const u = new Float64Array(1);
    const l = new DataView(u.buffer);
    const p = new Uint8Array(u.buffer);
    function* NumberToBytes(e) {
      const t = e === 0 ? 1 : Math.ceil(Math.floor(Math.log2(e) + 1) / 8);
      for (let r = 0; r < t; r++) {
        yield (e >> (8 * (t - 1 - r))) & 255;
      }
    }
    function ArrayType(e) {
      FNV1A64(s.Array);
      for (const t of e) {
        Visit(t);
      }
    }
    function BooleanType(e) {
      FNV1A64(s.Boolean);
      FNV1A64(e ? 1 : 0);
    }
    function BigIntType(e) {
      FNV1A64(s.BigInt);
      l.setBigInt64(0, e);
      for (const e of p) {
        FNV1A64(e);
      }
    }
    function DateType(e) {
      FNV1A64(s.Date);
      Visit(e.getTime());
    }
    function NullType(e) {
      FNV1A64(s.Null);
    }
    function NumberType(e) {
      FNV1A64(s.Number);
      l.setFloat64(0, e);
      for (const e of p) {
        FNV1A64(e);
      }
    }
    function ObjectType(e) {
      FNV1A64(s.Object);
      for (const t of globalThis.Object.getOwnPropertyNames(e).sort()) {
        Visit(t);
        Visit(e[t]);
      }
    }
    function StringType(e) {
      FNV1A64(s.String);
      for (let t = 0; t < e.length; t++) {
        for (const r of NumberToBytes(e.charCodeAt(t))) {
          FNV1A64(r);
        }
      }
    }
    function SymbolType(e) {
      FNV1A64(s.Symbol);
      Visit(e.description);
    }
    function Uint8ArrayType(e) {
      FNV1A64(s.Uint8Array);
      for (let t = 0; t < e.length; t++) {
        FNV1A64(e[t]);
      }
    }
    function UndefinedType(e) {
      return FNV1A64(s.Undefined);
    }
    function Visit(e) {
      if ((0, n.IsArray)(e)) return ArrayType(e);
      if ((0, n.IsBoolean)(e)) return BooleanType(e);
      if ((0, n.IsBigInt)(e)) return BigIntType(e);
      if ((0, n.IsDate)(e)) return DateType(e);
      if ((0, n.IsNull)(e)) return NullType(e);
      if ((0, n.IsNumber)(e)) return NumberType(e);
      if ((0, n.IsStandardObject)(e)) return ObjectType(e);
      if ((0, n.IsString)(e)) return StringType(e);
      if ((0, n.IsSymbol)(e)) return SymbolType(e);
      if ((0, n.IsUint8Array)(e)) return Uint8ArrayType(e);
      if ((0, n.IsUndefined)(e)) return UndefinedType(e);
      throw new ValueHashError(e);
    }
    function FNV1A64(e) {
      i = i ^ c[e];
      i = (i * a) % A;
    }
    function Hash(e) {
      i = BigInt("14695981039346656037");
      Visit(e);
      return i;
    }
    t.Hash = Hash;
  },
  7210: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(83760), t);
  },
  45105: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    t.Value = t.ValueErrorIterator = t.ValueErrorType = void 0;
    var s = r(65507);
    Object.defineProperty(t, "ValueErrorType", {
      enumerable: true,
      get: function () {
        return s.ValueErrorType;
      },
    });
    Object.defineProperty(t, "ValueErrorIterator", {
      enumerable: true,
      get: function () {
        return s.ValueErrorIterator;
      },
    });
    o(r(17479), t);
    o(r(46097), t);
    o(r(33742), t);
    o(r(6115), t);
    o(r(21683), t);
    o(r(41241), t);
    o(r(18050), t);
    o(r(97659), t);
    o(r(8124), t);
    o(r(46186), t);
    o(r(7210), t);
    o(r(36068), t);
    o(r(23079), t);
    o(r(50038), t);
    var i = r(22079);
    Object.defineProperty(t, "Value", {
      enumerable: true,
      get: function () {
        return i.Value;
      },
    });
  },
  36068: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(51212), t);
  },
  51212: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Mutate = t.ValueMutateError = void 0;
    const n = r(17479);
    const o = r(23079);
    const s = r(21683);
    const i = r(26113);
    class ValueMutateError extends i.TypeBoxError {
      constructor(e) {
        super(e);
      }
    }
    t.ValueMutateError = ValueMutateError;
    function ObjectType(e, t, r, i) {
      if (!(0, n.IsStandardObject)(r)) {
        o.ValuePointer.Set(e, t, (0, s.Clone)(i));
      } else {
        const n = Object.getOwnPropertyNames(r);
        const o = Object.getOwnPropertyNames(i);
        for (const e of n) {
          if (!o.includes(e)) {
            delete r[e];
          }
        }
        for (const e of o) {
          if (!n.includes(e)) {
            r[e] = null;
          }
        }
        for (const n of o) {
          Visit(e, `${t}/${n}`, r[n], i[n]);
        }
      }
    }
    function ArrayType(e, t, r, i) {
      if (!(0, n.IsArray)(r)) {
        o.ValuePointer.Set(e, t, (0, s.Clone)(i));
      } else {
        for (let n = 0; n < i.length; n++) {
          Visit(e, `${t}/${n}`, r[n], i[n]);
        }
        r.splice(i.length);
      }
    }
    function TypedArrayType(e, t, r, i) {
      if ((0, n.IsTypedArray)(r) && r.length === i.length) {
        for (let e = 0; e < r.length; e++) {
          r[e] = i[e];
        }
      } else {
        o.ValuePointer.Set(e, t, (0, s.Clone)(i));
      }
    }
    function ValueType(e, t, r, n) {
      if (r === n) return;
      o.ValuePointer.Set(e, t, n);
    }
    function Visit(e, t, r, o) {
      if ((0, n.IsArray)(o)) return ArrayType(e, t, r, o);
      if ((0, n.IsTypedArray)(o)) return TypedArrayType(e, t, r, o);
      if ((0, n.IsStandardObject)(o)) return ObjectType(e, t, r, o);
      if ((0, n.IsValueType)(o)) return ValueType(e, t, r, o);
    }
    function IsNonMutableValue(e) {
      return (0, n.IsTypedArray)(e) || (0, n.IsValueType)(e);
    }
    function IsMismatchedValue(e, t) {
      return ((0, n.IsStandardObject)(e) && (0, n.IsArray)(t)) || ((0, n.IsArray)(e) && (0, n.IsStandardObject)(t));
    }
    function Mutate(e, t) {
      if (IsNonMutableValue(e) || IsNonMutableValue(t)) throw new ValueMutateError("Only object and array types can be mutated at the root level");
      if (IsMismatchedValue(e, t)) throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
      Visit(e, "", e, t);
    }
    t.Mutate = Mutate;
  },
  23079: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ValuePointer = void 0;
    t.ValuePointer = r(65630);
  },
  65630: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Get = t.Has = t.Delete = t.Set = t.Format = t.ValuePointerRootDeleteError = t.ValuePointerRootSetError = void 0;
    const n = r(26113);
    class ValuePointerRootSetError extends n.TypeBoxError {
      constructor(e, t, r) {
        super("Cannot set root value");
        this.value = e;
        this.path = t;
        this.update = r;
      }
    }
    t.ValuePointerRootSetError = ValuePointerRootSetError;
    class ValuePointerRootDeleteError extends n.TypeBoxError {
      constructor(e, t) {
        super("Cannot delete root value");
        this.value = e;
        this.path = t;
      }
    }
    t.ValuePointerRootDeleteError = ValuePointerRootDeleteError;
    function Escape(e) {
      return e.indexOf("~") === -1 ? e : e.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    function* Format(e) {
      if (e === "") return;
      let [t, r] = [0, 0];
      for (let n = 0; n < e.length; n++) {
        const o = e.charAt(n);
        if (o === "/") {
          if (n === 0) {
            t = n + 1;
          } else {
            r = n;
            yield Escape(e.slice(t, r));
            t = n + 1;
          }
        } else {
          r = n;
        }
      }
      yield Escape(e.slice(t));
    }
    t.Format = Format;
    function Set(e, t, r) {
      if (t === "") throw new ValuePointerRootSetError(e, t, r);
      let [n, o, s] = [null, e, ""];
      for (const e of Format(t)) {
        if (o[e] === undefined) o[e] = {};
        n = o;
        o = o[e];
        s = e;
      }
      n[s] = r;
    }
    t.Set = Set;
    function Delete(e, t) {
      if (t === "") throw new ValuePointerRootDeleteError(e, t);
      let [r, n, o] = [null, e, ""];
      for (const e of Format(t)) {
        if (n[e] === undefined || n[e] === null) return;
        r = n;
        n = n[e];
        o = e;
      }
      if (Array.isArray(r)) {
        const e = parseInt(o);
        r.splice(e, 1);
      } else {
        delete r[o];
      }
    }
    t.Delete = Delete;
    function Has(e, t) {
      if (t === "") return true;
      let [r, n, o] = [null, e, ""];
      for (const e of Format(t)) {
        if (n[e] === undefined) return false;
        r = n;
        n = n[e];
        o = e;
      }
      return Object.getOwnPropertyNames(r).includes(o);
    }
    t.Has = Has;
    function Get(e, t) {
      if (t === "") return e;
      let r = e;
      for (const e of Format(t)) {
        if (r[e] === undefined) return undefined;
        r = r[e];
      }
      return r;
    }
    t.Get = Get;
  },
  37354: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TransformDecode = t.TransformDecodeError = t.TransformDecodeCheckError = void 0;
    const n = r(97034);
    const o = r(26113);
    const s = r(73373);
    const i = r(40886);
    const a = r(33742);
    const A = r(17479);
    const c = r(70384);
    class TransformDecodeCheckError extends o.TypeBoxError {
      constructor(e, t, r) {
        super(`Unable to decode value as it does not match the expected schema`);
        this.schema = e;
        this.value = t;
        this.error = r;
      }
    }
    t.TransformDecodeCheckError = TransformDecodeCheckError;
    class TransformDecodeError extends o.TypeBoxError {
      constructor(e, t, r, n) {
        super(n instanceof Error ? n.message : "Unknown error");
        this.schema = e;
        this.path = t;
        this.value = r;
        this.error = n;
      }
    }
    t.TransformDecodeError = TransformDecodeError;
    function Default(e, t, r) {
      try {
        return (0, c.IsTransform)(e) ? e[n.TransformKind].Decode(r) : r;
      } catch (n) {
        throw new TransformDecodeError(e, t, r, n);
      }
    }
    function FromArray(e, t, r, n) {
      return (0, A.IsArray)(n)
        ? Default(
            e,
            r,
            n.map((n, o) => Visit(e.items, t, `${r}/${o}`, n))
          )
        : Default(e, r, n);
    }
    function FromIntersect(e, t, r, n) {
      if (!(0, A.IsStandardObject)(n) || (0, A.IsValueType)(n)) return Default(e, r, n);
      const o = (0, s.KeyOfPropertyEntries)(e);
      const i = o.map((e) => e[0]);
      const a = { ...n };
      for (const [e, n] of o)
        if (e in a) {
          a[e] = Visit(n, t, `${r}/${e}`, a[e]);
        }
      if (!(0, c.IsTransform)(e.unevaluatedProperties)) {
        return Default(e, r, a);
      }
      const u = Object.getOwnPropertyNames(a);
      const l = e.unevaluatedProperties;
      const p = { ...a };
      for (const e of u)
        if (!i.includes(e)) {
          p[e] = Default(l, `${r}/${e}`, p[e]);
        }
      return Default(e, r, p);
    }
    function FromNot(e, t, r, n) {
      return Default(e, r, Visit(e.not, t, r, n));
    }
    function FromObject(e, t, r, n) {
      if (!(0, A.IsStandardObject)(n)) return Default(e, r, n);
      const o = (0, s.KeyOfPropertyKeys)(e);
      const i = { ...n };
      for (const n of o)
        if (n in i) {
          i[n] = Visit(e.properties[n], t, `${r}/${n}`, i[n]);
        }
      if (!(0, c.IsSchema)(e.additionalProperties)) {
        return Default(e, r, i);
      }
      const a = Object.getOwnPropertyNames(i);
      const u = e.additionalProperties;
      const l = { ...i };
      for (const e of a)
        if (!o.includes(e)) {
          l[e] = Default(u, `${r}/${e}`, l[e]);
        }
      return Default(e, r, l);
    }
    function FromRecord(e, t, r, n) {
      if (!(0, A.IsStandardObject)(n)) return Default(e, r, n);
      const o = Object.getOwnPropertyNames(e.patternProperties)[0];
      const s = new RegExp(o);
      const i = { ...n };
      for (const a of Object.getOwnPropertyNames(n))
        if (s.test(a)) {
          i[a] = Visit(e.patternProperties[o], t, `${r}/${a}`, i[a]);
        }
      if (!(0, c.IsSchema)(e.additionalProperties)) {
        return Default(e, r, i);
      }
      const a = Object.getOwnPropertyNames(i);
      const u = e.additionalProperties;
      const l = { ...i };
      for (const e of a)
        if (!s.test(e)) {
          l[e] = Default(u, `${r}/${e}`, l[e]);
        }
      return Default(e, r, l);
    }
    function FromRef(e, t, r, n) {
      const o = (0, i.Deref)(e, t);
      return Default(e, r, Visit(o, t, r, n));
    }
    function FromThis(e, t, r, n) {
      const o = (0, i.Deref)(e, t);
      return Default(e, r, Visit(o, t, r, n));
    }
    function FromTuple(e, t, r, n) {
      return (0, A.IsArray)(n) && (0, A.IsArray)(e.items)
        ? Default(
            e,
            r,
            e.items.map((e, o) => Visit(e, t, `${r}/${o}`, n[o]))
          )
        : Default(e, r, n);
    }
    function FromUnion(e, t, r, n) {
      for (const o of e.anyOf) {
        if (!(0, a.Check)(o, t, n)) continue;
        const s = Visit(o, t, r, n);
        return Default(e, r, s);
      }
      return Default(e, r, n);
    }
    function Visit(e, t, r, o) {
      const s = typeof e.$id === "string" ? [...t, e] : t;
      const i = e;
      switch (e[n.Kind]) {
        case "Array":
          return FromArray(i, s, r, o);
        case "Intersect":
          return FromIntersect(i, s, r, o);
        case "Not":
          return FromNot(i, s, r, o);
        case "Object":
          return FromObject(i, s, r, o);
        case "Record":
          return FromRecord(i, s, r, o);
        case "Ref":
          return FromRef(i, s, r, o);
        case "Symbol":
          return Default(i, r, o);
        case "This":
          return FromThis(i, s, r, o);
        case "Tuple":
          return FromTuple(i, s, r, o);
        case "Union":
          return FromUnion(i, s, r, o);
        default:
          return Default(i, r, o);
      }
    }
    function TransformDecode(e, t, r) {
      return Visit(e, t, "", r);
    }
    t.TransformDecode = TransformDecode;
  },
  33598: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TransformEncode = t.TransformEncodeError = t.TransformEncodeCheckError = void 0;
    const n = r(97034);
    const o = r(26113);
    const s = r(73373);
    const i = r(40886);
    const a = r(33742);
    const A = r(17479);
    const c = r(70384);
    class TransformEncodeCheckError extends o.TypeBoxError {
      constructor(e, t, r) {
        super(`The encoded value does not match the expected schema`);
        this.schema = e;
        this.value = t;
        this.error = r;
      }
    }
    t.TransformEncodeCheckError = TransformEncodeCheckError;
    class TransformEncodeError extends o.TypeBoxError {
      constructor(e, t, r, n) {
        super(`${n instanceof Error ? n.message : "Unknown error"}`);
        this.schema = e;
        this.path = t;
        this.value = r;
        this.error = n;
      }
    }
    t.TransformEncodeError = TransformEncodeError;
    function Default(e, t, r) {
      try {
        return (0, c.IsTransform)(e) ? e[n.TransformKind].Encode(r) : r;
      } catch (n) {
        throw new TransformEncodeError(e, t, r, n);
      }
    }
    function FromArray(e, t, r, n) {
      const o = Default(e, r, n);
      return (0, A.IsArray)(o) ? o.map((n, o) => Visit(e.items, t, `${r}/${o}`, n)) : o;
    }
    function FromIntersect(e, t, r, n) {
      const o = Default(e, r, n);
      if (!(0, A.IsStandardObject)(n) || (0, A.IsValueType)(n)) return o;
      const i = (0, s.KeyOfPropertyEntries)(e);
      const a = i.map((e) => e[0]);
      const u = { ...o };
      for (const [e, n] of i)
        if (e in u) {
          u[e] = Visit(n, t, `${r}/${e}`, u[e]);
        }
      if (!(0, c.IsTransform)(e.unevaluatedProperties)) {
        return Default(e, r, u);
      }
      const l = Object.getOwnPropertyNames(u);
      const p = e.unevaluatedProperties;
      const d = { ...u };
      for (const e of l)
        if (!a.includes(e)) {
          d[e] = Default(p, `${r}/${e}`, d[e]);
        }
      return d;
    }
    function FromNot(e, t, r, n) {
      return Default(e.not, r, Default(e, r, n));
    }
    function FromObject(e, t, r, n) {
      const o = Default(e, r, n);
      if (!(0, A.IsStandardObject)(o)) return o;
      const i = (0, s.KeyOfPropertyKeys)(e);
      const a = { ...o };
      for (const n of i)
        if (n in a) {
          a[n] = Visit(e.properties[n], t, `${r}/${n}`, a[n]);
        }
      if (!(0, c.IsSchema)(e.additionalProperties)) {
        return a;
      }
      const u = Object.getOwnPropertyNames(a);
      const l = e.additionalProperties;
      const p = { ...a };
      for (const e of u)
        if (!i.includes(e)) {
          p[e] = Default(l, `${r}/${e}`, p[e]);
        }
      return p;
    }
    function FromRecord(e, t, r, n) {
      const o = Default(e, r, n);
      if (!(0, A.IsStandardObject)(n)) return o;
      const s = Object.getOwnPropertyNames(e.patternProperties)[0];
      const i = new RegExp(s);
      const a = { ...o };
      for (const o of Object.getOwnPropertyNames(n))
        if (i.test(o)) {
          a[o] = Visit(e.patternProperties[s], t, `${r}/${o}`, a[o]);
        }
      if (!(0, c.IsSchema)(e.additionalProperties)) {
        return Default(e, r, a);
      }
      const u = Object.getOwnPropertyNames(a);
      const l = e.additionalProperties;
      const p = { ...a };
      for (const e of u)
        if (!i.test(e)) {
          p[e] = Default(l, `${r}/${e}`, p[e]);
        }
      return p;
    }
    function FromRef(e, t, r, n) {
      const o = (0, i.Deref)(e, t);
      const s = Visit(o, t, r, n);
      return Default(e, r, s);
    }
    function FromThis(e, t, r, n) {
      const o = (0, i.Deref)(e, t);
      const s = Visit(o, t, r, n);
      return Default(e, r, s);
    }
    function FromTuple(e, t, r, n) {
      const o = Default(e, r, n);
      return (0, A.IsArray)(e.items) ? e.items.map((e, n) => Visit(e, t, `${r}/${n}`, o[n])) : [];
    }
    function FromUnion(e, t, r, n) {
      for (const o of e.anyOf) {
        if (!(0, a.Check)(o, t, n)) continue;
        const s = Visit(o, t, r, n);
        return Default(e, r, s);
      }
      for (const o of e.anyOf) {
        const s = Visit(o, t, r, n);
        if (!(0, a.Check)(e, t, s)) continue;
        return Default(e, r, s);
      }
      return Default(e, r, n);
    }
    function Visit(e, t, r, o) {
      const s = typeof e.$id === "string" ? [...t, e] : t;
      const i = e;
      switch (e[n.Kind]) {
        case "Array":
          return FromArray(i, s, r, o);
        case "Intersect":
          return FromIntersect(i, s, r, o);
        case "Not":
          return FromNot(i, s, r, o);
        case "Object":
          return FromObject(i, s, r, o);
        case "Record":
          return FromRecord(i, s, r, o);
        case "Ref":
          return FromRef(i, s, r, o);
        case "This":
          return FromThis(i, s, r, o);
        case "Tuple":
          return FromTuple(i, s, r, o);
        case "Union":
          return FromUnion(i, s, r, o);
        default:
          return Default(i, r, o);
      }
    }
    function TransformEncode(e, t, r) {
      return Visit(e, t, "", r);
    }
    t.TransformEncode = TransformEncode;
  },
  51542: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.HasTransform = void 0;
    const n = r(40886);
    const o = r(97034);
    const s = r(70384);
    const i = r(17479);
    function FromArray(e, t) {
      return (0, s.IsTransform)(e) || Visit(e.items, t);
    }
    function FromAsyncIterator(e, t) {
      return (0, s.IsTransform)(e) || Visit(e.items, t);
    }
    function FromConstructor(e, t) {
      return (0, s.IsTransform)(e) || Visit(e.returns, t) || e.parameters.some((e) => Visit(e, t));
    }
    function FromFunction(e, t) {
      return (0, s.IsTransform)(e) || Visit(e.returns, t) || e.parameters.some((e) => Visit(e, t));
    }
    function FromIntersect(e, t) {
      return (0, s.IsTransform)(e) || (0, s.IsTransform)(e.unevaluatedProperties) || e.allOf.some((e) => Visit(e, t));
    }
    function FromIterator(e, t) {
      return (0, s.IsTransform)(e) || Visit(e.items, t);
    }
    function FromNot(e, t) {
      return (0, s.IsTransform)(e) || Visit(e.not, t);
    }
    function FromObject(e, t) {
      return (
        (0, s.IsTransform)(e) ||
        Object.values(e.properties).some((e) => Visit(e, t)) ||
        ((0, s.IsSchema)(e.additionalProperties) && Visit(e.additionalProperties, t))
      );
    }
    function FromPromise(e, t) {
      return (0, s.IsTransform)(e) || Visit(e.item, t);
    }
    function FromRecord(e, t) {
      const r = Object.getOwnPropertyNames(e.patternProperties)[0];
      const n = e.patternProperties[r];
      return (0, s.IsTransform)(e) || Visit(n, t) || ((0, s.IsSchema)(e.additionalProperties) && (0, s.IsTransform)(e.additionalProperties));
    }
    function FromRef(e, t) {
      if ((0, s.IsTransform)(e)) return true;
      return Visit((0, n.Deref)(e, t), t);
    }
    function FromThis(e, t) {
      if ((0, s.IsTransform)(e)) return true;
      return Visit((0, n.Deref)(e, t), t);
    }
    function FromTuple(e, t) {
      return (0, s.IsTransform)(e) || (!(0, i.IsUndefined)(e.items) && e.items.some((e) => Visit(e, t)));
    }
    function FromUnion(e, t) {
      return (0, s.IsTransform)(e) || e.anyOf.some((e) => Visit(e, t));
    }
    function Visit(e, t) {
      const r = (0, i.IsString)(e.$id) ? [...t, e] : t;
      const n = e;
      if (e.$id && a.has(e.$id)) return false;
      if (e.$id) a.add(e.$id);
      switch (e[o.Kind]) {
        case "Array":
          return FromArray(n, r);
        case "AsyncIterator":
          return FromAsyncIterator(n, r);
        case "Constructor":
          return FromConstructor(n, r);
        case "Function":
          return FromFunction(n, r);
        case "Intersect":
          return FromIntersect(n, r);
        case "Iterator":
          return FromIterator(n, r);
        case "Not":
          return FromNot(n, r);
        case "Object":
          return FromObject(n, r);
        case "Promise":
          return FromPromise(n, r);
        case "Record":
          return FromRecord(n, r);
        case "Ref":
          return FromRef(n, r);
        case "This":
          return FromThis(n, r);
        case "Tuple":
          return FromTuple(n, r);
        case "Union":
          return FromUnion(n, r);
        default:
          return (0, s.IsTransform)(e);
      }
    }
    const a = new Set();
    function HasTransform(e, t) {
      a.clear();
      return Visit(e, t);
    }
    t.HasTransform = HasTransform;
  },
  50038: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(37354), t);
    o(r(33598), t);
    o(r(51542), t);
  },
  22079: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Value = void 0;
    t.Value = r(50854);
  },
  50854: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.Mutate =
      t.Patch =
      t.Hash =
      t.Diff =
      t.Equal =
      t.Errors =
      t.Encode =
      t.Default =
      t.Decode =
      t.Clone =
      t.Convert =
      t.Clean =
      t.Check =
      t.Create =
      t.Cast =
        void 0;
    const n = r(50038);
    const o = r(36068);
    const s = r(7210);
    const i = r(46186);
    const a = r(46097);
    const A = r(21683);
    const c = r(41241);
    const u = r(18050);
    const l = r(6115);
    const p = r(33742);
    const d = r(97659);
    const g = r(8124);
    const m = r(65507);
    function Cast(...e) {
      return a.Cast.apply(a.Cast, e);
    }
    t.Cast = Cast;
    function Create(...e) {
      return u.Create.apply(u.Create, e);
    }
    t.Create = Create;
    function Check(...e) {
      return p.Check.apply(p.Check, e);
    }
    t.Check = Check;
    function Clean(...e) {
      return l.Clean.apply(l.Clean, e);
    }
    t.Clean = Clean;
    function Convert(...e) {
      return c.Convert.apply(c.Convert, e);
    }
    t.Convert = Convert;
    function Clone(e) {
      return (0, A.Clone)(e);
    }
    t.Clone = Clone;
    function Decode(...e) {
      const [t, r, o] = e.length === 3 ? [e[0], e[1], e[2]] : [e[0], [], e[1]];
      if (!Check(t, r, o)) throw new n.TransformDecodeCheckError(t, o, Errors(t, r, o).First());
      return (0, n.HasTransform)(t, r) ? (0, n.TransformDecode)(t, r, o) : o;
    }
    t.Decode = Decode;
    function Default(...e) {
      return d.Default.apply(d.Default, e);
    }
    t.Default = Default;
    function Encode(...e) {
      const [t, r, o] = e.length === 3 ? [e[0], e[1], e[2]] : [e[0], [], e[1]];
      const s = (0, n.HasTransform)(t, r) ? (0, n.TransformEncode)(t, r, o) : o;
      if (!Check(t, r, s)) throw new n.TransformEncodeCheckError(t, s, Errors(t, r, s).First());
      return s;
    }
    t.Encode = Encode;
    function Errors(...e) {
      return m.Errors.apply(m.Errors, e);
    }
    t.Errors = Errors;
    function Equal(e, t) {
      return (0, i.Equal)(e, t);
    }
    t.Equal = Equal;
    function Diff(e, t) {
      return (0, g.Diff)(e, t);
    }
    t.Diff = Diff;
    function Hash(e) {
      return (0, s.Hash)(e);
    }
    t.Hash = Hash;
    function Patch(e, t) {
      return (0, g.Patch)(e, t);
    }
    t.Patch = Patch;
    function Mutate(e, t) {
      (0, o.Mutate)(e, t);
    }
    t.Mutate = Mutate;
  },
  52732: (e, t, r) => {
    var n = r(11063);
    var o = r(22027);
    var s = r(59934);
    var i = Function.bind;
    var a = i.bind(i);
    function bindApi(e, t, r) {
      var n = a(s, null).apply(null, r ? [t, r] : [t]);
      e.api = { remove: n };
      e.remove = n;
      ["before", "error", "after", "wrap"].forEach(function (n) {
        var s = r ? [t, n, r] : [t, n];
        e[n] = e.api[n] = a(o, null).apply(null, s);
      });
    }
    function HookSingular() {
      var e = "h";
      var t = { registry: {} };
      var r = n.bind(null, t, e);
      bindApi(r, t, e);
      return r;
    }
    function HookCollection() {
      var e = { registry: {} };
      var t = n.bind(null, e);
      bindApi(t, e);
      return t;
    }
    var A = false;
    function Hook() {
      if (!A) {
        console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
        A = true;
      }
      return HookCollection();
    }
    Hook.Singular = HookSingular.bind();
    Hook.Collection = HookCollection.bind();
    e.exports = Hook;
    e.exports.Hook = Hook;
    e.exports.Singular = Hook.Singular;
    e.exports.Collection = Hook.Collection;
  },
  22027: (e) => {
    e.exports = addHook;
    function addHook(e, t, r, n) {
      var o = n;
      if (!e.registry[r]) {
        e.registry[r] = [];
      }
      if (t === "before") {
        n = function (e, t) {
          return Promise.resolve().then(o.bind(null, t)).then(e.bind(null, t));
        };
      }
      if (t === "after") {
        n = function (e, t) {
          var r;
          return Promise.resolve()
            .then(e.bind(null, t))
            .then(function (e) {
              r = e;
              return o(r, t);
            })
            .then(function () {
              return r;
            });
        };
      }
      if (t === "error") {
        n = function (e, t) {
          return Promise.resolve()
            .then(e.bind(null, t))
            .catch(function (e) {
              return o(e, t);
            });
        };
      }
      e.registry[r].push({ hook: n, orig: o });
    }
  },
  11063: (e) => {
    e.exports = register;
    function register(e, t, r, n) {
      if (typeof r !== "function") {
        throw new Error("method for before hook must be a function");
      }
      if (!n) {
        n = {};
      }
      if (Array.isArray(t)) {
        return t.reverse().reduce(function (t, r) {
          return register.bind(null, e, r, t, n);
        }, r)();
      }
      return Promise.resolve().then(function () {
        if (!e.registry[t]) {
          return r(n);
        }
        return e.registry[t].reduce(function (e, t) {
          return t.hook.bind(null, e, n);
        }, r)();
      });
    }
  },
  59934: (e) => {
    e.exports = removeHook;
    function removeHook(e, t, r) {
      if (!e.registry[t]) {
        return;
      }
      var n = e.registry[t]
        .map(function (e) {
          return e.orig;
        })
        .indexOf(r);
      if (n === -1) {
        return;
      }
      e.registry[t].splice(n, 1);
    }
  },
  14150: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    class Deprecation extends Error {
      constructor(e) {
        super(e);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        }
        this.name = "Deprecation";
      }
    }
    t.Deprecation = Deprecation;
  },
  18889: (e, t, r) => {
    const n = r(79896);
    const o = r(16928);
    const s = r(70857);
    const i = r(76982);
    const a = r(80056);
    const A = a.version;
    const c = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/gm;
    function parse(e) {
      const t = {};
      let r = e.toString();
      r = r.replace(/\r\n?/gm, "\n");
      let n;
      while ((n = c.exec(r)) != null) {
        const e = n[1];
        let r = n[2] || "";
        r = r.trim();
        const o = r[0];
        r = r.replace(/^(['"`])([\s\S]*)\1$/gm, "$2");
        if (o === '"') {
          r = r.replace(/\\n/g, "\n");
          r = r.replace(/\\r/g, "\r");
        }
        t[e] = r;
      }
      return t;
    }
    function _parseVault(e) {
      const t = _vaultPath(e);
      const r = u.configDotenv({ path: t });
      if (!r.parsed) {
        const e = new Error(`MISSING_DATA: Cannot parse ${t} for an unknown reason`);
        e.code = "MISSING_DATA";
        throw e;
      }
      const n = _dotenvKey(e).split(",");
      const o = n.length;
      let s;
      for (let e = 0; e < o; e++) {
        try {
          const t = n[e].trim();
          const o = _instructions(r, t);
          s = u.decrypt(o.ciphertext, o.key);
          break;
        } catch (t) {
          if (e + 1 >= o) {
            throw t;
          }
        }
      }
      return u.parse(s);
    }
    function _log(e) {
      console.log(`[dotenv@${A}][INFO] ${e}`);
    }
    function _warn(e) {
      console.log(`[dotenv@${A}][WARN] ${e}`);
    }
    function _debug(e) {
      console.log(`[dotenv@${A}][DEBUG] ${e}`);
    }
    function _dotenvKey(e) {
      if (e && e.DOTENV_KEY && e.DOTENV_KEY.length > 0) {
        return e.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(e, t) {
      let r;
      try {
        r = new URL(t);
      } catch (e) {
        if (e.code === "ERR_INVALID_URL") {
          const e = new Error(
            "INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development"
          );
          e.code = "INVALID_DOTENV_KEY";
          throw e;
        }
        throw e;
      }
      const n = r.password;
      if (!n) {
        const e = new Error("INVALID_DOTENV_KEY: Missing key part");
        e.code = "INVALID_DOTENV_KEY";
        throw e;
      }
      const o = r.searchParams.get("environment");
      if (!o) {
        const e = new Error("INVALID_DOTENV_KEY: Missing environment part");
        e.code = "INVALID_DOTENV_KEY";
        throw e;
      }
      const s = `DOTENV_VAULT_${o.toUpperCase()}`;
      const i = e.parsed[s];
      if (!i) {
        const e = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${s} in your .env.vault file.`);
        e.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw e;
      }
      return { ciphertext: i, key: n };
    }
    function _vaultPath(e) {
      let t = null;
      if (e && e.path && e.path.length > 0) {
        if (Array.isArray(e.path)) {
          for (const r of e.path) {
            if (n.existsSync(r)) {
              t = r.endsWith(".vault") ? r : `${r}.vault`;
            }
          }
        } else {
          t = e.path.endsWith(".vault") ? e.path : `${e.path}.vault`;
        }
      } else {
        t = o.resolve(process.cwd(), ".env.vault");
      }
      if (n.existsSync(t)) {
        return t;
      }
      return null;
    }
    function _resolveHome(e) {
      return e[0] === "~" ? o.join(s.homedir(), e.slice(1)) : e;
    }
    function _configVault(e) {
      _log("Loading env from encrypted .env.vault");
      const t = u._parseVault(e);
      let r = process.env;
      if (e && e.processEnv != null) {
        r = e.processEnv;
      }
      u.populate(r, t, e);
      return { parsed: t };
    }
    function configDotenv(e) {
      const t = o.resolve(process.cwd(), ".env");
      let r = "utf8";
      const s = Boolean(e && e.debug);
      if (e && e.encoding) {
        r = e.encoding;
      } else {
        if (s) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let i = [t];
      if (e && e.path) {
        if (!Array.isArray(e.path)) {
          i = [_resolveHome(e.path)];
        } else {
          i = [];
          for (const t of e.path) {
            i.push(_resolveHome(t));
          }
        }
      }
      let a;
      const A = {};
      for (const t of i) {
        try {
          const o = u.parse(n.readFileSync(t, { encoding: r }));
          u.populate(A, o, e);
        } catch (e) {
          if (s) {
            _debug(`Failed to load ${t} ${e.message}`);
          }
          a = e;
        }
      }
      let c = process.env;
      if (e && e.processEnv != null) {
        c = e.processEnv;
      }
      u.populate(c, A, e);
      if (a) {
        return { parsed: A, error: a };
      } else {
        return { parsed: A };
      }
    }
    function config(e) {
      if (_dotenvKey(e).length === 0) {
        return u.configDotenv(e);
      }
      const t = _vaultPath(e);
      if (!t) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${t}. Did you forget to build it?`);
        return u.configDotenv(e);
      }
      return u._configVault(e);
    }
    function decrypt(e, t) {
      const r = Buffer.from(t.slice(-64), "hex");
      let n = Buffer.from(e, "base64");
      const o = n.subarray(0, 12);
      const s = n.subarray(-16);
      n = n.subarray(12, -16);
      try {
        const e = i.createDecipheriv("aes-256-gcm", r, o);
        e.setAuthTag(s);
        return `${e.update(n)}${e.final()}`;
      } catch (e) {
        const t = e instanceof RangeError;
        const r = e.message === "Invalid key length";
        const n = e.message === "Unsupported state or unable to authenticate data";
        if (t || r) {
          const e = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          e.code = "INVALID_DOTENV_KEY";
          throw e;
        } else if (n) {
          const e = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          e.code = "DECRYPTION_FAILED";
          throw e;
        } else {
          throw e;
        }
      }
    }
    function populate(e, t, r = {}) {
      const n = Boolean(r && r.debug);
      const o = Boolean(r && r.override);
      if (typeof t !== "object") {
        const e = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        e.code = "OBJECT_REQUIRED";
        throw e;
      }
      for (const r of Object.keys(t)) {
        if (Object.prototype.hasOwnProperty.call(e, r)) {
          if (o === true) {
            e[r] = t[r];
          }
          if (n) {
            if (o === true) {
              _debug(`"${r}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${r}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          e[r] = t[r];
        }
      }
    }
    const u = {
      configDotenv: configDotenv,
      _configVault: _configVault,
      _parseVault: _parseVault,
      config: config,
      decrypt: decrypt,
      parse: parse,
      populate: populate,
    };
    e.exports.configDotenv = u.configDotenv;
    e.exports._configVault = u._configVault;
    e.exports._parseVault = u._parseVault;
    e.exports.config = u.config;
    e.exports.decrypt = u.decrypt;
    e.exports.parse = u.parse;
    e.exports.populate = u.populate;
    e.exports = u;
  },
  70744: (e) => {
    var t = 1e3;
    var r = t * 60;
    var n = r * 60;
    var o = n * 24;
    var s = o * 7;
    var i = o * 365.25;
    e.exports = function (e, t) {
      t = t || {};
      var r = typeof e;
      if (r === "string" && e.length > 0) {
        return parse(e);
      } else if (r === "number" && isFinite(e)) {
        return t.long ? fmtLong(e) : fmtShort(e);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(e));
    };
    function parse(e) {
      e = String(e);
      if (e.length > 100) {
        return;
      }
      var a = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(e);
      if (!a) {
        return;
      }
      var A = parseFloat(a[1]);
      var c = (a[2] || "ms").toLowerCase();
      switch (c) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return A * i;
        case "weeks":
        case "week":
        case "w":
          return A * s;
        case "days":
        case "day":
        case "d":
          return A * o;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return A * n;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return A * r;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return A * t;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return A;
        default:
          return undefined;
      }
    }
    function fmtShort(e) {
      var s = Math.abs(e);
      if (s >= o) {
        return Math.round(e / o) + "d";
      }
      if (s >= n) {
        return Math.round(e / n) + "h";
      }
      if (s >= r) {
        return Math.round(e / r) + "m";
      }
      if (s >= t) {
        return Math.round(e / t) + "s";
      }
      return e + "ms";
    }
    function fmtLong(e) {
      var s = Math.abs(e);
      if (s >= o) {
        return plural(e, s, o, "day");
      }
      if (s >= n) {
        return plural(e, s, n, "hour");
      }
      if (s >= r) {
        return plural(e, s, r, "minute");
      }
      if (s >= t) {
        return plural(e, s, t, "second");
      }
      return e + " ms";
    }
    function plural(e, t, r, n) {
      var o = t >= r * 1.5;
      return Math.round(e / r) + " " + n + (o ? "s" : "");
    }
  },
  55560: (e, t, r) => {
    var n = r(58264);
    e.exports = n(once);
    e.exports.strict = n(onceStrict);
    once.proto = once(function () {
      Object.defineProperty(Function.prototype, "once", {
        value: function () {
          return once(this);
        },
        configurable: true,
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: function () {
          return onceStrict(this);
        },
        configurable: true,
      });
    });
    function once(e) {
      var f = function () {
        if (f.called) return f.value;
        f.called = true;
        return (f.value = e.apply(this, arguments));
      };
      f.called = false;
      return f;
    }
    function onceStrict(e) {
      var f = function () {
        if (f.called) throw new Error(f.onceError);
        f.called = true;
        return (f.value = e.apply(this, arguments));
      };
      var t = e.name || "Function wrapped with `once`";
      f.onceError = t + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
  },
  61860: (e) => {
    var t;
    var r;
    var n;
    var o;
    var s;
    var i;
    var a;
    var A;
    var c;
    var u;
    var l;
    var p;
    var d;
    var g;
    var m;
    var h;
    var E;
    var I;
    var y;
    var C;
    var b;
    var Q;
    var B;
    var T;
    var v;
    var w;
    var _;
    var R;
    var O;
    var F;
    var D;
    (function (t) {
      var r = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
      if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (e) {
          t(createExporter(r, createExporter(e)));
        });
      } else if (true && typeof e.exports === "object") {
        t(createExporter(r, createExporter(e.exports)));
      } else {
        t(createExporter(r));
      }
      function createExporter(e, t) {
        if (e !== r) {
          if (typeof Object.create === "function") {
            Object.defineProperty(e, "__esModule", { value: true });
          } else {
            e.__esModule = true;
          }
        }
        return function (r, n) {
          return (e[r] = t ? t(r, n) : n);
        };
      }
    })(function (e) {
      var k =
        Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array &&
          function (e, t) {
            e.__proto__ = t;
          }) ||
        function (e, t) {
          for (var r in t) if (Object.prototype.hasOwnProperty.call(t, r)) e[r] = t[r];
        };
      t = function (e, t) {
        if (typeof t !== "function" && t !== null) throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
        k(e, t);
        function __() {
          this.constructor = e;
        }
        e.prototype = t === null ? Object.create(t) : ((__.prototype = t.prototype), new __());
      };
      r =
        Object.assign ||
        function (e) {
          for (var t, r = 1, n = arguments.length; r < n; r++) {
            t = arguments[r];
            for (var o in t) if (Object.prototype.hasOwnProperty.call(t, o)) e[o] = t[o];
          }
          return e;
        };
      n = function (e, t) {
        var r = {};
        for (var n in e) if (Object.prototype.hasOwnProperty.call(e, n) && t.indexOf(n) < 0) r[n] = e[n];
        if (e != null && typeof Object.getOwnPropertySymbols === "function")
          for (var o = 0, n = Object.getOwnPropertySymbols(e); o < n.length; o++) {
            if (t.indexOf(n[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, n[o])) r[n[o]] = e[n[o]];
          }
        return r;
      };
      o = function (e, t, r, n) {
        var o = arguments.length,
          s = o < 3 ? t : n === null ? (n = Object.getOwnPropertyDescriptor(t, r)) : n,
          i;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") s = Reflect.decorate(e, t, r, n);
        else for (var a = e.length - 1; a >= 0; a--) if ((i = e[a])) s = (o < 3 ? i(s) : o > 3 ? i(t, r, s) : i(t, r)) || s;
        return o > 3 && s && Object.defineProperty(t, r, s), s;
      };
      s = function (e, t) {
        return function (r, n) {
          t(r, n, e);
        };
      };
      i = function (e, t, r, n, o, s) {
        function accept(e) {
          if (e !== void 0 && typeof e !== "function") throw new TypeError("Function expected");
          return e;
        }
        var i = n.kind,
          a = i === "getter" ? "get" : i === "setter" ? "set" : "value";
        var A = !t && e ? (n["static"] ? e : e.prototype) : null;
        var c = t || (A ? Object.getOwnPropertyDescriptor(A, n.name) : {});
        var u,
          l = false;
        for (var p = r.length - 1; p >= 0; p--) {
          var d = {};
          for (var g in n) d[g] = g === "access" ? {} : n[g];
          for (var g in n.access) d.access[g] = n.access[g];
          d.addInitializer = function (e) {
            if (l) throw new TypeError("Cannot add initializers after decoration has completed");
            s.push(accept(e || null));
          };
          var m = (0, r[p])(i === "accessor" ? { get: c.get, set: c.set } : c[a], d);
          if (i === "accessor") {
            if (m === void 0) continue;
            if (m === null || typeof m !== "object") throw new TypeError("Object expected");
            if ((u = accept(m.get))) c.get = u;
            if ((u = accept(m.set))) c.set = u;
            if ((u = accept(m.init))) o.unshift(u);
          } else if ((u = accept(m))) {
            if (i === "field") o.unshift(u);
            else c[a] = u;
          }
        }
        if (A) Object.defineProperty(A, n.name, c);
        l = true;
      };
      a = function (e, t, r) {
        var n = arguments.length > 2;
        for (var o = 0; o < t.length; o++) {
          r = n ? t[o].call(e, r) : t[o].call(e);
        }
        return n ? r : void 0;
      };
      A = function (e) {
        return typeof e === "symbol" ? e : "".concat(e);
      };
      c = function (e, t, r) {
        if (typeof t === "symbol") t = t.description ? "[".concat(t.description, "]") : "";
        return Object.defineProperty(e, "name", { configurable: true, value: r ? "".concat(r, " ", t) : t });
      };
      u = function (e, t) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(e, t);
      };
      l = function (e, t, r, n) {
        function adopt(e) {
          return e instanceof r
            ? e
            : new r(function (t) {
                t(e);
              });
        }
        return new (r || (r = Promise))(function (r, o) {
          function fulfilled(e) {
            try {
              step(n.next(e));
            } catch (e) {
              o(e);
            }
          }
          function rejected(e) {
            try {
              step(n["throw"](e));
            } catch (e) {
              o(e);
            }
          }
          function step(e) {
            e.done ? r(e.value) : adopt(e.value).then(fulfilled, rejected);
          }
          step((n = n.apply(e, t || [])).next());
        });
      };
      p = function (e, t) {
        var r = {
            label: 0,
            sent: function () {
              if (s[0] & 1) throw s[1];
              return s[1];
            },
            trys: [],
            ops: [],
          },
          n,
          o,
          s,
          i;
        return (
          (i = { next: verb(0), throw: verb(1), return: verb(2) }),
          typeof Symbol === "function" &&
            (i[Symbol.iterator] = function () {
              return this;
            }),
          i
        );
        function verb(e) {
          return function (t) {
            return step([e, t]);
          };
        }
        function step(a) {
          if (n) throw new TypeError("Generator is already executing.");
          while ((i && ((i = 0), a[0] && (r = 0)), r))
            try {
              if (
                ((n = 1), o && (s = a[0] & 2 ? o["return"] : a[0] ? o["throw"] || ((s = o["return"]) && s.call(o), 0) : o.next) && !(s = s.call(o, a[1])).done)
              )
                return s;
              if (((o = 0), s)) a = [a[0] & 2, s.value];
              switch (a[0]) {
                case 0:
                case 1:
                  s = a;
                  break;
                case 4:
                  r.label++;
                  return { value: a[1], done: false };
                case 5:
                  r.label++;
                  o = a[1];
                  a = [0];
                  continue;
                case 7:
                  a = r.ops.pop();
                  r.trys.pop();
                  continue;
                default:
                  if (!((s = r.trys), (s = s.length > 0 && s[s.length - 1])) && (a[0] === 6 || a[0] === 2)) {
                    r = 0;
                    continue;
                  }
                  if (a[0] === 3 && (!s || (a[1] > s[0] && a[1] < s[3]))) {
                    r.label = a[1];
                    break;
                  }
                  if (a[0] === 6 && r.label < s[1]) {
                    r.label = s[1];
                    s = a;
                    break;
                  }
                  if (s && r.label < s[2]) {
                    r.label = s[2];
                    r.ops.push(a);
                    break;
                  }
                  if (s[2]) r.ops.pop();
                  r.trys.pop();
                  continue;
              }
              a = t.call(e, r);
            } catch (e) {
              a = [6, e];
              o = 0;
            } finally {
              n = s = 0;
            }
          if (a[0] & 5) throw a[1];
          return { value: a[0] ? a[1] : void 0, done: true };
        }
      };
      d = function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) O(t, e, r);
      };
      O = Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          };
      g = function (e) {
        var t = typeof Symbol === "function" && Symbol.iterator,
          r = t && e[t],
          n = 0;
        if (r) return r.call(e);
        if (e && typeof e.length === "number")
          return {
            next: function () {
              if (e && n >= e.length) e = void 0;
              return { value: e && e[n++], done: !e };
            },
          };
        throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      m = function (e, t) {
        var r = typeof Symbol === "function" && e[Symbol.iterator];
        if (!r) return e;
        var n = r.call(e),
          o,
          s = [],
          i;
        try {
          while ((t === void 0 || t-- > 0) && !(o = n.next()).done) s.push(o.value);
        } catch (e) {
          i = { error: e };
        } finally {
          try {
            if (o && !o.done && (r = n["return"])) r.call(n);
          } finally {
            if (i) throw i.error;
          }
        }
        return s;
      };
      h = function () {
        for (var e = [], t = 0; t < arguments.length; t++) e = e.concat(m(arguments[t]));
        return e;
      };
      E = function () {
        for (var e = 0, t = 0, r = arguments.length; t < r; t++) e += arguments[t].length;
        for (var n = Array(e), o = 0, t = 0; t < r; t++) for (var s = arguments[t], i = 0, a = s.length; i < a; i++, o++) n[o] = s[i];
        return n;
      };
      I = function (e, t, r) {
        if (r || arguments.length === 2)
          for (var n = 0, o = t.length, s; n < o; n++) {
            if (s || !(n in t)) {
              if (!s) s = Array.prototype.slice.call(t, 0, n);
              s[n] = t[n];
            }
          }
        return e.concat(s || Array.prototype.slice.call(t));
      };
      y = function (e) {
        return this instanceof y ? ((this.v = e), this) : new y(e);
      };
      C = function (e, t, r) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var n = r.apply(e, t || []),
          o,
          s = [];
        return (
          (o = {}),
          verb("next"),
          verb("throw"),
          verb("return", awaitReturn),
          (o[Symbol.asyncIterator] = function () {
            return this;
          }),
          o
        );
        function awaitReturn(e) {
          return function (t) {
            return Promise.resolve(t).then(e, reject);
          };
        }
        function verb(e, t) {
          if (n[e]) {
            o[e] = function (t) {
              return new Promise(function (r, n) {
                s.push([e, t, r, n]) > 1 || resume(e, t);
              });
            };
            if (t) o[e] = t(o[e]);
          }
        }
        function resume(e, t) {
          try {
            step(n[e](t));
          } catch (e) {
            settle(s[0][3], e);
          }
        }
        function step(e) {
          e.value instanceof y ? Promise.resolve(e.value.v).then(fulfill, reject) : settle(s[0][2], e);
        }
        function fulfill(e) {
          resume("next", e);
        }
        function reject(e) {
          resume("throw", e);
        }
        function settle(e, t) {
          if ((e(t), s.shift(), s.length)) resume(s[0][0], s[0][1]);
        }
      };
      b = function (e) {
        var t, r;
        return (
          (t = {}),
          verb("next"),
          verb("throw", function (e) {
            throw e;
          }),
          verb("return"),
          (t[Symbol.iterator] = function () {
            return this;
          }),
          t
        );
        function verb(n, o) {
          t[n] = e[n]
            ? function (t) {
                return (r = !r) ? { value: y(e[n](t)), done: false } : o ? o(t) : t;
              }
            : o;
        }
      };
      Q = function (e) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var t = e[Symbol.asyncIterator],
          r;
        return t
          ? t.call(e)
          : ((e = typeof g === "function" ? g(e) : e[Symbol.iterator]()),
            (r = {}),
            verb("next"),
            verb("throw"),
            verb("return"),
            (r[Symbol.asyncIterator] = function () {
              return this;
            }),
            r);
        function verb(t) {
          r[t] =
            e[t] &&
            function (r) {
              return new Promise(function (n, o) {
                (r = e[t](r)), settle(n, o, r.done, r.value);
              });
            };
        }
        function settle(e, t, r, n) {
          Promise.resolve(n).then(function (t) {
            e({ value: t, done: r });
          }, t);
        }
      };
      B = function (e, t) {
        if (Object.defineProperty) {
          Object.defineProperty(e, "raw", { value: t });
        } else {
          e.raw = t;
        }
        return e;
      };
      var S = Object.create
        ? function (e, t) {
            Object.defineProperty(e, "default", { enumerable: true, value: t });
          }
        : function (e, t) {
            e["default"] = t;
          };
      T = function (e) {
        if (e && e.__esModule) return e;
        var t = {};
        if (e != null) for (var r in e) if (r !== "default" && Object.prototype.hasOwnProperty.call(e, r)) O(t, e, r);
        S(t, e);
        return t;
      };
      v = function (e) {
        return e && e.__esModule ? e : { default: e };
      };
      w = function (e, t, r, n) {
        if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
        if (typeof t === "function" ? e !== t || !n : !t.has(e))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
      };
      _ = function (e, t, r, n, o) {
        if (n === "m") throw new TypeError("Private method is not writable");
        if (n === "a" && !o) throw new TypeError("Private accessor was defined without a setter");
        if (typeof t === "function" ? e !== t || !o : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return n === "a" ? o.call(e, r) : o ? (o.value = r) : t.set(e, r), r;
      };
      R = function (e, t) {
        if (t === null || (typeof t !== "object" && typeof t !== "function")) throw new TypeError("Cannot use 'in' operator on non-object");
        return typeof e === "function" ? t === e : e.has(t);
      };
      F = function (e, t, r) {
        if (t !== null && t !== void 0) {
          if (typeof t !== "object" && typeof t !== "function") throw new TypeError("Object expected.");
          var n, o;
          if (r) {
            if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
            n = t[Symbol.asyncDispose];
          }
          if (n === void 0) {
            if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
            n = t[Symbol.dispose];
            if (r) o = n;
          }
          if (typeof n !== "function") throw new TypeError("Object not disposable.");
          if (o)
            n = function () {
              try {
                o.call(this);
              } catch (e) {
                return Promise.reject(e);
              }
            };
          e.stack.push({ value: t, dispose: n, async: r });
        } else if (r) {
          e.stack.push({ async: true });
        }
        return t;
      };
      var N =
        typeof SuppressedError === "function"
          ? SuppressedError
          : function (e, t, r) {
              var n = new Error(r);
              return (n.name = "SuppressedError"), (n.error = e), (n.suppressed = t), n;
            };
      D = function (e) {
        function fail(t) {
          e.error = e.hasError ? new N(t, e.error, "An error was suppressed during disposal.") : t;
          e.hasError = true;
        }
        function next() {
          while (e.stack.length) {
            var t = e.stack.pop();
            try {
              var r = t.dispose && t.dispose.call(t.value);
              if (t.async)
                return Promise.resolve(r).then(next, function (e) {
                  fail(e);
                  return next();
                });
            } catch (e) {
              fail(e);
            }
          }
          if (e.hasError) throw e.error;
        }
        return next();
      };
      e("__extends", t);
      e("__assign", r);
      e("__rest", n);
      e("__decorate", o);
      e("__param", s);
      e("__esDecorate", i);
      e("__runInitializers", a);
      e("__propKey", A);
      e("__setFunctionName", c);
      e("__metadata", u);
      e("__awaiter", l);
      e("__generator", p);
      e("__exportStar", d);
      e("__createBinding", O);
      e("__values", g);
      e("__read", m);
      e("__spread", h);
      e("__spreadArrays", E);
      e("__spreadArray", I);
      e("__await", y);
      e("__asyncGenerator", C);
      e("__asyncDelegator", b);
      e("__asyncValues", Q);
      e("__makeTemplateObject", B);
      e("__importStar", T);
      e("__importDefault", v);
      e("__classPrivateFieldGet", w);
      e("__classPrivateFieldSet", _);
      e("__classPrivateFieldIn", R);
      e("__addDisposableResource", F);
      e("__disposeResources", D);
    });
  },
  20770: (e, t, r) => {
    e.exports = r(20218);
  },
  20218: (e, t, r) => {
    var n = r(69278);
    var o = r(64756);
    var s = r(58611);
    var i = r(65692);
    var a = r(24434);
    var A = r(42613);
    var c = r(39023);
    t.httpOverHttp = httpOverHttp;
    t.httpsOverHttp = httpsOverHttp;
    t.httpOverHttps = httpOverHttps;
    t.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(e) {
      var t = new TunnelingAgent(e);
      t.request = s.request;
      return t;
    }
    function httpsOverHttp(e) {
      var t = new TunnelingAgent(e);
      t.request = s.request;
      t.createSocket = createSecureSocket;
      t.defaultPort = 443;
      return t;
    }
    function httpOverHttps(e) {
      var t = new TunnelingAgent(e);
      t.request = i.request;
      return t;
    }
    function httpsOverHttps(e) {
      var t = new TunnelingAgent(e);
      t.request = i.request;
      t.createSocket = createSecureSocket;
      t.defaultPort = 443;
      return t;
    }
    function TunnelingAgent(e) {
      var t = this;
      t.options = e || {};
      t.proxyOptions = t.options.proxy || {};
      t.maxSockets = t.options.maxSockets || s.Agent.defaultMaxSockets;
      t.requests = [];
      t.sockets = [];
      t.on("free", function onFree(e, r, n, o) {
        var s = toOptions(r, n, o);
        for (var i = 0, a = t.requests.length; i < a; ++i) {
          var A = t.requests[i];
          if (A.host === s.host && A.port === s.port) {
            t.requests.splice(i, 1);
            A.request.onSocket(e);
            return;
          }
        }
        e.destroy();
        t.removeSocket(e);
      });
    }
    c.inherits(TunnelingAgent, a.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(e, t, r, n) {
      var o = this;
      var s = mergeOptions({ request: e }, o.options, toOptions(t, r, n));
      if (o.sockets.length >= this.maxSockets) {
        o.requests.push(s);
        return;
      }
      o.createSocket(s, function (t) {
        t.on("free", onFree);
        t.on("close", onCloseOrRemove);
        t.on("agentRemove", onCloseOrRemove);
        e.onSocket(t);
        function onFree() {
          o.emit("free", t, s);
        }
        function onCloseOrRemove(e) {
          o.removeSocket(t);
          t.removeListener("free", onFree);
          t.removeListener("close", onCloseOrRemove);
          t.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(e, t) {
      var r = this;
      var n = {};
      r.sockets.push(n);
      var o = mergeOptions({}, r.proxyOptions, { method: "CONNECT", path: e.host + ":" + e.port, agent: false, headers: { host: e.host + ":" + e.port } });
      if (e.localAddress) {
        o.localAddress = e.localAddress;
      }
      if (o.proxyAuth) {
        o.headers = o.headers || {};
        o.headers["Proxy-Authorization"] = "Basic " + new Buffer(o.proxyAuth).toString("base64");
      }
      u("making CONNECT request");
      var s = r.request(o);
      s.useChunkedEncodingByDefault = false;
      s.once("response", onResponse);
      s.once("upgrade", onUpgrade);
      s.once("connect", onConnect);
      s.once("error", onError);
      s.end();
      function onResponse(e) {
        e.upgrade = true;
      }
      function onUpgrade(e, t, r) {
        process.nextTick(function () {
          onConnect(e, t, r);
        });
      }
      function onConnect(o, i, a) {
        s.removeAllListeners();
        i.removeAllListeners();
        if (o.statusCode !== 200) {
          u("tunneling socket could not be established, statusCode=%d", o.statusCode);
          i.destroy();
          var A = new Error("tunneling socket could not be established, " + "statusCode=" + o.statusCode);
          A.code = "ECONNRESET";
          e.request.emit("error", A);
          r.removeSocket(n);
          return;
        }
        if (a.length > 0) {
          u("got illegal response body from proxy");
          i.destroy();
          var A = new Error("got illegal response body from proxy");
          A.code = "ECONNRESET";
          e.request.emit("error", A);
          r.removeSocket(n);
          return;
        }
        u("tunneling connection has established");
        r.sockets[r.sockets.indexOf(n)] = i;
        return t(i);
      }
      function onError(t) {
        s.removeAllListeners();
        u("tunneling socket could not be established, cause=%s\n", t.message, t.stack);
        var o = new Error("tunneling socket could not be established, " + "cause=" + t.message);
        o.code = "ECONNRESET";
        e.request.emit("error", o);
        r.removeSocket(n);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(e) {
      var t = this.sockets.indexOf(e);
      if (t === -1) {
        return;
      }
      this.sockets.splice(t, 1);
      var r = this.requests.shift();
      if (r) {
        this.createSocket(r, function (e) {
          r.request.onSocket(e);
        });
      }
    };
    function createSecureSocket(e, t) {
      var r = this;
      TunnelingAgent.prototype.createSocket.call(r, e, function (n) {
        var s = e.request.getHeader("host");
        var i = mergeOptions({}, r.options, { socket: n, servername: s ? s.replace(/:.*$/, "") : e.host });
        var a = o.connect(0, i);
        r.sockets[r.sockets.indexOf(n)] = a;
        t(a);
      });
    }
    function toOptions(e, t, r) {
      if (typeof e === "string") {
        return { host: e, port: t, localAddress: r };
      }
      return e;
    }
    function mergeOptions(e) {
      for (var t = 1, r = arguments.length; t < r; ++t) {
        var n = arguments[t];
        if (typeof n === "object") {
          var o = Object.keys(n);
          for (var s = 0, i = o.length; s < i; ++s) {
            var a = o[s];
            if (n[a] !== undefined) {
              e[a] = n[a];
            }
          }
        }
      }
      return e;
    }
    var u;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      u = function () {
        var e = Array.prototype.slice.call(arguments);
        if (typeof e[0] === "string") {
          e[0] = "TUNNEL: " + e[0];
        } else {
          e.unshift("TUNNEL:");
        }
        console.error.apply(console, e);
      };
    } else {
      u = function () {};
    }
    t.debug = u;
  },
  893: function (e, t, r) {
    var n =
      (this && this.__classPrivateFieldSet) ||
      function (e, t, r, n, o) {
        if (n === "m") throw new TypeError("Private method is not writable");
        if (n === "a" && !o) throw new TypeError("Private accessor was defined without a setter");
        if (typeof t === "function" ? e !== t || !o : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return n === "a" ? o.call(e, r) : o ? (o.value = r) : t.set(e, r), r;
      };
    var o =
      (this && this.__classPrivateFieldGet) ||
      function (e, t, r, n) {
        if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
        if (typeof t === "function" ? e !== t || !n : !t.has(e))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
      };
    var s;
    Object.defineProperty(t, "__esModule", { value: true });
    t.AbstractCompilingTypedUnionValidator = void 0;
    const i = r(45105);
    const a = r(25269);
    const A = r(73422);
    const c = r(17085);
    class AbstractCompilingTypedUnionValidator extends A.AbstractTypedUnionValidator {
      constructor(e) {
        super(e);
        s.set(this, void 0);
        n(this, s, new Array(e.anyOf.length), "f");
      }
      test(e) {
        const t = this.compiledFindSchemaMemberIndex(e);
        return this.compiledSchemaMemberTest(t, e);
      }
      errors(e) {
        const t = this.compiledFindSchemaMemberIndexOrError(e);
        if (typeof t !== "number") {
          return (0, c.createUnionTypeErrorIterable)(t);
        }
        return (0, c.createErrorsIterable)(i.Value.Errors(this.schema.anyOf[t], e));
      }
      assertReturningSchema(e, t) {
        const r = this.compiledFindSchemaMemberIndexOrError(e);
        if (typeof r !== "number") {
          (0, c.throwInvalidAssert)(t, r);
        }
        const n = this.schema.anyOf[r];
        if (!this.compiledSchemaMemberTest(r, e)) {
          (0, c.throwInvalidAssert)(t, i.Value.Errors(n, e).First());
        }
        return n;
      }
      validateReturningSchema(e, t) {
        const r = this.compiledFindSchemaMemberIndexOrError(e);
        if (typeof r !== "number") {
          (0, c.throwInvalidValidate)(t, r);
        }
        const n = this.schema.anyOf[r];
        if (!this.compiledSchemaMemberTest(r, e)) {
          (0, c.throwInvalidValidate)(t, i.Value.Errors(n, e));
        }
        return n;
      }
      compiledFindSchemaMemberIndexOrError(e) {
        const t = this.compiledFindSchemaMemberIndex(e);
        if (t === null) {
          return (0, c.createUnionTypeError)(this.schema, e);
        }
        return t;
      }
      compiledSchemaMemberTest(e, t) {
        if (e === null) {
          return false;
        }
        if (o(this, s, "f")[e] === undefined) {
          let t = a.TypeCompiler.Compile(this.schema.anyOf[e]).Code();
          t = t.replace(`(typeof value === 'object' && value !== null && !Array.isArray(value)) &&`, "");
          const r = t.indexOf("function");
          const n = t.indexOf("return", r);
          t = "return " + t.substring(t.indexOf("(", n), t.length - 1);
          o(this, s, "f")[e] = new Function("value", t);
        }
        return o(this, s, "f")[e](t);
      }
    }
    t.AbstractCompilingTypedUnionValidator = AbstractCompilingTypedUnionValidator;
    s = new WeakMap();
  },
  58453: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.AbstractStandardValidator = void 0;
    const n = r(29293);
    class AbstractStandardValidator extends n.AbstractValidator {
      constructor(e) {
        super(e);
      }
      assertAndClean(e, t) {
        this.assert(e, t);
        this.cleanValue(this.schema, e);
      }
      assertAndCleanCopy(e, t) {
        this.assert(e, t);
        return this.cleanCopyOfValue(this.schema, e);
      }
      validateAndClean(e, t) {
        this.validate(e, t);
        this.cleanValue(this.schema, e);
      }
      validateAndCleanCopy(e, t) {
        this.validate(e, t);
        return this.cleanCopyOfValue(this.schema, e);
      }
    }
    t.AbstractStandardValidator = AbstractStandardValidator;
  },
  73422: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.AbstractTypedUnionValidator = t.DEFAULT_DISCRIMINANT_KEY = void 0;
    const n = r(29293);
    t.DEFAULT_DISCRIMINANT_KEY = "kind";
    class AbstractTypedUnionValidator extends n.AbstractValidator {
      constructor(e) {
        super(e);
      }
      assert(e, t) {
        this.assertReturningSchema(e, t);
      }
      assertAndClean(e, t) {
        const r = this.assertReturningSchema(e, t);
        this.cleanValue(r, e);
      }
      assertAndCleanCopy(e, t) {
        const r = this.assertReturningSchema(e, t);
        return this.cleanCopyOfValue(r, e);
      }
      validate(e, t) {
        this.validateReturningSchema(e, t);
      }
      validateAndClean(e, t) {
        const r = this.validateReturningSchema(e, t);
        this.cleanValue(r, e);
      }
      validateAndCleanCopy(e, t) {
        const r = this.validateReturningSchema(e, t);
        return this.cleanCopyOfValue(r, e);
      }
      toValueKeyDereference(e) {
        return /^[a-zA-Z_$][a-zA-Z_$0-9]*$/.test(e) ? `value.${e}` : `value['${e.replace(/'/g, "\\'")}']`;
      }
    }
    t.AbstractTypedUnionValidator = AbstractTypedUnionValidator;
  },
  29293: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.AbstractValidator = void 0;
    const n = r(45105);
    const o = r(17085);
    class AbstractValidator {
      constructor(e) {
        this.schema = e;
      }
      testReturningErrors(e) {
        return this.test(e) ? null : this.errors(e);
      }
      testReturningFirstError(e) {
        const t = this.testReturningErrors(e);
        if (t === null) {
          return null;
        }
        const r = t[Symbol.iterator]().next();
        return r.done ? null : r.value;
      }
      firstError(e) {
        const t = this.errors(e)[Symbol.iterator]();
        const r = t.next();
        return r.done ? null : r.value;
      }
      cleanCopyOfValue(e, t) {
        if (e.type === "object" && typeof t === "object") {
          const r = {};
          Object.keys(e.properties).forEach((e) => {
            r[e] = t[e];
          });
          return r;
        }
        return t;
      }
      cleanValue(e, t) {
        if (e.type === "object" && typeof t === "object") {
          const r = Object.keys(e.properties);
          Object.getOwnPropertyNames(t).forEach((e) => {
            if (!r.includes(e)) {
              delete t[e];
            }
          });
        }
      }
      uncompiledAssert(e, t, r) {
        if (!n.Value.Check(e, t)) {
          (0, o.throwInvalidAssert)(r, n.Value.Errors(e, t).First());
        }
      }
      uncompiledValidate(e, t, r) {
        if (!n.Value.Check(e, t)) {
          (0, o.throwInvalidValidate)(r, n.Value.Errors(e, t));
        }
      }
    }
    t.AbstractValidator = AbstractValidator;
  },
  26498: function (e, t, r) {
    var n =
      (this && this.__classPrivateFieldSet) ||
      function (e, t, r, n, o) {
        if (n === "m") throw new TypeError("Private method is not writable");
        if (n === "a" && !o) throw new TypeError("Private accessor was defined without a setter");
        if (typeof t === "function" ? e !== t || !o : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return n === "a" ? o.call(e, r) : o ? (o.value = r) : t.set(e, r), r;
      };
    var o =
      (this && this.__classPrivateFieldGet) ||
      function (e, t, r, n) {
        if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
        if (typeof t === "function" ? e !== t || !n : !t.has(e))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
      };
    var s, i;
    Object.defineProperty(t, "__esModule", { value: true });
    t.CompilingDiscriminatedUnionValidator = void 0;
    const a = r(73422);
    const A = r(893);
    class CompilingDiscriminatedUnionValidator extends A.AbstractCompilingTypedUnionValidator {
      constructor(e) {
        var t;
        super(e);
        s.set(this, void 0);
        i.set(this, void 0);
        n(this, s, (t = this.schema.discriminantKey) !== null && t !== void 0 ? t : a.DEFAULT_DISCRIMINANT_KEY, "f");
      }
      compiledFindSchemaMemberIndex(e) {
        if (o(this, i, "f") === undefined) {
          const e = [
            `if (typeof value !== 'object' || value === null || Array.isArray(value)) return null;\n          switch (${this.toValueKeyDereference(o(this, s, "f"))}) {\n`,
          ];
          for (let t = 0; t < this.schema.anyOf.length; ++t) {
            const r = this.schema.anyOf[t].properties[o(this, s, "f")];
            if (r === undefined) {
              throw Error(`Discriminant key '${o(this, s, "f")}' not present in all members of discriminated union`);
            }
            const n = r.const;
            if (typeof n === "string") {
              e.push(`case '${n.replace(/'/g, "\\'")}': return ${t};\n`);
            } else {
              e.push(`case ${n}: return ${t};\n`);
            }
          }
          const t = e.join("") + "default: return null; }";
          n(this, i, new Function("value", t), "f");
        }
        return o(this, i, "f").call(this, e);
      }
    }
    t.CompilingDiscriminatedUnionValidator = CompilingDiscriminatedUnionValidator;
    (s = new WeakMap()), (i = new WeakMap());
  },
  59557: function (e, t, r) {
    var n =
      (this && this.__classPrivateFieldGet) ||
      function (e, t, r, n) {
        if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
        if (typeof t === "function" ? e !== t || !n : !t.has(e))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
      };
    var o =
      (this && this.__classPrivateFieldSet) ||
      function (e, t, r, n, o) {
        if (n === "m") throw new TypeError("Private method is not writable");
        if (n === "a" && !o) throw new TypeError("Private accessor was defined without a setter");
        if (typeof t === "function" ? e !== t || !o : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return n === "a" ? o.call(e, r) : o ? (o.value = r) : t.set(e, r), r;
      };
    var s;
    Object.defineProperty(t, "__esModule", { value: true });
    t.DiscriminatedUnionValidator = void 0;
    const i = r(45105);
    const a = r(73422);
    const A = r(17085);
    class DiscriminatedUnionValidator extends a.AbstractTypedUnionValidator {
      constructor(e) {
        var t;
        super(e);
        s.set(this, false);
        this.discriminantKey = (t = this.schema.discriminantKey) !== null && t !== void 0 ? t : a.DEFAULT_DISCRIMINANT_KEY;
      }
      test(e) {
        const t = this.findSchemaMemberIndex(e);
        if (typeof t !== "number") {
          return false;
        }
        return i.Value.Check(this.schema.anyOf[t], e);
      }
      errors(e) {
        const t = this.findSchemaMemberIndex(e);
        if (typeof t !== "number") {
          return (0, A.createUnionTypeErrorIterable)(t);
        }
        const r = this.schema.anyOf[t];
        return (0, A.createErrorsIterable)(i.Value.Errors(r, e));
      }
      assertReturningSchema(e, t) {
        const r = this.findSchemaMemberIndex(e);
        if (typeof r !== "number") {
          (0, A.throwInvalidAssert)(t, r);
        }
        const n = this.schema.anyOf[r];
        this.uncompiledAssert(n, e, t);
        return n;
      }
      validateReturningSchema(e, t) {
        const r = this.findSchemaMemberIndex(e);
        if (typeof r !== "number") {
          (0, A.throwInvalidValidate)(t, r);
        }
        const n = this.schema.anyOf[r];
        this.uncompiledValidate(n, e, t);
        return n;
      }
      findSchemaMemberIndex(e) {
        if (!n(this, s, "f")) {
          for (const e of this.schema.anyOf) {
            if (e.properties[this.discriminantKey] === undefined) {
              throw Error(`Discriminant key '${this.discriminantKey}' not present in all members of discriminated union`);
            }
          }
          o(this, s, true, "f");
        }
        if (typeof e === "object" && e !== null) {
          const t = e[this.discriminantKey];
          if (t !== undefined) {
            for (let e = 0; e < this.schema.anyOf.length; ++e) {
              const r = this.schema.anyOf[e].properties[this.discriminantKey];
              if (r !== undefined && r.const === t) {
                return e;
              }
            }
          }
        }
        return (0, A.createUnionTypeError)(this.schema, e);
      }
    }
    t.DiscriminatedUnionValidator = DiscriminatedUnionValidator;
    s = new WeakMap();
  },
  96388: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(59557), t);
    o(r(26498), t);
  },
  44574: function (e, t, r) {
    var n =
      (this && this.__classPrivateFieldSet) ||
      function (e, t, r, n, o) {
        if (n === "m") throw new TypeError("Private method is not writable");
        if (n === "a" && !o) throw new TypeError("Private accessor was defined without a setter");
        if (typeof t === "function" ? e !== t || !o : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return n === "a" ? o.call(e, r) : o ? (o.value = r) : t.set(e, r), r;
      };
    var o =
      (this && this.__classPrivateFieldGet) ||
      function (e, t, r, n) {
        if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
        if (typeof t === "function" ? e !== t || !n : !t.has(e))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
      };
    var s, i;
    Object.defineProperty(t, "__esModule", { value: true });
    t.CompilingHeterogeneousUnionValidator = void 0;
    const a = r(893);
    const A = r(25233);
    class CompilingHeterogeneousUnionValidator extends a.AbstractCompilingTypedUnionValidator {
      constructor(e) {
        super(e);
        s.set(this, void 0);
        i.set(this, void 0);
        n(this, s, new A.TypeIdentifyingKeyIndex(e), "f");
      }
      compiledFindSchemaMemberIndex(e) {
        if (o(this, i, "f") === undefined) {
          o(this, s, "f").cacheKeys();
          const e = [`return ((typeof value !== 'object' || value === null || Array.isArray(value)) ? null : `];
          for (let t = 0; t < this.schema.anyOf.length; ++t) {
            const r = o(this, s, "f").keyByMemberIndex[t];
            e.push(`${this.toValueKeyDereference(r)} !== undefined ? ${t} : `);
          }
          n(this, i, new Function("value", e.join("") + "null)"), "f");
        }
        return o(this, i, "f").call(this, e);
      }
    }
    t.CompilingHeterogeneousUnionValidator = CompilingHeterogeneousUnionValidator;
    (s = new WeakMap()), (i = new WeakMap());
  },
  2025: function (e, t, r) {
    var n =
      (this && this.__classPrivateFieldSet) ||
      function (e, t, r, n, o) {
        if (n === "m") throw new TypeError("Private method is not writable");
        if (n === "a" && !o) throw new TypeError("Private accessor was defined without a setter");
        if (typeof t === "function" ? e !== t || !o : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return n === "a" ? o.call(e, r) : o ? (o.value = r) : t.set(e, r), r;
      };
    var o =
      (this && this.__classPrivateFieldGet) ||
      function (e, t, r, n) {
        if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
        if (typeof t === "function" ? e !== t || !n : !t.has(e))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
      };
    var s;
    Object.defineProperty(t, "__esModule", { value: true });
    t.HeterogeneousUnionValidator = void 0;
    const i = r(45105);
    const a = r(73422);
    const A = r(17085);
    const c = r(25233);
    class HeterogeneousUnionValidator extends a.AbstractTypedUnionValidator {
      constructor(e) {
        super(e);
        s.set(this, void 0);
        n(this, s, new c.TypeIdentifyingKeyIndex(e), "f");
      }
      test(e) {
        const t = this.findSchemaMemberIndex(e);
        if (typeof t !== "number") {
          return false;
        }
        return i.Value.Check(this.schema.anyOf[t], e);
      }
      errors(e) {
        const t = this.findSchemaMemberIndex(e);
        if (typeof t !== "number") {
          return (0, A.createUnionTypeErrorIterable)(t);
        }
        const r = this.schema.anyOf[t];
        return (0, A.createErrorsIterable)(i.Value.Errors(r, e));
      }
      assertReturningSchema(e, t) {
        const r = this.findSchemaMemberIndex(e);
        if (typeof r !== "number") {
          (0, A.throwInvalidAssert)(t, r);
        }
        const n = this.schema.anyOf[r];
        this.uncompiledAssert(n, e, t);
        return n;
      }
      validateReturningSchema(e, t) {
        const r = this.findSchemaMemberIndex(e);
        if (typeof r !== "number") {
          (0, A.throwInvalidValidate)(t, r);
        }
        const n = this.schema.anyOf[r];
        this.uncompiledValidate(n, e, t);
        return n;
      }
      findSchemaMemberIndex(e) {
        if (o(this, s, "f").keyByMemberIndex === undefined) {
          o(this, s, "f").cacheKeys();
        }
        if (typeof e === "object" && e !== null) {
          for (let t = 0; t < this.schema.anyOf.length; ++t) {
            const r = o(this, s, "f").keyByMemberIndex[t];
            if (e[r] !== undefined) {
              return t;
            }
          }
        }
        return (0, A.createUnionTypeError)(this.schema, e);
      }
    }
    t.HeterogeneousUnionValidator = HeterogeneousUnionValidator;
    s = new WeakMap();
  },
  29539: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(2025), t);
    o(r(44574), t);
    o(r(5680), t);
  },
  25233: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TypeIdentifyingKeyIndex =
      t.MESSAGE_MEMBERS_MISSING_KEY =
      t.MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY =
      t.MESSAGE_MEMBER_WITH_MULTIPLE_KEYS =
      t.MESSAGE_OPTIONAL_TYPE_ID_KEY =
        void 0;
    const n = r(14019);
    t.MESSAGE_OPTIONAL_TYPE_ID_KEY = "Type identifying key cannot be optional";
    t.MESSAGE_MEMBER_WITH_MULTIPLE_KEYS = "Union has member with multiple identifying keys";
    t.MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY = "Union has multiple members with same identifying key";
    t.MESSAGE_MEMBERS_MISSING_KEY = "Union has members missing identifying keys";
    class TypeIdentifyingKeyIndex {
      constructor(e) {
        this.schema = e;
      }
      cacheKeys() {
        const e = this.schema.anyOf.length;
        const r = new Set();
        this.keyByMemberIndex = new Array(e);
        for (let o = 0; o < e; ++o) {
          const e = this.schema.anyOf[o];
          for (const [s, i] of Object.entries(e.properties)) {
            if (i.typeIdentifyingKey) {
              if (i[n.Optional] == "Optional") {
                throw Error(t.MESSAGE_OPTIONAL_TYPE_ID_KEY);
              }
              if (this.keyByMemberIndex[o] !== undefined) {
                throw Error(t.MESSAGE_MEMBER_WITH_MULTIPLE_KEYS);
              }
              if (r.has(s)) {
                throw Error(t.MESSAGE_MULTIPLE_MEMBERS_WITH_SAME_KEY);
              }
              this.keyByMemberIndex[o] = s;
              r.add(s);
            }
          }
        }
        if (r.size < e) {
          this.keyByMemberIndex = undefined;
          throw Error(t.MESSAGE_MEMBERS_MISSING_KEY);
        }
      }
    }
    t.TypeIdentifyingKeyIndex = TypeIdentifyingKeyIndex;
  },
  5680: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.TypeIdentifyingKey = void 0;
    function TypeIdentifyingKey(e) {
      return Object.assign(Object.assign({}, e), { typeIdentifyingKey: true });
    }
    t.TypeIdentifyingKey = TypeIdentifyingKey;
  },
  80619: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(29293), t);
    o(r(58453), t);
    o(r(73422), t);
    o(r(68589), t);
    o(r(29539), t);
    o(r(96388), t);
    o(r(55776), t);
  },
  17085: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.throwInvalidValidate =
      t.throwInvalidAssert =
      t.createUnionTypeErrorIterable =
      t.createUnionTypeError =
      t.createErrorsIterable =
      t.adjustErrorMessage =
      t.DEFAULT_UNKNOWN_TYPE_MESSAGE =
      t.DEFAULT_OVERALL_MESSAGE =
        void 0;
    const n = r(14019);
    const o = r(65507);
    const s = r(55776);
    t.DEFAULT_OVERALL_MESSAGE = "Invalid value";
    t.DEFAULT_UNKNOWN_TYPE_MESSAGE = "Object type not recognized";
    const i = "Expected required property";
    function adjustErrorMessage(e) {
      if (e.schema.errorMessage !== undefined) {
        e.message = e.schema.errorMessage;
      }
      return e;
    }
    t.adjustErrorMessage = adjustErrorMessage;
    function createErrorsIterable(e) {
      return {
        [Symbol.iterator]: function* () {
          const t = e[Symbol.iterator]();
          let r = t.next();
          let o = "???";
          while (r.value !== undefined) {
            const e = r.value;
            const s = e.message;
            if (e.path !== o) {
              adjustErrorMessage(e);
              if (e.message != s) {
                o = e.path;
                yield e;
              } else if (e.message != i || ["Any", "Unknown"].includes(e.schema[n.Kind])) {
                yield e;
              }
            }
            r = t.next();
          }
        },
      };
    }
    t.createErrorsIterable = createErrorsIterable;
    function createUnionTypeError(e, r) {
      var n;
      return {
        type: o.ValueErrorType.Union,
        path: "",
        schema: e,
        value: r,
        message: (n = e.errorMessage) !== null && n !== void 0 ? n : t.DEFAULT_UNKNOWN_TYPE_MESSAGE,
      };
    }
    t.createUnionTypeError = createUnionTypeError;
    function createUnionTypeErrorIterable(e) {
      return {
        [Symbol.iterator]: function* () {
          yield e;
        },
      };
    }
    t.createUnionTypeErrorIterable = createUnionTypeErrorIterable;
    function throwInvalidAssert(e, r) {
      adjustErrorMessage(r);
      throw new s.ValidationException(e === undefined ? t.DEFAULT_OVERALL_MESSAGE : e.replace("{error}", s.ValidationException.errorToString(r)), [r]);
    }
    t.throwInvalidAssert = throwInvalidAssert;
    function throwInvalidValidate(e, r) {
      throw new s.ValidationException(
        e !== null && e !== void 0 ? e : t.DEFAULT_OVERALL_MESSAGE,
        r instanceof o.ValueErrorIterator ? [...createErrorsIterable(r)] : [r]
      );
    }
    t.throwInvalidValidate = throwInvalidValidate;
  },
  55776: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.ValidationException = void 0;
    class ValidationException {
      constructor(e, t = []) {
        this.message = e;
        this.details = t;
      }
      toString() {
        let e = this.message;
        if (this.details.length > 0) {
          if (!e.endsWith(":")) {
            e += ":";
          }
          for (const t of this.details) {
            e += "\n * " + ValidationException.errorToString(t);
          }
        }
        return e;
      }
      static errorToString(e) {
        return e.path != "" ? `${e.path.substring(1)} - ${e.message}` : e.message;
      }
    }
    t.ValidationException = ValidationException;
  },
  3470: function (e, t, r) {
    var n =
      (this && this.__classPrivateFieldGet) ||
      function (e, t, r, n) {
        if (r === "a" && !n) throw new TypeError("Private accessor was defined without a getter");
        if (typeof t === "function" ? e !== t || !n : !t.has(e))
          throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return r === "m" ? n : r === "a" ? n.call(e) : n ? n.value : t.get(e);
      };
    var o =
      (this && this.__classPrivateFieldSet) ||
      function (e, t, r, n, o) {
        if (n === "m") throw new TypeError("Private method is not writable");
        if (n === "a" && !o) throw new TypeError("Private accessor was defined without a setter");
        if (typeof t === "function" ? e !== t || !o : !t.has(e)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return n === "a" ? o.call(e, r) : o ? (o.value = r) : t.set(e, r), r;
      };
    var s;
    Object.defineProperty(t, "__esModule", { value: true });
    t.CompilingStandardValidator = void 0;
    const i = r(25269);
    const a = r(58453);
    const A = r(17085);
    class CompilingStandardValidator extends a.AbstractStandardValidator {
      constructor(e) {
        super(e);
        s.set(this, void 0);
      }
      test(e) {
        const t = this.getCompiledType();
        return t.Check(e);
      }
      assert(e, t) {
        const r = this.getCompiledType();
        if (!r.Check(e)) {
          (0, A.throwInvalidAssert)(t, r.Errors(e).First());
        }
      }
      validate(e, t) {
        const r = this.getCompiledType();
        if (!r.Check(e)) {
          (0, A.throwInvalidValidate)(t, r.Errors(e));
        }
      }
      errors(e) {
        const t = this.getCompiledType();
        return (0, A.createErrorsIterable)(t.Errors(e));
      }
      getCompiledType() {
        if (n(this, s, "f") === undefined) {
          o(this, s, i.TypeCompiler.Compile(this.schema), "f");
        }
        return n(this, s, "f");
      }
    }
    t.CompilingStandardValidator = CompilingStandardValidator;
    s = new WeakMap();
  },
  68589: function (e, t, r) {
    var n =
      (this && this.__createBinding) ||
      (Object.create
        ? function (e, t, r, n) {
            if (n === undefined) n = r;
            var o = Object.getOwnPropertyDescriptor(t, r);
            if (!o || ("get" in o ? !t.__esModule : o.writable || o.configurable)) {
              o = {
                enumerable: true,
                get: function () {
                  return t[r];
                },
              };
            }
            Object.defineProperty(e, n, o);
          }
        : function (e, t, r, n) {
            if (n === undefined) n = r;
            e[n] = t[r];
          });
    var o =
      (this && this.__exportStar) ||
      function (e, t) {
        for (var r in e) if (r !== "default" && !Object.prototype.hasOwnProperty.call(t, r)) n(t, e, r);
      };
    Object.defineProperty(t, "__esModule", { value: true });
    o(r(12491), t);
    o(r(3470), t);
  },
  12491: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.StandardValidator = void 0;
    const n = r(58453);
    const o = r(45105);
    const s = r(17085);
    class StandardValidator extends n.AbstractStandardValidator {
      constructor(e) {
        super(e);
      }
      test(e) {
        return o.Value.Check(this.schema, e);
      }
      assert(e, t) {
        this.uncompiledAssert(this.schema, e, t);
      }
      validate(e, t) {
        this.uncompiledValidate(this.schema, e, t);
      }
      errors(e) {
        return (0, s.createErrorsIterable)(o.Value.Errors(this.schema, e));
      }
    }
    t.StandardValidator = StandardValidator;
  },
  46752: (e, t, r) => {
    const n = r(86197);
    const o = r(28611);
    const s = r(68707);
    const i = r(35076);
    const a = r(81093);
    const A = r(59965);
    const c = r(3440);
    const { InvalidArgumentError: u } = s;
    const l = r(56615);
    const p = r(59136);
    const d = r(47365);
    const g = r(47501);
    const m = r(94004);
    const h = r(52429);
    const E = r(22720);
    const I = r(53573);
    const { getGlobalDispatcher: y, setGlobalDispatcher: C } = r(32581);
    const b = r(78840);
    const Q = r(48299);
    const B = r(64415);
    let T;
    try {
      r(76982);
      T = true;
    } catch {
      T = false;
    }
    Object.assign(o.prototype, l);
    e.exports.Dispatcher = o;
    e.exports.Client = n;
    e.exports.Pool = i;
    e.exports.BalancedPool = a;
    e.exports.Agent = A;
    e.exports.ProxyAgent = E;
    e.exports.RetryHandler = I;
    e.exports.DecoratorHandler = b;
    e.exports.RedirectHandler = Q;
    e.exports.createRedirectInterceptor = B;
    e.exports.buildConnector = p;
    e.exports.errors = s;
    function makeDispatcher(e) {
      return (t, r, n) => {
        if (typeof r === "function") {
          n = r;
          r = null;
        }
        if (!t || (typeof t !== "string" && typeof t !== "object" && !(t instanceof URL))) {
          throw new u("invalid url");
        }
        if (r != null && typeof r !== "object") {
          throw new u("invalid opts");
        }
        if (r && r.path != null) {
          if (typeof r.path !== "string") {
            throw new u("invalid opts.path");
          }
          let e = r.path;
          if (!r.path.startsWith("/")) {
            e = `/${e}`;
          }
          t = new URL(c.parseOrigin(t).origin + e);
        } else {
          if (!r) {
            r = typeof t === "object" ? t : {};
          }
          t = c.parseURL(t);
        }
        const { agent: o, dispatcher: s = y() } = r;
        if (o) {
          throw new u("unsupported opts.agent. Did you mean opts.client?");
        }
        return e.call(s, { ...r, origin: t.origin, path: t.search ? `${t.pathname}${t.search}` : t.pathname, method: r.method || (r.body ? "PUT" : "GET") }, n);
      };
    }
    e.exports.setGlobalDispatcher = C;
    e.exports.getGlobalDispatcher = y;
    if (c.nodeMajor > 16 || (c.nodeMajor === 16 && c.nodeMinor >= 8)) {
      let t = null;
      e.exports.fetch = async function fetch(e) {
        if (!t) {
          t = r(12315).fetch;
        }
        try {
          return await t(...arguments);
        } catch (e) {
          if (typeof e === "object") {
            Error.captureStackTrace(e, this);
          }
          throw e;
        }
      };
      e.exports.Headers = r(26349).Headers;
      e.exports.Response = r(48676).Response;
      e.exports.Request = r(25194).Request;
      e.exports.FormData = r(43073).FormData;
      e.exports.File = r(63041).File;
      e.exports.FileReader = r(82160).FileReader;
      const { setGlobalOrigin: n, getGlobalOrigin: o } = r(75628);
      e.exports.setGlobalOrigin = n;
      e.exports.getGlobalOrigin = o;
      const { CacheStorage: s } = r(44738);
      const { kConstruct: i } = r(80296);
      e.exports.caches = new s(i);
    }
    if (c.nodeMajor >= 16) {
      const { deleteCookie: t, getCookies: n, getSetCookies: o, setCookie: s } = r(53168);
      e.exports.deleteCookie = t;
      e.exports.getCookies = n;
      e.exports.getSetCookies = o;
      e.exports.setCookie = s;
      const { parseMIMEType: i, serializeAMimeType: a } = r(94322);
      e.exports.parseMIMEType = i;
      e.exports.serializeAMimeType = a;
    }
    if (c.nodeMajor >= 18 && T) {
      const { WebSocket: t } = r(55171);
      e.exports.WebSocket = t;
    }
    e.exports.request = makeDispatcher(l.request);
    e.exports.stream = makeDispatcher(l.stream);
    e.exports.pipeline = makeDispatcher(l.pipeline);
    e.exports.connect = makeDispatcher(l.connect);
    e.exports.upgrade = makeDispatcher(l.upgrade);
    e.exports.MockClient = d;
    e.exports.MockPool = m;
    e.exports.MockAgent = g;
    e.exports.mockErrors = h;
  },
  59965: (e, t, r) => {
    const { InvalidArgumentError: n } = r(68707);
    const { kClients: o, kRunning: s, kClose: i, kDestroy: a, kDispatch: A, kInterceptors: c } = r(36443);
    const u = r(50001);
    const l = r(35076);
    const p = r(86197);
    const d = r(3440);
    const g = r(64415);
    const { WeakRef: m, FinalizationRegistry: h } = r(13194)();
    const E = Symbol("onConnect");
    const I = Symbol("onDisconnect");
    const y = Symbol("onConnectionError");
    const C = Symbol("maxRedirections");
    const b = Symbol("onDrain");
    const Q = Symbol("factory");
    const B = Symbol("finalizer");
    const T = Symbol("options");
    function defaultFactory(e, t) {
      return t && t.connections === 1 ? new p(e, t) : new l(e, t);
    }
    class Agent extends u {
      constructor({ factory: e = defaultFactory, maxRedirections: t = 0, connect: r, ...s } = {}) {
        super();
        if (typeof e !== "function") {
          throw new n("factory must be a function.");
        }
        if (r != null && typeof r !== "function" && typeof r !== "object") {
          throw new n("connect must be a function or an object");
        }
        if (!Number.isInteger(t) || t < 0) {
          throw new n("maxRedirections must be a positive number");
        }
        if (r && typeof r !== "function") {
          r = { ...r };
        }
        this[c] = s.interceptors && s.interceptors.Agent && Array.isArray(s.interceptors.Agent) ? s.interceptors.Agent : [g({ maxRedirections: t })];
        this[T] = { ...d.deepClone(s), connect: r };
        this[T].interceptors = s.interceptors ? { ...s.interceptors } : undefined;
        this[C] = t;
        this[Q] = e;
        this[o] = new Map();
        this[B] = new h((e) => {
          const t = this[o].get(e);
          if (t !== undefined && t.deref() === undefined) {
            this[o].delete(e);
          }
        });
        const i = this;
        this[b] = (e, t) => {
          i.emit("drain", e, [i, ...t]);
        };
        this[E] = (e, t) => {
          i.emit("connect", e, [i, ...t]);
        };
        this[I] = (e, t, r) => {
          i.emit("disconnect", e, [i, ...t], r);
        };
        this[y] = (e, t, r) => {
          i.emit("connectionError", e, [i, ...t], r);
        };
      }
      get [s]() {
        let e = 0;
        for (const t of this[o].values()) {
          const r = t.deref();
          if (r) {
            e += r[s];
          }
        }
        return e;
      }
      [A](e, t) {
        let r;
        if (e.origin && (typeof e.origin === "string" || e.origin instanceof URL)) {
          r = String(e.origin);
        } else {
          throw new n("opts.origin must be a non-empty string or URL.");
        }
        const s = this[o].get(r);
        let i = s ? s.deref() : null;
        if (!i) {
          i = this[Q](e.origin, this[T]).on("drain", this[b]).on("connect", this[E]).on("disconnect", this[I]).on("connectionError", this[y]);
          this[o].set(r, new m(i));
          this[B].register(i, r);
        }
        return i.dispatch(e, t);
      }
      async [i]() {
        const e = [];
        for (const t of this[o].values()) {
          const r = t.deref();
          if (r) {
            e.push(r.close());
          }
        }
        await Promise.all(e);
      }
      async [a](e) {
        const t = [];
        for (const r of this[o].values()) {
          const n = r.deref();
          if (n) {
            t.push(n.destroy(e));
          }
        }
        await Promise.all(t);
      }
    }
    e.exports = Agent;
  },
  80158: (e, t, r) => {
    const { addAbortListener: n } = r(3440);
    const { RequestAbortedError: o } = r(68707);
    const s = Symbol("kListener");
    const i = Symbol("kSignal");
    function abort(e) {
      if (e.abort) {
        e.abort();
      } else {
        e.onError(new o());
      }
    }
    function addSignal(e, t) {
      e[i] = null;
      e[s] = null;
      if (!t) {
        return;
      }
      if (t.aborted) {
        abort(e);
        return;
      }
      e[i] = t;
      e[s] = () => {
        abort(e);
      };
      n(e[i], e[s]);
    }
    function removeSignal(e) {
      if (!e[i]) {
        return;
      }
      if ("removeEventListener" in e[i]) {
        e[i].removeEventListener("abort", e[s]);
      } else {
        e[i].removeListener("abort", e[s]);
      }
      e[i] = null;
      e[s] = null;
    }
    e.exports = { addSignal: addSignal, removeSignal: removeSignal };
  },
  34660: (e, t, r) => {
    const { AsyncResource: n } = r(90290);
    const { InvalidArgumentError: o, RequestAbortedError: s, SocketError: i } = r(68707);
    const a = r(3440);
    const { addSignal: A, removeSignal: c } = r(80158);
    class ConnectHandler extends n {
      constructor(e, t) {
        if (!e || typeof e !== "object") {
          throw new o("invalid opts");
        }
        if (typeof t !== "function") {
          throw new o("invalid callback");
        }
        const { signal: r, opaque: n, responseHeaders: s } = e;
        if (r && typeof r.on !== "function" && typeof r.addEventListener !== "function") {
          throw new o("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_CONNECT");
        this.opaque = n || null;
        this.responseHeaders = s || null;
        this.callback = t;
        this.abort = null;
        A(this, r);
      }
      onConnect(e, t) {
        if (!this.callback) {
          throw new s();
        }
        this.abort = e;
        this.context = t;
      }
      onHeaders() {
        throw new i("bad connect", null);
      }
      onUpgrade(e, t, r) {
        const { callback: n, opaque: o, context: s } = this;
        c(this);
        this.callback = null;
        let i = t;
        if (i != null) {
          i = this.responseHeaders === "raw" ? a.parseRawHeaders(t) : a.parseHeaders(t);
        }
        this.runInAsyncScope(n, null, null, { statusCode: e, headers: i, socket: r, opaque: o, context: s });
      }
      onError(e) {
        const { callback: t, opaque: r } = this;
        c(this);
        if (t) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(t, null, e, { opaque: r });
          });
        }
      }
    }
    function connect(e, t) {
      if (t === undefined) {
        return new Promise((t, r) => {
          connect.call(this, e, (e, n) => (e ? r(e) : t(n)));
        });
      }
      try {
        const r = new ConnectHandler(e, t);
        this.dispatch({ ...e, method: "CONNECT" }, r);
      } catch (r) {
        if (typeof t !== "function") {
          throw r;
        }
        const n = e && e.opaque;
        queueMicrotask(() => t(r, { opaque: n }));
      }
    }
    e.exports = connect;
  },
  76862: (e, t, r) => {
    const { Readable: n, Duplex: o, PassThrough: s } = r(2203);
    const { InvalidArgumentError: i, InvalidReturnValueError: a, RequestAbortedError: A } = r(68707);
    const c = r(3440);
    const { AsyncResource: u } = r(90290);
    const { addSignal: l, removeSignal: p } = r(80158);
    const d = r(42613);
    const g = Symbol("resume");
    class PipelineRequest extends n {
      constructor() {
        super({ autoDestroy: true });
        this[g] = null;
      }
      _read() {
        const { [g]: e } = this;
        if (e) {
          this[g] = null;
          e();
        }
      }
      _destroy(e, t) {
        this._read();
        t(e);
      }
    }
    class PipelineResponse extends n {
      constructor(e) {
        super({ autoDestroy: true });
        this[g] = e;
      }
      _read() {
        this[g]();
      }
      _destroy(e, t) {
        if (!e && !this._readableState.endEmitted) {
          e = new A();
        }
        t(e);
      }
    }
    class PipelineHandler extends u {
      constructor(e, t) {
        if (!e || typeof e !== "object") {
          throw new i("invalid opts");
        }
        if (typeof t !== "function") {
          throw new i("invalid handler");
        }
        const { signal: r, method: n, opaque: s, onInfo: a, responseHeaders: u } = e;
        if (r && typeof r.on !== "function" && typeof r.addEventListener !== "function") {
          throw new i("signal must be an EventEmitter or EventTarget");
        }
        if (n === "CONNECT") {
          throw new i("invalid method");
        }
        if (a && typeof a !== "function") {
          throw new i("invalid onInfo callback");
        }
        super("UNDICI_PIPELINE");
        this.opaque = s || null;
        this.responseHeaders = u || null;
        this.handler = t;
        this.abort = null;
        this.context = null;
        this.onInfo = a || null;
        this.req = new PipelineRequest().on("error", c.nop);
        this.ret = new o({
          readableObjectMode: e.objectMode,
          autoDestroy: true,
          read: () => {
            const { body: e } = this;
            if (e && e.resume) {
              e.resume();
            }
          },
          write: (e, t, r) => {
            const { req: n } = this;
            if (n.push(e, t) || n._readableState.destroyed) {
              r();
            } else {
              n[g] = r;
            }
          },
          destroy: (e, t) => {
            const { body: r, req: n, res: o, ret: s, abort: i } = this;
            if (!e && !s._readableState.endEmitted) {
              e = new A();
            }
            if (i && e) {
              i();
            }
            c.destroy(r, e);
            c.destroy(n, e);
            c.destroy(o, e);
            p(this);
            t(e);
          },
        }).on("prefinish", () => {
          const { req: e } = this;
          e.push(null);
        });
        this.res = null;
        l(this, r);
      }
      onConnect(e, t) {
        const { ret: r, res: n } = this;
        d(!n, "pipeline cannot be retried");
        if (r.destroyed) {
          throw new A();
        }
        this.abort = e;
        this.context = t;
      }
      onHeaders(e, t, r) {
        const { opaque: n, handler: o, context: s } = this;
        if (e < 200) {
          if (this.onInfo) {
            const r = this.responseHeaders === "raw" ? c.parseRawHeaders(t) : c.parseHeaders(t);
            this.onInfo({ statusCode: e, headers: r });
          }
          return;
        }
        this.res = new PipelineResponse(r);
        let i;
        try {
          this.handler = null;
          const r = this.responseHeaders === "raw" ? c.parseRawHeaders(t) : c.parseHeaders(t);
          i = this.runInAsyncScope(o, null, { statusCode: e, headers: r, opaque: n, body: this.res, context: s });
        } catch (e) {
          this.res.on("error", c.nop);
          throw e;
        }
        if (!i || typeof i.on !== "function") {
          throw new a("expected Readable");
        }
        i.on("data", (e) => {
          const { ret: t, body: r } = this;
          if (!t.push(e) && r.pause) {
            r.pause();
          }
        })
          .on("error", (e) => {
            const { ret: t } = this;
            c.destroy(t, e);
          })
          .on("end", () => {
            const { ret: e } = this;
            e.push(null);
          })
          .on("close", () => {
            const { ret: e } = this;
            if (!e._readableState.ended) {
              c.destroy(e, new A());
            }
          });
        this.body = i;
      }
      onData(e) {
        const { res: t } = this;
        return t.push(e);
      }
      onComplete(e) {
        const { res: t } = this;
        t.push(null);
      }
      onError(e) {
        const { ret: t } = this;
        this.handler = null;
        c.destroy(t, e);
      }
    }
    function pipeline(e, t) {
      try {
        const r = new PipelineHandler(e, t);
        this.dispatch({ ...e, body: r.req }, r);
        return r.ret;
      } catch (e) {
        return new s().destroy(e);
      }
    }
    e.exports = pipeline;
  },
  14043: (e, t, r) => {
    const n = r(49927);
    const { InvalidArgumentError: o, RequestAbortedError: s } = r(68707);
    const i = r(3440);
    const { getResolveErrorBodyCallback: a } = r(87655);
    const { AsyncResource: A } = r(90290);
    const { addSignal: c, removeSignal: u } = r(80158);
    class RequestHandler extends A {
      constructor(e, t) {
        if (!e || typeof e !== "object") {
          throw new o("invalid opts");
        }
        const { signal: r, method: n, opaque: s, body: a, onInfo: A, responseHeaders: u, throwOnError: l, highWaterMark: p } = e;
        try {
          if (typeof t !== "function") {
            throw new o("invalid callback");
          }
          if (p && (typeof p !== "number" || p < 0)) {
            throw new o("invalid highWaterMark");
          }
          if (r && typeof r.on !== "function" && typeof r.addEventListener !== "function") {
            throw new o("signal must be an EventEmitter or EventTarget");
          }
          if (n === "CONNECT") {
            throw new o("invalid method");
          }
          if (A && typeof A !== "function") {
            throw new o("invalid onInfo callback");
          }
          super("UNDICI_REQUEST");
        } catch (e) {
          if (i.isStream(a)) {
            i.destroy(a.on("error", i.nop), e);
          }
          throw e;
        }
        this.responseHeaders = u || null;
        this.opaque = s || null;
        this.callback = t;
        this.res = null;
        this.abort = null;
        this.body = a;
        this.trailers = {};
        this.context = null;
        this.onInfo = A || null;
        this.throwOnError = l;
        this.highWaterMark = p;
        if (i.isStream(a)) {
          a.on("error", (e) => {
            this.onError(e);
          });
        }
        c(this, r);
      }
      onConnect(e, t) {
        if (!this.callback) {
          throw new s();
        }
        this.abort = e;
        this.context = t;
      }
      onHeaders(e, t, r, o) {
        const { callback: s, opaque: A, abort: c, context: u, responseHeaders: l, highWaterMark: p } = this;
        const d = l === "raw" ? i.parseRawHeaders(t) : i.parseHeaders(t);
        if (e < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode: e, headers: d });
          }
          return;
        }
        const g = l === "raw" ? i.parseHeaders(t) : d;
        const m = g["content-type"];
        const h = new n({ resume: r, abort: c, contentType: m, highWaterMark: p });
        this.callback = null;
        this.res = h;
        if (s !== null) {
          if (this.throwOnError && e >= 400) {
            this.runInAsyncScope(a, null, { callback: s, body: h, contentType: m, statusCode: e, statusMessage: o, headers: d });
          } else {
            this.runInAsyncScope(s, null, null, { statusCode: e, headers: d, trailers: this.trailers, opaque: A, body: h, context: u });
          }
        }
      }
      onData(e) {
        const { res: t } = this;
        return t.push(e);
      }
      onComplete(e) {
        const { res: t } = this;
        u(this);
        i.parseHeaders(e, this.trailers);
        t.push(null);
      }
      onError(e) {
        const { res: t, callback: r, body: n, opaque: o } = this;
        u(this);
        if (r) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(r, null, e, { opaque: o });
          });
        }
        if (t) {
          this.res = null;
          queueMicrotask(() => {
            i.destroy(t, e);
          });
        }
        if (n) {
          this.body = null;
          i.destroy(n, e);
        }
      }
    }
    function request(e, t) {
      if (t === undefined) {
        return new Promise((t, r) => {
          request.call(this, e, (e, n) => (e ? r(e) : t(n)));
        });
      }
      try {
        this.dispatch(e, new RequestHandler(e, t));
      } catch (r) {
        if (typeof t !== "function") {
          throw r;
        }
        const n = e && e.opaque;
        queueMicrotask(() => t(r, { opaque: n }));
      }
    }
    e.exports = request;
    e.exports.RequestHandler = RequestHandler;
  },
  3560: (e, t, r) => {
    const { finished: n, PassThrough: o } = r(2203);
    const { InvalidArgumentError: s, InvalidReturnValueError: i, RequestAbortedError: a } = r(68707);
    const A = r(3440);
    const { getResolveErrorBodyCallback: c } = r(87655);
    const { AsyncResource: u } = r(90290);
    const { addSignal: l, removeSignal: p } = r(80158);
    class StreamHandler extends u {
      constructor(e, t, r) {
        if (!e || typeof e !== "object") {
          throw new s("invalid opts");
        }
        const { signal: n, method: o, opaque: i, body: a, onInfo: c, responseHeaders: u, throwOnError: p } = e;
        try {
          if (typeof r !== "function") {
            throw new s("invalid callback");
          }
          if (typeof t !== "function") {
            throw new s("invalid factory");
          }
          if (n && typeof n.on !== "function" && typeof n.addEventListener !== "function") {
            throw new s("signal must be an EventEmitter or EventTarget");
          }
          if (o === "CONNECT") {
            throw new s("invalid method");
          }
          if (c && typeof c !== "function") {
            throw new s("invalid onInfo callback");
          }
          super("UNDICI_STREAM");
        } catch (e) {
          if (A.isStream(a)) {
            A.destroy(a.on("error", A.nop), e);
          }
          throw e;
        }
        this.responseHeaders = u || null;
        this.opaque = i || null;
        this.factory = t;
        this.callback = r;
        this.res = null;
        this.abort = null;
        this.context = null;
        this.trailers = null;
        this.body = a;
        this.onInfo = c || null;
        this.throwOnError = p || false;
        if (A.isStream(a)) {
          a.on("error", (e) => {
            this.onError(e);
          });
        }
        l(this, n);
      }
      onConnect(e, t) {
        if (!this.callback) {
          throw new a();
        }
        this.abort = e;
        this.context = t;
      }
      onHeaders(e, t, r, s) {
        const { factory: a, opaque: u, context: l, callback: p, responseHeaders: d } = this;
        const g = d === "raw" ? A.parseRawHeaders(t) : A.parseHeaders(t);
        if (e < 200) {
          if (this.onInfo) {
            this.onInfo({ statusCode: e, headers: g });
          }
          return;
        }
        this.factory = null;
        let m;
        if (this.throwOnError && e >= 400) {
          const r = d === "raw" ? A.parseHeaders(t) : g;
          const n = r["content-type"];
          m = new o();
          this.callback = null;
          this.runInAsyncScope(c, null, { callback: p, body: m, contentType: n, statusCode: e, statusMessage: s, headers: g });
        } else {
          if (a === null) {
            return;
          }
          m = this.runInAsyncScope(a, null, { statusCode: e, headers: g, opaque: u, context: l });
          if (!m || typeof m.write !== "function" || typeof m.end !== "function" || typeof m.on !== "function") {
            throw new i("expected Writable");
          }
          n(m, { readable: false }, (e) => {
            const { callback: t, res: r, opaque: n, trailers: o, abort: s } = this;
            this.res = null;
            if (e || !r.readable) {
              A.destroy(r, e);
            }
            this.callback = null;
            this.runInAsyncScope(t, null, e || null, { opaque: n, trailers: o });
            if (e) {
              s();
            }
          });
        }
        m.on("drain", r);
        this.res = m;
        const h = m.writableNeedDrain !== undefined ? m.writableNeedDrain : m._writableState && m._writableState.needDrain;
        return h !== true;
      }
      onData(e) {
        const { res: t } = this;
        return t ? t.write(e) : true;
      }
      onComplete(e) {
        const { res: t } = this;
        p(this);
        if (!t) {
          return;
        }
        this.trailers = A.parseHeaders(e);
        t.end();
      }
      onError(e) {
        const { res: t, callback: r, opaque: n, body: o } = this;
        p(this);
        this.factory = null;
        if (t) {
          this.res = null;
          A.destroy(t, e);
        } else if (r) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(r, null, e, { opaque: n });
          });
        }
        if (o) {
          this.body = null;
          A.destroy(o, e);
        }
      }
    }
    function stream(e, t, r) {
      if (r === undefined) {
        return new Promise((r, n) => {
          stream.call(this, e, t, (e, t) => (e ? n(e) : r(t)));
        });
      }
      try {
        this.dispatch(e, new StreamHandler(e, t, r));
      } catch (t) {
        if (typeof r !== "function") {
          throw t;
        }
        const n = e && e.opaque;
        queueMicrotask(() => r(t, { opaque: n }));
      }
    }
    e.exports = stream;
  },
  61882: (e, t, r) => {
    const { InvalidArgumentError: n, RequestAbortedError: o, SocketError: s } = r(68707);
    const { AsyncResource: i } = r(90290);
    const a = r(3440);
    const { addSignal: A, removeSignal: c } = r(80158);
    const u = r(42613);
    class UpgradeHandler extends i {
      constructor(e, t) {
        if (!e || typeof e !== "object") {
          throw new n("invalid opts");
        }
        if (typeof t !== "function") {
          throw new n("invalid callback");
        }
        const { signal: r, opaque: o, responseHeaders: s } = e;
        if (r && typeof r.on !== "function" && typeof r.addEventListener !== "function") {
          throw new n("signal must be an EventEmitter or EventTarget");
        }
        super("UNDICI_UPGRADE");
        this.responseHeaders = s || null;
        this.opaque = o || null;
        this.callback = t;
        this.abort = null;
        this.context = null;
        A(this, r);
      }
      onConnect(e, t) {
        if (!this.callback) {
          throw new o();
        }
        this.abort = e;
        this.context = null;
      }
      onHeaders() {
        throw new s("bad upgrade", null);
      }
      onUpgrade(e, t, r) {
        const { callback: n, opaque: o, context: s } = this;
        u.strictEqual(e, 101);
        c(this);
        this.callback = null;
        const i = this.responseHeaders === "raw" ? a.parseRawHeaders(t) : a.parseHeaders(t);
        this.runInAsyncScope(n, null, null, { headers: i, socket: r, opaque: o, context: s });
      }
      onError(e) {
        const { callback: t, opaque: r } = this;
        c(this);
        if (t) {
          this.callback = null;
          queueMicrotask(() => {
            this.runInAsyncScope(t, null, e, { opaque: r });
          });
        }
      }
    }
    function upgrade(e, t) {
      if (t === undefined) {
        return new Promise((t, r) => {
          upgrade.call(this, e, (e, n) => (e ? r(e) : t(n)));
        });
      }
      try {
        const r = new UpgradeHandler(e, t);
        this.dispatch({ ...e, method: e.method || "GET", upgrade: e.protocol || "Websocket" }, r);
      } catch (r) {
        if (typeof t !== "function") {
          throw r;
        }
        const n = e && e.opaque;
        queueMicrotask(() => t(r, { opaque: n }));
      }
    }
    e.exports = upgrade;
  },
  56615: (e, t, r) => {
    e.exports.request = r(14043);
    e.exports.stream = r(3560);
    e.exports.pipeline = r(76862);
    e.exports.upgrade = r(61882);
    e.exports.connect = r(34660);
  },
  49927: (e, t, r) => {
    const n = r(42613);
    const { Readable: o } = r(2203);
    const { RequestAbortedError: s, NotSupportedError: i, InvalidArgumentError: a } = r(68707);
    const A = r(3440);
    const { ReadableStreamFrom: c, toUSVString: u } = r(3440);
    let l;
    const p = Symbol("kConsume");
    const d = Symbol("kReading");
    const g = Symbol("kBody");
    const m = Symbol("abort");
    const h = Symbol("kContentType");
    const noop = () => {};
    e.exports = class BodyReadable extends o {
      constructor({ resume: e, abort: t, contentType: r = "", highWaterMark: n = 64 * 1024 }) {
        super({ autoDestroy: true, read: e, highWaterMark: n });
        this._readableState.dataEmitted = false;
        this[m] = t;
        this[p] = null;
        this[g] = null;
        this[h] = r;
        this[d] = false;
      }
      destroy(e) {
        if (this.destroyed) {
          return this;
        }
        if (!e && !this._readableState.endEmitted) {
          e = new s();
        }
        if (e) {
          this[m]();
        }
        return super.destroy(e);
      }
      emit(e, ...t) {
        if (e === "data") {
          this._readableState.dataEmitted = true;
        } else if (e === "error") {
          this._readableState.errorEmitted = true;
        }
        return super.emit(e, ...t);
      }
      on(e, ...t) {
        if (e === "data" || e === "readable") {
          this[d] = true;
        }
        return super.on(e, ...t);
      }
      addListener(e, ...t) {
        return this.on(e, ...t);
      }
      off(e, ...t) {
        const r = super.off(e, ...t);
        if (e === "data" || e === "readable") {
          this[d] = this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
        }
        return r;
      }
      removeListener(e, ...t) {
        return this.off(e, ...t);
      }
      push(e) {
        if (this[p] && e !== null && this.readableLength === 0) {
          consumePush(this[p], e);
          return this[d] ? super.push(e) : true;
        }
        return super.push(e);
      }
      async text() {
        return consume(this, "text");
      }
      async json() {
        return consume(this, "json");
      }
      async blob() {
        return consume(this, "blob");
      }
      async arrayBuffer() {
        return consume(this, "arrayBuffer");
      }
      async formData() {
        throw new i();
      }
      get bodyUsed() {
        return A.isDisturbed(this);
      }
      get body() {
        if (!this[g]) {
          this[g] = c(this);
          if (this[p]) {
            this[g].getReader();
            n(this[g].locked);
          }
        }
        return this[g];
      }
      dump(e) {
        let t = e && Number.isFinite(e.limit) ? e.limit : 262144;
        const r = e && e.signal;
        if (r) {
          try {
            if (typeof r !== "object" || !("aborted" in r)) {
              throw new a("signal must be an AbortSignal");
            }
            A.throwIfAborted(r);
          } catch (e) {
            return Promise.reject(e);
          }
        }
        if (this.closed) {
          return Promise.resolve(null);
        }
        return new Promise((e, n) => {
          const o = r
            ? A.addAbortListener(r, () => {
                this.destroy();
              })
            : noop;
          this.on("close", function () {
            o();
            if (r && r.aborted) {
              n(r.reason || Object.assign(new Error("The operation was aborted"), { name: "AbortError" }));
            } else {
              e(null);
            }
          })
            .on("error", noop)
            .on("data", function (e) {
              t -= e.length;
              if (t <= 0) {
                this.destroy();
              }
            })
            .resume();
        });
      }
    };
    function isLocked(e) {
      return (e[g] && e[g].locked === true) || e[p];
    }
    function isUnusable(e) {
      return A.isDisturbed(e) || isLocked(e);
    }
    async function consume(e, t) {
      if (isUnusable(e)) {
        throw new TypeError("unusable");
      }
      n(!e[p]);
      return new Promise((r, n) => {
        e[p] = { type: t, stream: e, resolve: r, reject: n, length: 0, body: [] };
        e.on("error", function (e) {
          consumeFinish(this[p], e);
        }).on("close", function () {
          if (this[p].body !== null) {
            consumeFinish(this[p], new s());
          }
        });
        process.nextTick(consumeStart, e[p]);
      });
    }
    function consumeStart(e) {
      if (e.body === null) {
        return;
      }
      const { _readableState: t } = e.stream;
      for (const r of t.buffer) {
        consumePush(e, r);
      }
      if (t.endEmitted) {
        consumeEnd(this[p]);
      } else {
        e.stream.on("end", function () {
          consumeEnd(this[p]);
        });
      }
      e.stream.resume();
      while (e.stream.read() != null) {}
    }
    function consumeEnd(e) {
      const { type: t, body: n, resolve: o, stream: s, length: i } = e;
      try {
        if (t === "text") {
          o(u(Buffer.concat(n)));
        } else if (t === "json") {
          o(JSON.parse(Buffer.concat(n)));
        } else if (t === "arrayBuffer") {
          const e = new Uint8Array(i);
          let t = 0;
          for (const r of n) {
            e.set(r, t);
            t += r.byteLength;
          }
          o(e.buffer);
        } else if (t === "blob") {
          if (!l) {
            l = r(20181).Blob;
          }
          o(new l(n, { type: s[h] }));
        }
        consumeFinish(e);
      } catch (e) {
        s.destroy(e);
      }
    }
    function consumePush(e, t) {
      e.length += t.length;
      e.body.push(t);
    }
    function consumeFinish(e, t) {
      if (e.body === null) {
        return;
      }
      if (t) {
        e.reject(t);
      } else {
        e.resolve();
      }
      e.type = null;
      e.stream = null;
      e.resolve = null;
      e.reject = null;
      e.length = 0;
      e.body = null;
    }
  },
  87655: (e, t, r) => {
    const n = r(42613);
    const { ResponseStatusCodeError: o } = r(68707);
    const { toUSVString: s } = r(3440);
    async function getResolveErrorBodyCallback({ callback: e, body: t, contentType: r, statusCode: i, statusMessage: a, headers: A }) {
      n(t);
      let c = [];
      let u = 0;
      for await (const e of t) {
        c.push(e);
        u += e.length;
        if (u > 128 * 1024) {
          c = null;
          break;
        }
      }
      if (i === 204 || !r || !c) {
        process.nextTick(e, new o(`Response status code ${i}${a ? `: ${a}` : ""}`, i, A));
        return;
      }
      try {
        if (r.startsWith("application/json")) {
          const t = JSON.parse(s(Buffer.concat(c)));
          process.nextTick(e, new o(`Response status code ${i}${a ? `: ${a}` : ""}`, i, A, t));
          return;
        }
        if (r.startsWith("text/")) {
          const t = s(Buffer.concat(c));
          process.nextTick(e, new o(`Response status code ${i}${a ? `: ${a}` : ""}`, i, A, t));
          return;
        }
      } catch (e) {}
      process.nextTick(e, new o(`Response status code ${i}${a ? `: ${a}` : ""}`, i, A));
    }
    e.exports = { getResolveErrorBodyCallback: getResolveErrorBodyCallback };
  },
  81093: (e, t, r) => {
    const { BalancedPoolMissingUpstreamError: n, InvalidArgumentError: o } = r(68707);
    const { PoolBase: s, kClients: i, kNeedDrain: a, kAddClient: A, kRemoveClient: c, kGetDispatcher: u } = r(58640);
    const l = r(35076);
    const { kUrl: p, kInterceptors: d } = r(36443);
    const { parseOrigin: g } = r(3440);
    const m = Symbol("factory");
    const h = Symbol("options");
    const E = Symbol("kGreatestCommonDivisor");
    const I = Symbol("kCurrentWeight");
    const y = Symbol("kIndex");
    const C = Symbol("kWeight");
    const b = Symbol("kMaxWeightPerServer");
    const Q = Symbol("kErrorPenalty");
    function getGreatestCommonDivisor(e, t) {
      if (t === 0) return e;
      return getGreatestCommonDivisor(t, e % t);
    }
    function defaultFactory(e, t) {
      return new l(e, t);
    }
    class BalancedPool extends s {
      constructor(e = [], { factory: t = defaultFactory, ...r } = {}) {
        super();
        this[h] = r;
        this[y] = -1;
        this[I] = 0;
        this[b] = this[h].maxWeightPerServer || 100;
        this[Q] = this[h].errorPenalty || 15;
        if (!Array.isArray(e)) {
          e = [e];
        }
        if (typeof t !== "function") {
          throw new o("factory must be a function.");
        }
        this[d] = r.interceptors && r.interceptors.BalancedPool && Array.isArray(r.interceptors.BalancedPool) ? r.interceptors.BalancedPool : [];
        this[m] = t;
        for (const t of e) {
          this.addUpstream(t);
        }
        this._updateBalancedPoolStats();
      }
      addUpstream(e) {
        const t = g(e).origin;
        if (this[i].find((e) => e[p].origin === t && e.closed !== true && e.destroyed !== true)) {
          return this;
        }
        const r = this[m](t, Object.assign({}, this[h]));
        this[A](r);
        r.on("connect", () => {
          r[C] = Math.min(this[b], r[C] + this[Q]);
        });
        r.on("connectionError", () => {
          r[C] = Math.max(1, r[C] - this[Q]);
          this._updateBalancedPoolStats();
        });
        r.on("disconnect", (...e) => {
          const t = e[2];
          if (t && t.code === "UND_ERR_SOCKET") {
            r[C] = Math.max(1, r[C] - this[Q]);
            this._updateBalancedPoolStats();
          }
        });
        for (const e of this[i]) {
          e[C] = this[b];
        }
        this._updateBalancedPoolStats();
        return this;
      }
      _updateBalancedPoolStats() {
        this[E] = this[i].map((e) => e[C]).reduce(getGreatestCommonDivisor, 0);
      }
      removeUpstream(e) {
        const t = g(e).origin;
        const r = this[i].find((e) => e[p].origin === t && e.closed !== true && e.destroyed !== true);
        if (r) {
          this[c](r);
        }
        return this;
      }
      get upstreams() {
        return this[i].filter((e) => e.closed !== true && e.destroyed !== true).map((e) => e[p].origin);
      }
      [u]() {
        if (this[i].length === 0) {
          throw new n();
        }
        const e = this[i].find((e) => !e[a] && e.closed !== true && e.destroyed !== true);
        if (!e) {
          return;
        }
        const t = this[i].map((e) => e[a]).reduce((e, t) => e && t, true);
        if (t) {
          return;
        }
        let r = 0;
        let o = this[i].findIndex((e) => !e[a]);
        while (r++ < this[i].length) {
          this[y] = (this[y] + 1) % this[i].length;
          const e = this[i][this[y]];
          if (e[C] > this[i][o][C] && !e[a]) {
            o = this[y];
          }
          if (this[y] === 0) {
            this[I] = this[I] - this[E];
            if (this[I] <= 0) {
              this[I] = this[b];
            }
          }
          if (e[C] >= this[I] && !e[a]) {
            return e;
          }
        }
        this[I] = this[i][o][C];
        this[y] = o;
        return this[i][o];
      }
    }
    e.exports = BalancedPool;
  },
  50479: (e, t, r) => {
    const { kConstruct: n } = r(80296);
    const { urlEquals: o, fieldValues: s } = r(23993);
    const { kEnumerableProperty: i, isDisturbed: a } = r(3440);
    const { kHeadersList: A } = r(36443);
    const { webidl: c } = r(74222);
    const { Response: u, cloneResponse: l } = r(48676);
    const { Request: p } = r(25194);
    const { kState: d, kHeaders: g, kGuard: m, kRealm: h } = r(89710);
    const { fetching: E } = r(12315);
    const { urlIsHttpHttpsScheme: I, createDeferredPromise: y, readAllBytes: C } = r(15523);
    const b = r(42613);
    const { getGlobalDispatcher: Q } = r(32581);
    class Cache {
      #e;
      constructor() {
        if (arguments[0] !== n) {
          c.illegalConstructor();
        }
        this.#e = arguments[1];
      }
      async match(e, t = {}) {
        c.brandCheck(this, Cache);
        c.argumentLengthCheck(arguments, 1, { header: "Cache.match" });
        e = c.converters.RequestInfo(e);
        t = c.converters.CacheQueryOptions(t);
        const r = await this.matchAll(e, t);
        if (r.length === 0) {
          return;
        }
        return r[0];
      }
      async matchAll(e = undefined, t = {}) {
        c.brandCheck(this, Cache);
        if (e !== undefined) e = c.converters.RequestInfo(e);
        t = c.converters.CacheQueryOptions(t);
        let r = null;
        if (e !== undefined) {
          if (e instanceof p) {
            r = e[d];
            if (r.method !== "GET" && !t.ignoreMethod) {
              return [];
            }
          } else if (typeof e === "string") {
            r = new p(e)[d];
          }
        }
        const n = [];
        if (e === undefined) {
          for (const e of this.#e) {
            n.push(e[1]);
          }
        } else {
          const e = this.#t(r, t);
          for (const t of e) {
            n.push(t[1]);
          }
        }
        const o = [];
        for (const e of n) {
          const t = new u(e.body?.source ?? null);
          const r = t[d].body;
          t[d] = e;
          t[d].body = r;
          t[g][A] = e.headersList;
          t[g][m] = "immutable";
          o.push(t);
        }
        return Object.freeze(o);
      }
      async add(e) {
        c.brandCheck(this, Cache);
        c.argumentLengthCheck(arguments, 1, { header: "Cache.add" });
        e = c.converters.RequestInfo(e);
        const t = [e];
        const r = this.addAll(t);
        return await r;
      }
      async addAll(e) {
        c.brandCheck(this, Cache);
        c.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" });
        e = c.converters["sequence<RequestInfo>"](e);
        const t = [];
        const r = [];
        for (const t of e) {
          if (typeof t === "string") {
            continue;
          }
          const e = t[d];
          if (!I(e.url) || e.method !== "GET") {
            throw c.errors.exception({ header: "Cache.addAll", message: "Expected http/s scheme when method is not GET." });
          }
        }
        const n = [];
        for (const o of e) {
          const e = new p(o)[d];
          if (!I(e.url)) {
            throw c.errors.exception({ header: "Cache.addAll", message: "Expected http/s scheme." });
          }
          e.initiator = "fetch";
          e.destination = "subresource";
          r.push(e);
          const i = y();
          n.push(
            E({
              request: e,
              dispatcher: Q(),
              processResponse(e) {
                if (e.type === "error" || e.status === 206 || e.status < 200 || e.status > 299) {
                  i.reject(c.errors.exception({ header: "Cache.addAll", message: "Received an invalid status code or the request failed." }));
                } else if (e.headersList.contains("vary")) {
                  const t = s(e.headersList.get("vary"));
                  for (const e of t) {
                    if (e === "*") {
                      i.reject(c.errors.exception({ header: "Cache.addAll", message: "invalid vary field value" }));
                      for (const e of n) {
                        e.abort();
                      }
                      return;
                    }
                  }
                }
              },
              processResponseEndOfBody(e) {
                if (e.aborted) {
                  i.reject(new DOMException("aborted", "AbortError"));
                  return;
                }
                i.resolve(e);
              },
            })
          );
          t.push(i.promise);
        }
        const o = Promise.all(t);
        const i = await o;
        const a = [];
        let A = 0;
        for (const e of i) {
          const t = { type: "put", request: r[A], response: e };
          a.push(t);
          A++;
        }
        const u = y();
        let l = null;
        try {
          this.#r(a);
        } catch (e) {
          l = e;
        }
        queueMicrotask(() => {
          if (l === null) {
            u.resolve(undefined);
          } else {
            u.reject(l);
          }
        });
        return u.promise;
      }
      async put(e, t) {
        c.brandCheck(this, Cache);
        c.argumentLengthCheck(arguments, 2, { header: "Cache.put" });
        e = c.converters.RequestInfo(e);
        t = c.converters.Response(t);
        let r = null;
        if (e instanceof p) {
          r = e[d];
        } else {
          r = new p(e)[d];
        }
        if (!I(r.url) || r.method !== "GET") {
          throw c.errors.exception({ header: "Cache.put", message: "Expected an http/s scheme when method is not GET" });
        }
        const n = t[d];
        if (n.status === 206) {
          throw c.errors.exception({ header: "Cache.put", message: "Got 206 status" });
        }
        if (n.headersList.contains("vary")) {
          const e = s(n.headersList.get("vary"));
          for (const t of e) {
            if (t === "*") {
              throw c.errors.exception({ header: "Cache.put", message: "Got * vary field value" });
            }
          }
        }
        if (n.body && (a(n.body.stream) || n.body.stream.locked)) {
          throw c.errors.exception({ header: "Cache.put", message: "Response body is locked or disturbed" });
        }
        const o = l(n);
        const i = y();
        if (n.body != null) {
          const e = n.body.stream;
          const t = e.getReader();
          C(t).then(i.resolve, i.reject);
        } else {
          i.resolve(undefined);
        }
        const A = [];
        const u = { type: "put", request: r, response: o };
        A.push(u);
        const g = await i.promise;
        if (o.body != null) {
          o.body.source = g;
        }
        const m = y();
        let h = null;
        try {
          this.#r(A);
        } catch (e) {
          h = e;
        }
        queueMicrotask(() => {
          if (h === null) {
            m.resolve();
          } else {
            m.reject(h);
          }
        });
        return m.promise;
      }
      async delete(e, t = {}) {
        c.brandCheck(this, Cache);
        c.argumentLengthCheck(arguments, 1, { header: "Cache.delete" });
        e = c.converters.RequestInfo(e);
        t = c.converters.CacheQueryOptions(t);
        let r = null;
        if (e instanceof p) {
          r = e[d];
          if (r.method !== "GET" && !t.ignoreMethod) {
            return false;
          }
        } else {
          b(typeof e === "string");
          r = new p(e)[d];
        }
        const n = [];
        const o = { type: "delete", request: r, options: t };
        n.push(o);
        const s = y();
        let i = null;
        let a;
        try {
          a = this.#r(n);
        } catch (e) {
          i = e;
        }
        queueMicrotask(() => {
          if (i === null) {
            s.resolve(!!a?.length);
          } else {
            s.reject(i);
          }
        });
        return s.promise;
      }
      async keys(e = undefined, t = {}) {
        c.brandCheck(this, Cache);
        if (e !== undefined) e = c.converters.RequestInfo(e);
        t = c.converters.CacheQueryOptions(t);
        let r = null;
        if (e !== undefined) {
          if (e instanceof p) {
            r = e[d];
            if (r.method !== "GET" && !t.ignoreMethod) {
              return [];
            }
          } else if (typeof e === "string") {
            r = new p(e)[d];
          }
        }
        const n = y();
        const o = [];
        if (e === undefined) {
          for (const e of this.#e) {
            o.push(e[0]);
          }
        } else {
          const e = this.#t(r, t);
          for (const t of e) {
            o.push(t[0]);
          }
        }
        queueMicrotask(() => {
          const e = [];
          for (const t of o) {
            const r = new p("https://a");
            r[d] = t;
            r[g][A] = t.headersList;
            r[g][m] = "immutable";
            r[h] = t.client;
            e.push(r);
          }
          n.resolve(Object.freeze(e));
        });
        return n.promise;
      }
      #r(e) {
        const t = this.#e;
        const r = [...t];
        const n = [];
        const o = [];
        try {
          for (const r of e) {
            if (r.type !== "delete" && r.type !== "put") {
              throw c.errors.exception({ header: "Cache.#batchCacheOperations", message: 'operation type does not match "delete" or "put"' });
            }
            if (r.type === "delete" && r.response != null) {
              throw c.errors.exception({ header: "Cache.#batchCacheOperations", message: "delete operation should not have an associated response" });
            }
            if (this.#t(r.request, r.options, n).length) {
              throw new DOMException("???", "InvalidStateError");
            }
            let e;
            if (r.type === "delete") {
              e = this.#t(r.request, r.options);
              if (e.length === 0) {
                return [];
              }
              for (const r of e) {
                const e = t.indexOf(r);
                b(e !== -1);
                t.splice(e, 1);
              }
            } else if (r.type === "put") {
              if (r.response == null) {
                throw c.errors.exception({ header: "Cache.#batchCacheOperations", message: "put operation should have an associated response" });
              }
              const o = r.request;
              if (!I(o.url)) {
                throw c.errors.exception({ header: "Cache.#batchCacheOperations", message: "expected http or https scheme" });
              }
              if (o.method !== "GET") {
                throw c.errors.exception({ header: "Cache.#batchCacheOperations", message: "not get method" });
              }
              if (r.options != null) {
                throw c.errors.exception({ header: "Cache.#batchCacheOperations", message: "options must not be defined" });
              }
              e = this.#t(r.request);
              for (const r of e) {
                const e = t.indexOf(r);
                b(e !== -1);
                t.splice(e, 1);
              }
              t.push([r.request, r.response]);
              n.push([r.request, r.response]);
            }
            o.push([r.request, r.response]);
          }
          return o;
        } catch (e) {
          this.#e.length = 0;
          this.#e = r;
          throw e;
        }
      }
      #t(e, t, r) {
        const n = [];
        const o = r ?? this.#e;
        for (const r of o) {
          const [o, s] = r;
          if (this.#n(e, o, s, t)) {
            n.push(r);
          }
        }
        return n;
      }
      #n(e, t, r = null, n) {
        const i = new URL(e.url);
        const a = new URL(t.url);
        if (n?.ignoreSearch) {
          a.search = "";
          i.search = "";
        }
        if (!o(i, a, true)) {
          return false;
        }
        if (r == null || n?.ignoreVary || !r.headersList.contains("vary")) {
          return true;
        }
        const A = s(r.headersList.get("vary"));
        for (const r of A) {
          if (r === "*") {
            return false;
          }
          const n = t.headersList.get(r);
          const o = e.headersList.get(r);
          if (n !== o) {
            return false;
          }
        }
        return true;
      }
    }
    Object.defineProperties(Cache.prototype, {
      [Symbol.toStringTag]: { value: "Cache", configurable: true },
      match: i,
      matchAll: i,
      add: i,
      addAll: i,
      put: i,
      delete: i,
      keys: i,
    });
    const B = [
      { key: "ignoreSearch", converter: c.converters.boolean, defaultValue: false },
      { key: "ignoreMethod", converter: c.converters.boolean, defaultValue: false },
      { key: "ignoreVary", converter: c.converters.boolean, defaultValue: false },
    ];
    c.converters.CacheQueryOptions = c.dictionaryConverter(B);
    c.converters.MultiCacheQueryOptions = c.dictionaryConverter([...B, { key: "cacheName", converter: c.converters.DOMString }]);
    c.converters.Response = c.interfaceConverter(u);
    c.converters["sequence<RequestInfo>"] = c.sequenceConverter(c.converters.RequestInfo);
    e.exports = { Cache: Cache };
  },
  44738: (e, t, r) => {
    const { kConstruct: n } = r(80296);
    const { Cache: o } = r(50479);
    const { webidl: s } = r(74222);
    const { kEnumerableProperty: i } = r(3440);
    class CacheStorage {
      #o = new Map();
      constructor() {
        if (arguments[0] !== n) {
          s.illegalConstructor();
        }
      }
      async match(e, t = {}) {
        s.brandCheck(this, CacheStorage);
        s.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" });
        e = s.converters.RequestInfo(e);
        t = s.converters.MultiCacheQueryOptions(t);
        if (t.cacheName != null) {
          if (this.#o.has(t.cacheName)) {
            const r = this.#o.get(t.cacheName);
            const s = new o(n, r);
            return await s.match(e, t);
          }
        } else {
          for (const r of this.#o.values()) {
            const s = new o(n, r);
            const i = await s.match(e, t);
            if (i !== undefined) {
              return i;
            }
          }
        }
      }
      async has(e) {
        s.brandCheck(this, CacheStorage);
        s.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" });
        e = s.converters.DOMString(e);
        return this.#o.has(e);
      }
      async open(e) {
        s.brandCheck(this, CacheStorage);
        s.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" });
        e = s.converters.DOMString(e);
        if (this.#o.has(e)) {
          const t = this.#o.get(e);
          return new o(n, t);
        }
        const t = [];
        this.#o.set(e, t);
        return new o(n, t);
      }
      async delete(e) {
        s.brandCheck(this, CacheStorage);
        s.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" });
        e = s.converters.DOMString(e);
        return this.#o.delete(e);
      }
      async keys() {
        s.brandCheck(this, CacheStorage);
        const e = this.#o.keys();
        return [...e];
      }
    }
    Object.defineProperties(CacheStorage.prototype, {
      [Symbol.toStringTag]: { value: "CacheStorage", configurable: true },
      match: i,
      has: i,
      open: i,
      delete: i,
      keys: i,
    });
    e.exports = { CacheStorage: CacheStorage };
  },
  80296: (e, t, r) => {
    e.exports = { kConstruct: r(36443).kConstruct };
  },
  23993: (e, t, r) => {
    const n = r(42613);
    const { URLSerializer: o } = r(94322);
    const { isValidHeaderName: s } = r(15523);
    function urlEquals(e, t, r = false) {
      const n = o(e, r);
      const s = o(t, r);
      return n === s;
    }
    function fieldValues(e) {
      n(e !== null);
      const t = [];
      for (let r of e.split(",")) {
        r = r.trim();
        if (!r.length) {
          continue;
        } else if (!s(r)) {
          continue;
        }
        t.push(r);
      }
      return t;
    }
    e.exports = { urlEquals: urlEquals, fieldValues: fieldValues };
  },
  86197: (e, t, r) => {
    const n = r(42613);
    const o = r(69278);
    const s = r(58611);
    const { pipeline: i } = r(2203);
    const a = r(3440);
    const A = r(28804);
    const c = r(44655);
    const u = r(50001);
    const {
      RequestContentLengthMismatchError: l,
      ResponseContentLengthMismatchError: p,
      InvalidArgumentError: d,
      RequestAbortedError: g,
      HeadersTimeoutError: m,
      HeadersOverflowError: h,
      SocketError: E,
      InformationalError: I,
      BodyTimeoutError: y,
      HTTPParserError: C,
      ResponseExceededMaxSizeError: b,
      ClientDestroyedError: Q,
    } = r(68707);
    const B = r(59136);
    const {
      kUrl: T,
      kReset: v,
      kServerName: w,
      kClient: _,
      kBusy: R,
      kParser: O,
      kConnect: F,
      kBlocking: D,
      kResuming: k,
      kRunning: S,
      kPending: N,
      kSize: P,
      kWriting: L,
      kQueue: U,
      kConnected: M,
      kConnecting: G,
      kNeedDrain: x,
      kNoRef: j,
      kKeepAliveDefaultTimeout: V,
      kHostHeader: H,
      kPendingIdx: Y,
      kRunningIdx: K,
      kError: q,
      kPipelining: J,
      kSocket: W,
      kKeepAliveTimeoutValue: $,
      kMaxHeadersSize: z,
      kKeepAliveMaxTimeout: Z,
      kKeepAliveTimeoutThreshold: X,
      kHeadersTimeout: ee,
      kBodyTimeout: te,
      kStrictContentLength: re,
      kConnector: ne,
      kMaxRedirections: oe,
      kMaxRequests: se,
      kCounter: ie,
      kClose: ae,
      kDestroy: Ae,
      kDispatch: ce,
      kInterceptors: ue,
      kLocalAddress: le,
      kMaxResponseSize: pe,
      kHTTPConnVersion: de,
      kHost: fe,
      kHTTP2Session: ge,
      kHTTP2SessionState: me,
      kHTTP2BuildRequest: he,
      kHTTP2CopyHeaders: Ee,
      kHTTP1BuildRequest: Ie,
    } = r(36443);
    let ye;
    try {
      ye = r(85675);
    } catch {
      ye = { constants: {} };
    }
    const {
      constants: {
        HTTP2_HEADER_AUTHORITY: Ce,
        HTTP2_HEADER_METHOD: be,
        HTTP2_HEADER_PATH: Qe,
        HTTP2_HEADER_SCHEME: Be,
        HTTP2_HEADER_CONTENT_LENGTH: Te,
        HTTP2_HEADER_EXPECT: ve,
        HTTP2_HEADER_STATUS: we,
      },
    } = ye;
    let _e = false;
    const Re = Buffer[Symbol.species];
    const Oe = Symbol("kClosedResolve");
    const Fe = {};
    try {
      const e = r(31637);
      Fe.sendHeaders = e.channel("undici:client:sendHeaders");
      Fe.beforeConnect = e.channel("undici:client:beforeConnect");
      Fe.connectError = e.channel("undici:client:connectError");
      Fe.connected = e.channel("undici:client:connected");
    } catch {
      Fe.sendHeaders = { hasSubscribers: false };
      Fe.beforeConnect = { hasSubscribers: false };
      Fe.connectError = { hasSubscribers: false };
      Fe.connected = { hasSubscribers: false };
    }
    class Client extends u {
      constructor(
        e,
        {
          interceptors: t,
          maxHeaderSize: r,
          headersTimeout: n,
          socketTimeout: i,
          requestTimeout: A,
          connectTimeout: c,
          bodyTimeout: u,
          idleTimeout: l,
          keepAlive: p,
          keepAliveTimeout: g,
          maxKeepAliveTimeout: m,
          keepAliveMaxTimeout: h,
          keepAliveTimeoutThreshold: E,
          socketPath: I,
          pipelining: y,
          tls: C,
          strictContentLength: b,
          maxCachedSessions: Q,
          maxRedirections: v,
          connect: _,
          maxRequestsPerClient: R,
          localAddress: O,
          maxResponseSize: F,
          autoSelectFamily: D,
          autoSelectFamilyAttemptTimeout: S,
          allowH2: N,
          maxConcurrentStreams: P,
        } = {}
      ) {
        super();
        if (p !== undefined) {
          throw new d("unsupported keepAlive, use pipelining=0 instead");
        }
        if (i !== undefined) {
          throw new d("unsupported socketTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (A !== undefined) {
          throw new d("unsupported requestTimeout, use headersTimeout & bodyTimeout instead");
        }
        if (l !== undefined) {
          throw new d("unsupported idleTimeout, use keepAliveTimeout instead");
        }
        if (m !== undefined) {
          throw new d("unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead");
        }
        if (r != null && !Number.isFinite(r)) {
          throw new d("invalid maxHeaderSize");
        }
        if (I != null && typeof I !== "string") {
          throw new d("invalid socketPath");
        }
        if (c != null && (!Number.isFinite(c) || c < 0)) {
          throw new d("invalid connectTimeout");
        }
        if (g != null && (!Number.isFinite(g) || g <= 0)) {
          throw new d("invalid keepAliveTimeout");
        }
        if (h != null && (!Number.isFinite(h) || h <= 0)) {
          throw new d("invalid keepAliveMaxTimeout");
        }
        if (E != null && !Number.isFinite(E)) {
          throw new d("invalid keepAliveTimeoutThreshold");
        }
        if (n != null && (!Number.isInteger(n) || n < 0)) {
          throw new d("headersTimeout must be a positive integer or zero");
        }
        if (u != null && (!Number.isInteger(u) || u < 0)) {
          throw new d("bodyTimeout must be a positive integer or zero");
        }
        if (_ != null && typeof _ !== "function" && typeof _ !== "object") {
          throw new d("connect must be a function or an object");
        }
        if (v != null && (!Number.isInteger(v) || v < 0)) {
          throw new d("maxRedirections must be a positive number");
        }
        if (R != null && (!Number.isInteger(R) || R < 0)) {
          throw new d("maxRequestsPerClient must be a positive number");
        }
        if (O != null && (typeof O !== "string" || o.isIP(O) === 0)) {
          throw new d("localAddress must be valid string IP address");
        }
        if (F != null && (!Number.isInteger(F) || F < -1)) {
          throw new d("maxResponseSize must be a positive number");
        }
        if (S != null && (!Number.isInteger(S) || S < -1)) {
          throw new d("autoSelectFamilyAttemptTimeout must be a positive number");
        }
        if (N != null && typeof N !== "boolean") {
          throw new d("allowH2 must be a valid boolean value");
        }
        if (P != null && (typeof P !== "number" || P < 1)) {
          throw new d("maxConcurrentStreams must be a possitive integer, greater than 0");
        }
        if (typeof _ !== "function") {
          _ = B({
            ...C,
            maxCachedSessions: Q,
            allowH2: N,
            socketPath: I,
            timeout: c,
            ...(a.nodeHasAutoSelectFamily && D ? { autoSelectFamily: D, autoSelectFamilyAttemptTimeout: S } : undefined),
            ..._,
          });
        }
        this[ue] = t && t.Client && Array.isArray(t.Client) ? t.Client : [ke({ maxRedirections: v })];
        this[T] = a.parseOrigin(e);
        this[ne] = _;
        this[W] = null;
        this[J] = y != null ? y : 1;
        this[z] = r || s.maxHeaderSize;
        this[V] = g == null ? 4e3 : g;
        this[Z] = h == null ? 6e5 : h;
        this[X] = E == null ? 1e3 : E;
        this[$] = this[V];
        this[w] = null;
        this[le] = O != null ? O : null;
        this[k] = 0;
        this[x] = 0;
        this[H] = `host: ${this[T].hostname}${this[T].port ? `:${this[T].port}` : ""}\r\n`;
        this[te] = u != null ? u : 3e5;
        this[ee] = n != null ? n : 3e5;
        this[re] = b == null ? true : b;
        this[oe] = v;
        this[se] = R;
        this[Oe] = null;
        this[pe] = F > -1 ? F : -1;
        this[de] = "h1";
        this[ge] = null;
        this[me] = !N ? null : { openStreams: 0, maxConcurrentStreams: P != null ? P : 100 };
        this[fe] = `${this[T].hostname}${this[T].port ? `:${this[T].port}` : ""}`;
        this[U] = [];
        this[K] = 0;
        this[Y] = 0;
      }
      get pipelining() {
        return this[J];
      }
      set pipelining(e) {
        this[J] = e;
        resume(this, true);
      }
      get [N]() {
        return this[U].length - this[Y];
      }
      get [S]() {
        return this[Y] - this[K];
      }
      get [P]() {
        return this[U].length - this[K];
      }
      get [M]() {
        return !!this[W] && !this[G] && !this[W].destroyed;
      }
      get [R]() {
        const e = this[W];
        return (e && (e[v] || e[L] || e[D])) || this[P] >= (this[J] || 1) || this[N] > 0;
      }
      [F](e) {
        connect(this);
        this.once("connect", e);
      }
      [ce](e, t) {
        const r = e.origin || this[T].origin;
        const n = this[de] === "h2" ? c[he](r, e, t) : c[Ie](r, e, t);
        this[U].push(n);
        if (this[k]) {
        } else if (a.bodyLength(n.body) == null && a.isIterable(n.body)) {
          this[k] = 1;
          process.nextTick(resume, this);
        } else {
          resume(this, true);
        }
        if (this[k] && this[x] !== 2 && this[R]) {
          this[x] = 2;
        }
        return this[x] < 2;
      }
      async [ae]() {
        return new Promise((e) => {
          if (!this[P]) {
            e(null);
          } else {
            this[Oe] = e;
          }
        });
      }
      async [Ae](e) {
        return new Promise((t) => {
          const r = this[U].splice(this[Y]);
          for (let t = 0; t < r.length; t++) {
            const n = r[t];
            errorRequest(this, n, e);
          }
          const callback = () => {
            if (this[Oe]) {
              this[Oe]();
              this[Oe] = null;
            }
            t();
          };
          if (this[ge] != null) {
            a.destroy(this[ge], e);
            this[ge] = null;
            this[me] = null;
          }
          if (!this[W]) {
            queueMicrotask(callback);
          } else {
            a.destroy(this[W].on("close", callback), e);
          }
          resume(this);
        });
      }
    }
    function onHttp2SessionError(e) {
      n(e.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      this[W][q] = e;
      onError(this[_], e);
    }
    function onHttp2FrameError(e, t, r) {
      const n = new I(`HTTP/2: "frameError" received - type ${e}, code ${t}`);
      if (r === 0) {
        this[W][q] = n;
        onError(this[_], n);
      }
    }
    function onHttp2SessionEnd() {
      a.destroy(this, new E("other side closed"));
      a.destroy(this[W], new E("other side closed"));
    }
    function onHTTP2GoAway(e) {
      const t = this[_];
      const r = new I(`HTTP/2: "GOAWAY" frame received with code ${e}`);
      t[W] = null;
      t[ge] = null;
      if (t.destroyed) {
        n(this[N] === 0);
        const e = t[U].splice(t[K]);
        for (let t = 0; t < e.length; t++) {
          const n = e[t];
          errorRequest(this, n, r);
        }
      } else if (t[S] > 0) {
        const e = t[U][t[K]];
        t[U][t[K]++] = null;
        errorRequest(t, e, r);
      }
      t[Y] = t[K];
      n(t[S] === 0);
      t.emit("disconnect", t[T], [t], r);
      resume(t);
    }
    const De = r(52824);
    const ke = r(64415);
    const Se = Buffer.alloc(0);
    async function lazyllhttp() {
      const e = process.env.JEST_WORKER_ID ? r(63870) : undefined;
      let t;
      try {
        t = await WebAssembly.compile(Buffer.from(r(53434), "base64"));
      } catch (n) {
        t = await WebAssembly.compile(Buffer.from(e || r(63870), "base64"));
      }
      return await WebAssembly.instantiate(t, {
        env: {
          wasm_on_url: (e, t, r) => 0,
          wasm_on_status: (e, t, r) => {
            n.strictEqual(Le.ptr, e);
            const o = t - Ge + Ue.byteOffset;
            return Le.onStatus(new Re(Ue.buffer, o, r)) || 0;
          },
          wasm_on_message_begin: (e) => {
            n.strictEqual(Le.ptr, e);
            return Le.onMessageBegin() || 0;
          },
          wasm_on_header_field: (e, t, r) => {
            n.strictEqual(Le.ptr, e);
            const o = t - Ge + Ue.byteOffset;
            return Le.onHeaderField(new Re(Ue.buffer, o, r)) || 0;
          },
          wasm_on_header_value: (e, t, r) => {
            n.strictEqual(Le.ptr, e);
            const o = t - Ge + Ue.byteOffset;
            return Le.onHeaderValue(new Re(Ue.buffer, o, r)) || 0;
          },
          wasm_on_headers_complete: (e, t, r, o) => {
            n.strictEqual(Le.ptr, e);
            return Le.onHeadersComplete(t, Boolean(r), Boolean(o)) || 0;
          },
          wasm_on_body: (e, t, r) => {
            n.strictEqual(Le.ptr, e);
            const o = t - Ge + Ue.byteOffset;
            return Le.onBody(new Re(Ue.buffer, o, r)) || 0;
          },
          wasm_on_message_complete: (e) => {
            n.strictEqual(Le.ptr, e);
            return Le.onMessageComplete() || 0;
          },
        },
      });
    }
    let Ne = null;
    let Pe = lazyllhttp();
    Pe.catch();
    let Le = null;
    let Ue = null;
    let Me = 0;
    let Ge = null;
    const xe = 1;
    const je = 2;
    const Ve = 3;
    class Parser {
      constructor(e, t, { exports: r }) {
        n(Number.isFinite(e[z]) && e[z] > 0);
        this.llhttp = r;
        this.ptr = this.llhttp.llhttp_alloc(De.TYPE.RESPONSE);
        this.client = e;
        this.socket = t;
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.statusCode = null;
        this.statusText = "";
        this.upgrade = false;
        this.headers = [];
        this.headersSize = 0;
        this.headersMaxSize = e[z];
        this.shouldKeepAlive = false;
        this.paused = false;
        this.resume = this.resume.bind(this);
        this.bytesRead = 0;
        this.keepAlive = "";
        this.contentLength = "";
        this.connection = "";
        this.maxResponseSize = e[pe];
      }
      setTimeout(e, t) {
        this.timeoutType = t;
        if (e !== this.timeoutValue) {
          A.clearTimeout(this.timeout);
          if (e) {
            this.timeout = A.setTimeout(onParserTimeout, e, this);
            if (this.timeout.unref) {
              this.timeout.unref();
            }
          } else {
            this.timeout = null;
          }
          this.timeoutValue = e;
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
      }
      resume() {
        if (this.socket.destroyed || !this.paused) {
          return;
        }
        n(this.ptr != null);
        n(Le == null);
        this.llhttp.llhttp_resume(this.ptr);
        n(this.timeoutType === je);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        this.paused = false;
        this.execute(this.socket.read() || Se);
        this.readMore();
      }
      readMore() {
        while (!this.paused && this.ptr) {
          const e = this.socket.read();
          if (e === null) {
            break;
          }
          this.execute(e);
        }
      }
      execute(e) {
        n(this.ptr != null);
        n(Le == null);
        n(!this.paused);
        const { socket: t, llhttp: r } = this;
        if (e.length > Me) {
          if (Ge) {
            r.free(Ge);
          }
          Me = Math.ceil(e.length / 4096) * 4096;
          Ge = r.malloc(Me);
        }
        new Uint8Array(r.memory.buffer, Ge, Me).set(e);
        try {
          let n;
          try {
            Ue = e;
            Le = this;
            n = r.llhttp_execute(this.ptr, Ge, e.length);
          } catch (e) {
            throw e;
          } finally {
            Le = null;
            Ue = null;
          }
          const o = r.llhttp_get_error_pos(this.ptr) - Ge;
          if (n === De.ERROR.PAUSED_UPGRADE) {
            this.onUpgrade(e.slice(o));
          } else if (n === De.ERROR.PAUSED) {
            this.paused = true;
            t.unshift(e.slice(o));
          } else if (n !== De.ERROR.OK) {
            const t = r.llhttp_get_error_reason(this.ptr);
            let s = "";
            if (t) {
              const e = new Uint8Array(r.memory.buffer, t).indexOf(0);
              s = "Response does not match the HTTP/1.1 protocol (" + Buffer.from(r.memory.buffer, t, e).toString() + ")";
            }
            throw new C(s, De.ERROR[n], e.slice(o));
          }
        } catch (e) {
          a.destroy(t, e);
        }
      }
      destroy() {
        n(this.ptr != null);
        n(Le == null);
        this.llhttp.llhttp_free(this.ptr);
        this.ptr = null;
        A.clearTimeout(this.timeout);
        this.timeout = null;
        this.timeoutValue = null;
        this.timeoutType = null;
        this.paused = false;
      }
      onStatus(e) {
        this.statusText = e.toString();
      }
      onMessageBegin() {
        const { socket: e, client: t } = this;
        if (e.destroyed) {
          return -1;
        }
        const r = t[U][t[K]];
        if (!r) {
          return -1;
        }
      }
      onHeaderField(e) {
        const t = this.headers.length;
        if ((t & 1) === 0) {
          this.headers.push(e);
        } else {
          this.headers[t - 1] = Buffer.concat([this.headers[t - 1], e]);
        }
        this.trackHeader(e.length);
      }
      onHeaderValue(e) {
        let t = this.headers.length;
        if ((t & 1) === 1) {
          this.headers.push(e);
          t += 1;
        } else {
          this.headers[t - 1] = Buffer.concat([this.headers[t - 1], e]);
        }
        const r = this.headers[t - 2];
        if (r.length === 10 && r.toString().toLowerCase() === "keep-alive") {
          this.keepAlive += e.toString();
        } else if (r.length === 10 && r.toString().toLowerCase() === "connection") {
          this.connection += e.toString();
        } else if (r.length === 14 && r.toString().toLowerCase() === "content-length") {
          this.contentLength += e.toString();
        }
        this.trackHeader(e.length);
      }
      trackHeader(e) {
        this.headersSize += e;
        if (this.headersSize >= this.headersMaxSize) {
          a.destroy(this.socket, new h());
        }
      }
      onUpgrade(e) {
        const { upgrade: t, client: r, socket: o, headers: s, statusCode: i } = this;
        n(t);
        const A = r[U][r[K]];
        n(A);
        n(!o.destroyed);
        n(o === r[W]);
        n(!this.paused);
        n(A.upgrade || A.method === "CONNECT");
        this.statusCode = null;
        this.statusText = "";
        this.shouldKeepAlive = null;
        n(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        o.unshift(e);
        o[O].destroy();
        o[O] = null;
        o[_] = null;
        o[q] = null;
        o.removeListener("error", onSocketError)
          .removeListener("readable", onSocketReadable)
          .removeListener("end", onSocketEnd)
          .removeListener("close", onSocketClose);
        r[W] = null;
        r[U][r[K]++] = null;
        r.emit("disconnect", r[T], [r], new I("upgrade"));
        try {
          A.onUpgrade(i, s, o);
        } catch (e) {
          a.destroy(o, e);
        }
        resume(r);
      }
      onHeadersComplete(e, t, r) {
        const { client: o, socket: s, headers: i, statusText: A } = this;
        if (s.destroyed) {
          return -1;
        }
        const c = o[U][o[K]];
        if (!c) {
          return -1;
        }
        n(!this.upgrade);
        n(this.statusCode < 200);
        if (e === 100) {
          a.destroy(s, new E("bad response", a.getSocketInfo(s)));
          return -1;
        }
        if (t && !c.upgrade) {
          a.destroy(s, new E("bad upgrade", a.getSocketInfo(s)));
          return -1;
        }
        n.strictEqual(this.timeoutType, xe);
        this.statusCode = e;
        this.shouldKeepAlive = r || (c.method === "HEAD" && !s[v] && this.connection.toLowerCase() === "keep-alive");
        if (this.statusCode >= 200) {
          const e = c.bodyTimeout != null ? c.bodyTimeout : o[te];
          this.setTimeout(e, je);
        } else if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        if (c.method === "CONNECT") {
          n(o[S] === 1);
          this.upgrade = true;
          return 2;
        }
        if (t) {
          n(o[S] === 1);
          this.upgrade = true;
          return 2;
        }
        n(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (this.shouldKeepAlive && o[J]) {
          const e = this.keepAlive ? a.parseKeepAliveTimeout(this.keepAlive) : null;
          if (e != null) {
            const t = Math.min(e - o[X], o[Z]);
            if (t <= 0) {
              s[v] = true;
            } else {
              o[$] = t;
            }
          } else {
            o[$] = o[V];
          }
        } else {
          s[v] = true;
        }
        const u = c.onHeaders(e, i, this.resume, A) === false;
        if (c.aborted) {
          return -1;
        }
        if (c.method === "HEAD") {
          return 1;
        }
        if (e < 200) {
          return 1;
        }
        if (s[D]) {
          s[D] = false;
          resume(o);
        }
        return u ? De.ERROR.PAUSED : 0;
      }
      onBody(e) {
        const { client: t, socket: r, statusCode: o, maxResponseSize: s } = this;
        if (r.destroyed) {
          return -1;
        }
        const i = t[U][t[K]];
        n(i);
        n.strictEqual(this.timeoutType, je);
        if (this.timeout) {
          if (this.timeout.refresh) {
            this.timeout.refresh();
          }
        }
        n(o >= 200);
        if (s > -1 && this.bytesRead + e.length > s) {
          a.destroy(r, new b());
          return -1;
        }
        this.bytesRead += e.length;
        if (i.onData(e) === false) {
          return De.ERROR.PAUSED;
        }
      }
      onMessageComplete() {
        const { client: e, socket: t, statusCode: r, upgrade: o, headers: s, contentLength: i, bytesRead: A, shouldKeepAlive: c } = this;
        if (t.destroyed && (!r || c)) {
          return -1;
        }
        if (o) {
          return;
        }
        const u = e[U][e[K]];
        n(u);
        n(r >= 100);
        this.statusCode = null;
        this.statusText = "";
        this.bytesRead = 0;
        this.contentLength = "";
        this.keepAlive = "";
        this.connection = "";
        n(this.headers.length % 2 === 0);
        this.headers = [];
        this.headersSize = 0;
        if (r < 200) {
          return;
        }
        if (u.method !== "HEAD" && i && A !== parseInt(i, 10)) {
          a.destroy(t, new p());
          return -1;
        }
        u.onComplete(s);
        e[U][e[K]++] = null;
        if (t[L]) {
          n.strictEqual(e[S], 0);
          a.destroy(t, new I("reset"));
          return De.ERROR.PAUSED;
        } else if (!c) {
          a.destroy(t, new I("reset"));
          return De.ERROR.PAUSED;
        } else if (t[v] && e[S] === 0) {
          a.destroy(t, new I("reset"));
          return De.ERROR.PAUSED;
        } else if (e[J] === 1) {
          setImmediate(resume, e);
        } else {
          resume(e);
        }
      }
    }
    function onParserTimeout(e) {
      const { socket: t, timeoutType: r, client: o } = e;
      if (r === xe) {
        if (!t[L] || t.writableNeedDrain || o[S] > 1) {
          n(!e.paused, "cannot be paused while waiting for headers");
          a.destroy(t, new m());
        }
      } else if (r === je) {
        if (!e.paused) {
          a.destroy(t, new y());
        }
      } else if (r === Ve) {
        n(o[S] === 0 && o[$]);
        a.destroy(t, new I("socket idle timeout"));
      }
    }
    function onSocketReadable() {
      const { [O]: e } = this;
      if (e) {
        e.readMore();
      }
    }
    function onSocketError(e) {
      const { [_]: t, [O]: r } = this;
      n(e.code !== "ERR_TLS_CERT_ALTNAME_INVALID");
      if (t[de] !== "h2") {
        if (e.code === "ECONNRESET" && r.statusCode && !r.shouldKeepAlive) {
          r.onMessageComplete();
          return;
        }
      }
      this[q] = e;
      onError(this[_], e);
    }
    function onError(e, t) {
      if (e[S] === 0 && t.code !== "UND_ERR_INFO" && t.code !== "UND_ERR_SOCKET") {
        n(e[Y] === e[K]);
        const r = e[U].splice(e[K]);
        for (let n = 0; n < r.length; n++) {
          const o = r[n];
          errorRequest(e, o, t);
        }
        n(e[P] === 0);
      }
    }
    function onSocketEnd() {
      const { [O]: e, [_]: t } = this;
      if (t[de] !== "h2") {
        if (e.statusCode && !e.shouldKeepAlive) {
          e.onMessageComplete();
          return;
        }
      }
      a.destroy(this, new E("other side closed", a.getSocketInfo(this)));
    }
    function onSocketClose() {
      const { [_]: e, [O]: t } = this;
      if (e[de] === "h1" && t) {
        if (!this[q] && t.statusCode && !t.shouldKeepAlive) {
          t.onMessageComplete();
        }
        this[O].destroy();
        this[O] = null;
      }
      const r = this[q] || new E("closed", a.getSocketInfo(this));
      e[W] = null;
      if (e.destroyed) {
        n(e[N] === 0);
        const t = e[U].splice(e[K]);
        for (let n = 0; n < t.length; n++) {
          const o = t[n];
          errorRequest(e, o, r);
        }
      } else if (e[S] > 0 && r.code !== "UND_ERR_INFO") {
        const t = e[U][e[K]];
        e[U][e[K]++] = null;
        errorRequest(e, t, r);
      }
      e[Y] = e[K];
      n(e[S] === 0);
      e.emit("disconnect", e[T], [e], r);
      resume(e);
    }
    async function connect(e) {
      n(!e[G]);
      n(!e[W]);
      let { host: t, hostname: r, protocol: s, port: i } = e[T];
      if (r[0] === "[") {
        const e = r.indexOf("]");
        n(e !== -1);
        const t = r.substring(1, e);
        n(o.isIP(t));
        r = t;
      }
      e[G] = true;
      if (Fe.beforeConnect.hasSubscribers) {
        Fe.beforeConnect.publish({ connectParams: { host: t, hostname: r, protocol: s, port: i, servername: e[w], localAddress: e[le] }, connector: e[ne] });
      }
      try {
        const o = await new Promise((n, o) => {
          e[ne]({ host: t, hostname: r, protocol: s, port: i, servername: e[w], localAddress: e[le] }, (e, t) => {
            if (e) {
              o(e);
            } else {
              n(t);
            }
          });
        });
        if (e.destroyed) {
          a.destroy(
            o.on("error", () => {}),
            new Q()
          );
          return;
        }
        e[G] = false;
        n(o);
        const A = o.alpnProtocol === "h2";
        if (A) {
          if (!_e) {
            _e = true;
            process.emitWarning("H2 support is experimental, expect them to change at any time.", { code: "UNDICI-H2" });
          }
          const t = ye.connect(e[T], { createConnection: () => o, peerMaxConcurrentStreams: e[me].maxConcurrentStreams });
          e[de] = "h2";
          t[_] = e;
          t[W] = o;
          t.on("error", onHttp2SessionError);
          t.on("frameError", onHttp2FrameError);
          t.on("end", onHttp2SessionEnd);
          t.on("goaway", onHTTP2GoAway);
          t.on("close", onSocketClose);
          t.unref();
          e[ge] = t;
          o[ge] = t;
        } else {
          if (!Ne) {
            Ne = await Pe;
            Pe = null;
          }
          o[j] = false;
          o[L] = false;
          o[v] = false;
          o[D] = false;
          o[O] = new Parser(e, o, Ne);
        }
        o[ie] = 0;
        o[se] = e[se];
        o[_] = e;
        o[q] = null;
        o.on("error", onSocketError).on("readable", onSocketReadable).on("end", onSocketEnd).on("close", onSocketClose);
        e[W] = o;
        if (Fe.connected.hasSubscribers) {
          Fe.connected.publish({
            connectParams: { host: t, hostname: r, protocol: s, port: i, servername: e[w], localAddress: e[le] },
            connector: e[ne],
            socket: o,
          });
        }
        e.emit("connect", e[T], [e]);
      } catch (o) {
        if (e.destroyed) {
          return;
        }
        e[G] = false;
        if (Fe.connectError.hasSubscribers) {
          Fe.connectError.publish({
            connectParams: { host: t, hostname: r, protocol: s, port: i, servername: e[w], localAddress: e[le] },
            connector: e[ne],
            error: o,
          });
        }
        if (o.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
          n(e[S] === 0);
          while (e[N] > 0 && e[U][e[Y]].servername === e[w]) {
            const t = e[U][e[Y]++];
            errorRequest(e, t, o);
          }
        } else {
          onError(e, o);
        }
        e.emit("connectionError", e[T], [e], o);
      }
      resume(e);
    }
    function emitDrain(e) {
      e[x] = 0;
      e.emit("drain", e[T], [e]);
    }
    function resume(e, t) {
      if (e[k] === 2) {
        return;
      }
      e[k] = 2;
      _resume(e, t);
      e[k] = 0;
      if (e[K] > 256) {
        e[U].splice(0, e[K]);
        e[Y] -= e[K];
        e[K] = 0;
      }
    }
    function _resume(e, t) {
      while (true) {
        if (e.destroyed) {
          n(e[N] === 0);
          return;
        }
        if (e[Oe] && !e[P]) {
          e[Oe]();
          e[Oe] = null;
          return;
        }
        const r = e[W];
        if (r && !r.destroyed && r.alpnProtocol !== "h2") {
          if (e[P] === 0) {
            if (!r[j] && r.unref) {
              r.unref();
              r[j] = true;
            }
          } else if (r[j] && r.ref) {
            r.ref();
            r[j] = false;
          }
          if (e[P] === 0) {
            if (r[O].timeoutType !== Ve) {
              r[O].setTimeout(e[$], Ve);
            }
          } else if (e[S] > 0 && r[O].statusCode < 200) {
            if (r[O].timeoutType !== xe) {
              const t = e[U][e[K]];
              const n = t.headersTimeout != null ? t.headersTimeout : e[ee];
              r[O].setTimeout(n, xe);
            }
          }
        }
        if (e[R]) {
          e[x] = 2;
        } else if (e[x] === 2) {
          if (t) {
            e[x] = 1;
            process.nextTick(emitDrain, e);
          } else {
            emitDrain(e);
          }
          continue;
        }
        if (e[N] === 0) {
          return;
        }
        if (e[S] >= (e[J] || 1)) {
          return;
        }
        const o = e[U][e[Y]];
        if (e[T].protocol === "https:" && e[w] !== o.servername) {
          if (e[S] > 0) {
            return;
          }
          e[w] = o.servername;
          if (r && r.servername !== o.servername) {
            a.destroy(r, new I("servername changed"));
            return;
          }
        }
        if (e[G]) {
          return;
        }
        if (!r && !e[ge]) {
          connect(e);
          return;
        }
        if (r.destroyed || r[L] || r[v] || r[D]) {
          return;
        }
        if (e[S] > 0 && !o.idempotent) {
          return;
        }
        if (e[S] > 0 && (o.upgrade || o.method === "CONNECT")) {
          return;
        }
        if (e[S] > 0 && a.bodyLength(o.body) !== 0 && (a.isStream(o.body) || a.isAsyncIterable(o.body))) {
          return;
        }
        if (!o.aborted && write(e, o)) {
          e[Y]++;
        } else {
          e[U].splice(e[Y], 1);
        }
      }
    }
    function shouldSendContentLength(e) {
      return e !== "GET" && e !== "HEAD" && e !== "OPTIONS" && e !== "TRACE" && e !== "CONNECT";
    }
    function write(e, t) {
      if (e[de] === "h2") {
        writeH2(e, e[ge], t);
        return;
      }
      const { body: r, method: o, path: s, host: i, upgrade: A, headers: c, blocking: u, reset: p } = t;
      const d = o === "PUT" || o === "POST" || o === "PATCH";
      if (r && typeof r.read === "function") {
        r.read(0);
      }
      const m = a.bodyLength(r);
      let h = m;
      if (h === null) {
        h = t.contentLength;
      }
      if (h === 0 && !d) {
        h = null;
      }
      if (shouldSendContentLength(o) && h > 0 && t.contentLength !== null && t.contentLength !== h) {
        if (e[re]) {
          errorRequest(e, t, new l());
          return false;
        }
        process.emitWarning(new l());
      }
      const E = e[W];
      try {
        t.onConnect((r) => {
          if (t.aborted || t.completed) {
            return;
          }
          errorRequest(e, t, r || new g());
          a.destroy(E, new I("aborted"));
        });
      } catch (r) {
        errorRequest(e, t, r);
      }
      if (t.aborted) {
        return false;
      }
      if (o === "HEAD") {
        E[v] = true;
      }
      if (A || o === "CONNECT") {
        E[v] = true;
      }
      if (p != null) {
        E[v] = p;
      }
      if (e[se] && E[ie]++ >= e[se]) {
        E[v] = true;
      }
      if (u) {
        E[D] = true;
      }
      let y = `${o} ${s} HTTP/1.1\r\n`;
      if (typeof i === "string") {
        y += `host: ${i}\r\n`;
      } else {
        y += e[H];
      }
      if (A) {
        y += `connection: upgrade\r\nupgrade: ${A}\r\n`;
      } else if (e[J] && !E[v]) {
        y += "connection: keep-alive\r\n";
      } else {
        y += "connection: close\r\n";
      }
      if (c) {
        y += c;
      }
      if (Fe.sendHeaders.hasSubscribers) {
        Fe.sendHeaders.publish({ request: t, headers: y, socket: E });
      }
      if (!r || m === 0) {
        if (h === 0) {
          E.write(`${y}content-length: 0\r\n\r\n`, "latin1");
        } else {
          n(h === null, "no body must not have content length");
          E.write(`${y}\r\n`, "latin1");
        }
        t.onRequestSent();
      } else if (a.isBuffer(r)) {
        n(h === r.byteLength, "buffer body must have content length");
        E.cork();
        E.write(`${y}content-length: ${h}\r\n\r\n`, "latin1");
        E.write(r);
        E.uncork();
        t.onBodySent(r);
        t.onRequestSent();
        if (!d) {
          E[v] = true;
        }
      } else if (a.isBlobLike(r)) {
        if (typeof r.stream === "function") {
          writeIterable({ body: r.stream(), client: e, request: t, socket: E, contentLength: h, header: y, expectsPayload: d });
        } else {
          writeBlob({ body: r, client: e, request: t, socket: E, contentLength: h, header: y, expectsPayload: d });
        }
      } else if (a.isStream(r)) {
        writeStream({ body: r, client: e, request: t, socket: E, contentLength: h, header: y, expectsPayload: d });
      } else if (a.isIterable(r)) {
        writeIterable({ body: r, client: e, request: t, socket: E, contentLength: h, header: y, expectsPayload: d });
      } else {
        n(false);
      }
      return true;
    }
    function writeH2(e, t, r) {
      const { body: o, method: s, path: i, host: A, upgrade: u, expectContinue: p, signal: d, headers: m } = r;
      let h;
      if (typeof m === "string") h = c[Ee](m.trim());
      else h = m;
      if (u) {
        errorRequest(e, r, new Error("Upgrade not supported for H2"));
        return false;
      }
      try {
        r.onConnect((t) => {
          if (r.aborted || r.completed) {
            return;
          }
          errorRequest(e, r, t || new g());
        });
      } catch (t) {
        errorRequest(e, r, t);
      }
      if (r.aborted) {
        return false;
      }
      let E;
      const y = e[me];
      h[Ce] = A || e[fe];
      h[be] = s;
      if (s === "CONNECT") {
        t.ref();
        E = t.request(h, { endStream: false, signal: d });
        if (E.id && !E.pending) {
          r.onUpgrade(null, null, E);
          ++y.openStreams;
        } else {
          E.once("ready", () => {
            r.onUpgrade(null, null, E);
            ++y.openStreams;
          });
        }
        E.once("close", () => {
          y.openStreams -= 1;
          if (y.openStreams === 0) t.unref();
        });
        return true;
      }
      h[Qe] = i;
      h[Be] = "https";
      const C = s === "PUT" || s === "POST" || s === "PATCH";
      if (o && typeof o.read === "function") {
        o.read(0);
      }
      let b = a.bodyLength(o);
      if (b == null) {
        b = r.contentLength;
      }
      if (b === 0 || !C) {
        b = null;
      }
      if (shouldSendContentLength(s) && b > 0 && r.contentLength != null && r.contentLength !== b) {
        if (e[re]) {
          errorRequest(e, r, new l());
          return false;
        }
        process.emitWarning(new l());
      }
      if (b != null) {
        n(o, "no body must not have content length");
        h[Te] = `${b}`;
      }
      t.ref();
      const Q = s === "GET" || s === "HEAD";
      if (p) {
        h[ve] = "100-continue";
        E = t.request(h, { endStream: Q, signal: d });
        E.once("continue", writeBodyH2);
      } else {
        E = t.request(h, { endStream: Q, signal: d });
        writeBodyH2();
      }
      ++y.openStreams;
      E.once("response", (e) => {
        const { [we]: t, ...n } = e;
        if (r.onHeaders(Number(t), n, E.resume.bind(E), "") === false) {
          E.pause();
        }
      });
      E.once("end", () => {
        r.onComplete([]);
      });
      E.on("data", (e) => {
        if (r.onData(e) === false) {
          E.pause();
        }
      });
      E.once("close", () => {
        y.openStreams -= 1;
        if (y.openStreams === 0) {
          t.unref();
        }
      });
      E.once("error", function (t) {
        if (e[ge] && !e[ge].destroyed && !this.closed && !this.destroyed) {
          y.streams -= 1;
          a.destroy(E, t);
        }
      });
      E.once("frameError", (t, n) => {
        const o = new I(`HTTP/2: "frameError" received - type ${t}, code ${n}`);
        errorRequest(e, r, o);
        if (e[ge] && !e[ge].destroyed && !this.closed && !this.destroyed) {
          y.streams -= 1;
          a.destroy(E, o);
        }
      });
      return true;
      function writeBodyH2() {
        if (!o) {
          r.onRequestSent();
        } else if (a.isBuffer(o)) {
          n(b === o.byteLength, "buffer body must have content length");
          E.cork();
          E.write(o);
          E.uncork();
          E.end();
          r.onBodySent(o);
          r.onRequestSent();
        } else if (a.isBlobLike(o)) {
          if (typeof o.stream === "function") {
            writeIterable({ client: e, request: r, contentLength: b, h2stream: E, expectsPayload: C, body: o.stream(), socket: e[W], header: "" });
          } else {
            writeBlob({ body: o, client: e, request: r, contentLength: b, expectsPayload: C, h2stream: E, header: "", socket: e[W] });
          }
        } else if (a.isStream(o)) {
          writeStream({ body: o, client: e, request: r, contentLength: b, expectsPayload: C, socket: e[W], h2stream: E, header: "" });
        } else if (a.isIterable(o)) {
          writeIterable({ body: o, client: e, request: r, contentLength: b, expectsPayload: C, header: "", h2stream: E, socket: e[W] });
        } else {
          n(false);
        }
      }
    }
    function writeStream({ h2stream: e, body: t, client: r, request: o, socket: s, contentLength: A, header: c, expectsPayload: u }) {
      n(A !== 0 || r[S] === 0, "stream body cannot be pipelined");
      if (r[de] === "h2") {
        const d = i(t, e, (r) => {
          if (r) {
            a.destroy(t, r);
            a.destroy(e, r);
          } else {
            o.onRequestSent();
          }
        });
        d.on("data", onPipeData);
        d.once("end", () => {
          d.removeListener("data", onPipeData);
          a.destroy(d);
        });
        function onPipeData(e) {
          o.onBodySent(e);
        }
        return;
      }
      let l = false;
      const p = new AsyncWriter({ socket: s, request: o, contentLength: A, client: r, expectsPayload: u, header: c });
      const onData = function (e) {
        if (l) {
          return;
        }
        try {
          if (!p.write(e) && this.pause) {
            this.pause();
          }
        } catch (e) {
          a.destroy(this, e);
        }
      };
      const onDrain = function () {
        if (l) {
          return;
        }
        if (t.resume) {
          t.resume();
        }
      };
      const onAbort = function () {
        if (l) {
          return;
        }
        const e = new g();
        queueMicrotask(() => onFinished(e));
      };
      const onFinished = function (e) {
        if (l) {
          return;
        }
        l = true;
        n(s.destroyed || (s[L] && r[S] <= 1));
        s.off("drain", onDrain).off("error", onFinished);
        t.removeListener("data", onData).removeListener("end", onFinished).removeListener("error", onFinished).removeListener("close", onAbort);
        if (!e) {
          try {
            p.end();
          } catch (t) {
            e = t;
          }
        }
        p.destroy(e);
        if (e && (e.code !== "UND_ERR_INFO" || e.message !== "reset")) {
          a.destroy(t, e);
        } else {
          a.destroy(t);
        }
      };
      t.on("data", onData).on("end", onFinished).on("error", onFinished).on("close", onAbort);
      if (t.resume) {
        t.resume();
      }
      s.on("drain", onDrain).on("error", onFinished);
    }
    async function writeBlob({ h2stream: e, body: t, client: r, request: o, socket: s, contentLength: i, header: A, expectsPayload: c }) {
      n(i === t.size, "blob body must have content length");
      const u = r[de] === "h2";
      try {
        if (i != null && i !== t.size) {
          throw new l();
        }
        const n = Buffer.from(await t.arrayBuffer());
        if (u) {
          e.cork();
          e.write(n);
          e.uncork();
        } else {
          s.cork();
          s.write(`${A}content-length: ${i}\r\n\r\n`, "latin1");
          s.write(n);
          s.uncork();
        }
        o.onBodySent(n);
        o.onRequestSent();
        if (!c) {
          s[v] = true;
        }
        resume(r);
      } catch (t) {
        a.destroy(u ? e : s, t);
      }
    }
    async function writeIterable({ h2stream: e, body: t, client: r, request: o, socket: s, contentLength: i, header: a, expectsPayload: A }) {
      n(i !== 0 || r[S] === 0, "iterator body cannot be pipelined");
      let c = null;
      function onDrain() {
        if (c) {
          const e = c;
          c = null;
          e();
        }
      }
      const waitForDrain = () =>
        new Promise((e, t) => {
          n(c === null);
          if (s[q]) {
            t(s[q]);
          } else {
            c = e;
          }
        });
      if (r[de] === "h2") {
        e.on("close", onDrain).on("drain", onDrain);
        try {
          for await (const r of t) {
            if (s[q]) {
              throw s[q];
            }
            const t = e.write(r);
            o.onBodySent(r);
            if (!t) {
              await waitForDrain();
            }
          }
        } catch (t) {
          e.destroy(t);
        } finally {
          o.onRequestSent();
          e.end();
          e.off("close", onDrain).off("drain", onDrain);
        }
        return;
      }
      s.on("close", onDrain).on("drain", onDrain);
      const u = new AsyncWriter({ socket: s, request: o, contentLength: i, client: r, expectsPayload: A, header: a });
      try {
        for await (const e of t) {
          if (s[q]) {
            throw s[q];
          }
          if (!u.write(e)) {
            await waitForDrain();
          }
        }
        u.end();
      } catch (e) {
        u.destroy(e);
      } finally {
        s.off("close", onDrain).off("drain", onDrain);
      }
    }
    class AsyncWriter {
      constructor({ socket: e, request: t, contentLength: r, client: n, expectsPayload: o, header: s }) {
        this.socket = e;
        this.request = t;
        this.contentLength = r;
        this.client = n;
        this.bytesWritten = 0;
        this.expectsPayload = o;
        this.header = s;
        e[L] = true;
      }
      write(e) {
        const { socket: t, request: r, contentLength: n, client: o, bytesWritten: s, expectsPayload: i, header: a } = this;
        if (t[q]) {
          throw t[q];
        }
        if (t.destroyed) {
          return false;
        }
        const A = Buffer.byteLength(e);
        if (!A) {
          return true;
        }
        if (n !== null && s + A > n) {
          if (o[re]) {
            throw new l();
          }
          process.emitWarning(new l());
        }
        t.cork();
        if (s === 0) {
          if (!i) {
            t[v] = true;
          }
          if (n === null) {
            t.write(`${a}transfer-encoding: chunked\r\n`, "latin1");
          } else {
            t.write(`${a}content-length: ${n}\r\n\r\n`, "latin1");
          }
        }
        if (n === null) {
          t.write(`\r\n${A.toString(16)}\r\n`, "latin1");
        }
        this.bytesWritten += A;
        const c = t.write(e);
        t.uncork();
        r.onBodySent(e);
        if (!c) {
          if (t[O].timeout && t[O].timeoutType === xe) {
            if (t[O].timeout.refresh) {
              t[O].timeout.refresh();
            }
          }
        }
        return c;
      }
      end() {
        const { socket: e, contentLength: t, client: r, bytesWritten: n, expectsPayload: o, header: s, request: i } = this;
        i.onRequestSent();
        e[L] = false;
        if (e[q]) {
          throw e[q];
        }
        if (e.destroyed) {
          return;
        }
        if (n === 0) {
          if (o) {
            e.write(`${s}content-length: 0\r\n\r\n`, "latin1");
          } else {
            e.write(`${s}\r\n`, "latin1");
          }
        } else if (t === null) {
          e.write("\r\n0\r\n\r\n", "latin1");
        }
        if (t !== null && n !== t) {
          if (r[re]) {
            throw new l();
          } else {
            process.emitWarning(new l());
          }
        }
        if (e[O].timeout && e[O].timeoutType === xe) {
          if (e[O].timeout.refresh) {
            e[O].timeout.refresh();
          }
        }
        resume(r);
      }
      destroy(e) {
        const { socket: t, client: r } = this;
        t[L] = false;
        if (e) {
          n(r[S] <= 1, "pipeline should only contain this request");
          a.destroy(t, e);
        }
      }
    }
    function errorRequest(e, t, r) {
      try {
        t.onError(r);
        n(t.aborted);
      } catch (r) {
        e.emit("error", r);
      }
    }
    e.exports = Client;
  },
  13194: (e, t, r) => {
    const { kConnected: n, kSize: o } = r(36443);
    class CompatWeakRef {
      constructor(e) {
        this.value = e;
      }
      deref() {
        return this.value[n] === 0 && this.value[o] === 0 ? undefined : this.value;
      }
    }
    class CompatFinalizer {
      constructor(e) {
        this.finalizer = e;
      }
      register(e, t) {
        if (e.on) {
          e.on("disconnect", () => {
            if (e[n] === 0 && e[o] === 0) {
              this.finalizer(t);
            }
          });
        }
      }
    }
    e.exports = function () {
      if (process.env.NODE_V8_COVERAGE) {
        return { WeakRef: CompatWeakRef, FinalizationRegistry: CompatFinalizer };
      }
      return { WeakRef: global.WeakRef || CompatWeakRef, FinalizationRegistry: global.FinalizationRegistry || CompatFinalizer };
    };
  },
  19237: (e) => {
    const t = 1024;
    const r = 4096;
    e.exports = { maxAttributeValueSize: t, maxNameValuePairSize: r };
  },
  53168: (e, t, r) => {
    const { parseSetCookie: n } = r(8915);
    const { stringify: o, getHeadersList: s } = r(3834);
    const { webidl: i } = r(74222);
    const { Headers: a } = r(26349);
    function getCookies(e) {
      i.argumentLengthCheck(arguments, 1, { header: "getCookies" });
      i.brandCheck(e, a, { strict: false });
      const t = e.get("cookie");
      const r = {};
      if (!t) {
        return r;
      }
      for (const e of t.split(";")) {
        const [t, ...n] = e.split("=");
        r[t.trim()] = n.join("=");
      }
      return r;
    }
    function deleteCookie(e, t, r) {
      i.argumentLengthCheck(arguments, 2, { header: "deleteCookie" });
      i.brandCheck(e, a, { strict: false });
      t = i.converters.DOMString(t);
      r = i.converters.DeleteCookieAttributes(r);
      setCookie(e, { name: t, value: "", expires: new Date(0), ...r });
    }
    function getSetCookies(e) {
      i.argumentLengthCheck(arguments, 1, { header: "getSetCookies" });
      i.brandCheck(e, a, { strict: false });
      const t = s(e).cookies;
      if (!t) {
        return [];
      }
      return t.map((e) => n(Array.isArray(e) ? e[1] : e));
    }
    function setCookie(e, t) {
      i.argumentLengthCheck(arguments, 2, { header: "setCookie" });
      i.brandCheck(e, a, { strict: false });
      t = i.converters.Cookie(t);
      const r = o(t);
      if (r) {
        e.append("Set-Cookie", o(t));
      }
    }
    i.converters.DeleteCookieAttributes = i.dictionaryConverter([
      { converter: i.nullableConverter(i.converters.DOMString), key: "path", defaultValue: null },
      { converter: i.nullableConverter(i.converters.DOMString), key: "domain", defaultValue: null },
    ]);
    i.converters.Cookie = i.dictionaryConverter([
      { converter: i.converters.DOMString, key: "name" },
      { converter: i.converters.DOMString, key: "value" },
      {
        converter: i.nullableConverter((e) => {
          if (typeof e === "number") {
            return i.converters["unsigned long long"](e);
          }
          return new Date(e);
        }),
        key: "expires",
        defaultValue: null,
      },
      { converter: i.nullableConverter(i.converters["long long"]), key: "maxAge", defaultValue: null },
      { converter: i.nullableConverter(i.converters.DOMString), key: "domain", defaultValue: null },
      { converter: i.nullableConverter(i.converters.DOMString), key: "path", defaultValue: null },
      { converter: i.nullableConverter(i.converters.boolean), key: "secure", defaultValue: null },
      { converter: i.nullableConverter(i.converters.boolean), key: "httpOnly", defaultValue: null },
      { converter: i.converters.USVString, key: "sameSite", allowedValues: ["Strict", "Lax", "None"] },
      { converter: i.sequenceConverter(i.converters.DOMString), key: "unparsed", defaultValue: [] },
    ]);
    e.exports = { getCookies: getCookies, deleteCookie: deleteCookie, getSetCookies: getSetCookies, setCookie: setCookie };
  },
  8915: (e, t, r) => {
    const { maxNameValuePairSize: n, maxAttributeValueSize: o } = r(19237);
    const { isCTLExcludingHtab: s } = r(3834);
    const { collectASequenceOfCodePointsFast: i } = r(94322);
    const a = r(42613);
    function parseSetCookie(e) {
      if (s(e)) {
        return null;
      }
      let t = "";
      let r = "";
      let o = "";
      let a = "";
      if (e.includes(";")) {
        const n = { position: 0 };
        t = i(";", e, n);
        r = e.slice(n.position);
      } else {
        t = e;
      }
      if (!t.includes("=")) {
        a = t;
      } else {
        const e = { position: 0 };
        o = i("=", t, e);
        a = t.slice(e.position + 1);
      }
      o = o.trim();
      a = a.trim();
      if (o.length + a.length > n) {
        return null;
      }
      return { name: o, value: a, ...parseUnparsedAttributes(r) };
    }
    function parseUnparsedAttributes(e, t = {}) {
      if (e.length === 0) {
        return t;
      }
      a(e[0] === ";");
      e = e.slice(1);
      let r = "";
      if (e.includes(";")) {
        r = i(";", e, { position: 0 });
        e = e.slice(r.length);
      } else {
        r = e;
        e = "";
      }
      let n = "";
      let s = "";
      if (r.includes("=")) {
        const e = { position: 0 };
        n = i("=", r, e);
        s = r.slice(e.position + 1);
      } else {
        n = r;
      }
      n = n.trim();
      s = s.trim();
      if (s.length > o) {
        return parseUnparsedAttributes(e, t);
      }
      const A = n.toLowerCase();
      if (A === "expires") {
        const e = new Date(s);
        t.expires = e;
      } else if (A === "max-age") {
        const r = s.charCodeAt(0);
        if ((r < 48 || r > 57) && s[0] !== "-") {
          return parseUnparsedAttributes(e, t);
        }
        if (!/^\d+$/.test(s)) {
          return parseUnparsedAttributes(e, t);
        }
        const n = Number(s);
        t.maxAge = n;
      } else if (A === "domain") {
        let e = s;
        if (e[0] === ".") {
          e = e.slice(1);
        }
        e = e.toLowerCase();
        t.domain = e;
      } else if (A === "path") {
        let e = "";
        if (s.length === 0 || s[0] !== "/") {
          e = "/";
        } else {
          e = s;
        }
        t.path = e;
      } else if (A === "secure") {
        t.secure = true;
      } else if (A === "httponly") {
        t.httpOnly = true;
      } else if (A === "samesite") {
        let e = "Default";
        const r = s.toLowerCase();
        if (r.includes("none")) {
          e = "None";
        }
        if (r.includes("strict")) {
          e = "Strict";
        }
        if (r.includes("lax")) {
          e = "Lax";
        }
        t.sameSite = e;
      } else {
        t.unparsed ??= [];
        t.unparsed.push(`${n}=${s}`);
      }
      return parseUnparsedAttributes(e, t);
    }
    e.exports = { parseSetCookie: parseSetCookie, parseUnparsedAttributes: parseUnparsedAttributes };
  },
  3834: (e, t, r) => {
    const n = r(42613);
    const { kHeadersList: o } = r(36443);
    function isCTLExcludingHtab(e) {
      if (e.length === 0) {
        return false;
      }
      for (const t of e) {
        const e = t.charCodeAt(0);
        if (e >= 0 || e <= 8 || e >= 10 || e <= 31 || e === 127) {
          return false;
        }
      }
    }
    function validateCookieName(e) {
      for (const t of e) {
        const e = t.charCodeAt(0);
        if (
          e <= 32 ||
          e > 127 ||
          t === "(" ||
          t === ")" ||
          t === ">" ||
          t === "<" ||
          t === "@" ||
          t === "," ||
          t === ";" ||
          t === ":" ||
          t === "\\" ||
          t === '"' ||
          t === "/" ||
          t === "[" ||
          t === "]" ||
          t === "?" ||
          t === "=" ||
          t === "{" ||
          t === "}"
        ) {
          throw new Error("Invalid cookie name");
        }
      }
    }
    function validateCookieValue(e) {
      for (const t of e) {
        const e = t.charCodeAt(0);
        if (e < 33 || e === 34 || e === 44 || e === 59 || e === 92 || e > 126) {
          throw new Error("Invalid header value");
        }
      }
    }
    function validateCookiePath(e) {
      for (const t of e) {
        const e = t.charCodeAt(0);
        if (e < 33 || t === ";") {
          throw new Error("Invalid cookie path");
        }
      }
    }
    function validateCookieDomain(e) {
      if (e.startsWith("-") || e.endsWith(".") || e.endsWith("-")) {
        throw new Error("Invalid cookie domain");
      }
    }
    function toIMFDate(e) {
      if (typeof e === "number") {
        e = new Date(e);
      }
      const t = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
      const r = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
      const n = t[e.getUTCDay()];
      const o = e.getUTCDate().toString().padStart(2, "0");
      const s = r[e.getUTCMonth()];
      const i = e.getUTCFullYear();
      const a = e.getUTCHours().toString().padStart(2, "0");
      const A = e.getUTCMinutes().toString().padStart(2, "0");
      const c = e.getUTCSeconds().toString().padStart(2, "0");
      return `${n}, ${o} ${s} ${i} ${a}:${A}:${c} GMT`;
    }
    function validateCookieMaxAge(e) {
      if (e < 0) {
        throw new Error("Invalid cookie max-age");
      }
    }
    function stringify(e) {
      if (e.name.length === 0) {
        return null;
      }
      validateCookieName(e.name);
      validateCookieValue(e.value);
      const t = [`${e.name}=${e.value}`];
      if (e.name.startsWith("__Secure-")) {
        e.secure = true;
      }
      if (e.name.startsWith("__Host-")) {
        e.secure = true;
        e.domain = null;
        e.path = "/";
      }
      if (e.secure) {
        t.push("Secure");
      }
      if (e.httpOnly) {
        t.push("HttpOnly");
      }
      if (typeof e.maxAge === "number") {
        validateCookieMaxAge(e.maxAge);
        t.push(`Max-Age=${e.maxAge}`);
      }
      if (e.domain) {
        validateCookieDomain(e.domain);
        t.push(`Domain=${e.domain}`);
      }
      if (e.path) {
        validateCookiePath(e.path);
        t.push(`Path=${e.path}`);
      }
      if (e.expires && e.expires.toString() !== "Invalid Date") {
        t.push(`Expires=${toIMFDate(e.expires)}`);
      }
      if (e.sameSite) {
        t.push(`SameSite=${e.sameSite}`);
      }
      for (const r of e.unparsed) {
        if (!r.includes("=")) {
          throw new Error("Invalid unparsed");
        }
        const [e, ...n] = r.split("=");
        t.push(`${e.trim()}=${n.join("=")}`);
      }
      return t.join("; ");
    }
    let s;
    function getHeadersList(e) {
      if (e[o]) {
        return e[o];
      }
      if (!s) {
        s = Object.getOwnPropertySymbols(e).find((e) => e.description === "headers list");
        n(s, "Headers cannot be parsed");
      }
      const t = e[s];
      n(t);
      return t;
    }
    e.exports = { isCTLExcludingHtab: isCTLExcludingHtab, stringify: stringify, getHeadersList: getHeadersList };
  },
  59136: (e, t, r) => {
    const n = r(69278);
    const o = r(42613);
    const s = r(3440);
    const { InvalidArgumentError: i, ConnectTimeoutError: a } = r(68707);
    let A;
    let c;
    if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE) {
      c = class WeakSessionCache {
        constructor(e) {
          this._maxCachedSessions = e;
          this._sessionCache = new Map();
          this._sessionRegistry = new global.FinalizationRegistry((e) => {
            if (this._sessionCache.size < this._maxCachedSessions) {
              return;
            }
            const t = this._sessionCache.get(e);
            if (t !== undefined && t.deref() === undefined) {
              this._sessionCache.delete(e);
            }
          });
        }
        get(e) {
          const t = this._sessionCache.get(e);
          return t ? t.deref() : null;
        }
        set(e, t) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          this._sessionCache.set(e, new WeakRef(t));
          this._sessionRegistry.register(t, e);
        }
      };
    } else {
      c = class SimpleSessionCache {
        constructor(e) {
          this._maxCachedSessions = e;
          this._sessionCache = new Map();
        }
        get(e) {
          return this._sessionCache.get(e);
        }
        set(e, t) {
          if (this._maxCachedSessions === 0) {
            return;
          }
          if (this._sessionCache.size >= this._maxCachedSessions) {
            const { value: e } = this._sessionCache.keys().next();
            this._sessionCache.delete(e);
          }
          this._sessionCache.set(e, t);
        }
      };
    }
    function buildConnector({ allowH2: e, maxCachedSessions: t, socketPath: a, timeout: u, ...l }) {
      if (t != null && (!Number.isInteger(t) || t < 0)) {
        throw new i("maxCachedSessions must be a positive integer or zero");
      }
      const p = { path: a, ...l };
      const d = new c(t == null ? 100 : t);
      u = u == null ? 1e4 : u;
      e = e != null ? e : false;
      return function connect({ hostname: t, host: i, protocol: a, port: c, servername: l, localAddress: g, httpSocket: m }, h) {
        let E;
        if (a === "https:") {
          if (!A) {
            A = r(64756);
          }
          l = l || p.servername || s.getServerName(i) || null;
          const n = l || t;
          const a = d.get(n) || null;
          o(n);
          E = A.connect({
            highWaterMark: 16384,
            ...p,
            servername: l,
            session: a,
            localAddress: g,
            ALPNProtocols: e ? ["http/1.1", "h2"] : ["http/1.1"],
            socket: m,
            port: c || 443,
            host: t,
          });
          E.on("session", function (e) {
            d.set(n, e);
          });
        } else {
          o(!m, "httpSocket can only be sent on TLS update");
          E = n.connect({ highWaterMark: 64 * 1024, ...p, localAddress: g, port: c || 80, host: t });
        }
        if (p.keepAlive == null || p.keepAlive) {
          const e = p.keepAliveInitialDelay === undefined ? 6e4 : p.keepAliveInitialDelay;
          E.setKeepAlive(true, e);
        }
        const I = setupTimeout(() => onConnectTimeout(E), u);
        E.setNoDelay(true)
          .once(a === "https:" ? "secureConnect" : "connect", function () {
            I();
            if (h) {
              const e = h;
              h = null;
              e(null, this);
            }
          })
          .on("error", function (e) {
            I();
            if (h) {
              const t = h;
              h = null;
              t(e);
            }
          });
        return E;
      };
    }
    function setupTimeout(e, t) {
      if (!t) {
        return () => {};
      }
      let r = null;
      let n = null;
      const o = setTimeout(() => {
        r = setImmediate(() => {
          if (process.platform === "win32") {
            n = setImmediate(() => e());
          } else {
            e();
          }
        });
      }, t);
      return () => {
        clearTimeout(o);
        clearImmediate(r);
        clearImmediate(n);
      };
    }
    function onConnectTimeout(e) {
      s.destroy(e, new a());
    }
    e.exports = buildConnector;
  },
  10735: (e) => {
    const t = {};
    const r = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection",
    ];
    for (let e = 0; e < r.length; ++e) {
      const n = r[e];
      const o = n.toLowerCase();
      t[n] = t[o] = o;
    }
    Object.setPrototypeOf(t, null);
    e.exports = { wellknownHeaderNames: r, headerNameLowerCasedRecord: t };
  },
  68707: (e) => {
    class UndiciError extends Error {
      constructor(e) {
        super(e);
        this.name = "UndiciError";
        this.code = "UND_ERR";
      }
    }
    class ConnectTimeoutError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, ConnectTimeoutError);
        this.name = "ConnectTimeoutError";
        this.message = e || "Connect Timeout Error";
        this.code = "UND_ERR_CONNECT_TIMEOUT";
      }
    }
    class HeadersTimeoutError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, HeadersTimeoutError);
        this.name = "HeadersTimeoutError";
        this.message = e || "Headers Timeout Error";
        this.code = "UND_ERR_HEADERS_TIMEOUT";
      }
    }
    class HeadersOverflowError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, HeadersOverflowError);
        this.name = "HeadersOverflowError";
        this.message = e || "Headers Overflow Error";
        this.code = "UND_ERR_HEADERS_OVERFLOW";
      }
    }
    class BodyTimeoutError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, BodyTimeoutError);
        this.name = "BodyTimeoutError";
        this.message = e || "Body Timeout Error";
        this.code = "UND_ERR_BODY_TIMEOUT";
      }
    }
    class ResponseStatusCodeError extends UndiciError {
      constructor(e, t, r, n) {
        super(e);
        Error.captureStackTrace(this, ResponseStatusCodeError);
        this.name = "ResponseStatusCodeError";
        this.message = e || "Response Status Code Error";
        this.code = "UND_ERR_RESPONSE_STATUS_CODE";
        this.body = n;
        this.status = t;
        this.statusCode = t;
        this.headers = r;
      }
    }
    class InvalidArgumentError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, InvalidArgumentError);
        this.name = "InvalidArgumentError";
        this.message = e || "Invalid Argument Error";
        this.code = "UND_ERR_INVALID_ARG";
      }
    }
    class InvalidReturnValueError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, InvalidReturnValueError);
        this.name = "InvalidReturnValueError";
        this.message = e || "Invalid Return Value Error";
        this.code = "UND_ERR_INVALID_RETURN_VALUE";
      }
    }
    class RequestAbortedError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, RequestAbortedError);
        this.name = "AbortError";
        this.message = e || "Request aborted";
        this.code = "UND_ERR_ABORTED";
      }
    }
    class InformationalError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, InformationalError);
        this.name = "InformationalError";
        this.message = e || "Request information";
        this.code = "UND_ERR_INFO";
      }
    }
    class RequestContentLengthMismatchError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, RequestContentLengthMismatchError);
        this.name = "RequestContentLengthMismatchError";
        this.message = e || "Request body length does not match content-length header";
        this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH";
      }
    }
    class ResponseContentLengthMismatchError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, ResponseContentLengthMismatchError);
        this.name = "ResponseContentLengthMismatchError";
        this.message = e || "Response body length does not match content-length header";
        this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH";
      }
    }
    class ClientDestroyedError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, ClientDestroyedError);
        this.name = "ClientDestroyedError";
        this.message = e || "The client is destroyed";
        this.code = "UND_ERR_DESTROYED";
      }
    }
    class ClientClosedError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, ClientClosedError);
        this.name = "ClientClosedError";
        this.message = e || "The client is closed";
        this.code = "UND_ERR_CLOSED";
      }
    }
    class SocketError extends UndiciError {
      constructor(e, t) {
        super(e);
        Error.captureStackTrace(this, SocketError);
        this.name = "SocketError";
        this.message = e || "Socket error";
        this.code = "UND_ERR_SOCKET";
        this.socket = t;
      }
    }
    class NotSupportedError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "NotSupportedError";
        this.message = e || "Not supported error";
        this.code = "UND_ERR_NOT_SUPPORTED";
      }
    }
    class BalancedPoolMissingUpstreamError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, NotSupportedError);
        this.name = "MissingUpstreamError";
        this.message = e || "No upstream has been added to the BalancedPool";
        this.code = "UND_ERR_BPL_MISSING_UPSTREAM";
      }
    }
    class HTTPParserError extends Error {
      constructor(e, t, r) {
        super(e);
        Error.captureStackTrace(this, HTTPParserError);
        this.name = "HTTPParserError";
        this.code = t ? `HPE_${t}` : undefined;
        this.data = r ? r.toString() : undefined;
      }
    }
    class ResponseExceededMaxSizeError extends UndiciError {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, ResponseExceededMaxSizeError);
        this.name = "ResponseExceededMaxSizeError";
        this.message = e || "Response content exceeded max size";
        this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE";
      }
    }
    class RequestRetryError extends UndiciError {
      constructor(e, t, { headers: r, data: n }) {
        super(e);
        Error.captureStackTrace(this, RequestRetryError);
        this.name = "RequestRetryError";
        this.message = e || "Request retry error";
        this.code = "UND_ERR_REQ_RETRY";
        this.statusCode = t;
        this.data = n;
        this.headers = r;
      }
    }
    e.exports = {
      HTTPParserError: HTTPParserError,
      UndiciError: UndiciError,
      HeadersTimeoutError: HeadersTimeoutError,
      HeadersOverflowError: HeadersOverflowError,
      BodyTimeoutError: BodyTimeoutError,
      RequestContentLengthMismatchError: RequestContentLengthMismatchError,
      ConnectTimeoutError: ConnectTimeoutError,
      ResponseStatusCodeError: ResponseStatusCodeError,
      InvalidArgumentError: InvalidArgumentError,
      InvalidReturnValueError: InvalidReturnValueError,
      RequestAbortedError: RequestAbortedError,
      ClientDestroyedError: ClientDestroyedError,
      ClientClosedError: ClientClosedError,
      InformationalError: InformationalError,
      SocketError: SocketError,
      NotSupportedError: NotSupportedError,
      ResponseContentLengthMismatchError: ResponseContentLengthMismatchError,
      BalancedPoolMissingUpstreamError: BalancedPoolMissingUpstreamError,
      ResponseExceededMaxSizeError: ResponseExceededMaxSizeError,
      RequestRetryError: RequestRetryError,
    };
  },
  44655: (e, t, r) => {
    const { InvalidArgumentError: n, NotSupportedError: o } = r(68707);
    const s = r(42613);
    const { kHTTP2BuildRequest: i, kHTTP2CopyHeaders: a, kHTTP1BuildRequest: A } = r(36443);
    const c = r(3440);
    const u = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/;
    const l = /[^\t\x20-\x7e\x80-\xff]/;
    const p = /[^\u0021-\u00ff]/;
    const d = Symbol("handler");
    const g = {};
    let m;
    try {
      const e = r(31637);
      g.create = e.channel("undici:request:create");
      g.bodySent = e.channel("undici:request:bodySent");
      g.headers = e.channel("undici:request:headers");
      g.trailers = e.channel("undici:request:trailers");
      g.error = e.channel("undici:request:error");
    } catch {
      g.create = { hasSubscribers: false };
      g.bodySent = { hasSubscribers: false };
      g.headers = { hasSubscribers: false };
      g.trailers = { hasSubscribers: false };
      g.error = { hasSubscribers: false };
    }
    class Request {
      constructor(
        e,
        {
          path: t,
          method: o,
          body: s,
          headers: i,
          query: a,
          idempotent: A,
          blocking: l,
          upgrade: h,
          headersTimeout: E,
          bodyTimeout: I,
          reset: y,
          throwOnError: C,
          expectContinue: b,
        },
        Q
      ) {
        if (typeof t !== "string") {
          throw new n("path must be a string");
        } else if (t[0] !== "/" && !(t.startsWith("http://") || t.startsWith("https://")) && o !== "CONNECT") {
          throw new n("path must be an absolute URL or start with a slash");
        } else if (p.exec(t) !== null) {
          throw new n("invalid request path");
        }
        if (typeof o !== "string") {
          throw new n("method must be a string");
        } else if (u.exec(o) === null) {
          throw new n("invalid request method");
        }
        if (h && typeof h !== "string") {
          throw new n("upgrade must be a string");
        }
        if (E != null && (!Number.isFinite(E) || E < 0)) {
          throw new n("invalid headersTimeout");
        }
        if (I != null && (!Number.isFinite(I) || I < 0)) {
          throw new n("invalid bodyTimeout");
        }
        if (y != null && typeof y !== "boolean") {
          throw new n("invalid reset");
        }
        if (b != null && typeof b !== "boolean") {
          throw new n("invalid expectContinue");
        }
        this.headersTimeout = E;
        this.bodyTimeout = I;
        this.throwOnError = C === true;
        this.method = o;
        this.abort = null;
        if (s == null) {
          this.body = null;
        } else if (c.isStream(s)) {
          this.body = s;
          const e = this.body._readableState;
          if (!e || !e.autoDestroy) {
            this.endHandler = function autoDestroy() {
              c.destroy(this);
            };
            this.body.on("end", this.endHandler);
          }
          this.errorHandler = (e) => {
            if (this.abort) {
              this.abort(e);
            } else {
              this.error = e;
            }
          };
          this.body.on("error", this.errorHandler);
        } else if (c.isBuffer(s)) {
          this.body = s.byteLength ? s : null;
        } else if (ArrayBuffer.isView(s)) {
          this.body = s.buffer.byteLength ? Buffer.from(s.buffer, s.byteOffset, s.byteLength) : null;
        } else if (s instanceof ArrayBuffer) {
          this.body = s.byteLength ? Buffer.from(s) : null;
        } else if (typeof s === "string") {
          this.body = s.length ? Buffer.from(s) : null;
        } else if (c.isFormDataLike(s) || c.isIterable(s) || c.isBlobLike(s)) {
          this.body = s;
        } else {
          throw new n("body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable");
        }
        this.completed = false;
        this.aborted = false;
        this.upgrade = h || null;
        this.path = a ? c.buildURL(t, a) : t;
        this.origin = e;
        this.idempotent = A == null ? o === "HEAD" || o === "GET" : A;
        this.blocking = l == null ? false : l;
        this.reset = y == null ? null : y;
        this.host = null;
        this.contentLength = null;
        this.contentType = null;
        this.headers = "";
        this.expectContinue = b != null ? b : false;
        if (Array.isArray(i)) {
          if (i.length % 2 !== 0) {
            throw new n("headers array must be even");
          }
          for (let e = 0; e < i.length; e += 2) {
            processHeader(this, i[e], i[e + 1]);
          }
        } else if (i && typeof i === "object") {
          const e = Object.keys(i);
          for (let t = 0; t < e.length; t++) {
            const r = e[t];
            processHeader(this, r, i[r]);
          }
        } else if (i != null) {
          throw new n("headers must be an object or an array");
        }
        if (c.isFormDataLike(this.body)) {
          if (c.nodeMajor < 16 || (c.nodeMajor === 16 && c.nodeMinor < 8)) {
            throw new n("Form-Data bodies are only supported in node v16.8 and newer.");
          }
          if (!m) {
            m = r(8923).extractBody;
          }
          const [e, t] = m(s);
          if (this.contentType == null) {
            this.contentType = t;
            this.headers += `content-type: ${t}\r\n`;
          }
          this.body = e.stream;
          this.contentLength = e.length;
        } else if (c.isBlobLike(s) && this.contentType == null && s.type) {
          this.contentType = s.type;
          this.headers += `content-type: ${s.type}\r\n`;
        }
        c.validateHandler(Q, o, h);
        this.servername = c.getServerName(this.host);
        this[d] = Q;
        if (g.create.hasSubscribers) {
          g.create.publish({ request: this });
        }
      }
      onBodySent(e) {
        if (this[d].onBodySent) {
          try {
            return this[d].onBodySent(e);
          } catch (e) {
            this.abort(e);
          }
        }
      }
      onRequestSent() {
        if (g.bodySent.hasSubscribers) {
          g.bodySent.publish({ request: this });
        }
        if (this[d].onRequestSent) {
          try {
            return this[d].onRequestSent();
          } catch (e) {
            this.abort(e);
          }
        }
      }
      onConnect(e) {
        s(!this.aborted);
        s(!this.completed);
        if (this.error) {
          e(this.error);
        } else {
          this.abort = e;
          return this[d].onConnect(e);
        }
      }
      onHeaders(e, t, r, n) {
        s(!this.aborted);
        s(!this.completed);
        if (g.headers.hasSubscribers) {
          g.headers.publish({ request: this, response: { statusCode: e, headers: t, statusText: n } });
        }
        try {
          return this[d].onHeaders(e, t, r, n);
        } catch (e) {
          this.abort(e);
        }
      }
      onData(e) {
        s(!this.aborted);
        s(!this.completed);
        try {
          return this[d].onData(e);
        } catch (e) {
          this.abort(e);
          return false;
        }
      }
      onUpgrade(e, t, r) {
        s(!this.aborted);
        s(!this.completed);
        return this[d].onUpgrade(e, t, r);
      }
      onComplete(e) {
        this.onFinally();
        s(!this.aborted);
        this.completed = true;
        if (g.trailers.hasSubscribers) {
          g.trailers.publish({ request: this, trailers: e });
        }
        try {
          return this[d].onComplete(e);
        } catch (e) {
          this.onError(e);
        }
      }
      onError(e) {
        this.onFinally();
        if (g.error.hasSubscribers) {
          g.error.publish({ request: this, error: e });
        }
        if (this.aborted) {
          return;
        }
        this.aborted = true;
        return this[d].onError(e);
      }
      onFinally() {
        if (this.errorHandler) {
          this.body.off("error", this.errorHandler);
          this.errorHandler = null;
        }
        if (this.endHandler) {
          this.body.off("end", this.endHandler);
          this.endHandler = null;
        }
      }
      addHeader(e, t) {
        processHeader(this, e, t);
        return this;
      }
      static [A](e, t, r) {
        return new Request(e, t, r);
      }
      static [i](e, t, r) {
        const o = t.headers;
        t = { ...t, headers: null };
        const s = new Request(e, t, r);
        s.headers = {};
        if (Array.isArray(o)) {
          if (o.length % 2 !== 0) {
            throw new n("headers array must be even");
          }
          for (let e = 0; e < o.length; e += 2) {
            processHeader(s, o[e], o[e + 1], true);
          }
        } else if (o && typeof o === "object") {
          const e = Object.keys(o);
          for (let t = 0; t < e.length; t++) {
            const r = e[t];
            processHeader(s, r, o[r], true);
          }
        } else if (o != null) {
          throw new n("headers must be an object or an array");
        }
        return s;
      }
      static [a](e) {
        const t = e.split("\r\n");
        const r = {};
        for (const e of t) {
          const [t, n] = e.split(": ");
          if (n == null || n.length === 0) continue;
          if (r[t]) r[t] += `,${n}`;
          else r[t] = n;
        }
        return r;
      }
    }
    function processHeaderValue(e, t, r) {
      if (t && typeof t === "object") {
        throw new n(`invalid ${e} header`);
      }
      t = t != null ? `${t}` : "";
      if (l.exec(t) !== null) {
        throw new n(`invalid ${e} header`);
      }
      return r ? t : `${e}: ${t}\r\n`;
    }
    function processHeader(e, t, r, s = false) {
      if (r && typeof r === "object" && !Array.isArray(r)) {
        throw new n(`invalid ${t} header`);
      } else if (r === undefined) {
        return;
      }
      if (e.host === null && t.length === 4 && t.toLowerCase() === "host") {
        if (l.exec(r) !== null) {
          throw new n(`invalid ${t} header`);
        }
        e.host = r;
      } else if (e.contentLength === null && t.length === 14 && t.toLowerCase() === "content-length") {
        e.contentLength = parseInt(r, 10);
        if (!Number.isFinite(e.contentLength)) {
          throw new n("invalid content-length header");
        }
      } else if (e.contentType === null && t.length === 12 && t.toLowerCase() === "content-type") {
        e.contentType = r;
        if (s) e.headers[t] = processHeaderValue(t, r, s);
        else e.headers += processHeaderValue(t, r);
      } else if (t.length === 17 && t.toLowerCase() === "transfer-encoding") {
        throw new n("invalid transfer-encoding header");
      } else if (t.length === 10 && t.toLowerCase() === "connection") {
        const t = typeof r === "string" ? r.toLowerCase() : null;
        if (t !== "close" && t !== "keep-alive") {
          throw new n("invalid connection header");
        } else if (t === "close") {
          e.reset = true;
        }
      } else if (t.length === 10 && t.toLowerCase() === "keep-alive") {
        throw new n("invalid keep-alive header");
      } else if (t.length === 7 && t.toLowerCase() === "upgrade") {
        throw new n("invalid upgrade header");
      } else if (t.length === 6 && t.toLowerCase() === "expect") {
        throw new o("expect header not supported");
      } else if (u.exec(t) === null) {
        throw new n("invalid header key");
      } else {
        if (Array.isArray(r)) {
          for (let n = 0; n < r.length; n++) {
            if (s) {
              if (e.headers[t]) e.headers[t] += `,${processHeaderValue(t, r[n], s)}`;
              else e.headers[t] = processHeaderValue(t, r[n], s);
            } else {
              e.headers += processHeaderValue(t, r[n]);
            }
          }
        } else {
          if (s) e.headers[t] = processHeaderValue(t, r, s);
          else e.headers += processHeaderValue(t, r);
        }
      }
    }
    e.exports = Request;
  },
  36443: (e) => {
    e.exports = {
      kClose: Symbol("close"),
      kDestroy: Symbol("destroy"),
      kDispatch: Symbol("dispatch"),
      kUrl: Symbol("url"),
      kWriting: Symbol("writing"),
      kResuming: Symbol("resuming"),
      kQueue: Symbol("queue"),
      kConnect: Symbol("connect"),
      kConnecting: Symbol("connecting"),
      kHeadersList: Symbol("headers list"),
      kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
      kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
      kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
      kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
      kKeepAlive: Symbol("keep alive"),
      kHeadersTimeout: Symbol("headers timeout"),
      kBodyTimeout: Symbol("body timeout"),
      kServerName: Symbol("server name"),
      kLocalAddress: Symbol("local address"),
      kHost: Symbol("host"),
      kNoRef: Symbol("no ref"),
      kBodyUsed: Symbol("used"),
      kRunning: Symbol("running"),
      kBlocking: Symbol("blocking"),
      kPending: Symbol("pending"),
      kSize: Symbol("size"),
      kBusy: Symbol("busy"),
      kQueued: Symbol("queued"),
      kFree: Symbol("free"),
      kConnected: Symbol("connected"),
      kClosed: Symbol("closed"),
      kNeedDrain: Symbol("need drain"),
      kReset: Symbol("reset"),
      kDestroyed: Symbol.for("nodejs.stream.destroyed"),
      kMaxHeadersSize: Symbol("max headers size"),
      kRunningIdx: Symbol("running index"),
      kPendingIdx: Symbol("pending index"),
      kError: Symbol("error"),
      kClients: Symbol("clients"),
      kClient: Symbol("client"),
      kParser: Symbol("parser"),
      kOnDestroyed: Symbol("destroy callbacks"),
      kPipelining: Symbol("pipelining"),
      kSocket: Symbol("socket"),
      kHostHeader: Symbol("host header"),
      kConnector: Symbol("connector"),
      kStrictContentLength: Symbol("strict content length"),
      kMaxRedirections: Symbol("maxRedirections"),
      kMaxRequests: Symbol("maxRequestsPerClient"),
      kProxy: Symbol("proxy agent options"),
      kCounter: Symbol("socket request counter"),
      kInterceptors: Symbol("dispatch interceptors"),
      kMaxResponseSize: Symbol("max response size"),
      kHTTP2Session: Symbol("http2Session"),
      kHTTP2SessionState: Symbol("http2Session state"),
      kHTTP2BuildRequest: Symbol("http2 build request"),
      kHTTP1BuildRequest: Symbol("http1 build request"),
      kHTTP2CopyHeaders: Symbol("http2 copy headers"),
      kHTTPConnVersion: Symbol("http connection version"),
      kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
      kConstruct: Symbol("constructable"),
    };
  },
  3440: (e, t, r) => {
    const n = r(42613);
    const { kDestroyed: o, kBodyUsed: s } = r(36443);
    const { IncomingMessage: i } = r(58611);
    const a = r(2203);
    const A = r(69278);
    const { InvalidArgumentError: c } = r(68707);
    const { Blob: u } = r(20181);
    const l = r(39023);
    const { stringify: p } = r(83480);
    const { headerNameLowerCasedRecord: d } = r(10735);
    const [g, m] = process.versions.node.split(".").map((e) => Number(e));
    function nop() {}
    function isStream(e) {
      return e && typeof e === "object" && typeof e.pipe === "function" && typeof e.on === "function";
    }
    function isBlobLike(e) {
      return (
        (u && e instanceof u) ||
        (e && typeof e === "object" && (typeof e.stream === "function" || typeof e.arrayBuffer === "function") && /^(Blob|File)$/.test(e[Symbol.toStringTag]))
      );
    }
    function buildURL(e, t) {
      if (e.includes("?") || e.includes("#")) {
        throw new Error('Query params cannot be passed when url already contains "?" or "#".');
      }
      const r = p(t);
      if (r) {
        e += "?" + r;
      }
      return e;
    }
    function parseURL(e) {
      if (typeof e === "string") {
        e = new URL(e);
        if (!/^https?:/.test(e.origin || e.protocol)) {
          throw new c("Invalid URL protocol: the URL must start with `http:` or `https:`.");
        }
        return e;
      }
      if (!e || typeof e !== "object") {
        throw new c("Invalid URL: The URL argument must be a non-null object.");
      }
      if (!/^https?:/.test(e.origin || e.protocol)) {
        throw new c("Invalid URL protocol: the URL must start with `http:` or `https:`.");
      }
      if (!(e instanceof URL)) {
        if (e.port != null && e.port !== "" && !Number.isFinite(parseInt(e.port))) {
          throw new c("Invalid URL: port must be a valid integer or a string representation of an integer.");
        }
        if (e.path != null && typeof e.path !== "string") {
          throw new c("Invalid URL path: the path must be a string or null/undefined.");
        }
        if (e.pathname != null && typeof e.pathname !== "string") {
          throw new c("Invalid URL pathname: the pathname must be a string or null/undefined.");
        }
        if (e.hostname != null && typeof e.hostname !== "string") {
          throw new c("Invalid URL hostname: the hostname must be a string or null/undefined.");
        }
        if (e.origin != null && typeof e.origin !== "string") {
          throw new c("Invalid URL origin: the origin must be a string or null/undefined.");
        }
        const t = e.port != null ? e.port : e.protocol === "https:" ? 443 : 80;
        let r = e.origin != null ? e.origin : `${e.protocol}//${e.hostname}:${t}`;
        let n = e.path != null ? e.path : `${e.pathname || ""}${e.search || ""}`;
        if (r.endsWith("/")) {
          r = r.substring(0, r.length - 1);
        }
        if (n && !n.startsWith("/")) {
          n = `/${n}`;
        }
        e = new URL(r + n);
      }
      return e;
    }
    function parseOrigin(e) {
      e = parseURL(e);
      if (e.pathname !== "/" || e.search || e.hash) {
        throw new c("invalid url");
      }
      return e;
    }
    function getHostname(e) {
      if (e[0] === "[") {
        const t = e.indexOf("]");
        n(t !== -1);
        return e.substring(1, t);
      }
      const t = e.indexOf(":");
      if (t === -1) return e;
      return e.substring(0, t);
    }
    function getServerName(e) {
      if (!e) {
        return null;
      }
      n.strictEqual(typeof e, "string");
      const t = getHostname(e);
      if (A.isIP(t)) {
        return "";
      }
      return t;
    }
    function deepClone(e) {
      return JSON.parse(JSON.stringify(e));
    }
    function isAsyncIterable(e) {
      return !!(e != null && typeof e[Symbol.asyncIterator] === "function");
    }
    function isIterable(e) {
      return !!(e != null && (typeof e[Symbol.iterator] === "function" || typeof e[Symbol.asyncIterator] === "function"));
    }
    function bodyLength(e) {
      if (e == null) {
        return 0;
      } else if (isStream(e)) {
        const t = e._readableState;
        return t && t.objectMode === false && t.ended === true && Number.isFinite(t.length) ? t.length : null;
      } else if (isBlobLike(e)) {
        return e.size != null ? e.size : null;
      } else if (isBuffer(e)) {
        return e.byteLength;
      }
      return null;
    }
    function isDestroyed(e) {
      return !e || !!(e.destroyed || e[o]);
    }
    function isReadableAborted(e) {
      const t = e && e._readableState;
      return isDestroyed(e) && t && !t.endEmitted;
    }
    function destroy(e, t) {
      if (e == null || !isStream(e) || isDestroyed(e)) {
        return;
      }
      if (typeof e.destroy === "function") {
        if (Object.getPrototypeOf(e).constructor === i) {
          e.socket = null;
        }
        e.destroy(t);
      } else if (t) {
        process.nextTick(
          (e, t) => {
            e.emit("error", t);
          },
          e,
          t
        );
      }
      if (e.destroyed !== true) {
        e[o] = true;
      }
    }
    const h = /timeout=(\d+)/;
    function parseKeepAliveTimeout(e) {
      const t = e.toString().match(h);
      return t ? parseInt(t[1], 10) * 1e3 : null;
    }
    function headerNameToString(e) {
      return d[e] || e.toLowerCase();
    }
    function parseHeaders(e, t = {}) {
      if (!Array.isArray(e)) return e;
      for (let r = 0; r < e.length; r += 2) {
        const n = e[r].toString().toLowerCase();
        let o = t[n];
        if (!o) {
          if (Array.isArray(e[r + 1])) {
            t[n] = e[r + 1].map((e) => e.toString("utf8"));
          } else {
            t[n] = e[r + 1].toString("utf8");
          }
        } else {
          if (!Array.isArray(o)) {
            o = [o];
            t[n] = o;
          }
          o.push(e[r + 1].toString("utf8"));
        }
      }
      if ("content-length" in t && "content-disposition" in t) {
        t["content-disposition"] = Buffer.from(t["content-disposition"]).toString("latin1");
      }
      return t;
    }
    function parseRawHeaders(e) {
      const t = [];
      let r = false;
      let n = -1;
      for (let o = 0; o < e.length; o += 2) {
        const s = e[o + 0].toString();
        const i = e[o + 1].toString("utf8");
        if (s.length === 14 && (s === "content-length" || s.toLowerCase() === "content-length")) {
          t.push(s, i);
          r = true;
        } else if (s.length === 19 && (s === "content-disposition" || s.toLowerCase() === "content-disposition")) {
          n = t.push(s, i) - 1;
        } else {
          t.push(s, i);
        }
      }
      if (r && n !== -1) {
        t[n] = Buffer.from(t[n]).toString("latin1");
      }
      return t;
    }
    function isBuffer(e) {
      return e instanceof Uint8Array || Buffer.isBuffer(e);
    }
    function validateHandler(e, t, r) {
      if (!e || typeof e !== "object") {
        throw new c("handler must be an object");
      }
      if (typeof e.onConnect !== "function") {
        throw new c("invalid onConnect method");
      }
      if (typeof e.onError !== "function") {
        throw new c("invalid onError method");
      }
      if (typeof e.onBodySent !== "function" && e.onBodySent !== undefined) {
        throw new c("invalid onBodySent method");
      }
      if (r || t === "CONNECT") {
        if (typeof e.onUpgrade !== "function") {
          throw new c("invalid onUpgrade method");
        }
      } else {
        if (typeof e.onHeaders !== "function") {
          throw new c("invalid onHeaders method");
        }
        if (typeof e.onData !== "function") {
          throw new c("invalid onData method");
        }
        if (typeof e.onComplete !== "function") {
          throw new c("invalid onComplete method");
        }
      }
    }
    function isDisturbed(e) {
      return !!(
        e &&
        (a.isDisturbed ? a.isDisturbed(e) || e[s] : e[s] || e.readableDidRead || (e._readableState && e._readableState.dataEmitted) || isReadableAborted(e))
      );
    }
    function isErrored(e) {
      return !!(e && (a.isErrored ? a.isErrored(e) : /state: 'errored'/.test(l.inspect(e))));
    }
    function isReadable(e) {
      return !!(e && (a.isReadable ? a.isReadable(e) : /state: 'readable'/.test(l.inspect(e))));
    }
    function getSocketInfo(e) {
      return {
        localAddress: e.localAddress,
        localPort: e.localPort,
        remoteAddress: e.remoteAddress,
        remotePort: e.remotePort,
        remoteFamily: e.remoteFamily,
        timeout: e.timeout,
        bytesWritten: e.bytesWritten,
        bytesRead: e.bytesRead,
      };
    }
    async function* convertIterableToBuffer(e) {
      for await (const t of e) {
        yield Buffer.isBuffer(t) ? t : Buffer.from(t);
      }
    }
    let E;
    function ReadableStreamFrom(e) {
      if (!E) {
        E = r(63774).ReadableStream;
      }
      if (E.from) {
        return E.from(convertIterableToBuffer(e));
      }
      let t;
      return new E(
        {
          async start() {
            t = e[Symbol.asyncIterator]();
          },
          async pull(e) {
            const { done: r, value: n } = await t.next();
            if (r) {
              queueMicrotask(() => {
                e.close();
              });
            } else {
              const t = Buffer.isBuffer(n) ? n : Buffer.from(n);
              e.enqueue(new Uint8Array(t));
            }
            return e.desiredSize > 0;
          },
          async cancel(e) {
            await t.return();
          },
        },
        0
      );
    }
    function isFormDataLike(e) {
      return (
        e &&
        typeof e === "object" &&
        typeof e.append === "function" &&
        typeof e.delete === "function" &&
        typeof e.get === "function" &&
        typeof e.getAll === "function" &&
        typeof e.has === "function" &&
        typeof e.set === "function" &&
        e[Symbol.toStringTag] === "FormData"
      );
    }
    function throwIfAborted(e) {
      if (!e) {
        return;
      }
      if (typeof e.throwIfAborted === "function") {
        e.throwIfAborted();
      } else {
        if (e.aborted) {
          const e = new Error("The operation was aborted");
          e.name = "AbortError";
          throw e;
        }
      }
    }
    function addAbortListener(e, t) {
      if ("addEventListener" in e) {
        e.addEventListener("abort", t, { once: true });
        return () => e.removeEventListener("abort", t);
      }
      e.addListener("abort", t);
      return () => e.removeListener("abort", t);
    }
    const I = !!String.prototype.toWellFormed;
    function toUSVString(e) {
      if (I) {
        return `${e}`.toWellFormed();
      } else if (l.toUSVString) {
        return l.toUSVString(e);
      }
      return `${e}`;
    }
    function parseRangeHeader(e) {
      if (e == null || e === "") return { start: 0, end: null, size: null };
      const t = e ? e.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
      return t ? { start: parseInt(t[1]), end: t[2] ? parseInt(t[2]) : null, size: t[3] ? parseInt(t[3]) : null } : null;
    }
    const y = Object.create(null);
    y.enumerable = true;
    e.exports = {
      kEnumerableProperty: y,
      nop: nop,
      isDisturbed: isDisturbed,
      isErrored: isErrored,
      isReadable: isReadable,
      toUSVString: toUSVString,
      isReadableAborted: isReadableAborted,
      isBlobLike: isBlobLike,
      parseOrigin: parseOrigin,
      parseURL: parseURL,
      getServerName: getServerName,
      isStream: isStream,
      isIterable: isIterable,
      isAsyncIterable: isAsyncIterable,
      isDestroyed: isDestroyed,
      headerNameToString: headerNameToString,
      parseRawHeaders: parseRawHeaders,
      parseHeaders: parseHeaders,
      parseKeepAliveTimeout: parseKeepAliveTimeout,
      destroy: destroy,
      bodyLength: bodyLength,
      deepClone: deepClone,
      ReadableStreamFrom: ReadableStreamFrom,
      isBuffer: isBuffer,
      validateHandler: validateHandler,
      getSocketInfo: getSocketInfo,
      isFormDataLike: isFormDataLike,
      buildURL: buildURL,
      throwIfAborted: throwIfAborted,
      addAbortListener: addAbortListener,
      parseRangeHeader: parseRangeHeader,
      nodeMajor: g,
      nodeMinor: m,
      nodeHasAutoSelectFamily: g > 18 || (g === 18 && m >= 13),
      safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
    };
  },
  50001: (e, t, r) => {
    const n = r(28611);
    const { ClientDestroyedError: o, ClientClosedError: s, InvalidArgumentError: i } = r(68707);
    const { kDestroy: a, kClose: A, kDispatch: c, kInterceptors: u } = r(36443);
    const l = Symbol("destroyed");
    const p = Symbol("closed");
    const d = Symbol("onDestroyed");
    const g = Symbol("onClosed");
    const m = Symbol("Intercepted Dispatch");
    class DispatcherBase extends n {
      constructor() {
        super();
        this[l] = false;
        this[d] = null;
        this[p] = false;
        this[g] = [];
      }
      get destroyed() {
        return this[l];
      }
      get closed() {
        return this[p];
      }
      get interceptors() {
        return this[u];
      }
      set interceptors(e) {
        if (e) {
          for (let t = e.length - 1; t >= 0; t--) {
            const e = this[u][t];
            if (typeof e !== "function") {
              throw new i("interceptor must be an function");
            }
          }
        }
        this[u] = e;
      }
      close(e) {
        if (e === undefined) {
          return new Promise((e, t) => {
            this.close((r, n) => (r ? t(r) : e(n)));
          });
        }
        if (typeof e !== "function") {
          throw new i("invalid callback");
        }
        if (this[l]) {
          queueMicrotask(() => e(new o(), null));
          return;
        }
        if (this[p]) {
          if (this[g]) {
            this[g].push(e);
          } else {
            queueMicrotask(() => e(null, null));
          }
          return;
        }
        this[p] = true;
        this[g].push(e);
        const onClosed = () => {
          const e = this[g];
          this[g] = null;
          for (let t = 0; t < e.length; t++) {
            e[t](null, null);
          }
        };
        this[A]()
          .then(() => this.destroy())
          .then(() => {
            queueMicrotask(onClosed);
          });
      }
      destroy(e, t) {
        if (typeof e === "function") {
          t = e;
          e = null;
        }
        if (t === undefined) {
          return new Promise((t, r) => {
            this.destroy(e, (e, n) => (e ? r(e) : t(n)));
          });
        }
        if (typeof t !== "function") {
          throw new i("invalid callback");
        }
        if (this[l]) {
          if (this[d]) {
            this[d].push(t);
          } else {
            queueMicrotask(() => t(null, null));
          }
          return;
        }
        if (!e) {
          e = new o();
        }
        this[l] = true;
        this[d] = this[d] || [];
        this[d].push(t);
        const onDestroyed = () => {
          const e = this[d];
          this[d] = null;
          for (let t = 0; t < e.length; t++) {
            e[t](null, null);
          }
        };
        this[a](e).then(() => {
          queueMicrotask(onDestroyed);
        });
      }
      [m](e, t) {
        if (!this[u] || this[u].length === 0) {
          this[m] = this[c];
          return this[c](e, t);
        }
        let r = this[c].bind(this);
        for (let e = this[u].length - 1; e >= 0; e--) {
          r = this[u][e](r);
        }
        this[m] = r;
        return r(e, t);
      }
      dispatch(e, t) {
        if (!t || typeof t !== "object") {
          throw new i("handler must be an object");
        }
        try {
          if (!e || typeof e !== "object") {
            throw new i("opts must be an object.");
          }
          if (this[l] || this[d]) {
            throw new o();
          }
          if (this[p]) {
            throw new s();
          }
          return this[m](e, t);
        } catch (e) {
          if (typeof t.onError !== "function") {
            throw new i("invalid onError method");
          }
          t.onError(e);
          return false;
        }
      }
    }
    e.exports = DispatcherBase;
  },
  28611: (e, t, r) => {
    const n = r(24434);
    class Dispatcher extends n {
      dispatch() {
        throw new Error("not implemented");
      }
      close() {
        throw new Error("not implemented");
      }
      destroy() {
        throw new Error("not implemented");
      }
    }
    e.exports = Dispatcher;
  },
  8923: (e, t, r) => {
    const n = r(89581);
    const o = r(3440);
    const { ReadableStreamFrom: s, isBlobLike: i, isReadableStreamLike: a, readableStreamClose: A, createDeferredPromise: c, fullyReadBody: u } = r(15523);
    const { FormData: l } = r(43073);
    const { kState: p } = r(89710);
    const { webidl: d } = r(74222);
    const { DOMException: g, structuredClone: m } = r(87326);
    const { Blob: h, File: E } = r(20181);
    const { kBodyUsed: I } = r(36443);
    const y = r(42613);
    const { isErrored: C } = r(3440);
    const { isUint8Array: b, isArrayBuffer: Q } = r(98253);
    const { File: B } = r(63041);
    const { parseMIMEType: T, serializeAMimeType: v } = r(94322);
    let w = globalThis.ReadableStream;
    const _ = E ?? B;
    const R = new TextEncoder();
    const O = new TextDecoder();
    function extractBody(e, t = false) {
      if (!w) {
        w = r(63774).ReadableStream;
      }
      let n = null;
      if (e instanceof w) {
        n = e;
      } else if (i(e)) {
        n = e.stream();
      } else {
        n = new w({
          async pull(e) {
            e.enqueue(typeof u === "string" ? R.encode(u) : u);
            queueMicrotask(() => A(e));
          },
          start() {},
          type: undefined,
        });
      }
      y(a(n));
      let c = null;
      let u = null;
      let l = null;
      let p = null;
      if (typeof e === "string") {
        u = e;
        p = "text/plain;charset=UTF-8";
      } else if (e instanceof URLSearchParams) {
        u = e.toString();
        p = "application/x-www-form-urlencoded;charset=UTF-8";
      } else if (Q(e)) {
        u = new Uint8Array(e.slice());
      } else if (ArrayBuffer.isView(e)) {
        u = new Uint8Array(e.buffer.slice(e.byteOffset, e.byteOffset + e.byteLength));
      } else if (o.isFormDataLike(e)) {
        const t = `----formdata-undici-0${`${Math.floor(Math.random() * 1e11)}`.padStart(11, "0")}`;
        const r = `--${t}\r\nContent-Disposition: form-data`;
        /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ const escape = (e) =>
          e.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22");
        const normalizeLinefeeds = (e) => e.replace(/\r?\n|\r/g, "\r\n");
        const n = [];
        const o = new Uint8Array([13, 10]);
        l = 0;
        let s = false;
        for (const [t, i] of e) {
          if (typeof i === "string") {
            const e = R.encode(r + `; name="${escape(normalizeLinefeeds(t))}"` + `\r\n\r\n${normalizeLinefeeds(i)}\r\n`);
            n.push(e);
            l += e.byteLength;
          } else {
            const e = R.encode(
              `${r}; name="${escape(normalizeLinefeeds(t))}"` +
                (i.name ? `; filename="${escape(i.name)}"` : "") +
                "\r\n" +
                `Content-Type: ${i.type || "application/octet-stream"}\r\n\r\n`
            );
            n.push(e, i, o);
            if (typeof i.size === "number") {
              l += e.byteLength + i.size + o.byteLength;
            } else {
              s = true;
            }
          }
        }
        const i = R.encode(`--${t}--`);
        n.push(i);
        l += i.byteLength;
        if (s) {
          l = null;
        }
        u = e;
        c = async function* () {
          for (const e of n) {
            if (e.stream) {
              yield* e.stream();
            } else {
              yield e;
            }
          }
        };
        p = "multipart/form-data; boundary=" + t;
      } else if (i(e)) {
        u = e;
        l = e.size;
        if (e.type) {
          p = e.type;
        }
      } else if (typeof e[Symbol.asyncIterator] === "function") {
        if (t) {
          throw new TypeError("keepalive");
        }
        if (o.isDisturbed(e) || e.locked) {
          throw new TypeError("Response body object should not be disturbed or locked");
        }
        n = e instanceof w ? e : s(e);
      }
      if (typeof u === "string" || o.isBuffer(u)) {
        l = Buffer.byteLength(u);
      }
      if (c != null) {
        let t;
        n = new w({
          async start() {
            t = c(e)[Symbol.asyncIterator]();
          },
          async pull(e) {
            const { value: r, done: o } = await t.next();
            if (o) {
              queueMicrotask(() => {
                e.close();
              });
            } else {
              if (!C(n)) {
                e.enqueue(new Uint8Array(r));
              }
            }
            return e.desiredSize > 0;
          },
          async cancel(e) {
            await t.return();
          },
          type: undefined,
        });
      }
      const d = { stream: n, source: u, length: l };
      return [d, p];
    }
    function safelyExtractBody(e, t = false) {
      if (!w) {
        w = r(63774).ReadableStream;
      }
      if (e instanceof w) {
        y(!o.isDisturbed(e), "The body has already been consumed.");
        y(!e.locked, "The stream is locked.");
      }
      return extractBody(e, t);
    }
    function cloneBody(e) {
      const [t, r] = e.stream.tee();
      const n = m(r, { transfer: [r] });
      const [, o] = n.tee();
      e.stream = t;
      return { stream: o, length: e.length, source: e.source };
    }
    async function* consumeBody(e) {
      if (e) {
        if (b(e)) {
          yield e;
        } else {
          const t = e.stream;
          if (o.isDisturbed(t)) {
            throw new TypeError("The body has already been consumed.");
          }
          if (t.locked) {
            throw new TypeError("The stream is locked.");
          }
          t[I] = true;
          yield* t;
        }
      }
    }
    function throwIfAborted(e) {
      if (e.aborted) {
        throw new g("The operation was aborted.", "AbortError");
      }
    }
    function bodyMixinMethods(e) {
      const t = {
        blob() {
          return specConsumeBody(
            this,
            (e) => {
              let t = bodyMimeType(this);
              if (t === "failure") {
                t = "";
              } else if (t) {
                t = v(t);
              }
              return new h([e], { type: t });
            },
            e
          );
        },
        arrayBuffer() {
          return specConsumeBody(this, (e) => new Uint8Array(e).buffer, e);
        },
        text() {
          return specConsumeBody(this, utf8DecodeBytes, e);
        },
        json() {
          return specConsumeBody(this, parseJSONFromBytes, e);
        },
        async formData() {
          d.brandCheck(this, e);
          throwIfAborted(this[p]);
          const t = this.headers.get("Content-Type");
          if (/multipart\/form-data/.test(t)) {
            const e = {};
            for (const [t, r] of this.headers) e[t.toLowerCase()] = r;
            const t = new l();
            let r;
            try {
              r = new n({ headers: e, preservePath: true });
            } catch (e) {
              throw new g(`${e}`, "AbortError");
            }
            r.on("field", (e, r) => {
              t.append(e, r);
            });
            r.on("file", (e, r, n, o, s) => {
              const i = [];
              if (o === "base64" || o.toLowerCase() === "base64") {
                let o = "";
                r.on("data", (e) => {
                  o += e.toString().replace(/[\r\n]/gm, "");
                  const t = o.length - (o.length % 4);
                  i.push(Buffer.from(o.slice(0, t), "base64"));
                  o = o.slice(t);
                });
                r.on("end", () => {
                  i.push(Buffer.from(o, "base64"));
                  t.append(e, new _(i, n, { type: s }));
                });
              } else {
                r.on("data", (e) => {
                  i.push(e);
                });
                r.on("end", () => {
                  t.append(e, new _(i, n, { type: s }));
                });
              }
            });
            const o = new Promise((e, t) => {
              r.on("finish", e);
              r.on("error", (e) => t(new TypeError(e)));
            });
            if (this.body !== null) for await (const e of consumeBody(this[p].body)) r.write(e);
            r.end();
            await o;
            return t;
          } else if (/application\/x-www-form-urlencoded/.test(t)) {
            let e;
            try {
              let t = "";
              const r = new TextDecoder("utf-8", { ignoreBOM: true });
              for await (const e of consumeBody(this[p].body)) {
                if (!b(e)) {
                  throw new TypeError("Expected Uint8Array chunk");
                }
                t += r.decode(e, { stream: true });
              }
              t += r.decode();
              e = new URLSearchParams(t);
            } catch (e) {
              throw Object.assign(new TypeError(), { cause: e });
            }
            const t = new l();
            for (const [r, n] of e) {
              t.append(r, n);
            }
            return t;
          } else {
            await Promise.resolve();
            throwIfAborted(this[p]);
            throw d.errors.exception({ header: `${e.name}.formData`, message: "Could not parse content as FormData." });
          }
        },
      };
      return t;
    }
    function mixinBody(e) {
      Object.assign(e.prototype, bodyMixinMethods(e));
    }
    async function specConsumeBody(e, t, r) {
      d.brandCheck(e, r);
      throwIfAborted(e[p]);
      if (bodyUnusable(e[p].body)) {
        throw new TypeError("Body is unusable");
      }
      const n = c();
      const errorSteps = (e) => n.reject(e);
      const successSteps = (e) => {
        try {
          n.resolve(t(e));
        } catch (e) {
          errorSteps(e);
        }
      };
      if (e[p].body == null) {
        successSteps(new Uint8Array());
        return n.promise;
      }
      await u(e[p].body, successSteps, errorSteps);
      return n.promise;
    }
    function bodyUnusable(e) {
      return e != null && (e.stream.locked || o.isDisturbed(e.stream));
    }
    function utf8DecodeBytes(e) {
      if (e.length === 0) {
        return "";
      }
      if (e[0] === 239 && e[1] === 187 && e[2] === 191) {
        e = e.subarray(3);
      }
      const t = O.decode(e);
      return t;
    }
    function parseJSONFromBytes(e) {
      return JSON.parse(utf8DecodeBytes(e));
    }
    function bodyMimeType(e) {
      const { headersList: t } = e[p];
      const r = t.get("content-type");
      if (r === null) {
        return "failure";
      }
      return T(r);
    }
    e.exports = { extractBody: extractBody, safelyExtractBody: safelyExtractBody, cloneBody: cloneBody, mixinBody: mixinBody };
  },
  87326: (e, t, r) => {
    const { MessageChannel: n, receiveMessageOnPort: o } = r(28167);
    const s = ["GET", "HEAD", "POST"];
    const i = new Set(s);
    const a = [101, 204, 205, 304];
    const A = [301, 302, 303, 307, 308];
    const c = new Set(A);
    const u = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080",
    ];
    const l = new Set(u);
    const p = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url",
    ];
    const d = new Set(p);
    const g = ["follow", "manual", "error"];
    const m = ["GET", "HEAD", "OPTIONS", "TRACE"];
    const h = new Set(m);
    const E = ["navigate", "same-origin", "no-cors", "cors"];
    const I = ["omit", "same-origin", "include"];
    const y = ["default", "no-store", "reload", "no-cache", "force-cache", "only-if-cached"];
    const C = ["content-encoding", "content-language", "content-location", "content-type", "content-length"];
    const b = ["half"];
    const Q = ["CONNECT", "TRACE", "TRACK"];
    const B = new Set(Q);
    const T = ["audio", "audioworklet", "font", "image", "manifest", "paintworklet", "script", "style", "track", "video", "xslt", ""];
    const v = new Set(T);
    const w =
      globalThis.DOMException ??
      (() => {
        try {
          atob("~");
        } catch (e) {
          return Object.getPrototypeOf(e).constructor;
        }
      })();
    let _;
    const R =
      globalThis.structuredClone ??
      function structuredClone(e, t = undefined) {
        if (arguments.length === 0) {
          throw new TypeError("missing argument");
        }
        if (!_) {
          _ = new n();
        }
        _.port1.unref();
        _.port2.unref();
        _.port1.postMessage(e, t?.transfer);
        return o(_.port2).message;
      };
    e.exports = {
      DOMException: w,
      structuredClone: R,
      subresource: T,
      forbiddenMethods: Q,
      requestBodyHeader: C,
      referrerPolicy: p,
      requestRedirect: g,
      requestMode: E,
      requestCredentials: I,
      requestCache: y,
      redirectStatus: A,
      corsSafeListedMethods: s,
      nullBodyStatus: a,
      safeMethods: m,
      badPorts: u,
      requestDuplex: b,
      subresourceSet: v,
      badPortsSet: l,
      redirectStatusSet: c,
      corsSafeListedMethodsSet: i,
      safeMethodsSet: h,
      forbiddenMethodsSet: B,
      referrerPolicySet: d,
    };
  },
  94322: (e, t, r) => {
    const n = r(42613);
    const { atob: o } = r(20181);
    const { isomorphicDecode: s } = r(15523);
    const i = new TextEncoder();
    const a = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/;
    const A = /(\u000A|\u000D|\u0009|\u0020)/;
    const c = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
    function dataURLProcessor(e) {
      n(e.protocol === "data:");
      let t = URLSerializer(e, true);
      t = t.slice(5);
      const r = { position: 0 };
      let o = collectASequenceOfCodePointsFast(",", t, r);
      const i = o.length;
      o = removeASCIIWhitespace(o, true, true);
      if (r.position >= t.length) {
        return "failure";
      }
      r.position++;
      const a = t.slice(i + 1);
      let A = stringPercentDecode(a);
      if (/;(\u0020){0,}base64$/i.test(o)) {
        const e = s(A);
        A = forgivingBase64(e);
        if (A === "failure") {
          return "failure";
        }
        o = o.slice(0, -6);
        o = o.replace(/(\u0020)+$/, "");
        o = o.slice(0, -1);
      }
      if (o.startsWith(";")) {
        o = "text/plain" + o;
      }
      let c = parseMIMEType(o);
      if (c === "failure") {
        c = parseMIMEType("text/plain;charset=US-ASCII");
      }
      return { mimeType: c, body: A };
    }
    function URLSerializer(e, t = false) {
      if (!t) {
        return e.href;
      }
      const r = e.href;
      const n = e.hash.length;
      return n === 0 ? r : r.substring(0, r.length - n);
    }
    function collectASequenceOfCodePoints(e, t, r) {
      let n = "";
      while (r.position < t.length && e(t[r.position])) {
        n += t[r.position];
        r.position++;
      }
      return n;
    }
    function collectASequenceOfCodePointsFast(e, t, r) {
      const n = t.indexOf(e, r.position);
      const o = r.position;
      if (n === -1) {
        r.position = t.length;
        return t.slice(o);
      }
      r.position = n;
      return t.slice(o, r.position);
    }
    function stringPercentDecode(e) {
      const t = i.encode(e);
      return percentDecode(t);
    }
    function percentDecode(e) {
      const t = [];
      for (let r = 0; r < e.length; r++) {
        const n = e[r];
        if (n !== 37) {
          t.push(n);
        } else if (n === 37 && !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(e[r + 1], e[r + 2]))) {
          t.push(37);
        } else {
          const n = String.fromCharCode(e[r + 1], e[r + 2]);
          const o = Number.parseInt(n, 16);
          t.push(o);
          r += 2;
        }
      }
      return Uint8Array.from(t);
    }
    function parseMIMEType(e) {
      e = removeHTTPWhitespace(e, true, true);
      const t = { position: 0 };
      const r = collectASequenceOfCodePointsFast("/", e, t);
      if (r.length === 0 || !a.test(r)) {
        return "failure";
      }
      if (t.position > e.length) {
        return "failure";
      }
      t.position++;
      let n = collectASequenceOfCodePointsFast(";", e, t);
      n = removeHTTPWhitespace(n, false, true);
      if (n.length === 0 || !a.test(n)) {
        return "failure";
      }
      const o = r.toLowerCase();
      const s = n.toLowerCase();
      const i = { type: o, subtype: s, parameters: new Map(), essence: `${o}/${s}` };
      while (t.position < e.length) {
        t.position++;
        collectASequenceOfCodePoints((e) => A.test(e), e, t);
        let r = collectASequenceOfCodePoints((e) => e !== ";" && e !== "=", e, t);
        r = r.toLowerCase();
        if (t.position < e.length) {
          if (e[t.position] === ";") {
            continue;
          }
          t.position++;
        }
        if (t.position > e.length) {
          break;
        }
        let n = null;
        if (e[t.position] === '"') {
          n = collectAnHTTPQuotedString(e, t, true);
          collectASequenceOfCodePointsFast(";", e, t);
        } else {
          n = collectASequenceOfCodePointsFast(";", e, t);
          n = removeHTTPWhitespace(n, false, true);
          if (n.length === 0) {
            continue;
          }
        }
        if (r.length !== 0 && a.test(r) && (n.length === 0 || c.test(n)) && !i.parameters.has(r)) {
          i.parameters.set(r, n);
        }
      }
      return i;
    }
    function forgivingBase64(e) {
      e = e.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "");
      if (e.length % 4 === 0) {
        e = e.replace(/=?=$/, "");
      }
      if (e.length % 4 === 1) {
        return "failure";
      }
      if (/[^+/0-9A-Za-z]/.test(e)) {
        return "failure";
      }
      const t = o(e);
      const r = new Uint8Array(t.length);
      for (let e = 0; e < t.length; e++) {
        r[e] = t.charCodeAt(e);
      }
      return r;
    }
    function collectAnHTTPQuotedString(e, t, r) {
      const o = t.position;
      let s = "";
      n(e[t.position] === '"');
      t.position++;
      while (true) {
        s += collectASequenceOfCodePoints((e) => e !== '"' && e !== "\\", e, t);
        if (t.position >= e.length) {
          break;
        }
        const r = e[t.position];
        t.position++;
        if (r === "\\") {
          if (t.position >= e.length) {
            s += "\\";
            break;
          }
          s += e[t.position];
          t.position++;
        } else {
          n(r === '"');
          break;
        }
      }
      if (r) {
        return s;
      }
      return e.slice(o, t.position);
    }
    function serializeAMimeType(e) {
      n(e !== "failure");
      const { parameters: t, essence: r } = e;
      let o = r;
      for (let [e, r] of t.entries()) {
        o += ";";
        o += e;
        o += "=";
        if (!a.test(r)) {
          r = r.replace(/(\\|")/g, "\\$1");
          r = '"' + r;
          r += '"';
        }
        o += r;
      }
      return o;
    }
    function isHTTPWhiteSpace(e) {
      return e === "\r" || e === "\n" || e === "\t" || e === " ";
    }
    function removeHTTPWhitespace(e, t = true, r = true) {
      let n = 0;
      let o = e.length - 1;
      if (t) {
        for (; n < e.length && isHTTPWhiteSpace(e[n]); n++);
      }
      if (r) {
        for (; o > 0 && isHTTPWhiteSpace(e[o]); o--);
      }
      return e.slice(n, o + 1);
    }
    function isASCIIWhitespace(e) {
      return e === "\r" || e === "\n" || e === "\t" || e === "\f" || e === " ";
    }
    function removeASCIIWhitespace(e, t = true, r = true) {
      let n = 0;
      let o = e.length - 1;
      if (t) {
        for (; n < e.length && isASCIIWhitespace(e[n]); n++);
      }
      if (r) {
        for (; o > 0 && isASCIIWhitespace(e[o]); o--);
      }
      return e.slice(n, o + 1);
    }
    e.exports = {
      dataURLProcessor: dataURLProcessor,
      URLSerializer: URLSerializer,
      collectASequenceOfCodePoints: collectASequenceOfCodePoints,
      collectASequenceOfCodePointsFast: collectASequenceOfCodePointsFast,
      stringPercentDecode: stringPercentDecode,
      parseMIMEType: parseMIMEType,
      collectAnHTTPQuotedString: collectAnHTTPQuotedString,
      serializeAMimeType: serializeAMimeType,
    };
  },
  63041: (e, t, r) => {
    const { Blob: n, File: o } = r(20181);
    const { types: s } = r(39023);
    const { kState: i } = r(89710);
    const { isBlobLike: a } = r(15523);
    const { webidl: A } = r(74222);
    const { parseMIMEType: c, serializeAMimeType: u } = r(94322);
    const { kEnumerableProperty: l } = r(3440);
    const p = new TextEncoder();
    class File extends n {
      constructor(e, t, r = {}) {
        A.argumentLengthCheck(arguments, 2, { header: "File constructor" });
        e = A.converters["sequence<BlobPart>"](e);
        t = A.converters.USVString(t);
        r = A.converters.FilePropertyBag(r);
        const n = t;
        let o = r.type;
        let s;
        e: {
          if (o) {
            o = c(o);
            if (o === "failure") {
              o = "";
              break e;
            }
            o = u(o).toLowerCase();
          }
          s = r.lastModified;
        }
        super(processBlobParts(e, r), { type: o });
        this[i] = { name: n, lastModified: s, type: o };
      }
      get name() {
        A.brandCheck(this, File);
        return this[i].name;
      }
      get lastModified() {
        A.brandCheck(this, File);
        return this[i].lastModified;
      }
      get type() {
        A.brandCheck(this, File);
        return this[i].type;
      }
    }
    class FileLike {
      constructor(e, t, r = {}) {
        const n = t;
        const o = r.type;
        const s = r.lastModified ?? Date.now();
        this[i] = { blobLike: e, name: n, type: o, lastModified: s };
      }
      stream(...e) {
        A.brandCheck(this, FileLike);
        return this[i].blobLike.stream(...e);
      }
      arrayBuffer(...e) {
        A.brandCheck(this, FileLike);
        return this[i].blobLike.arrayBuffer(...e);
      }
      slice(...e) {
        A.brandCheck(this, FileLike);
        return this[i].blobLike.slice(...e);
      }
      text(...e) {
        A.brandCheck(this, FileLike);
        return this[i].blobLike.text(...e);
      }
      get size() {
        A.brandCheck(this, FileLike);
        return this[i].blobLike.size;
      }
      get type() {
        A.brandCheck(this, FileLike);
        return this[i].blobLike.type;
      }
      get name() {
        A.brandCheck(this, FileLike);
        return this[i].name;
      }
      get lastModified() {
        A.brandCheck(this, FileLike);
        return this[i].lastModified;
      }
      get [Symbol.toStringTag]() {
        return "File";
      }
    }
    Object.defineProperties(File.prototype, { [Symbol.toStringTag]: { value: "File", configurable: true }, name: l, lastModified: l });
    A.converters.Blob = A.interfaceConverter(n);
    A.converters.BlobPart = function (e, t) {
      if (A.util.Type(e) === "Object") {
        if (a(e)) {
          return A.converters.Blob(e, { strict: false });
        }
        if (ArrayBuffer.isView(e) || s.isAnyArrayBuffer(e)) {
          return A.converters.BufferSource(e, t);
        }
      }
      return A.converters.USVString(e, t);
    };
    A.converters["sequence<BlobPart>"] = A.sequenceConverter(A.converters.BlobPart);
    A.converters.FilePropertyBag = A.dictionaryConverter([
      {
        key: "lastModified",
        converter: A.converters["long long"],
        get defaultValue() {
          return Date.now();
        },
      },
      { key: "type", converter: A.converters.DOMString, defaultValue: "" },
      {
        key: "endings",
        converter: (e) => {
          e = A.converters.DOMString(e);
          e = e.toLowerCase();
          if (e !== "native") {
            e = "transparent";
          }
          return e;
        },
        defaultValue: "transparent",
      },
    ]);
    function processBlobParts(e, t) {
      const r = [];
      for (const n of e) {
        if (typeof n === "string") {
          let e = n;
          if (t.endings === "native") {
            e = convertLineEndingsNative(e);
          }
          r.push(p.encode(e));
        } else if (s.isAnyArrayBuffer(n) || s.isTypedArray(n)) {
          if (!n.buffer) {
            r.push(new Uint8Array(n));
          } else {
            r.push(new Uint8Array(n.buffer, n.byteOffset, n.byteLength));
          }
        } else if (a(n)) {
          r.push(n);
        }
      }
      return r;
    }
    function convertLineEndingsNative(e) {
      let t = "\n";
      if (process.platform === "win32") {
        t = "\r\n";
      }
      return e.replace(/\r?\n/g, t);
    }
    function isFileLike(e) {
      return (
        (o && e instanceof o) ||
        e instanceof File ||
        (e && (typeof e.stream === "function" || typeof e.arrayBuffer === "function") && e[Symbol.toStringTag] === "File")
      );
    }
    e.exports = { File: File, FileLike: FileLike, isFileLike: isFileLike };
  },
  43073: (e, t, r) => {
    const { isBlobLike: n, toUSVString: o, makeIterator: s } = r(15523);
    const { kState: i } = r(89710);
    const { File: a, FileLike: A, isFileLike: c } = r(63041);
    const { webidl: u } = r(74222);
    const { Blob: l, File: p } = r(20181);
    const d = p ?? a;
    class FormData {
      constructor(e) {
        if (e !== undefined) {
          throw u.errors.conversionFailed({ prefix: "FormData constructor", argument: "Argument 1", types: ["undefined"] });
        }
        this[i] = [];
      }
      append(e, t, r = undefined) {
        u.brandCheck(this, FormData);
        u.argumentLengthCheck(arguments, 2, { header: "FormData.append" });
        if (arguments.length === 3 && !n(t)) {
          throw new TypeError("Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'");
        }
        e = u.converters.USVString(e);
        t = n(t) ? u.converters.Blob(t, { strict: false }) : u.converters.USVString(t);
        r = arguments.length === 3 ? u.converters.USVString(r) : undefined;
        const o = makeEntry(e, t, r);
        this[i].push(o);
      }
      delete(e) {
        u.brandCheck(this, FormData);
        u.argumentLengthCheck(arguments, 1, { header: "FormData.delete" });
        e = u.converters.USVString(e);
        this[i] = this[i].filter((t) => t.name !== e);
      }
      get(e) {
        u.brandCheck(this, FormData);
        u.argumentLengthCheck(arguments, 1, { header: "FormData.get" });
        e = u.converters.USVString(e);
        const t = this[i].findIndex((t) => t.name === e);
        if (t === -1) {
          return null;
        }
        return this[i][t].value;
      }
      getAll(e) {
        u.brandCheck(this, FormData);
        u.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" });
        e = u.converters.USVString(e);
        return this[i].filter((t) => t.name === e).map((e) => e.value);
      }
      has(e) {
        u.brandCheck(this, FormData);
        u.argumentLengthCheck(arguments, 1, { header: "FormData.has" });
        e = u.converters.USVString(e);
        return this[i].findIndex((t) => t.name === e) !== -1;
      }
      set(e, t, r = undefined) {
        u.brandCheck(this, FormData);
        u.argumentLengthCheck(arguments, 2, { header: "FormData.set" });
        if (arguments.length === 3 && !n(t)) {
          throw new TypeError("Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'");
        }
        e = u.converters.USVString(e);
        t = n(t) ? u.converters.Blob(t, { strict: false }) : u.converters.USVString(t);
        r = arguments.length === 3 ? o(r) : undefined;
        const s = makeEntry(e, t, r);
        const a = this[i].findIndex((t) => t.name === e);
        if (a !== -1) {
          this[i] = [...this[i].slice(0, a), s, ...this[i].slice(a + 1).filter((t) => t.name !== e)];
        } else {
          this[i].push(s);
        }
      }
      entries() {
        u.brandCheck(this, FormData);
        return s(() => this[i].map((e) => [e.name, e.value]), "FormData", "key+value");
      }
      keys() {
        u.brandCheck(this, FormData);
        return s(() => this[i].map((e) => [e.name, e.value]), "FormData", "key");
      }
      values() {
        u.brandCheck(this, FormData);
        return s(() => this[i].map((e) => [e.name, e.value]), "FormData", "value");
      }
      forEach(e, t = globalThis) {
        u.brandCheck(this, FormData);
        u.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" });
        if (typeof e !== "function") {
          throw new TypeError("Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.");
        }
        for (const [r, n] of this) {
          e.apply(t, [n, r, this]);
        }
      }
    }
    FormData.prototype[Symbol.iterator] = FormData.prototype.entries;
    Object.defineProperties(FormData.prototype, { [Symbol.toStringTag]: { value: "FormData", configurable: true } });
    function makeEntry(e, t, r) {
      e = Buffer.from(e).toString("utf8");
      if (typeof t === "string") {
        t = Buffer.from(t).toString("utf8");
      } else {
        if (!c(t)) {
          t = t instanceof l ? new d([t], "blob", { type: t.type }) : new A(t, "blob", { type: t.type });
        }
        if (r !== undefined) {
          const e = { type: t.type, lastModified: t.lastModified };
          t = (p && t instanceof p) || t instanceof a ? new d([t], r, e) : new A(t, r, e);
        }
      }
      return { name: e, value: t };
    }
    e.exports = { FormData: FormData };
  },
  75628: (e) => {
    const t = Symbol.for("undici.globalOrigin.1");
    function getGlobalOrigin() {
      return globalThis[t];
    }
    function setGlobalOrigin(e) {
      if (e === undefined) {
        Object.defineProperty(globalThis, t, { value: undefined, writable: true, enumerable: false, configurable: false });
        return;
      }
      const r = new URL(e);
      if (r.protocol !== "http:" && r.protocol !== "https:") {
        throw new TypeError(`Only http & https urls are allowed, received ${r.protocol}`);
      }
      Object.defineProperty(globalThis, t, { value: r, writable: true, enumerable: false, configurable: false });
    }
    e.exports = { getGlobalOrigin: getGlobalOrigin, setGlobalOrigin: setGlobalOrigin };
  },
  26349: (e, t, r) => {
    const { kHeadersList: n, kConstruct: o } = r(36443);
    const { kGuard: s } = r(89710);
    const { kEnumerableProperty: i } = r(3440);
    const { makeIterator: a, isValidHeaderName: A, isValidHeaderValue: c } = r(15523);
    const { webidl: u } = r(74222);
    const l = r(42613);
    const p = Symbol("headers map");
    const d = Symbol("headers map sorted");
    function isHTTPWhiteSpaceCharCode(e) {
      return e === 10 || e === 13 || e === 9 || e === 32;
    }
    function headerValueNormalize(e) {
      let t = 0;
      let r = e.length;
      while (r > t && isHTTPWhiteSpaceCharCode(e.charCodeAt(r - 1))) --r;
      while (r > t && isHTTPWhiteSpaceCharCode(e.charCodeAt(t))) ++t;
      return t === 0 && r === e.length ? e : e.substring(t, r);
    }
    function fill(e, t) {
      if (Array.isArray(t)) {
        for (let r = 0; r < t.length; ++r) {
          const n = t[r];
          if (n.length !== 2) {
            throw u.errors.exception({ header: "Headers constructor", message: `expected name/value pair to be length 2, found ${n.length}.` });
          }
          appendHeader(e, n[0], n[1]);
        }
      } else if (typeof t === "object" && t !== null) {
        const r = Object.keys(t);
        for (let n = 0; n < r.length; ++n) {
          appendHeader(e, r[n], t[r[n]]);
        }
      } else {
        throw u.errors.conversionFailed({
          prefix: "Headers constructor",
          argument: "Argument 1",
          types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"],
        });
      }
    }
    function appendHeader(e, t, r) {
      r = headerValueNormalize(r);
      if (!A(t)) {
        throw u.errors.invalidArgument({ prefix: "Headers.append", value: t, type: "header name" });
      } else if (!c(r)) {
        throw u.errors.invalidArgument({ prefix: "Headers.append", value: r, type: "header value" });
      }
      if (e[s] === "immutable") {
        throw new TypeError("immutable");
      } else if (e[s] === "request-no-cors") {
      }
      return e[n].append(t, r);
    }
    class HeadersList {
      cookies = null;
      constructor(e) {
        if (e instanceof HeadersList) {
          this[p] = new Map(e[p]);
          this[d] = e[d];
          this.cookies = e.cookies === null ? null : [...e.cookies];
        } else {
          this[p] = new Map(e);
          this[d] = null;
        }
      }
      contains(e) {
        e = e.toLowerCase();
        return this[p].has(e);
      }
      clear() {
        this[p].clear();
        this[d] = null;
        this.cookies = null;
      }
      append(e, t) {
        this[d] = null;
        const r = e.toLowerCase();
        const n = this[p].get(r);
        if (n) {
          const e = r === "cookie" ? "; " : ", ";
          this[p].set(r, { name: n.name, value: `${n.value}${e}${t}` });
        } else {
          this[p].set(r, { name: e, value: t });
        }
        if (r === "set-cookie") {
          this.cookies ??= [];
          this.cookies.push(t);
        }
      }
      set(e, t) {
        this[d] = null;
        const r = e.toLowerCase();
        if (r === "set-cookie") {
          this.cookies = [t];
        }
        this[p].set(r, { name: e, value: t });
      }
      delete(e) {
        this[d] = null;
        e = e.toLowerCase();
        if (e === "set-cookie") {
          this.cookies = null;
        }
        this[p].delete(e);
      }
      get(e) {
        const t = this[p].get(e.toLowerCase());
        return t === undefined ? null : t.value;
      }
      *[Symbol.iterator]() {
        for (const [e, { value: t }] of this[p]) {
          yield [e, t];
        }
      }
      get entries() {
        const e = {};
        if (this[p].size) {
          for (const { name: t, value: r } of this[p].values()) {
            e[t] = r;
          }
        }
        return e;
      }
    }
    class Headers {
      constructor(e = undefined) {
        if (e === o) {
          return;
        }
        this[n] = new HeadersList();
        this[s] = "none";
        if (e !== undefined) {
          e = u.converters.HeadersInit(e);
          fill(this, e);
        }
      }
      append(e, t) {
        u.brandCheck(this, Headers);
        u.argumentLengthCheck(arguments, 2, { header: "Headers.append" });
        e = u.converters.ByteString(e);
        t = u.converters.ByteString(t);
        return appendHeader(this, e, t);
      }
      delete(e) {
        u.brandCheck(this, Headers);
        u.argumentLengthCheck(arguments, 1, { header: "Headers.delete" });
        e = u.converters.ByteString(e);
        if (!A(e)) {
          throw u.errors.invalidArgument({ prefix: "Headers.delete", value: e, type: "header name" });
        }
        if (this[s] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[s] === "request-no-cors") {
        }
        if (!this[n].contains(e)) {
          return;
        }
        this[n].delete(e);
      }
      get(e) {
        u.brandCheck(this, Headers);
        u.argumentLengthCheck(arguments, 1, { header: "Headers.get" });
        e = u.converters.ByteString(e);
        if (!A(e)) {
          throw u.errors.invalidArgument({ prefix: "Headers.get", value: e, type: "header name" });
        }
        return this[n].get(e);
      }
      has(e) {
        u.brandCheck(this, Headers);
        u.argumentLengthCheck(arguments, 1, { header: "Headers.has" });
        e = u.converters.ByteString(e);
        if (!A(e)) {
          throw u.errors.invalidArgument({ prefix: "Headers.has", value: e, type: "header name" });
        }
        return this[n].contains(e);
      }
      set(e, t) {
        u.brandCheck(this, Headers);
        u.argumentLengthCheck(arguments, 2, { header: "Headers.set" });
        e = u.converters.ByteString(e);
        t = u.converters.ByteString(t);
        t = headerValueNormalize(t);
        if (!A(e)) {
          throw u.errors.invalidArgument({ prefix: "Headers.set", value: e, type: "header name" });
        } else if (!c(t)) {
          throw u.errors.invalidArgument({ prefix: "Headers.set", value: t, type: "header value" });
        }
        if (this[s] === "immutable") {
          throw new TypeError("immutable");
        } else if (this[s] === "request-no-cors") {
        }
        this[n].set(e, t);
      }
      getSetCookie() {
        u.brandCheck(this, Headers);
        const e = this[n].cookies;
        if (e) {
          return [...e];
        }
        return [];
      }
      get [d]() {
        if (this[n][d]) {
          return this[n][d];
        }
        const e = [];
        const t = [...this[n]].sort((e, t) => (e[0] < t[0] ? -1 : 1));
        const r = this[n].cookies;
        for (let n = 0; n < t.length; ++n) {
          const [o, s] = t[n];
          if (o === "set-cookie") {
            for (let t = 0; t < r.length; ++t) {
              e.push([o, r[t]]);
            }
          } else {
            l(s !== null);
            e.push([o, s]);
          }
        }
        this[n][d] = e;
        return e;
      }
      keys() {
        u.brandCheck(this, Headers);
        if (this[s] === "immutable") {
          const e = this[d];
          return a(() => e, "Headers", "key");
        }
        return a(() => [...this[d].values()], "Headers", "key");
      }
      values() {
        u.brandCheck(this, Headers);
        if (this[s] === "immutable") {
          const e = this[d];
          return a(() => e, "Headers", "value");
        }
        return a(() => [...this[d].values()], "Headers", "value");
      }
      entries() {
        u.brandCheck(this, Headers);
        if (this[s] === "immutable") {
          const e = this[d];
          return a(() => e, "Headers", "key+value");
        }
        return a(() => [...this[d].values()], "Headers", "key+value");
      }
      forEach(e, t = globalThis) {
        u.brandCheck(this, Headers);
        u.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" });
        if (typeof e !== "function") {
          throw new TypeError("Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.");
        }
        for (const [r, n] of this) {
          e.apply(t, [n, r, this]);
        }
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        u.brandCheck(this, Headers);
        return this[n];
      }
    }
    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
    Object.defineProperties(Headers.prototype, {
      append: i,
      delete: i,
      get: i,
      has: i,
      set: i,
      getSetCookie: i,
      keys: i,
      values: i,
      entries: i,
      forEach: i,
      [Symbol.iterator]: { enumerable: false },
      [Symbol.toStringTag]: { value: "Headers", configurable: true },
    });
    u.converters.HeadersInit = function (e) {
      if (u.util.Type(e) === "Object") {
        if (e[Symbol.iterator]) {
          return u.converters["sequence<sequence<ByteString>>"](e);
        }
        return u.converters["record<ByteString, ByteString>"](e);
      }
      throw u.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: ["sequence<sequence<ByteString>>", "record<ByteString, ByteString>"],
      });
    };
    e.exports = { fill: fill, Headers: Headers, HeadersList: HeadersList };
  },
  12315: (e, t, r) => {
    const { Response: n, makeNetworkError: o, makeAppropriateNetworkError: s, filterResponse: i, makeResponse: a } = r(48676);
    const { Headers: A } = r(26349);
    const { Request: c, makeRequest: u } = r(25194);
    const l = r(43106);
    const {
      bytesMatch: p,
      makePolicyContainer: d,
      clonePolicyContainer: g,
      requestBadPort: m,
      TAOCheck: h,
      appendRequestOriginHeader: E,
      responseLocationURL: I,
      requestCurrentURL: y,
      setRequestReferrerPolicyOnRedirect: C,
      tryUpgradeRequestToAPotentiallyTrustworthyURL: b,
      createOpaqueTimingInfo: Q,
      appendFetchMetadata: B,
      corsCheck: T,
      crossOriginResourcePolicyCheck: v,
      determineRequestsReferrer: w,
      coarsenedSharedCurrentTime: _,
      createDeferredPromise: R,
      isBlobLike: O,
      sameOrigin: F,
      isCancelled: D,
      isAborted: k,
      isErrorLike: S,
      fullyReadBody: N,
      readableStreamClose: P,
      isomorphicEncode: L,
      urlIsLocal: U,
      urlIsHttpHttpsScheme: M,
      urlHasHttpsScheme: G,
    } = r(15523);
    const { kState: x, kHeaders: j, kGuard: V, kRealm: H } = r(89710);
    const Y = r(42613);
    const { safelyExtractBody: K } = r(8923);
    const { redirectStatusSet: q, nullBodyStatus: J, safeMethodsSet: W, requestBodyHeader: $, subresourceSet: z, DOMException: Z } = r(87326);
    const { kHeadersList: X } = r(36443);
    const ee = r(24434);
    const { Readable: te, pipeline: re } = r(2203);
    const { addAbortListener: ne, isErrored: oe, isReadable: se, nodeMajor: ie, nodeMinor: ae } = r(3440);
    const { dataURLProcessor: Ae, serializeAMimeType: ce } = r(94322);
    const { TransformStream: ue } = r(63774);
    const { getGlobalDispatcher: le } = r(32581);
    const { webidl: pe } = r(74222);
    const { STATUS_CODES: de } = r(58611);
    const fe = ["GET", "HEAD"];
    let ge;
    let me = globalThis.ReadableStream;
    class Fetch extends ee {
      constructor(e) {
        super();
        this.dispatcher = e;
        this.connection = null;
        this.dump = false;
        this.state = "ongoing";
        this.setMaxListeners(21);
      }
      terminate(e) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "terminated";
        this.connection?.destroy(e);
        this.emit("terminated", e);
      }
      abort(e) {
        if (this.state !== "ongoing") {
          return;
        }
        this.state = "aborted";
        if (!e) {
          e = new Z("The operation was aborted.", "AbortError");
        }
        this.serializedAbortReason = e;
        this.connection?.destroy(e);
        this.emit("terminated", e);
      }
    }
    function fetch(e, t = {}) {
      pe.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
      const r = R();
      let o;
      try {
        o = new c(e, t);
      } catch (e) {
        r.reject(e);
        return r.promise;
      }
      const s = o[x];
      if (o.signal.aborted) {
        abortFetch(r, s, null, o.signal.reason);
        return r.promise;
      }
      const i = s.client.globalObject;
      if (i?.constructor?.name === "ServiceWorkerGlobalScope") {
        s.serviceWorkers = "none";
      }
      let a = null;
      const A = null;
      let u = false;
      let l = null;
      ne(o.signal, () => {
        u = true;
        Y(l != null);
        l.abort(o.signal.reason);
        abortFetch(r, s, a, o.signal.reason);
      });
      const handleFetchDone = (e) => finalizeAndReportTiming(e, "fetch");
      const processResponse = (e) => {
        if (u) {
          return Promise.resolve();
        }
        if (e.aborted) {
          abortFetch(r, s, a, l.serializedAbortReason);
          return Promise.resolve();
        }
        if (e.type === "error") {
          r.reject(Object.assign(new TypeError("fetch failed"), { cause: e.error }));
          return Promise.resolve();
        }
        a = new n();
        a[x] = e;
        a[H] = A;
        a[j][X] = e.headersList;
        a[j][V] = "immutable";
        a[j][H] = A;
        r.resolve(a);
      };
      l = fetching({ request: s, processResponseEndOfBody: handleFetchDone, processResponse: processResponse, dispatcher: t.dispatcher ?? le() });
      return r.promise;
    }
    function finalizeAndReportTiming(e, t = "other") {
      if (e.type === "error" && e.aborted) {
        return;
      }
      if (!e.urlList?.length) {
        return;
      }
      const r = e.urlList[0];
      let n = e.timingInfo;
      let o = e.cacheState;
      if (!M(r)) {
        return;
      }
      if (n === null) {
        return;
      }
      if (!e.timingAllowPassed) {
        n = Q({ startTime: n.startTime });
        o = "";
      }
      n.endTime = _();
      e.timingInfo = n;
      markResourceTiming(n, r, t, globalThis, o);
    }
    function markResourceTiming(e, t, r, n, o) {
      if (ie > 18 || (ie === 18 && ae >= 2)) {
        performance.markResourceTiming(e, t.href, r, n, o);
      }
    }
    function abortFetch(e, t, r, n) {
      if (!n) {
        n = new Z("The operation was aborted.", "AbortError");
      }
      e.reject(n);
      if (t.body != null && se(t.body?.stream)) {
        t.body.stream.cancel(n).catch((e) => {
          if (e.code === "ERR_INVALID_STATE") {
            return;
          }
          throw e;
        });
      }
      if (r == null) {
        return;
      }
      const o = r[x];
      if (o.body != null && se(o.body?.stream)) {
        o.body.stream.cancel(n).catch((e) => {
          if (e.code === "ERR_INVALID_STATE") {
            return;
          }
          throw e;
        });
      }
    }
    function fetching({
      request: e,
      processRequestBodyChunkLength: t,
      processRequestEndOfBody: r,
      processResponse: n,
      processResponseEndOfBody: o,
      processResponseConsumeBody: s,
      useParallelQueue: i = false,
      dispatcher: a,
    }) {
      let A = null;
      let c = false;
      if (e.client != null) {
        A = e.client.globalObject;
        c = e.client.crossOriginIsolatedCapability;
      }
      const u = _(c);
      const l = Q({ startTime: u });
      const p = {
        controller: new Fetch(a),
        request: e,
        timingInfo: l,
        processRequestBodyChunkLength: t,
        processRequestEndOfBody: r,
        processResponse: n,
        processResponseConsumeBody: s,
        processResponseEndOfBody: o,
        taskDestination: A,
        crossOriginIsolatedCapability: c,
      };
      Y(!e.body || e.body.stream);
      if (e.window === "client") {
        e.window = e.client?.globalObject?.constructor?.name === "Window" ? e.client : "no-window";
      }
      if (e.origin === "client") {
        e.origin = e.client?.origin;
      }
      if (e.policyContainer === "client") {
        if (e.client != null) {
          e.policyContainer = g(e.client.policyContainer);
        } else {
          e.policyContainer = d();
        }
      }
      if (!e.headersList.contains("accept")) {
        const t = "*/*";
        e.headersList.append("accept", t);
      }
      if (!e.headersList.contains("accept-language")) {
        e.headersList.append("accept-language", "*");
      }
      if (e.priority === null) {
      }
      if (z.has(e.destination)) {
      }
      mainFetch(p).catch((e) => {
        p.controller.terminate(e);
      });
      return p.controller;
    }
    async function mainFetch(e, t = false) {
      const r = e.request;
      let n = null;
      if (r.localURLsOnly && !U(y(r))) {
        n = o("local URLs only");
      }
      b(r);
      if (m(r) === "blocked") {
        n = o("bad port");
      }
      if (r.referrerPolicy === "") {
        r.referrerPolicy = r.policyContainer.referrerPolicy;
      }
      if (r.referrer !== "no-referrer") {
        r.referrer = w(r);
      }
      if (n === null) {
        n = await (async () => {
          const t = y(r);
          if ((F(t, r.url) && r.responseTainting === "basic") || t.protocol === "data:" || r.mode === "navigate" || r.mode === "websocket") {
            r.responseTainting = "basic";
            return await schemeFetch(e);
          }
          if (r.mode === "same-origin") {
            return o('request mode cannot be "same-origin"');
          }
          if (r.mode === "no-cors") {
            if (r.redirect !== "follow") {
              return o('redirect mode cannot be "follow" for "no-cors" request');
            }
            r.responseTainting = "opaque";
            return await schemeFetch(e);
          }
          if (!M(y(r))) {
            return o("URL scheme must be a HTTP(S) scheme");
          }
          r.responseTainting = "cors";
          return await httpFetch(e);
        })();
      }
      if (t) {
        return n;
      }
      if (n.status !== 0 && !n.internalResponse) {
        if (r.responseTainting === "cors") {
        }
        if (r.responseTainting === "basic") {
          n = i(n, "basic");
        } else if (r.responseTainting === "cors") {
          n = i(n, "cors");
        } else if (r.responseTainting === "opaque") {
          n = i(n, "opaque");
        } else {
          Y(false);
        }
      }
      let s = n.status === 0 ? n : n.internalResponse;
      if (s.urlList.length === 0) {
        s.urlList.push(...r.urlList);
      }
      if (!r.timingAllowFailed) {
        n.timingAllowPassed = true;
      }
      if (n.type === "opaque" && s.status === 206 && s.rangeRequested && !r.headers.contains("range")) {
        n = s = o();
      }
      if (n.status !== 0 && (r.method === "HEAD" || r.method === "CONNECT" || J.includes(s.status))) {
        s.body = null;
        e.controller.dump = true;
      }
      if (r.integrity) {
        const processBodyError = (t) => fetchFinale(e, o(t));
        if (r.responseTainting === "opaque" || n.body == null) {
          processBodyError(n.error);
          return;
        }
        const processBody = (t) => {
          if (!p(t, r.integrity)) {
            processBodyError("integrity mismatch");
            return;
          }
          n.body = K(t)[0];
          fetchFinale(e, n);
        };
        await N(n.body, processBody, processBodyError);
      } else {
        fetchFinale(e, n);
      }
    }
    function schemeFetch(e) {
      if (D(e) && e.request.redirectCount === 0) {
        return Promise.resolve(s(e));
      }
      const { request: t } = e;
      const { protocol: n } = y(t);
      switch (n) {
        case "about:": {
          return Promise.resolve(o("about scheme is not supported"));
        }
        case "blob:": {
          if (!ge) {
            ge = r(20181).resolveObjectURL;
          }
          const e = y(t);
          if (e.search.length !== 0) {
            return Promise.resolve(o("NetworkError when attempting to fetch resource."));
          }
          const n = ge(e.toString());
          if (t.method !== "GET" || !O(n)) {
            return Promise.resolve(o("invalid method"));
          }
          const s = K(n);
          const i = s[0];
          const A = L(`${i.length}`);
          const c = s[1] ?? "";
          const u = a({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: A }],
              ["content-type", { name: "Content-Type", value: c }],
            ],
          });
          u.body = i;
          return Promise.resolve(u);
        }
        case "data:": {
          const e = y(t);
          const r = Ae(e);
          if (r === "failure") {
            return Promise.resolve(o("failed to fetch the data URL"));
          }
          const n = ce(r.mimeType);
          return Promise.resolve(a({ statusText: "OK", headersList: [["content-type", { name: "Content-Type", value: n }]], body: K(r.body)[0] }));
        }
        case "file:": {
          return Promise.resolve(o("not implemented... yet..."));
        }
        case "http:":
        case "https:": {
          return httpFetch(e).catch((e) => o(e));
        }
        default: {
          return Promise.resolve(o("unknown scheme"));
        }
      }
    }
    function finalizeResponse(e, t) {
      e.request.done = true;
      if (e.processResponseDone != null) {
        queueMicrotask(() => e.processResponseDone(t));
      }
    }
    function fetchFinale(e, t) {
      if (t.type === "error") {
        t.urlList = [e.request.urlList[0]];
        t.timingInfo = Q({ startTime: e.timingInfo.startTime });
      }
      const processResponseEndOfBody = () => {
        e.request.done = true;
        if (e.processResponseEndOfBody != null) {
          queueMicrotask(() => e.processResponseEndOfBody(t));
        }
      };
      if (e.processResponse != null) {
        queueMicrotask(() => e.processResponse(t));
      }
      if (t.body == null) {
        processResponseEndOfBody();
      } else {
        const identityTransformAlgorithm = (e, t) => {
          t.enqueue(e);
        };
        const e = new ue(
          { start() {}, transform: identityTransformAlgorithm, flush: processResponseEndOfBody },
          {
            size() {
              return 1;
            },
          },
          {
            size() {
              return 1;
            },
          }
        );
        t.body = { stream: t.body.stream.pipeThrough(e) };
      }
      if (e.processResponseConsumeBody != null) {
        const processBody = (r) => e.processResponseConsumeBody(t, r);
        const processBodyError = (r) => e.processResponseConsumeBody(t, r);
        if (t.body == null) {
          queueMicrotask(() => processBody(null));
        } else {
          return N(t.body, processBody, processBodyError);
        }
        return Promise.resolve();
      }
    }
    async function httpFetch(e) {
      const t = e.request;
      let r = null;
      let n = null;
      const s = e.timingInfo;
      if (t.serviceWorkers === "all") {
      }
      if (r === null) {
        if (t.redirect === "follow") {
          t.serviceWorkers = "none";
        }
        n = r = await httpNetworkOrCacheFetch(e);
        if (t.responseTainting === "cors" && T(t, r) === "failure") {
          return o("cors failure");
        }
        if (h(t, r) === "failure") {
          t.timingAllowFailed = true;
        }
      }
      if ((t.responseTainting === "opaque" || r.type === "opaque") && v(t.origin, t.client, t.destination, n) === "blocked") {
        return o("blocked");
      }
      if (q.has(n.status)) {
        if (t.redirect !== "manual") {
          e.controller.connection.destroy();
        }
        if (t.redirect === "error") {
          r = o("unexpected redirect");
        } else if (t.redirect === "manual") {
          r = n;
        } else if (t.redirect === "follow") {
          r = await httpRedirectFetch(e, r);
        } else {
          Y(false);
        }
      }
      r.timingInfo = s;
      return r;
    }
    function httpRedirectFetch(e, t) {
      const r = e.request;
      const n = t.internalResponse ? t.internalResponse : t;
      let s;
      try {
        s = I(n, y(r).hash);
        if (s == null) {
          return t;
        }
      } catch (e) {
        return Promise.resolve(o(e));
      }
      if (!M(s)) {
        return Promise.resolve(o("URL scheme must be a HTTP(S) scheme"));
      }
      if (r.redirectCount === 20) {
        return Promise.resolve(o("redirect count exceeded"));
      }
      r.redirectCount += 1;
      if (r.mode === "cors" && (s.username || s.password) && !F(r, s)) {
        return Promise.resolve(o('cross origin not allowed for request mode "cors"'));
      }
      if (r.responseTainting === "cors" && (s.username || s.password)) {
        return Promise.resolve(o('URL cannot contain credentials for request mode "cors"'));
      }
      if (n.status !== 303 && r.body != null && r.body.source == null) {
        return Promise.resolve(o());
      }
      if (([301, 302].includes(n.status) && r.method === "POST") || (n.status === 303 && !fe.includes(r.method))) {
        r.method = "GET";
        r.body = null;
        for (const e of $) {
          r.headersList.delete(e);
        }
      }
      if (!F(y(r), s)) {
        r.headersList.delete("authorization");
        r.headersList.delete("proxy-authorization", true);
        r.headersList.delete("cookie");
        r.headersList.delete("host");
      }
      if (r.body != null) {
        Y(r.body.source != null);
        r.body = K(r.body.source)[0];
      }
      const i = e.timingInfo;
      i.redirectEndTime = i.postRedirectStartTime = _(e.crossOriginIsolatedCapability);
      if (i.redirectStartTime === 0) {
        i.redirectStartTime = i.startTime;
      }
      r.urlList.push(s);
      C(r, n);
      return mainFetch(e, true);
    }
    async function httpNetworkOrCacheFetch(e, t = false, r = false) {
      const n = e.request;
      let i = null;
      let a = null;
      let A = null;
      const c = null;
      const l = false;
      if (n.window === "no-window" && n.redirect === "error") {
        i = e;
        a = n;
      } else {
        a = u(n);
        i = { ...e };
        i.request = a;
      }
      const p = n.credentials === "include" || (n.credentials === "same-origin" && n.responseTainting === "basic");
      const d = a.body ? a.body.length : null;
      let g = null;
      if (a.body == null && ["POST", "PUT"].includes(a.method)) {
        g = "0";
      }
      if (d != null) {
        g = L(`${d}`);
      }
      if (g != null) {
        a.headersList.append("content-length", g);
      }
      if (d != null && a.keepalive) {
      }
      if (a.referrer instanceof URL) {
        a.headersList.append("referer", L(a.referrer.href));
      }
      E(a);
      B(a);
      if (!a.headersList.contains("user-agent")) {
        a.headersList.append("user-agent", typeof esbuildDetection === "undefined" ? "undici" : "node");
      }
      if (
        a.cache === "default" &&
        (a.headersList.contains("if-modified-since") ||
          a.headersList.contains("if-none-match") ||
          a.headersList.contains("if-unmodified-since") ||
          a.headersList.contains("if-match") ||
          a.headersList.contains("if-range"))
      ) {
        a.cache = "no-store";
      }
      if (a.cache === "no-cache" && !a.preventNoCacheCacheControlHeaderModification && !a.headersList.contains("cache-control")) {
        a.headersList.append("cache-control", "max-age=0");
      }
      if (a.cache === "no-store" || a.cache === "reload") {
        if (!a.headersList.contains("pragma")) {
          a.headersList.append("pragma", "no-cache");
        }
        if (!a.headersList.contains("cache-control")) {
          a.headersList.append("cache-control", "no-cache");
        }
      }
      if (a.headersList.contains("range")) {
        a.headersList.append("accept-encoding", "identity");
      }
      if (!a.headersList.contains("accept-encoding")) {
        if (G(y(a))) {
          a.headersList.append("accept-encoding", "br, gzip, deflate");
        } else {
          a.headersList.append("accept-encoding", "gzip, deflate");
        }
      }
      a.headersList.delete("host");
      if (p) {
      }
      if (c == null) {
        a.cache = "no-store";
      }
      if (a.mode !== "no-store" && a.mode !== "reload") {
      }
      if (A == null) {
        if (a.mode === "only-if-cached") {
          return o("only if cached");
        }
        const e = await httpNetworkFetch(i, p, r);
        if (!W.has(a.method) && e.status >= 200 && e.status <= 399) {
        }
        if (l && e.status === 304) {
        }
        if (A == null) {
          A = e;
        }
      }
      A.urlList = [...a.urlList];
      if (a.headersList.contains("range")) {
        A.rangeRequested = true;
      }
      A.requestIncludesCredentials = p;
      if (A.status === 407) {
        if (n.window === "no-window") {
          return o();
        }
        if (D(e)) {
          return s(e);
        }
        return o("proxy authentication required");
      }
      if (A.status === 421 && !r && (n.body == null || n.body.source != null)) {
        if (D(e)) {
          return s(e);
        }
        e.controller.connection.destroy();
        A = await httpNetworkOrCacheFetch(e, t, true);
      }
      if (t) {
      }
      return A;
    }
    async function httpNetworkFetch(e, t = false, n = false) {
      Y(!e.controller.connection || e.controller.connection.destroyed);
      e.controller.connection = {
        abort: null,
        destroyed: false,
        destroy(e) {
          if (!this.destroyed) {
            this.destroyed = true;
            this.abort?.(e ?? new Z("The operation was aborted.", "AbortError"));
          }
        },
      };
      const i = e.request;
      let c = null;
      const u = e.timingInfo;
      const p = null;
      if (p == null) {
        i.cache = "no-store";
      }
      const d = n ? "yes" : "no";
      if (i.mode === "websocket") {
      } else {
      }
      let g = null;
      if (i.body == null && e.processRequestEndOfBody) {
        queueMicrotask(() => e.processRequestEndOfBody());
      } else if (i.body != null) {
        const processBodyChunk = async function* (t) {
          if (D(e)) {
            return;
          }
          yield t;
          e.processRequestBodyChunkLength?.(t.byteLength);
        };
        const processEndOfBody = () => {
          if (D(e)) {
            return;
          }
          if (e.processRequestEndOfBody) {
            e.processRequestEndOfBody();
          }
        };
        const processBodyError = (t) => {
          if (D(e)) {
            return;
          }
          if (t.name === "AbortError") {
            e.controller.abort();
          } else {
            e.controller.terminate(t);
          }
        };
        g = (async function* () {
          try {
            for await (const e of i.body.stream) {
              yield* processBodyChunk(e);
            }
            processEndOfBody();
          } catch (e) {
            processBodyError(e);
          }
        })();
      }
      try {
        const { body: t, status: r, statusText: n, headersList: o, socket: s } = await dispatch({ body: g });
        if (s) {
          c = a({ status: r, statusText: n, headersList: o, socket: s });
        } else {
          const s = t[Symbol.asyncIterator]();
          e.controller.next = () => s.next();
          c = a({ status: r, statusText: n, headersList: o });
        }
      } catch (t) {
        if (t.name === "AbortError") {
          e.controller.connection.destroy();
          return s(e, t);
        }
        return o(t);
      }
      const pullAlgorithm = () => {
        e.controller.resume();
      };
      const cancelAlgorithm = (t) => {
        e.controller.abort(t);
      };
      if (!me) {
        me = r(63774).ReadableStream;
      }
      const m = new me(
        {
          async start(t) {
            e.controller.controller = t;
          },
          async pull(e) {
            await pullAlgorithm(e);
          },
          async cancel(e) {
            await cancelAlgorithm(e);
          },
        },
        {
          highWaterMark: 0,
          size() {
            return 1;
          },
        }
      );
      c.body = { stream: m };
      e.controller.on("terminated", onAborted);
      e.controller.resume = async () => {
        while (true) {
          let t;
          let r;
          try {
            const { done: r, value: n } = await e.controller.next();
            if (k(e)) {
              break;
            }
            t = r ? undefined : n;
          } catch (n) {
            if (e.controller.ended && !u.encodedBodySize) {
              t = undefined;
            } else {
              t = n;
              r = true;
            }
          }
          if (t === undefined) {
            P(e.controller.controller);
            finalizeResponse(e, c);
            return;
          }
          u.decodedBodySize += t?.byteLength ?? 0;
          if (r) {
            e.controller.terminate(t);
            return;
          }
          e.controller.controller.enqueue(new Uint8Array(t));
          if (oe(m)) {
            e.controller.terminate();
            return;
          }
          if (!e.controller.controller.desiredSize) {
            return;
          }
        }
      };
      function onAborted(t) {
        if (k(e)) {
          c.aborted = true;
          if (se(m)) {
            e.controller.controller.error(e.controller.serializedAbortReason);
          }
        } else {
          if (se(m)) {
            e.controller.controller.error(new TypeError("terminated", { cause: S(t) ? t : undefined }));
          }
        }
        e.controller.connection.destroy();
      }
      return c;
      async function dispatch({ body: t }) {
        const r = y(i);
        const n = e.controller.dispatcher;
        return new Promise((o, s) =>
          n.dispatch(
            {
              path: r.pathname + r.search,
              origin: r.origin,
              method: i.method,
              body: e.controller.dispatcher.isMockActive ? i.body && (i.body.source || i.body.stream) : t,
              headers: i.headersList.entries,
              maxRedirections: 0,
              upgrade: i.mode === "websocket" ? "websocket" : undefined,
            },
            {
              body: null,
              abort: null,
              onConnect(t) {
                const { connection: r } = e.controller;
                if (r.destroyed) {
                  t(new Z("The operation was aborted.", "AbortError"));
                } else {
                  e.controller.on("terminated", t);
                  this.abort = r.abort = t;
                }
              },
              onHeaders(e, t, r, n) {
                if (e < 200) {
                  return;
                }
                let s = [];
                let a = "";
                const c = new A();
                if (Array.isArray(t)) {
                  for (let e = 0; e < t.length; e += 2) {
                    const r = t[e + 0].toString("latin1");
                    const n = t[e + 1].toString("latin1");
                    if (r.toLowerCase() === "content-encoding") {
                      s = n
                        .toLowerCase()
                        .split(",")
                        .map((e) => e.trim());
                    } else if (r.toLowerCase() === "location") {
                      a = n;
                    }
                    c[X].append(r, n);
                  }
                } else {
                  const e = Object.keys(t);
                  for (const r of e) {
                    const e = t[r];
                    if (r.toLowerCase() === "content-encoding") {
                      s = e
                        .toLowerCase()
                        .split(",")
                        .map((e) => e.trim())
                        .reverse();
                    } else if (r.toLowerCase() === "location") {
                      a = e;
                    }
                    c[X].append(r, e);
                  }
                }
                this.body = new te({ read: r });
                const u = [];
                const p = i.redirect === "follow" && a && q.has(e);
                if (i.method !== "HEAD" && i.method !== "CONNECT" && !J.includes(e) && !p) {
                  for (const e of s) {
                    if (e === "x-gzip" || e === "gzip") {
                      u.push(l.createGunzip({ flush: l.constants.Z_SYNC_FLUSH, finishFlush: l.constants.Z_SYNC_FLUSH }));
                    } else if (e === "deflate") {
                      u.push(l.createInflate());
                    } else if (e === "br") {
                      u.push(l.createBrotliDecompress());
                    } else {
                      u.length = 0;
                      break;
                    }
                  }
                }
                o({ status: e, statusText: n, headersList: c[X], body: u.length ? re(this.body, ...u, () => {}) : this.body.on("error", () => {}) });
                return true;
              },
              onData(t) {
                if (e.controller.dump) {
                  return;
                }
                const r = t;
                u.encodedBodySize += r.byteLength;
                return this.body.push(r);
              },
              onComplete() {
                if (this.abort) {
                  e.controller.off("terminated", this.abort);
                }
                e.controller.ended = true;
                this.body.push(null);
              },
              onError(t) {
                if (this.abort) {
                  e.controller.off("terminated", this.abort);
                }
                this.body?.destroy(t);
                e.controller.terminate(t);
                s(t);
              },
              onUpgrade(e, t, r) {
                if (e !== 101) {
                  return;
                }
                const n = new A();
                for (let e = 0; e < t.length; e += 2) {
                  const r = t[e + 0].toString("latin1");
                  const o = t[e + 1].toString("latin1");
                  n[X].append(r, o);
                }
                o({ status: e, statusText: de[e], headersList: n[X], socket: r });
                return true;
              },
            }
          )
        );
      }
    }
    e.exports = { fetch: fetch, Fetch: Fetch, fetching: fetching, finalizeAndReportTiming: finalizeAndReportTiming };
  },
  25194: (e, t, r) => {
    const { extractBody: n, mixinBody: o, cloneBody: s } = r(8923);
    const { Headers: i, fill: a, HeadersList: A } = r(26349);
    const { FinalizationRegistry: c } = r(13194)();
    const u = r(3440);
    const { isValidHTTPToken: l, sameOrigin: p, normalizeMethod: d, makePolicyContainer: g, normalizeMethodRecord: m } = r(15523);
    const {
      forbiddenMethodsSet: h,
      corsSafeListedMethodsSet: E,
      referrerPolicy: I,
      requestRedirect: y,
      requestMode: C,
      requestCredentials: b,
      requestCache: Q,
      requestDuplex: B,
    } = r(87326);
    const { kEnumerableProperty: T } = u;
    const { kHeaders: v, kSignal: w, kState: _, kGuard: R, kRealm: O } = r(89710);
    const { webidl: F } = r(74222);
    const { getGlobalOrigin: D } = r(75628);
    const { URLSerializer: k } = r(94322);
    const { kHeadersList: S, kConstruct: N } = r(36443);
    const P = r(42613);
    const { getMaxListeners: L, setMaxListeners: U, getEventListeners: M, defaultMaxListeners: G } = r(24434);
    let x = globalThis.TransformStream;
    const j = Symbol("abortController");
    const V = new c(({ signal: e, abort: t }) => {
      e.removeEventListener("abort", t);
    });
    class Request {
      constructor(e, t = {}) {
        if (e === N) {
          return;
        }
        F.argumentLengthCheck(arguments, 1, { header: "Request constructor" });
        e = F.converters.RequestInfo(e);
        t = F.converters.RequestInit(t);
        this[O] = {
          settingsObject: {
            baseUrl: D(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: g(),
          },
        };
        let o = null;
        let s = null;
        const c = this[O].settingsObject.baseUrl;
        let I = null;
        if (typeof e === "string") {
          let t;
          try {
            t = new URL(e, c);
          } catch (t) {
            throw new TypeError("Failed to parse URL from " + e, { cause: t });
          }
          if (t.username || t.password) {
            throw new TypeError("Request cannot be constructed from a URL that includes credentials: " + e);
          }
          o = makeRequest({ urlList: [t] });
          s = "cors";
        } else {
          P(e instanceof Request);
          o = e[_];
          I = e[w];
        }
        const y = this[O].settingsObject.origin;
        let C = "client";
        if (o.window?.constructor?.name === "EnvironmentSettingsObject" && p(o.window, y)) {
          C = o.window;
        }
        if (t.window != null) {
          throw new TypeError(`'window' option '${C}' must be null`);
        }
        if ("window" in t) {
          C = "no-window";
        }
        o = makeRequest({
          method: o.method,
          headersList: o.headersList,
          unsafeRequest: o.unsafeRequest,
          client: this[O].settingsObject,
          window: C,
          priority: o.priority,
          origin: o.origin,
          referrer: o.referrer,
          referrerPolicy: o.referrerPolicy,
          mode: o.mode,
          credentials: o.credentials,
          cache: o.cache,
          redirect: o.redirect,
          integrity: o.integrity,
          keepalive: o.keepalive,
          reloadNavigation: o.reloadNavigation,
          historyNavigation: o.historyNavigation,
          urlList: [...o.urlList],
        });
        const b = Object.keys(t).length !== 0;
        if (b) {
          if (o.mode === "navigate") {
            o.mode = "same-origin";
          }
          o.reloadNavigation = false;
          o.historyNavigation = false;
          o.origin = "client";
          o.referrer = "client";
          o.referrerPolicy = "";
          o.url = o.urlList[o.urlList.length - 1];
          o.urlList = [o.url];
        }
        if (t.referrer !== undefined) {
          const e = t.referrer;
          if (e === "") {
            o.referrer = "no-referrer";
          } else {
            let t;
            try {
              t = new URL(e, c);
            } catch (t) {
              throw new TypeError(`Referrer "${e}" is not a valid URL.`, { cause: t });
            }
            if ((t.protocol === "about:" && t.hostname === "client") || (y && !p(t, this[O].settingsObject.baseUrl))) {
              o.referrer = "client";
            } else {
              o.referrer = t;
            }
          }
        }
        if (t.referrerPolicy !== undefined) {
          o.referrerPolicy = t.referrerPolicy;
        }
        let Q;
        if (t.mode !== undefined) {
          Q = t.mode;
        } else {
          Q = s;
        }
        if (Q === "navigate") {
          throw F.errors.exception({ header: "Request constructor", message: "invalid request mode navigate." });
        }
        if (Q != null) {
          o.mode = Q;
        }
        if (t.credentials !== undefined) {
          o.credentials = t.credentials;
        }
        if (t.cache !== undefined) {
          o.cache = t.cache;
        }
        if (o.cache === "only-if-cached" && o.mode !== "same-origin") {
          throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
        }
        if (t.redirect !== undefined) {
          o.redirect = t.redirect;
        }
        if (t.integrity != null) {
          o.integrity = String(t.integrity);
        }
        if (t.keepalive !== undefined) {
          o.keepalive = Boolean(t.keepalive);
        }
        if (t.method !== undefined) {
          let e = t.method;
          if (!l(e)) {
            throw new TypeError(`'${e}' is not a valid HTTP method.`);
          }
          if (h.has(e.toUpperCase())) {
            throw new TypeError(`'${e}' HTTP method is unsupported.`);
          }
          e = m[e] ?? d(e);
          o.method = e;
        }
        if (t.signal !== undefined) {
          I = t.signal;
        }
        this[_] = o;
        const B = new AbortController();
        this[w] = B.signal;
        this[w][O] = this[O];
        if (I != null) {
          if (!I || typeof I.aborted !== "boolean" || typeof I.addEventListener !== "function") {
            throw new TypeError("Failed to construct 'Request': member signal is not of type AbortSignal.");
          }
          if (I.aborted) {
            B.abort(I.reason);
          } else {
            this[j] = B;
            const e = new WeakRef(B);
            const abort = function () {
              const t = e.deref();
              if (t !== undefined) {
                t.abort(this.reason);
              }
            };
            try {
              if (typeof L === "function" && L(I) === G) {
                U(100, I);
              } else if (M(I, "abort").length >= G) {
                U(100, I);
              }
            } catch {}
            u.addAbortListener(I, abort);
            V.register(B, { signal: I, abort: abort });
          }
        }
        this[v] = new i(N);
        this[v][S] = o.headersList;
        this[v][R] = "request";
        this[v][O] = this[O];
        if (Q === "no-cors") {
          if (!E.has(o.method)) {
            throw new TypeError(`'${o.method} is unsupported in no-cors mode.`);
          }
          this[v][R] = "request-no-cors";
        }
        if (b) {
          const e = this[v][S];
          const r = t.headers !== undefined ? t.headers : new A(e);
          e.clear();
          if (r instanceof A) {
            for (const [t, n] of r) {
              e.append(t, n);
            }
            e.cookies = r.cookies;
          } else {
            a(this[v], r);
          }
        }
        const T = e instanceof Request ? e[_].body : null;
        if ((t.body != null || T != null) && (o.method === "GET" || o.method === "HEAD")) {
          throw new TypeError("Request with GET/HEAD method cannot have body.");
        }
        let k = null;
        if (t.body != null) {
          const [e, r] = n(t.body, o.keepalive);
          k = e;
          if (r && !this[v][S].contains("content-type")) {
            this[v].append("content-type", r);
          }
        }
        const H = k ?? T;
        if (H != null && H.source == null) {
          if (k != null && t.duplex == null) {
            throw new TypeError("RequestInit: duplex option is required when sending a body.");
          }
          if (o.mode !== "same-origin" && o.mode !== "cors") {
            throw new TypeError('If request is made from ReadableStream, mode should be "same-origin" or "cors"');
          }
          o.useCORSPreflightFlag = true;
        }
        let Y = H;
        if (k == null && T != null) {
          if (u.isDisturbed(T.stream) || T.stream.locked) {
            throw new TypeError("Cannot construct a Request with a Request object that has already been used.");
          }
          if (!x) {
            x = r(63774).TransformStream;
          }
          const e = new x();
          T.stream.pipeThrough(e);
          Y = { source: T.source, length: T.length, stream: e.readable };
        }
        this[_].body = Y;
      }
      get method() {
        F.brandCheck(this, Request);
        return this[_].method;
      }
      get url() {
        F.brandCheck(this, Request);
        return k(this[_].url);
      }
      get headers() {
        F.brandCheck(this, Request);
        return this[v];
      }
      get destination() {
        F.brandCheck(this, Request);
        return this[_].destination;
      }
      get referrer() {
        F.brandCheck(this, Request);
        if (this[_].referrer === "no-referrer") {
          return "";
        }
        if (this[_].referrer === "client") {
          return "about:client";
        }
        return this[_].referrer.toString();
      }
      get referrerPolicy() {
        F.brandCheck(this, Request);
        return this[_].referrerPolicy;
      }
      get mode() {
        F.brandCheck(this, Request);
        return this[_].mode;
      }
      get credentials() {
        return this[_].credentials;
      }
      get cache() {
        F.brandCheck(this, Request);
        return this[_].cache;
      }
      get redirect() {
        F.brandCheck(this, Request);
        return this[_].redirect;
      }
      get integrity() {
        F.brandCheck(this, Request);
        return this[_].integrity;
      }
      get keepalive() {
        F.brandCheck(this, Request);
        return this[_].keepalive;
      }
      get isReloadNavigation() {
        F.brandCheck(this, Request);
        return this[_].reloadNavigation;
      }
      get isHistoryNavigation() {
        F.brandCheck(this, Request);
        return this[_].historyNavigation;
      }
      get signal() {
        F.brandCheck(this, Request);
        return this[w];
      }
      get body() {
        F.brandCheck(this, Request);
        return this[_].body ? this[_].body.stream : null;
      }
      get bodyUsed() {
        F.brandCheck(this, Request);
        return !!this[_].body && u.isDisturbed(this[_].body.stream);
      }
      get duplex() {
        F.brandCheck(this, Request);
        return "half";
      }
      clone() {
        F.brandCheck(this, Request);
        if (this.bodyUsed || this.body?.locked) {
          throw new TypeError("unusable");
        }
        const e = cloneRequest(this[_]);
        const t = new Request(N);
        t[_] = e;
        t[O] = this[O];
        t[v] = new i(N);
        t[v][S] = e.headersList;
        t[v][R] = this[v][R];
        t[v][O] = this[v][O];
        const r = new AbortController();
        if (this.signal.aborted) {
          r.abort(this.signal.reason);
        } else {
          u.addAbortListener(this.signal, () => {
            r.abort(this.signal.reason);
          });
        }
        t[w] = r.signal;
        return t;
      }
    }
    o(Request);
    function makeRequest(e) {
      const t = {
        method: "GET",
        localURLsOnly: false,
        unsafeRequest: false,
        body: null,
        client: null,
        reservedClient: null,
        replacesClientId: "",
        window: "client",
        keepalive: false,
        serviceWorkers: "all",
        initiator: "",
        destination: "",
        priority: null,
        origin: "client",
        policyContainer: "client",
        referrer: "client",
        referrerPolicy: "",
        mode: "no-cors",
        useCORSPreflightFlag: false,
        credentials: "same-origin",
        useCredentials: false,
        cache: "default",
        redirect: "follow",
        integrity: "",
        cryptoGraphicsNonceMetadata: "",
        parserMetadata: "",
        reloadNavigation: false,
        historyNavigation: false,
        userActivation: false,
        taintedOrigin: false,
        redirectCount: 0,
        responseTainting: "basic",
        preventNoCacheCacheControlHeaderModification: false,
        done: false,
        timingAllowFailed: false,
        ...e,
        headersList: e.headersList ? new A(e.headersList) : new A(),
      };
      t.url = t.urlList[0];
      return t;
    }
    function cloneRequest(e) {
      const t = makeRequest({ ...e, body: null });
      if (e.body != null) {
        t.body = s(e.body);
      }
      return t;
    }
    Object.defineProperties(Request.prototype, {
      method: T,
      url: T,
      headers: T,
      redirect: T,
      clone: T,
      signal: T,
      duplex: T,
      destination: T,
      body: T,
      bodyUsed: T,
      isHistoryNavigation: T,
      isReloadNavigation: T,
      keepalive: T,
      integrity: T,
      cache: T,
      credentials: T,
      attribute: T,
      referrerPolicy: T,
      referrer: T,
      mode: T,
      [Symbol.toStringTag]: { value: "Request", configurable: true },
    });
    F.converters.Request = F.interfaceConverter(Request);
    F.converters.RequestInfo = function (e) {
      if (typeof e === "string") {
        return F.converters.USVString(e);
      }
      if (e instanceof Request) {
        return F.converters.Request(e);
      }
      return F.converters.USVString(e);
    };
    F.converters.AbortSignal = F.interfaceConverter(AbortSignal);
    F.converters.RequestInit = F.dictionaryConverter([
      { key: "method", converter: F.converters.ByteString },
      { key: "headers", converter: F.converters.HeadersInit },
      { key: "body", converter: F.nullableConverter(F.converters.BodyInit) },
      { key: "referrer", converter: F.converters.USVString },
      { key: "referrerPolicy", converter: F.converters.DOMString, allowedValues: I },
      { key: "mode", converter: F.converters.DOMString, allowedValues: C },
      { key: "credentials", converter: F.converters.DOMString, allowedValues: b },
      { key: "cache", converter: F.converters.DOMString, allowedValues: Q },
      { key: "redirect", converter: F.converters.DOMString, allowedValues: y },
      { key: "integrity", converter: F.converters.DOMString },
      { key: "keepalive", converter: F.converters.boolean },
      { key: "signal", converter: F.nullableConverter((e) => F.converters.AbortSignal(e, { strict: false })) },
      { key: "window", converter: F.converters.any },
      { key: "duplex", converter: F.converters.DOMString, allowedValues: B },
    ]);
    e.exports = { Request: Request, makeRequest: makeRequest };
  },
  48676: (e, t, r) => {
    const { Headers: n, HeadersList: o, fill: s } = r(26349);
    const { extractBody: i, cloneBody: a, mixinBody: A } = r(8923);
    const c = r(3440);
    const { kEnumerableProperty: u } = c;
    const {
      isValidReasonPhrase: l,
      isCancelled: p,
      isAborted: d,
      isBlobLike: g,
      serializeJavascriptValueToJSONString: m,
      isErrorLike: h,
      isomorphicEncode: E,
    } = r(15523);
    const { redirectStatusSet: I, nullBodyStatus: y, DOMException: C } = r(87326);
    const { kState: b, kHeaders: Q, kGuard: B, kRealm: T } = r(89710);
    const { webidl: v } = r(74222);
    const { FormData: w } = r(43073);
    const { getGlobalOrigin: _ } = r(75628);
    const { URLSerializer: R } = r(94322);
    const { kHeadersList: O, kConstruct: F } = r(36443);
    const D = r(42613);
    const { types: k } = r(39023);
    const S = globalThis.ReadableStream || r(63774).ReadableStream;
    const N = new TextEncoder("utf-8");
    class Response {
      static error() {
        const e = { settingsObject: {} };
        const t = new Response();
        t[b] = makeNetworkError();
        t[T] = e;
        t[Q][O] = t[b].headersList;
        t[Q][B] = "immutable";
        t[Q][T] = e;
        return t;
      }
      static json(e, t = {}) {
        v.argumentLengthCheck(arguments, 1, { header: "Response.json" });
        if (t !== null) {
          t = v.converters.ResponseInit(t);
        }
        const r = N.encode(m(e));
        const n = i(r);
        const o = { settingsObject: {} };
        const s = new Response();
        s[T] = o;
        s[Q][B] = "response";
        s[Q][T] = o;
        initializeResponse(s, t, { body: n[0], type: "application/json" });
        return s;
      }
      static redirect(e, t = 302) {
        const r = { settingsObject: {} };
        v.argumentLengthCheck(arguments, 1, { header: "Response.redirect" });
        e = v.converters.USVString(e);
        t = v.converters["unsigned short"](t);
        let n;
        try {
          n = new URL(e, _());
        } catch (t) {
          throw Object.assign(new TypeError("Failed to parse URL from " + e), { cause: t });
        }
        if (!I.has(t)) {
          throw new RangeError("Invalid status code " + t);
        }
        const o = new Response();
        o[T] = r;
        o[Q][B] = "immutable";
        o[Q][T] = r;
        o[b].status = t;
        const s = E(R(n));
        o[b].headersList.append("location", s);
        return o;
      }
      constructor(e = null, t = {}) {
        if (e !== null) {
          e = v.converters.BodyInit(e);
        }
        t = v.converters.ResponseInit(t);
        this[T] = { settingsObject: {} };
        this[b] = makeResponse({});
        this[Q] = new n(F);
        this[Q][B] = "response";
        this[Q][O] = this[b].headersList;
        this[Q][T] = this[T];
        let r = null;
        if (e != null) {
          const [t, n] = i(e);
          r = { body: t, type: n };
        }
        initializeResponse(this, t, r);
      }
      get type() {
        v.brandCheck(this, Response);
        return this[b].type;
      }
      get url() {
        v.brandCheck(this, Response);
        const e = this[b].urlList;
        const t = e[e.length - 1] ?? null;
        if (t === null) {
          return "";
        }
        return R(t, true);
      }
      get redirected() {
        v.brandCheck(this, Response);
        return this[b].urlList.length > 1;
      }
      get status() {
        v.brandCheck(this, Response);
        return this[b].status;
      }
      get ok() {
        v.brandCheck(this, Response);
        return this[b].status >= 200 && this[b].status <= 299;
      }
      get statusText() {
        v.brandCheck(this, Response);
        return this[b].statusText;
      }
      get headers() {
        v.brandCheck(this, Response);
        return this[Q];
      }
      get body() {
        v.brandCheck(this, Response);
        return this[b].body ? this[b].body.stream : null;
      }
      get bodyUsed() {
        v.brandCheck(this, Response);
        return !!this[b].body && c.isDisturbed(this[b].body.stream);
      }
      clone() {
        v.brandCheck(this, Response);
        if (this.bodyUsed || (this.body && this.body.locked)) {
          throw v.errors.exception({ header: "Response.clone", message: "Body has already been consumed." });
        }
        const e = cloneResponse(this[b]);
        const t = new Response();
        t[b] = e;
        t[T] = this[T];
        t[Q][O] = e.headersList;
        t[Q][B] = this[Q][B];
        t[Q][T] = this[Q][T];
        return t;
      }
    }
    A(Response);
    Object.defineProperties(Response.prototype, {
      type: u,
      url: u,
      status: u,
      ok: u,
      redirected: u,
      statusText: u,
      headers: u,
      clone: u,
      body: u,
      bodyUsed: u,
      [Symbol.toStringTag]: { value: "Response", configurable: true },
    });
    Object.defineProperties(Response, { json: u, redirect: u, error: u });
    function cloneResponse(e) {
      if (e.internalResponse) {
        return filterResponse(cloneResponse(e.internalResponse), e.type);
      }
      const t = makeResponse({ ...e, body: null });
      if (e.body != null) {
        t.body = a(e.body);
      }
      return t;
    }
    function makeResponse(e) {
      return {
        aborted: false,
        rangeRequested: false,
        timingAllowPassed: false,
        requestIncludesCredentials: false,
        type: "default",
        status: 200,
        timingInfo: null,
        cacheState: "",
        statusText: "",
        ...e,
        headersList: e.headersList ? new o(e.headersList) : new o(),
        urlList: e.urlList ? [...e.urlList] : [],
      };
    }
    function makeNetworkError(e) {
      const t = h(e);
      return makeResponse({ type: "error", status: 0, error: t ? e : new Error(e ? String(e) : e), aborted: e && e.name === "AbortError" });
    }
    function makeFilteredResponse(e, t) {
      t = { internalResponse: e, ...t };
      return new Proxy(e, {
        get(e, r) {
          return r in t ? t[r] : e[r];
        },
        set(e, r, n) {
          D(!(r in t));
          e[r] = n;
          return true;
        },
      });
    }
    function filterResponse(e, t) {
      if (t === "basic") {
        return makeFilteredResponse(e, { type: "basic", headersList: e.headersList });
      } else if (t === "cors") {
        return makeFilteredResponse(e, { type: "cors", headersList: e.headersList });
      } else if (t === "opaque") {
        return makeFilteredResponse(e, { type: "opaque", urlList: Object.freeze([]), status: 0, statusText: "", body: null });
      } else if (t === "opaqueredirect") {
        return makeFilteredResponse(e, { type: "opaqueredirect", status: 0, statusText: "", headersList: [], body: null });
      } else {
        D(false);
      }
    }
    function makeAppropriateNetworkError(e, t = null) {
      D(p(e));
      return d(e)
        ? makeNetworkError(Object.assign(new C("The operation was aborted.", "AbortError"), { cause: t }))
        : makeNetworkError(Object.assign(new C("Request was cancelled."), { cause: t }));
    }
    function initializeResponse(e, t, r) {
      if (t.status !== null && (t.status < 200 || t.status > 599)) {
        throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
      }
      if ("statusText" in t && t.statusText != null) {
        if (!l(String(t.statusText))) {
          throw new TypeError("Invalid statusText");
        }
      }
      if ("status" in t && t.status != null) {
        e[b].status = t.status;
      }
      if ("statusText" in t && t.statusText != null) {
        e[b].statusText = t.statusText;
      }
      if ("headers" in t && t.headers != null) {
        s(e[Q], t.headers);
      }
      if (r) {
        if (y.includes(e.status)) {
          throw v.errors.exception({ header: "Response constructor", message: "Invalid response status code " + e.status });
        }
        e[b].body = r.body;
        if (r.type != null && !e[b].headersList.contains("Content-Type")) {
          e[b].headersList.append("content-type", r.type);
        }
      }
    }
    v.converters.ReadableStream = v.interfaceConverter(S);
    v.converters.FormData = v.interfaceConverter(w);
    v.converters.URLSearchParams = v.interfaceConverter(URLSearchParams);
    v.converters.XMLHttpRequestBodyInit = function (e) {
      if (typeof e === "string") {
        return v.converters.USVString(e);
      }
      if (g(e)) {
        return v.converters.Blob(e, { strict: false });
      }
      if (k.isArrayBuffer(e) || k.isTypedArray(e) || k.isDataView(e)) {
        return v.converters.BufferSource(e);
      }
      if (c.isFormDataLike(e)) {
        return v.converters.FormData(e, { strict: false });
      }
      if (e instanceof URLSearchParams) {
        return v.converters.URLSearchParams(e);
      }
      return v.converters.DOMString(e);
    };
    v.converters.BodyInit = function (e) {
      if (e instanceof S) {
        return v.converters.ReadableStream(e);
      }
      if (e?.[Symbol.asyncIterator]) {
        return e;
      }
      return v.converters.XMLHttpRequestBodyInit(e);
    };
    v.converters.ResponseInit = v.dictionaryConverter([
      { key: "status", converter: v.converters["unsigned short"], defaultValue: 200 },
      { key: "statusText", converter: v.converters.ByteString, defaultValue: "" },
      { key: "headers", converter: v.converters.HeadersInit },
    ]);
    e.exports = {
      makeNetworkError: makeNetworkError,
      makeResponse: makeResponse,
      makeAppropriateNetworkError: makeAppropriateNetworkError,
      filterResponse: filterResponse,
      Response: Response,
      cloneResponse: cloneResponse,
    };
  },
  89710: (e) => {
    e.exports = {
      kUrl: Symbol("url"),
      kHeaders: Symbol("headers"),
      kSignal: Symbol("signal"),
      kState: Symbol("state"),
      kGuard: Symbol("guard"),
      kRealm: Symbol("realm"),
    };
  },
  15523: (e, t, r) => {
    const { redirectStatusSet: n, referrerPolicySet: o, badPortsSet: s } = r(87326);
    const { getGlobalOrigin: i } = r(75628);
    const { performance: a } = r(82987);
    const { isBlobLike: A, toUSVString: c, ReadableStreamFrom: u } = r(3440);
    const l = r(42613);
    const { isUint8Array: p } = r(98253);
    let d = [];
    let g;
    try {
      g = r(76982);
      const e = ["sha256", "sha384", "sha512"];
      d = g.getHashes().filter((t) => e.includes(t));
    } catch {}
    function responseURL(e) {
      const t = e.urlList;
      const r = t.length;
      return r === 0 ? null : t[r - 1].toString();
    }
    function responseLocationURL(e, t) {
      if (!n.has(e.status)) {
        return null;
      }
      let r = e.headersList.get("location");
      if (r !== null && isValidHeaderValue(r)) {
        r = new URL(r, responseURL(e));
      }
      if (r && !r.hash) {
        r.hash = t;
      }
      return r;
    }
    function requestCurrentURL(e) {
      return e.urlList[e.urlList.length - 1];
    }
    function requestBadPort(e) {
      const t = requestCurrentURL(e);
      if (urlIsHttpHttpsScheme(t) && s.has(t.port)) {
        return "blocked";
      }
      return "allowed";
    }
    function isErrorLike(e) {
      return e instanceof Error || e?.constructor?.name === "Error" || e?.constructor?.name === "DOMException";
    }
    function isValidReasonPhrase(e) {
      for (let t = 0; t < e.length; ++t) {
        const r = e.charCodeAt(t);
        if (!(r === 9 || (r >= 32 && r <= 126) || (r >= 128 && r <= 255))) {
          return false;
        }
      }
      return true;
    }
    function isTokenCharCode(e) {
      switch (e) {
        case 34:
        case 40:
        case 41:
        case 44:
        case 47:
        case 58:
        case 59:
        case 60:
        case 61:
        case 62:
        case 63:
        case 64:
        case 91:
        case 92:
        case 93:
        case 123:
        case 125:
          return false;
        default:
          return e >= 33 && e <= 126;
      }
    }
    function isValidHTTPToken(e) {
      if (e.length === 0) {
        return false;
      }
      for (let t = 0; t < e.length; ++t) {
        if (!isTokenCharCode(e.charCodeAt(t))) {
          return false;
        }
      }
      return true;
    }
    function isValidHeaderName(e) {
      return isValidHTTPToken(e);
    }
    function isValidHeaderValue(e) {
      if (e.startsWith("\t") || e.startsWith(" ") || e.endsWith("\t") || e.endsWith(" ")) {
        return false;
      }
      if (e.includes("\0") || e.includes("\r") || e.includes("\n")) {
        return false;
      }
      return true;
    }
    function setRequestReferrerPolicyOnRedirect(e, t) {
      const { headersList: r } = t;
      const n = (r.get("referrer-policy") ?? "").split(",");
      let s = "";
      if (n.length > 0) {
        for (let e = n.length; e !== 0; e--) {
          const t = n[e - 1].trim();
          if (o.has(t)) {
            s = t;
            break;
          }
        }
      }
      if (s !== "") {
        e.referrerPolicy = s;
      }
    }
    function crossOriginResourcePolicyCheck() {
      return "allowed";
    }
    function corsCheck() {
      return "success";
    }
    function TAOCheck() {
      return "success";
    }
    function appendFetchMetadata(e) {
      let t = null;
      t = e.mode;
      e.headersList.set("sec-fetch-mode", t);
    }
    function appendRequestOriginHeader(e) {
      let t = e.origin;
      if (e.responseTainting === "cors" || e.mode === "websocket") {
        if (t) {
          e.headersList.append("origin", t);
        }
      } else if (e.method !== "GET" && e.method !== "HEAD") {
        switch (e.referrerPolicy) {
          case "no-referrer":
            t = null;
            break;
          case "no-referrer-when-downgrade":
          case "strict-origin":
          case "strict-origin-when-cross-origin":
            if (e.origin && urlHasHttpsScheme(e.origin) && !urlHasHttpsScheme(requestCurrentURL(e))) {
              t = null;
            }
            break;
          case "same-origin":
            if (!sameOrigin(e, requestCurrentURL(e))) {
              t = null;
            }
            break;
          default:
        }
        if (t) {
          e.headersList.append("origin", t);
        }
      }
    }
    function coarsenedSharedCurrentTime(e) {
      return a.now();
    }
    function createOpaqueTimingInfo(e) {
      return {
        startTime: e.startTime ?? 0,
        redirectStartTime: 0,
        redirectEndTime: 0,
        postRedirectStartTime: e.startTime ?? 0,
        finalServiceWorkerStartTime: 0,
        finalNetworkResponseStartTime: 0,
        finalNetworkRequestStartTime: 0,
        endTime: 0,
        encodedBodySize: 0,
        decodedBodySize: 0,
        finalConnectionTimingInfo: null,
      };
    }
    function makePolicyContainer() {
      return { referrerPolicy: "strict-origin-when-cross-origin" };
    }
    function clonePolicyContainer(e) {
      return { referrerPolicy: e.referrerPolicy };
    }
    function determineRequestsReferrer(e) {
      const t = e.referrerPolicy;
      l(t);
      let r = null;
      if (e.referrer === "client") {
        const e = i();
        if (!e || e.origin === "null") {
          return "no-referrer";
        }
        r = new URL(e);
      } else if (e.referrer instanceof URL) {
        r = e.referrer;
      }
      let n = stripURLForReferrer(r);
      const o = stripURLForReferrer(r, true);
      if (n.toString().length > 4096) {
        n = o;
      }
      const s = sameOrigin(e, n);
      const a = isURLPotentiallyTrustworthy(n) && !isURLPotentiallyTrustworthy(e.url);
      switch (t) {
        case "origin":
          return o != null ? o : stripURLForReferrer(r, true);
        case "unsafe-url":
          return n;
        case "same-origin":
          return s ? o : "no-referrer";
        case "origin-when-cross-origin":
          return s ? n : o;
        case "strict-origin-when-cross-origin": {
          const t = requestCurrentURL(e);
          if (sameOrigin(n, t)) {
            return n;
          }
          if (isURLPotentiallyTrustworthy(n) && !isURLPotentiallyTrustworthy(t)) {
            return "no-referrer";
          }
          return o;
        }
        case "strict-origin":
        case "no-referrer-when-downgrade":
        default:
          return a ? "no-referrer" : o;
      }
    }
    function stripURLForReferrer(e, t) {
      l(e instanceof URL);
      if (e.protocol === "file:" || e.protocol === "about:" || e.protocol === "blank:") {
        return "no-referrer";
      }
      e.username = "";
      e.password = "";
      e.hash = "";
      if (t) {
        e.pathname = "";
        e.search = "";
      }
      return e;
    }
    function isURLPotentiallyTrustworthy(e) {
      if (!(e instanceof URL)) {
        return false;
      }
      if (e.href === "about:blank" || e.href === "about:srcdoc") {
        return true;
      }
      if (e.protocol === "data:") return true;
      if (e.protocol === "file:") return true;
      return isOriginPotentiallyTrustworthy(e.origin);
      function isOriginPotentiallyTrustworthy(e) {
        if (e == null || e === "null") return false;
        const t = new URL(e);
        if (t.protocol === "https:" || t.protocol === "wss:") {
          return true;
        }
        if (
          /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(t.hostname) ||
          t.hostname === "localhost" ||
          t.hostname.includes("localhost.") ||
          t.hostname.endsWith(".localhost")
        ) {
          return true;
        }
        return false;
      }
    }
    function bytesMatch(e, t) {
      if (g === undefined) {
        return true;
      }
      const r = parseMetadata(t);
      if (r === "no metadata") {
        return true;
      }
      if (r.length === 0) {
        return true;
      }
      const n = getStrongestMetadata(r);
      const o = filterMetadataListByAlgorithm(r, n);
      for (const t of o) {
        const r = t.algo;
        const n = t.hash;
        let o = g.createHash(r).update(e).digest("base64");
        if (o[o.length - 1] === "=") {
          if (o[o.length - 2] === "=") {
            o = o.slice(0, -2);
          } else {
            o = o.slice(0, -1);
          }
        }
        if (compareBase64Mixed(o, n)) {
          return true;
        }
      }
      return false;
    }
    const m = /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
    function parseMetadata(e) {
      const t = [];
      let r = true;
      for (const n of e.split(" ")) {
        r = false;
        const e = m.exec(n);
        if (e === null || e.groups === undefined || e.groups.algo === undefined) {
          continue;
        }
        const o = e.groups.algo.toLowerCase();
        if (d.includes(o)) {
          t.push(e.groups);
        }
      }
      if (r === true) {
        return "no metadata";
      }
      return t;
    }
    function getStrongestMetadata(e) {
      let t = e[0].algo;
      if (t[3] === "5") {
        return t;
      }
      for (let r = 1; r < e.length; ++r) {
        const n = e[r];
        if (n.algo[3] === "5") {
          t = "sha512";
          break;
        } else if (t[3] === "3") {
          continue;
        } else if (n.algo[3] === "3") {
          t = "sha384";
        }
      }
      return t;
    }
    function filterMetadataListByAlgorithm(e, t) {
      if (e.length === 1) {
        return e;
      }
      let r = 0;
      for (let n = 0; n < e.length; ++n) {
        if (e[n].algo === t) {
          e[r++] = e[n];
        }
      }
      e.length = r;
      return e;
    }
    function compareBase64Mixed(e, t) {
      if (e.length !== t.length) {
        return false;
      }
      for (let r = 0; r < e.length; ++r) {
        if (e[r] !== t[r]) {
          if ((e[r] === "+" && t[r] === "-") || (e[r] === "/" && t[r] === "_")) {
            continue;
          }
          return false;
        }
      }
      return true;
    }
    function tryUpgradeRequestToAPotentiallyTrustworthyURL(e) {}
    function sameOrigin(e, t) {
      if (e.origin === t.origin && e.origin === "null") {
        return true;
      }
      if (e.protocol === t.protocol && e.hostname === t.hostname && e.port === t.port) {
        return true;
      }
      return false;
    }
    function createDeferredPromise() {
      let e;
      let t;
      const r = new Promise((r, n) => {
        e = r;
        t = n;
      });
      return { promise: r, resolve: e, reject: t };
    }
    function isAborted(e) {
      return e.controller.state === "aborted";
    }
    function isCancelled(e) {
      return e.controller.state === "aborted" || e.controller.state === "terminated";
    }
    const h = {
      delete: "DELETE",
      DELETE: "DELETE",
      get: "GET",
      GET: "GET",
      head: "HEAD",
      HEAD: "HEAD",
      options: "OPTIONS",
      OPTIONS: "OPTIONS",
      post: "POST",
      POST: "POST",
      put: "PUT",
      PUT: "PUT",
    };
    Object.setPrototypeOf(h, null);
    function normalizeMethod(e) {
      return h[e.toLowerCase()] ?? e;
    }
    function serializeJavascriptValueToJSONString(e) {
      const t = JSON.stringify(e);
      if (t === undefined) {
        throw new TypeError("Value is not JSON serializable");
      }
      l(typeof t === "string");
      return t;
    }
    const E = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
    function makeIterator(e, t, r) {
      const n = { index: 0, kind: r, target: e };
      const o = {
        next() {
          if (Object.getPrototypeOf(this) !== o) {
            throw new TypeError(`'next' called on an object that does not implement interface ${t} Iterator.`);
          }
          const { index: e, kind: r, target: s } = n;
          const i = s();
          const a = i.length;
          if (e >= a) {
            return { value: undefined, done: true };
          }
          const A = i[e];
          n.index = e + 1;
          return iteratorResult(A, r);
        },
        [Symbol.toStringTag]: `${t} Iterator`,
      };
      Object.setPrototypeOf(o, E);
      return Object.setPrototypeOf({}, o);
    }
    function iteratorResult(e, t) {
      let r;
      switch (t) {
        case "key": {
          r = e[0];
          break;
        }
        case "value": {
          r = e[1];
          break;
        }
        case "key+value": {
          r = e;
          break;
        }
      }
      return { value: r, done: false };
    }
    async function fullyReadBody(e, t, r) {
      const n = t;
      const o = r;
      let s;
      try {
        s = e.stream.getReader();
      } catch (e) {
        o(e);
        return;
      }
      try {
        const e = await readAllBytes(s);
        n(e);
      } catch (e) {
        o(e);
      }
    }
    let I = globalThis.ReadableStream;
    function isReadableStreamLike(e) {
      if (!I) {
        I = r(63774).ReadableStream;
      }
      return e instanceof I || (e[Symbol.toStringTag] === "ReadableStream" && typeof e.tee === "function");
    }
    const y = 65535;
    function isomorphicDecode(e) {
      if (e.length < y) {
        return String.fromCharCode(...e);
      }
      return e.reduce((e, t) => e + String.fromCharCode(t), "");
    }
    function readableStreamClose(e) {
      try {
        e.close();
      } catch (e) {
        if (!e.message.includes("Controller is already closed")) {
          throw e;
        }
      }
    }
    function isomorphicEncode(e) {
      for (let t = 0; t < e.length; t++) {
        l(e.charCodeAt(t) <= 255);
      }
      return e;
    }
    async function readAllBytes(e) {
      const t = [];
      let r = 0;
      while (true) {
        const { done: n, value: o } = await e.read();
        if (n) {
          return Buffer.concat(t, r);
        }
        if (!p(o)) {
          throw new TypeError("Received non-Uint8Array chunk");
        }
        t.push(o);
        r += o.length;
      }
    }
    function urlIsLocal(e) {
      l("protocol" in e);
      const t = e.protocol;
      return t === "about:" || t === "blob:" || t === "data:";
    }
    function urlHasHttpsScheme(e) {
      if (typeof e === "string") {
        return e.startsWith("https:");
      }
      return e.protocol === "https:";
    }
    function urlIsHttpHttpsScheme(e) {
      l("protocol" in e);
      const t = e.protocol;
      return t === "http:" || t === "https:";
    }
    const C = Object.hasOwn || ((e, t) => Object.prototype.hasOwnProperty.call(e, t));
    e.exports = {
      isAborted: isAborted,
      isCancelled: isCancelled,
      createDeferredPromise: createDeferredPromise,
      ReadableStreamFrom: u,
      toUSVString: c,
      tryUpgradeRequestToAPotentiallyTrustworthyURL: tryUpgradeRequestToAPotentiallyTrustworthyURL,
      coarsenedSharedCurrentTime: coarsenedSharedCurrentTime,
      determineRequestsReferrer: determineRequestsReferrer,
      makePolicyContainer: makePolicyContainer,
      clonePolicyContainer: clonePolicyContainer,
      appendFetchMetadata: appendFetchMetadata,
      appendRequestOriginHeader: appendRequestOriginHeader,
      TAOCheck: TAOCheck,
      corsCheck: corsCheck,
      crossOriginResourcePolicyCheck: crossOriginResourcePolicyCheck,
      createOpaqueTimingInfo: createOpaqueTimingInfo,
      setRequestReferrerPolicyOnRedirect: setRequestReferrerPolicyOnRedirect,
      isValidHTTPToken: isValidHTTPToken,
      requestBadPort: requestBadPort,
      requestCurrentURL: requestCurrentURL,
      responseURL: responseURL,
      responseLocationURL: responseLocationURL,
      isBlobLike: A,
      isURLPotentiallyTrustworthy: isURLPotentiallyTrustworthy,
      isValidReasonPhrase: isValidReasonPhrase,
      sameOrigin: sameOrigin,
      normalizeMethod: normalizeMethod,
      serializeJavascriptValueToJSONString: serializeJavascriptValueToJSONString,
      makeIterator: makeIterator,
      isValidHeaderName: isValidHeaderName,
      isValidHeaderValue: isValidHeaderValue,
      hasOwn: C,
      isErrorLike: isErrorLike,
      fullyReadBody: fullyReadBody,
      bytesMatch: bytesMatch,
      isReadableStreamLike: isReadableStreamLike,
      readableStreamClose: readableStreamClose,
      isomorphicEncode: isomorphicEncode,
      isomorphicDecode: isomorphicDecode,
      urlIsLocal: urlIsLocal,
      urlHasHttpsScheme: urlHasHttpsScheme,
      urlIsHttpHttpsScheme: urlIsHttpHttpsScheme,
      readAllBytes: readAllBytes,
      normalizeMethodRecord: h,
      parseMetadata: parseMetadata,
    };
  },
  74222: (e, t, r) => {
    const { types: n } = r(39023);
    const { hasOwn: o, toUSVString: s } = r(15523);
    const i = {};
    i.converters = {};
    i.util = {};
    i.errors = {};
    i.errors.exception = function (e) {
      return new TypeError(`${e.header}: ${e.message}`);
    };
    i.errors.conversionFailed = function (e) {
      const t = e.types.length === 1 ? "" : " one of";
      const r = `${e.argument} could not be converted to` + `${t}: ${e.types.join(", ")}.`;
      return i.errors.exception({ header: e.prefix, message: r });
    };
    i.errors.invalidArgument = function (e) {
      return i.errors.exception({ header: e.prefix, message: `"${e.value}" is an invalid ${e.type}.` });
    };
    i.brandCheck = function (e, t, r = undefined) {
      if (r?.strict !== false && !(e instanceof t)) {
        throw new TypeError("Illegal invocation");
      } else {
        return e?.[Symbol.toStringTag] === t.prototype[Symbol.toStringTag];
      }
    };
    i.argumentLengthCheck = function ({ length: e }, t, r) {
      if (e < t) {
        throw i.errors.exception({ message: `${t} argument${t !== 1 ? "s" : ""} required, ` + `but${e ? " only" : ""} ${e} found.`, ...r });
      }
    };
    i.illegalConstructor = function () {
      throw i.errors.exception({ header: "TypeError", message: "Illegal constructor" });
    };
    i.util.Type = function (e) {
      switch (typeof e) {
        case "undefined":
          return "Undefined";
        case "boolean":
          return "Boolean";
        case "string":
          return "String";
        case "symbol":
          return "Symbol";
        case "number":
          return "Number";
        case "bigint":
          return "BigInt";
        case "function":
        case "object": {
          if (e === null) {
            return "Null";
          }
          return "Object";
        }
      }
    };
    i.util.ConvertToInt = function (e, t, r, n = {}) {
      let o;
      let s;
      if (t === 64) {
        o = Math.pow(2, 53) - 1;
        if (r === "unsigned") {
          s = 0;
        } else {
          s = Math.pow(-2, 53) + 1;
        }
      } else if (r === "unsigned") {
        s = 0;
        o = Math.pow(2, t) - 1;
      } else {
        s = Math.pow(-2, t) - 1;
        o = Math.pow(2, t - 1) - 1;
      }
      let a = Number(e);
      if (a === 0) {
        a = 0;
      }
      if (n.enforceRange === true) {
        if (Number.isNaN(a) || a === Number.POSITIVE_INFINITY || a === Number.NEGATIVE_INFINITY) {
          throw i.errors.exception({ header: "Integer conversion", message: `Could not convert ${e} to an integer.` });
        }
        a = i.util.IntegerPart(a);
        if (a < s || a > o) {
          throw i.errors.exception({ header: "Integer conversion", message: `Value must be between ${s}-${o}, got ${a}.` });
        }
        return a;
      }
      if (!Number.isNaN(a) && n.clamp === true) {
        a = Math.min(Math.max(a, s), o);
        if (Math.floor(a) % 2 === 0) {
          a = Math.floor(a);
        } else {
          a = Math.ceil(a);
        }
        return a;
      }
      if (Number.isNaN(a) || (a === 0 && Object.is(0, a)) || a === Number.POSITIVE_INFINITY || a === Number.NEGATIVE_INFINITY) {
        return 0;
      }
      a = i.util.IntegerPart(a);
      a = a % Math.pow(2, t);
      if (r === "signed" && a >= Math.pow(2, t) - 1) {
        return a - Math.pow(2, t);
      }
      return a;
    };
    i.util.IntegerPart = function (e) {
      const t = Math.floor(Math.abs(e));
      if (e < 0) {
        return -1 * t;
      }
      return t;
    };
    i.sequenceConverter = function (e) {
      return (t) => {
        if (i.util.Type(t) !== "Object") {
          throw i.errors.exception({ header: "Sequence", message: `Value of type ${i.util.Type(t)} is not an Object.` });
        }
        const r = t?.[Symbol.iterator]?.();
        const n = [];
        if (r === undefined || typeof r.next !== "function") {
          throw i.errors.exception({ header: "Sequence", message: "Object is not an iterator." });
        }
        while (true) {
          const { done: t, value: o } = r.next();
          if (t) {
            break;
          }
          n.push(e(o));
        }
        return n;
      };
    };
    i.recordConverter = function (e, t) {
      return (r) => {
        if (i.util.Type(r) !== "Object") {
          throw i.errors.exception({ header: "Record", message: `Value of type ${i.util.Type(r)} is not an Object.` });
        }
        const o = {};
        if (!n.isProxy(r)) {
          const n = Object.keys(r);
          for (const s of n) {
            const n = e(s);
            const i = t(r[s]);
            o[n] = i;
          }
          return o;
        }
        const s = Reflect.ownKeys(r);
        for (const n of s) {
          const s = Reflect.getOwnPropertyDescriptor(r, n);
          if (s?.enumerable) {
            const s = e(n);
            const i = t(r[n]);
            o[s] = i;
          }
        }
        return o;
      };
    };
    i.interfaceConverter = function (e) {
      return (t, r = {}) => {
        if (r.strict !== false && !(t instanceof e)) {
          throw i.errors.exception({ header: e.name, message: `Expected ${t} to be an instance of ${e.name}.` });
        }
        return t;
      };
    };
    i.dictionaryConverter = function (e) {
      return (t) => {
        const r = i.util.Type(t);
        const n = {};
        if (r === "Null" || r === "Undefined") {
          return n;
        } else if (r !== "Object") {
          throw i.errors.exception({ header: "Dictionary", message: `Expected ${t} to be one of: Null, Undefined, Object.` });
        }
        for (const r of e) {
          const { key: e, defaultValue: s, required: a, converter: A } = r;
          if (a === true) {
            if (!o(t, e)) {
              throw i.errors.exception({ header: "Dictionary", message: `Missing required key "${e}".` });
            }
          }
          let c = t[e];
          const u = o(r, "defaultValue");
          if (u && c !== null) {
            c = c ?? s;
          }
          if (a || u || c !== undefined) {
            c = A(c);
            if (r.allowedValues && !r.allowedValues.includes(c)) {
              throw i.errors.exception({ header: "Dictionary", message: `${c} is not an accepted type. Expected one of ${r.allowedValues.join(", ")}.` });
            }
            n[e] = c;
          }
        }
        return n;
      };
    };
    i.nullableConverter = function (e) {
      return (t) => {
        if (t === null) {
          return t;
        }
        return e(t);
      };
    };
    i.converters.DOMString = function (e, t = {}) {
      if (e === null && t.legacyNullToEmptyString) {
        return "";
      }
      if (typeof e === "symbol") {
        throw new TypeError("Could not convert argument of type symbol to string.");
      }
      return String(e);
    };
    i.converters.ByteString = function (e) {
      const t = i.converters.DOMString(e);
      for (let e = 0; e < t.length; e++) {
        if (t.charCodeAt(e) > 255) {
          throw new TypeError(
            "Cannot convert argument to a ByteString because the character at " + `index ${e} has a value of ${t.charCodeAt(e)} which is greater than 255.`
          );
        }
      }
      return t;
    };
    i.converters.USVString = s;
    i.converters.boolean = function (e) {
      const t = Boolean(e);
      return t;
    };
    i.converters.any = function (e) {
      return e;
    };
    i.converters["long long"] = function (e) {
      const t = i.util.ConvertToInt(e, 64, "signed");
      return t;
    };
    i.converters["unsigned long long"] = function (e) {
      const t = i.util.ConvertToInt(e, 64, "unsigned");
      return t;
    };
    i.converters["unsigned long"] = function (e) {
      const t = i.util.ConvertToInt(e, 32, "unsigned");
      return t;
    };
    i.converters["unsigned short"] = function (e, t) {
      const r = i.util.ConvertToInt(e, 16, "unsigned", t);
      return r;
    };
    i.converters.ArrayBuffer = function (e, t = {}) {
      if (i.util.Type(e) !== "Object" || !n.isAnyArrayBuffer(e)) {
        throw i.errors.conversionFailed({ prefix: `${e}`, argument: `${e}`, types: ["ArrayBuffer"] });
      }
      if (t.allowShared === false && n.isSharedArrayBuffer(e)) {
        throw i.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
      }
      return e;
    };
    i.converters.TypedArray = function (e, t, r = {}) {
      if (i.util.Type(e) !== "Object" || !n.isTypedArray(e) || e.constructor.name !== t.name) {
        throw i.errors.conversionFailed({ prefix: `${t.name}`, argument: `${e}`, types: [t.name] });
      }
      if (r.allowShared === false && n.isSharedArrayBuffer(e.buffer)) {
        throw i.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
      }
      return e;
    };
    i.converters.DataView = function (e, t = {}) {
      if (i.util.Type(e) !== "Object" || !n.isDataView(e)) {
        throw i.errors.exception({ header: "DataView", message: "Object is not a DataView." });
      }
      if (t.allowShared === false && n.isSharedArrayBuffer(e.buffer)) {
        throw i.errors.exception({ header: "ArrayBuffer", message: "SharedArrayBuffer is not allowed." });
      }
      return e;
    };
    i.converters.BufferSource = function (e, t = {}) {
      if (n.isAnyArrayBuffer(e)) {
        return i.converters.ArrayBuffer(e, t);
      }
      if (n.isTypedArray(e)) {
        return i.converters.TypedArray(e, e.constructor);
      }
      if (n.isDataView(e)) {
        return i.converters.DataView(e, t);
      }
      throw new TypeError(`Could not convert ${e} to a BufferSource.`);
    };
    i.converters["sequence<ByteString>"] = i.sequenceConverter(i.converters.ByteString);
    i.converters["sequence<sequence<ByteString>>"] = i.sequenceConverter(i.converters["sequence<ByteString>"]);
    i.converters["record<ByteString, ByteString>"] = i.recordConverter(i.converters.ByteString, i.converters.ByteString);
    e.exports = { webidl: i };
  },
  40396: (e) => {
    function getEncoding(e) {
      if (!e) {
        return "failure";
      }
      switch (e.trim().toLowerCase()) {
        case "unicode-1-1-utf-8":
        case "unicode11utf8":
        case "unicode20utf8":
        case "utf-8":
        case "utf8":
        case "x-unicode20utf8":
          return "UTF-8";
        case "866":
        case "cp866":
        case "csibm866":
        case "ibm866":
          return "IBM866";
        case "csisolatin2":
        case "iso-8859-2":
        case "iso-ir-101":
        case "iso8859-2":
        case "iso88592":
        case "iso_8859-2":
        case "iso_8859-2:1987":
        case "l2":
        case "latin2":
          return "ISO-8859-2";
        case "csisolatin3":
        case "iso-8859-3":
        case "iso-ir-109":
        case "iso8859-3":
        case "iso88593":
        case "iso_8859-3":
        case "iso_8859-3:1988":
        case "l3":
        case "latin3":
          return "ISO-8859-3";
        case "csisolatin4":
        case "iso-8859-4":
        case "iso-ir-110":
        case "iso8859-4":
        case "iso88594":
        case "iso_8859-4":
        case "iso_8859-4:1988":
        case "l4":
        case "latin4":
          return "ISO-8859-4";
        case "csisolatincyrillic":
        case "cyrillic":
        case "iso-8859-5":
        case "iso-ir-144":
        case "iso8859-5":
        case "iso88595":
        case "iso_8859-5":
        case "iso_8859-5:1988":
          return "ISO-8859-5";
        case "arabic":
        case "asmo-708":
        case "csiso88596e":
        case "csiso88596i":
        case "csisolatinarabic":
        case "ecma-114":
        case "iso-8859-6":
        case "iso-8859-6-e":
        case "iso-8859-6-i":
        case "iso-ir-127":
        case "iso8859-6":
        case "iso88596":
        case "iso_8859-6":
        case "iso_8859-6:1987":
          return "ISO-8859-6";
        case "csisolatingreek":
        case "ecma-118":
        case "elot_928":
        case "greek":
        case "greek8":
        case "iso-8859-7":
        case "iso-ir-126":
        case "iso8859-7":
        case "iso88597":
        case "iso_8859-7":
        case "iso_8859-7:1987":
        case "sun_eu_greek":
          return "ISO-8859-7";
        case "csiso88598e":
        case "csisolatinhebrew":
        case "hebrew":
        case "iso-8859-8":
        case "iso-8859-8-e":
        case "iso-ir-138":
        case "iso8859-8":
        case "iso88598":
        case "iso_8859-8":
        case "iso_8859-8:1988":
        case "visual":
          return "ISO-8859-8";
        case "csiso88598i":
        case "iso-8859-8-i":
        case "logical":
          return "ISO-8859-8-I";
        case "csisolatin6":
        case "iso-8859-10":
        case "iso-ir-157":
        case "iso8859-10":
        case "iso885910":
        case "l6":
        case "latin6":
          return "ISO-8859-10";
        case "iso-8859-13":
        case "iso8859-13":
        case "iso885913":
          return "ISO-8859-13";
        case "iso-8859-14":
        case "iso8859-14":
        case "iso885914":
          return "ISO-8859-14";
        case "csisolatin9":
        case "iso-8859-15":
        case "iso8859-15":
        case "iso885915":
        case "iso_8859-15":
        case "l9":
          return "ISO-8859-15";
        case "iso-8859-16":
          return "ISO-8859-16";
        case "cskoi8r":
        case "koi":
        case "koi8":
        case "koi8-r":
        case "koi8_r":
          return "KOI8-R";
        case "koi8-ru":
        case "koi8-u":
          return "KOI8-U";
        case "csmacintosh":
        case "mac":
        case "macintosh":
        case "x-mac-roman":
          return "macintosh";
        case "iso-8859-11":
        case "iso8859-11":
        case "iso885911":
        case "tis-620":
        case "windows-874":
          return "windows-874";
        case "cp1250":
        case "windows-1250":
        case "x-cp1250":
          return "windows-1250";
        case "cp1251":
        case "windows-1251":
        case "x-cp1251":
          return "windows-1251";
        case "ansi_x3.4-1968":
        case "ascii":
        case "cp1252":
        case "cp819":
        case "csisolatin1":
        case "ibm819":
        case "iso-8859-1":
        case "iso-ir-100":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "iso_8859-1:1987":
        case "l1":
        case "latin1":
        case "us-ascii":
        case "windows-1252":
        case "x-cp1252":
          return "windows-1252";
        case "cp1253":
        case "windows-1253":
        case "x-cp1253":
          return "windows-1253";
        case "cp1254":
        case "csisolatin5":
        case "iso-8859-9":
        case "iso-ir-148":
        case "iso8859-9":
        case "iso88599":
        case "iso_8859-9":
        case "iso_8859-9:1989":
        case "l5":
        case "latin5":
        case "windows-1254":
        case "x-cp1254":
          return "windows-1254";
        case "cp1255":
        case "windows-1255":
        case "x-cp1255":
          return "windows-1255";
        case "cp1256":
        case "windows-1256":
        case "x-cp1256":
          return "windows-1256";
        case "cp1257":
        case "windows-1257":
        case "x-cp1257":
          return "windows-1257";
        case "cp1258":
        case "windows-1258":
        case "x-cp1258":
          return "windows-1258";
        case "x-mac-cyrillic":
        case "x-mac-ukrainian":
          return "x-mac-cyrillic";
        case "chinese":
        case "csgb2312":
        case "csiso58gb231280":
        case "gb2312":
        case "gb_2312":
        case "gb_2312-80":
        case "gbk":
        case "iso-ir-58":
        case "x-gbk":
          return "GBK";
        case "gb18030":
          return "gb18030";
        case "big5":
        case "big5-hkscs":
        case "cn-big5":
        case "csbig5":
        case "x-x-big5":
          return "Big5";
        case "cseucpkdfmtjapanese":
        case "euc-jp":
        case "x-euc-jp":
          return "EUC-JP";
        case "csiso2022jp":
        case "iso-2022-jp":
          return "ISO-2022-JP";
        case "csshiftjis":
        case "ms932":
        case "ms_kanji":
        case "shift-jis":
        case "shift_jis":
        case "sjis":
        case "windows-31j":
        case "x-sjis":
          return "Shift_JIS";
        case "cseuckr":
        case "csksc56011987":
        case "euc-kr":
        case "iso-ir-149":
        case "korean":
        case "ks_c_5601-1987":
        case "ks_c_5601-1989":
        case "ksc5601":
        case "ksc_5601":
        case "windows-949":
          return "EUC-KR";
        case "csiso2022kr":
        case "hz-gb-2312":
        case "iso-2022-cn":
        case "iso-2022-cn-ext":
        case "iso-2022-kr":
        case "replacement":
          return "replacement";
        case "unicodefffe":
        case "utf-16be":
          return "UTF-16BE";
        case "csunicode":
        case "iso-10646-ucs-2":
        case "ucs-2":
        case "unicode":
        case "unicodefeff":
        case "utf-16":
        case "utf-16le":
          return "UTF-16LE";
        case "x-user-defined":
          return "x-user-defined";
        default:
          return "failure";
      }
    }
    e.exports = { getEncoding: getEncoding };
  },
  82160: (e, t, r) => {
    const { staticPropertyDescriptors: n, readOperation: o, fireAProgressEvent: s } = r(10165);
    const { kState: i, kError: a, kResult: A, kEvents: c, kAborted: u } = r(86812);
    const { webidl: l } = r(74222);
    const { kEnumerableProperty: p } = r(3440);
    class FileReader extends EventTarget {
      constructor() {
        super();
        this[i] = "empty";
        this[A] = null;
        this[a] = null;
        this[c] = { loadend: null, error: null, abort: null, load: null, progress: null, loadstart: null };
      }
      readAsArrayBuffer(e) {
        l.brandCheck(this, FileReader);
        l.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsArrayBuffer" });
        e = l.converters.Blob(e, { strict: false });
        o(this, e, "ArrayBuffer");
      }
      readAsBinaryString(e) {
        l.brandCheck(this, FileReader);
        l.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsBinaryString" });
        e = l.converters.Blob(e, { strict: false });
        o(this, e, "BinaryString");
      }
      readAsText(e, t = undefined) {
        l.brandCheck(this, FileReader);
        l.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsText" });
        e = l.converters.Blob(e, { strict: false });
        if (t !== undefined) {
          t = l.converters.DOMString(t);
        }
        o(this, e, "Text", t);
      }
      readAsDataURL(e) {
        l.brandCheck(this, FileReader);
        l.argumentLengthCheck(arguments, 1, { header: "FileReader.readAsDataURL" });
        e = l.converters.Blob(e, { strict: false });
        o(this, e, "DataURL");
      }
      abort() {
        if (this[i] === "empty" || this[i] === "done") {
          this[A] = null;
          return;
        }
        if (this[i] === "loading") {
          this[i] = "done";
          this[A] = null;
        }
        this[u] = true;
        s("abort", this);
        if (this[i] !== "loading") {
          s("loadend", this);
        }
      }
      get readyState() {
        l.brandCheck(this, FileReader);
        switch (this[i]) {
          case "empty":
            return this.EMPTY;
          case "loading":
            return this.LOADING;
          case "done":
            return this.DONE;
        }
      }
      get result() {
        l.brandCheck(this, FileReader);
        return this[A];
      }
      get error() {
        l.brandCheck(this, FileReader);
        return this[a];
      }
      get onloadend() {
        l.brandCheck(this, FileReader);
        return this[c].loadend;
      }
      set onloadend(e) {
        l.brandCheck(this, FileReader);
        if (this[c].loadend) {
          this.removeEventListener("loadend", this[c].loadend);
        }
        if (typeof e === "function") {
          this[c].loadend = e;
          this.addEventListener("loadend", e);
        } else {
          this[c].loadend = null;
        }
      }
      get onerror() {
        l.brandCheck(this, FileReader);
        return this[c].error;
      }
      set onerror(e) {
        l.brandCheck(this, FileReader);
        if (this[c].error) {
          this.removeEventListener("error", this[c].error);
        }
        if (typeof e === "function") {
          this[c].error = e;
          this.addEventListener("error", e);
        } else {
          this[c].error = null;
        }
      }
      get onloadstart() {
        l.brandCheck(this, FileReader);
        return this[c].loadstart;
      }
      set onloadstart(e) {
        l.brandCheck(this, FileReader);
        if (this[c].loadstart) {
          this.removeEventListener("loadstart", this[c].loadstart);
        }
        if (typeof e === "function") {
          this[c].loadstart = e;
          this.addEventListener("loadstart", e);
        } else {
          this[c].loadstart = null;
        }
      }
      get onprogress() {
        l.brandCheck(this, FileReader);
        return this[c].progress;
      }
      set onprogress(e) {
        l.brandCheck(this, FileReader);
        if (this[c].progress) {
          this.removeEventListener("progress", this[c].progress);
        }
        if (typeof e === "function") {
          this[c].progress = e;
          this.addEventListener("progress", e);
        } else {
          this[c].progress = null;
        }
      }
      get onload() {
        l.brandCheck(this, FileReader);
        return this[c].load;
      }
      set onload(e) {
        l.brandCheck(this, FileReader);
        if (this[c].load) {
          this.removeEventListener("load", this[c].load);
        }
        if (typeof e === "function") {
          this[c].load = e;
          this.addEventListener("load", e);
        } else {
          this[c].load = null;
        }
      }
      get onabort() {
        l.brandCheck(this, FileReader);
        return this[c].abort;
      }
      set onabort(e) {
        l.brandCheck(this, FileReader);
        if (this[c].abort) {
          this.removeEventListener("abort", this[c].abort);
        }
        if (typeof e === "function") {
          this[c].abort = e;
          this.addEventListener("abort", e);
        } else {
          this[c].abort = null;
        }
      }
    }
    FileReader.EMPTY = FileReader.prototype.EMPTY = 0;
    FileReader.LOADING = FileReader.prototype.LOADING = 1;
    FileReader.DONE = FileReader.prototype.DONE = 2;
    Object.defineProperties(FileReader.prototype, {
      EMPTY: n,
      LOADING: n,
      DONE: n,
      readAsArrayBuffer: p,
      readAsBinaryString: p,
      readAsText: p,
      readAsDataURL: p,
      abort: p,
      readyState: p,
      result: p,
      error: p,
      onloadstart: p,
      onprogress: p,
      onload: p,
      onabort: p,
      onerror: p,
      onloadend: p,
      [Symbol.toStringTag]: { value: "FileReader", writable: false, enumerable: false, configurable: true },
    });
    Object.defineProperties(FileReader, { EMPTY: n, LOADING: n, DONE: n });
    e.exports = { FileReader: FileReader };
  },
  15976: (e, t, r) => {
    const { webidl: n } = r(74222);
    const o = Symbol("ProgressEvent state");
    class ProgressEvent extends Event {
      constructor(e, t = {}) {
        e = n.converters.DOMString(e);
        t = n.converters.ProgressEventInit(t ?? {});
        super(e, t);
        this[o] = { lengthComputable: t.lengthComputable, loaded: t.loaded, total: t.total };
      }
      get lengthComputable() {
        n.brandCheck(this, ProgressEvent);
        return this[o].lengthComputable;
      }
      get loaded() {
        n.brandCheck(this, ProgressEvent);
        return this[o].loaded;
      }
      get total() {
        n.brandCheck(this, ProgressEvent);
        return this[o].total;
      }
    }
    n.converters.ProgressEventInit = n.dictionaryConverter([
      { key: "lengthComputable", converter: n.converters.boolean, defaultValue: false },
      { key: "loaded", converter: n.converters["unsigned long long"], defaultValue: 0 },
      { key: "total", converter: n.converters["unsigned long long"], defaultValue: 0 },
      { key: "bubbles", converter: n.converters.boolean, defaultValue: false },
      { key: "cancelable", converter: n.converters.boolean, defaultValue: false },
      { key: "composed", converter: n.converters.boolean, defaultValue: false },
    ]);
    e.exports = { ProgressEvent: ProgressEvent };
  },
  86812: (e) => {
    e.exports = {
      kState: Symbol("FileReader state"),
      kResult: Symbol("FileReader result"),
      kError: Symbol("FileReader error"),
      kLastProgressEventFired: Symbol("FileReader last progress event fired timestamp"),
      kEvents: Symbol("FileReader events"),
      kAborted: Symbol("FileReader aborted"),
    };
  },
  10165: (e, t, r) => {
    const { kState: n, kError: o, kResult: s, kAborted: i, kLastProgressEventFired: a } = r(86812);
    const { ProgressEvent: A } = r(15976);
    const { getEncoding: c } = r(40396);
    const { DOMException: u } = r(87326);
    const { serializeAMimeType: l, parseMIMEType: p } = r(94322);
    const { types: d } = r(39023);
    const { StringDecoder: g } = r(13193);
    const { btoa: m } = r(20181);
    const h = { enumerable: true, writable: false, configurable: false };
    function readOperation(e, t, r, A) {
      if (e[n] === "loading") {
        throw new u("Invalid state", "InvalidStateError");
      }
      e[n] = "loading";
      e[s] = null;
      e[o] = null;
      const c = t.stream();
      const l = c.getReader();
      const p = [];
      let g = l.read();
      let m = true;
      (async () => {
        while (!e[i]) {
          try {
            const { done: c, value: u } = await g;
            if (m && !e[i]) {
              queueMicrotask(() => {
                fireAProgressEvent("loadstart", e);
              });
            }
            m = false;
            if (!c && d.isUint8Array(u)) {
              p.push(u);
              if ((e[a] === undefined || Date.now() - e[a] >= 50) && !e[i]) {
                e[a] = Date.now();
                queueMicrotask(() => {
                  fireAProgressEvent("progress", e);
                });
              }
              g = l.read();
            } else if (c) {
              queueMicrotask(() => {
                e[n] = "done";
                try {
                  const n = packageData(p, r, t.type, A);
                  if (e[i]) {
                    return;
                  }
                  e[s] = n;
                  fireAProgressEvent("load", e);
                } catch (t) {
                  e[o] = t;
                  fireAProgressEvent("error", e);
                }
                if (e[n] !== "loading") {
                  fireAProgressEvent("loadend", e);
                }
              });
              break;
            }
          } catch (t) {
            if (e[i]) {
              return;
            }
            queueMicrotask(() => {
              e[n] = "done";
              e[o] = t;
              fireAProgressEvent("error", e);
              if (e[n] !== "loading") {
                fireAProgressEvent("loadend", e);
              }
            });
            break;
          }
        }
      })();
    }
    function fireAProgressEvent(e, t) {
      const r = new A(e, { bubbles: false, cancelable: false });
      t.dispatchEvent(r);
    }
    function packageData(e, t, r, n) {
      switch (t) {
        case "DataURL": {
          let t = "data:";
          const n = p(r || "application/octet-stream");
          if (n !== "failure") {
            t += l(n);
          }
          t += ";base64,";
          const o = new g("latin1");
          for (const r of e) {
            t += m(o.write(r));
          }
          t += m(o.end());
          return t;
        }
        case "Text": {
          let t = "failure";
          if (n) {
            t = c(n);
          }
          if (t === "failure" && r) {
            const e = p(r);
            if (e !== "failure") {
              t = c(e.parameters.get("charset"));
            }
          }
          if (t === "failure") {
            t = "UTF-8";
          }
          return decode(e, t);
        }
        case "ArrayBuffer": {
          const t = combineByteSequences(e);
          return t.buffer;
        }
        case "BinaryString": {
          let t = "";
          const r = new g("latin1");
          for (const n of e) {
            t += r.write(n);
          }
          t += r.end();
          return t;
        }
      }
    }
    function decode(e, t) {
      const r = combineByteSequences(e);
      const n = BOMSniffing(r);
      let o = 0;
      if (n !== null) {
        t = n;
        o = n === "UTF-8" ? 3 : 2;
      }
      const s = r.slice(o);
      return new TextDecoder(t).decode(s);
    }
    function BOMSniffing(e) {
      const [t, r, n] = e;
      if (t === 239 && r === 187 && n === 191) {
        return "UTF-8";
      } else if (t === 254 && r === 255) {
        return "UTF-16BE";
      } else if (t === 255 && r === 254) {
        return "UTF-16LE";
      }
      return null;
    }
    function combineByteSequences(e) {
      const t = e.reduce((e, t) => e + t.byteLength, 0);
      let r = 0;
      return e.reduce((e, t) => {
        e.set(t, r);
        r += t.byteLength;
        return e;
      }, new Uint8Array(t));
    }
    e.exports = { staticPropertyDescriptors: h, readOperation: readOperation, fireAProgressEvent: fireAProgressEvent };
  },
  32581: (e, t, r) => {
    const n = Symbol.for("undici.globalDispatcher.1");
    const { InvalidArgumentError: o } = r(68707);
    const s = r(59965);
    if (getGlobalDispatcher() === undefined) {
      setGlobalDispatcher(new s());
    }
    function setGlobalDispatcher(e) {
      if (!e || typeof e.dispatch !== "function") {
        throw new o("Argument agent must implement Agent");
      }
      Object.defineProperty(globalThis, n, { value: e, writable: true, enumerable: false, configurable: false });
    }
    function getGlobalDispatcher() {
      return globalThis[n];
    }
    e.exports = { setGlobalDispatcher: setGlobalDispatcher, getGlobalDispatcher: getGlobalDispatcher };
  },
  78840: (e) => {
    e.exports = class DecoratorHandler {
      constructor(e) {
        this.handler = e;
      }
      onConnect(...e) {
        return this.handler.onConnect(...e);
      }
      onError(...e) {
        return this.handler.onError(...e);
      }
      onUpgrade(...e) {
        return this.handler.onUpgrade(...e);
      }
      onHeaders(...e) {
        return this.handler.onHeaders(...e);
      }
      onData(...e) {
        return this.handler.onData(...e);
      }
      onComplete(...e) {
        return this.handler.onComplete(...e);
      }
      onBodySent(...e) {
        return this.handler.onBodySent(...e);
      }
    };
  },
  48299: (e, t, r) => {
    const n = r(3440);
    const { kBodyUsed: o } = r(36443);
    const s = r(42613);
    const { InvalidArgumentError: i } = r(68707);
    const a = r(24434);
    const A = [300, 301, 302, 303, 307, 308];
    const c = Symbol("body");
    class BodyAsyncIterable {
      constructor(e) {
        this[c] = e;
        this[o] = false;
      }
      async *[Symbol.asyncIterator]() {
        s(!this[o], "disturbed");
        this[o] = true;
        yield* this[c];
      }
    }
    class RedirectHandler {
      constructor(e, t, r, A) {
        if (t != null && (!Number.isInteger(t) || t < 0)) {
          throw new i("maxRedirections must be a positive number");
        }
        n.validateHandler(A, r.method, r.upgrade);
        this.dispatch = e;
        this.location = null;
        this.abort = null;
        this.opts = { ...r, maxRedirections: 0 };
        this.maxRedirections = t;
        this.handler = A;
        this.history = [];
        if (n.isStream(this.opts.body)) {
          if (n.bodyLength(this.opts.body) === 0) {
            this.opts.body.on("data", function () {
              s(false);
            });
          }
          if (typeof this.opts.body.readableDidRead !== "boolean") {
            this.opts.body[o] = false;
            a.prototype.on.call(this.opts.body, "data", function () {
              this[o] = true;
            });
          }
        } else if (this.opts.body && typeof this.opts.body.pipeTo === "function") {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        } else if (this.opts.body && typeof this.opts.body !== "string" && !ArrayBuffer.isView(this.opts.body) && n.isIterable(this.opts.body)) {
          this.opts.body = new BodyAsyncIterable(this.opts.body);
        }
      }
      onConnect(e) {
        this.abort = e;
        this.handler.onConnect(e, { history: this.history });
      }
      onUpgrade(e, t, r) {
        this.handler.onUpgrade(e, t, r);
      }
      onError(e) {
        this.handler.onError(e);
      }
      onHeaders(e, t, r, o) {
        this.location = this.history.length >= this.maxRedirections || n.isDisturbed(this.opts.body) ? null : parseLocation(e, t);
        if (this.opts.origin) {
          this.history.push(new URL(this.opts.path, this.opts.origin));
        }
        if (!this.location) {
          return this.handler.onHeaders(e, t, r, o);
        }
        const { origin: s, pathname: i, search: a } = n.parseURL(new URL(this.location, this.opts.origin && new URL(this.opts.path, this.opts.origin)));
        const A = a ? `${i}${a}` : i;
        this.opts.headers = cleanRequestHeaders(this.opts.headers, e === 303, this.opts.origin !== s);
        this.opts.path = A;
        this.opts.origin = s;
        this.opts.maxRedirections = 0;
        this.opts.query = null;
        if (e === 303 && this.opts.method !== "HEAD") {
          this.opts.method = "GET";
          this.opts.body = null;
        }
      }
      onData(e) {
        if (this.location) {
        } else {
          return this.handler.onData(e);
        }
      }
      onComplete(e) {
        if (this.location) {
          this.location = null;
          this.abort = null;
          this.dispatch(this.opts, this);
        } else {
          this.handler.onComplete(e);
        }
      }
      onBodySent(e) {
        if (this.handler.onBodySent) {
          this.handler.onBodySent(e);
        }
      }
    }
    function parseLocation(e, t) {
      if (A.indexOf(e) === -1) {
        return null;
      }
      for (let e = 0; e < t.length; e += 2) {
        if (t[e].toString().toLowerCase() === "location") {
          return t[e + 1];
        }
      }
    }
    function shouldRemoveHeader(e, t, r) {
      if (e.length === 4) {
        return n.headerNameToString(e) === "host";
      }
      if (t && n.headerNameToString(e).startsWith("content-")) {
        return true;
      }
      if (r && (e.length === 13 || e.length === 6 || e.length === 19)) {
        const t = n.headerNameToString(e);
        return t === "authorization" || t === "cookie" || t === "proxy-authorization";
      }
      return false;
    }
    function cleanRequestHeaders(e, t, r) {
      const n = [];
      if (Array.isArray(e)) {
        for (let o = 0; o < e.length; o += 2) {
          if (!shouldRemoveHeader(e[o], t, r)) {
            n.push(e[o], e[o + 1]);
          }
        }
      } else if (e && typeof e === "object") {
        for (const o of Object.keys(e)) {
          if (!shouldRemoveHeader(o, t, r)) {
            n.push(o, e[o]);
          }
        }
      } else {
        s(e == null, "headers must be an object or an array");
      }
      return n;
    }
    e.exports = RedirectHandler;
  },
  53573: (e, t, r) => {
    const n = r(42613);
    const { kRetryHandlerDefaultRetry: o } = r(36443);
    const { RequestRetryError: s } = r(68707);
    const { isDisturbed: i, parseHeaders: a, parseRangeHeader: A } = r(3440);
    function calculateRetryAfterHeader(e) {
      const t = Date.now();
      const r = new Date(e).getTime() - t;
      return r;
    }
    class RetryHandler {
      constructor(e, t) {
        const { retryOptions: r, ...n } = e;
        const { retry: s, maxRetries: i, maxTimeout: a, minTimeout: A, timeoutFactor: c, methods: u, errorCodes: l, retryAfter: p, statusCodes: d } = r ?? {};
        this.dispatch = t.dispatch;
        this.handler = t.handler;
        this.opts = n;
        this.abort = null;
        this.aborted = false;
        this.retryOpts = {
          retry: s ?? RetryHandler[o],
          retryAfter: p ?? true,
          maxTimeout: a ?? 30 * 1e3,
          timeout: A ?? 500,
          timeoutFactor: c ?? 2,
          maxRetries: i ?? 5,
          methods: u ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          statusCodes: d ?? [500, 502, 503, 504, 429],
          errorCodes: l ?? ["ECONNRESET", "ECONNREFUSED", "ENOTFOUND", "ENETDOWN", "ENETUNREACH", "EHOSTDOWN", "EHOSTUNREACH", "EPIPE"],
        };
        this.retryCount = 0;
        this.start = 0;
        this.end = null;
        this.etag = null;
        this.resume = null;
        this.handler.onConnect((e) => {
          this.aborted = true;
          if (this.abort) {
            this.abort(e);
          } else {
            this.reason = e;
          }
        });
      }
      onRequestSent() {
        if (this.handler.onRequestSent) {
          this.handler.onRequestSent();
        }
      }
      onUpgrade(e, t, r) {
        if (this.handler.onUpgrade) {
          this.handler.onUpgrade(e, t, r);
        }
      }
      onConnect(e) {
        if (this.aborted) {
          e(this.reason);
        } else {
          this.abort = e;
        }
      }
      onBodySent(e) {
        if (this.handler.onBodySent) return this.handler.onBodySent(e);
      }
      static [o](e, { state: t, opts: r }, n) {
        const { statusCode: o, code: s, headers: i } = e;
        const { method: a, retryOptions: A } = r;
        const { maxRetries: c, timeout: u, maxTimeout: l, timeoutFactor: p, statusCodes: d, errorCodes: g, methods: m } = A;
        let { counter: h, currentTimeout: E } = t;
        E = E != null && E > 0 ? E : u;
        if (s && s !== "UND_ERR_REQ_RETRY" && s !== "UND_ERR_SOCKET" && !g.includes(s)) {
          n(e);
          return;
        }
        if (Array.isArray(m) && !m.includes(a)) {
          n(e);
          return;
        }
        if (o != null && Array.isArray(d) && !d.includes(o)) {
          n(e);
          return;
        }
        if (h > c) {
          n(e);
          return;
        }
        let I = i != null && i["retry-after"];
        if (I) {
          I = Number(I);
          I = isNaN(I) ? calculateRetryAfterHeader(I) : I * 1e3;
        }
        const y = I > 0 ? Math.min(I, l) : Math.min(E * p ** h, l);
        t.currentTimeout = y;
        setTimeout(() => n(null), y);
      }
      onHeaders(e, t, r, o) {
        const i = a(t);
        this.retryCount += 1;
        if (e >= 300) {
          this.abort(new s("Request failed", e, { headers: i, count: this.retryCount }));
          return false;
        }
        if (this.resume != null) {
          this.resume = null;
          if (e !== 206) {
            return true;
          }
          const t = A(i["content-range"]);
          if (!t) {
            this.abort(new s("Content-Range mismatch", e, { headers: i, count: this.retryCount }));
            return false;
          }
          if (this.etag != null && this.etag !== i.etag) {
            this.abort(new s("ETag mismatch", e, { headers: i, count: this.retryCount }));
            return false;
          }
          const { start: o, size: a, end: c = a } = t;
          n(this.start === o, "content-range mismatch");
          n(this.end == null || this.end === c, "content-range mismatch");
          this.resume = r;
          return true;
        }
        if (this.end == null) {
          if (e === 206) {
            const s = A(i["content-range"]);
            if (s == null) {
              return this.handler.onHeaders(e, t, r, o);
            }
            const { start: a, size: c, end: u = c } = s;
            n(a != null && Number.isFinite(a) && this.start !== a, "content-range mismatch");
            n(Number.isFinite(a));
            n(u != null && Number.isFinite(u) && this.end !== u, "invalid content-length");
            this.start = a;
            this.end = u;
          }
          if (this.end == null) {
            const e = i["content-length"];
            this.end = e != null ? Number(e) : null;
          }
          n(Number.isFinite(this.start));
          n(this.end == null || Number.isFinite(this.end), "invalid content-length");
          this.resume = r;
          this.etag = i.etag != null ? i.etag : null;
          return this.handler.onHeaders(e, t, r, o);
        }
        const c = new s("Request failed", e, { headers: i, count: this.retryCount });
        this.abort(c);
        return false;
      }
      onData(e) {
        this.start += e.length;
        return this.handler.onData(e);
      }
      onComplete(e) {
        this.retryCount = 0;
        return this.handler.onComplete(e);
      }
      onError(e) {
        if (this.aborted || i(this.opts.body)) {
          return this.handler.onError(e);
        }
        this.retryOpts.retry(
          e,
          { state: { counter: this.retryCount++, currentTimeout: this.retryAfter }, opts: { retryOptions: this.retryOpts, ...this.opts } },
          onRetry.bind(this)
        );
        function onRetry(e) {
          if (e != null || this.aborted || i(this.opts.body)) {
            return this.handler.onError(e);
          }
          if (this.start !== 0) {
            this.opts = { ...this.opts, headers: { ...this.opts.headers, range: `bytes=${this.start}-${this.end ?? ""}` } };
          }
          try {
            this.dispatch(this.opts, this);
          } catch (e) {
            this.handler.onError(e);
          }
        }
      }
    }
    e.exports = RetryHandler;
  },
  64415: (e, t, r) => {
    const n = r(48299);
    function createRedirectInterceptor({ maxRedirections: e }) {
      return (t) =>
        function Intercept(r, o) {
          const { maxRedirections: s = e } = r;
          if (!s) {
            return t(r, o);
          }
          const i = new n(t, s, r, o);
          r = { ...r, maxRedirections: 0 };
          return t(r, i);
        };
    }
    e.exports = createRedirectInterceptor;
  },
  52824: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.SPECIAL_HEADERS =
      t.HEADER_STATE =
      t.MINOR =
      t.MAJOR =
      t.CONNECTION_TOKEN_CHARS =
      t.HEADER_CHARS =
      t.TOKEN =
      t.STRICT_TOKEN =
      t.HEX =
      t.URL_CHAR =
      t.STRICT_URL_CHAR =
      t.USERINFO_CHARS =
      t.MARK =
      t.ALPHANUM =
      t.NUM =
      t.HEX_MAP =
      t.NUM_MAP =
      t.ALPHA =
      t.FINISH =
      t.H_METHOD_MAP =
      t.METHOD_MAP =
      t.METHODS_RTSP =
      t.METHODS_ICE =
      t.METHODS_HTTP =
      t.METHODS =
      t.LENIENT_FLAGS =
      t.FLAGS =
      t.TYPE =
      t.ERROR =
        void 0;
    const n = r(50172);
    var o;
    (function (e) {
      e[(e["OK"] = 0)] = "OK";
      e[(e["INTERNAL"] = 1)] = "INTERNAL";
      e[(e["STRICT"] = 2)] = "STRICT";
      e[(e["LF_EXPECTED"] = 3)] = "LF_EXPECTED";
      e[(e["UNEXPECTED_CONTENT_LENGTH"] = 4)] = "UNEXPECTED_CONTENT_LENGTH";
      e[(e["CLOSED_CONNECTION"] = 5)] = "CLOSED_CONNECTION";
      e[(e["INVALID_METHOD"] = 6)] = "INVALID_METHOD";
      e[(e["INVALID_URL"] = 7)] = "INVALID_URL";
      e[(e["INVALID_CONSTANT"] = 8)] = "INVALID_CONSTANT";
      e[(e["INVALID_VERSION"] = 9)] = "INVALID_VERSION";
      e[(e["INVALID_HEADER_TOKEN"] = 10)] = "INVALID_HEADER_TOKEN";
      e[(e["INVALID_CONTENT_LENGTH"] = 11)] = "INVALID_CONTENT_LENGTH";
      e[(e["INVALID_CHUNK_SIZE"] = 12)] = "INVALID_CHUNK_SIZE";
      e[(e["INVALID_STATUS"] = 13)] = "INVALID_STATUS";
      e[(e["INVALID_EOF_STATE"] = 14)] = "INVALID_EOF_STATE";
      e[(e["INVALID_TRANSFER_ENCODING"] = 15)] = "INVALID_TRANSFER_ENCODING";
      e[(e["CB_MESSAGE_BEGIN"] = 16)] = "CB_MESSAGE_BEGIN";
      e[(e["CB_HEADERS_COMPLETE"] = 17)] = "CB_HEADERS_COMPLETE";
      e[(e["CB_MESSAGE_COMPLETE"] = 18)] = "CB_MESSAGE_COMPLETE";
      e[(e["CB_CHUNK_HEADER"] = 19)] = "CB_CHUNK_HEADER";
      e[(e["CB_CHUNK_COMPLETE"] = 20)] = "CB_CHUNK_COMPLETE";
      e[(e["PAUSED"] = 21)] = "PAUSED";
      e[(e["PAUSED_UPGRADE"] = 22)] = "PAUSED_UPGRADE";
      e[(e["PAUSED_H2_UPGRADE"] = 23)] = "PAUSED_H2_UPGRADE";
      e[(e["USER"] = 24)] = "USER";
    })((o = t.ERROR || (t.ERROR = {})));
    var s;
    (function (e) {
      e[(e["BOTH"] = 0)] = "BOTH";
      e[(e["REQUEST"] = 1)] = "REQUEST";
      e[(e["RESPONSE"] = 2)] = "RESPONSE";
    })((s = t.TYPE || (t.TYPE = {})));
    var i;
    (function (e) {
      e[(e["CONNECTION_KEEP_ALIVE"] = 1)] = "CONNECTION_KEEP_ALIVE";
      e[(e["CONNECTION_CLOSE"] = 2)] = "CONNECTION_CLOSE";
      e[(e["CONNECTION_UPGRADE"] = 4)] = "CONNECTION_UPGRADE";
      e[(e["CHUNKED"] = 8)] = "CHUNKED";
      e[(e["UPGRADE"] = 16)] = "UPGRADE";
      e[(e["CONTENT_LENGTH"] = 32)] = "CONTENT_LENGTH";
      e[(e["SKIPBODY"] = 64)] = "SKIPBODY";
      e[(e["TRAILING"] = 128)] = "TRAILING";
      e[(e["TRANSFER_ENCODING"] = 512)] = "TRANSFER_ENCODING";
    })((i = t.FLAGS || (t.FLAGS = {})));
    var a;
    (function (e) {
      e[(e["HEADERS"] = 1)] = "HEADERS";
      e[(e["CHUNKED_LENGTH"] = 2)] = "CHUNKED_LENGTH";
      e[(e["KEEP_ALIVE"] = 4)] = "KEEP_ALIVE";
    })((a = t.LENIENT_FLAGS || (t.LENIENT_FLAGS = {})));
    var A;
    (function (e) {
      e[(e["DELETE"] = 0)] = "DELETE";
      e[(e["GET"] = 1)] = "GET";
      e[(e["HEAD"] = 2)] = "HEAD";
      e[(e["POST"] = 3)] = "POST";
      e[(e["PUT"] = 4)] = "PUT";
      e[(e["CONNECT"] = 5)] = "CONNECT";
      e[(e["OPTIONS"] = 6)] = "OPTIONS";
      e[(e["TRACE"] = 7)] = "TRACE";
      e[(e["COPY"] = 8)] = "COPY";
      e[(e["LOCK"] = 9)] = "LOCK";
      e[(e["MKCOL"] = 10)] = "MKCOL";
      e[(e["MOVE"] = 11)] = "MOVE";
      e[(e["PROPFIND"] = 12)] = "PROPFIND";
      e[(e["PROPPATCH"] = 13)] = "PROPPATCH";
      e[(e["SEARCH"] = 14)] = "SEARCH";
      e[(e["UNLOCK"] = 15)] = "UNLOCK";
      e[(e["BIND"] = 16)] = "BIND";
      e[(e["REBIND"] = 17)] = "REBIND";
      e[(e["UNBIND"] = 18)] = "UNBIND";
      e[(e["ACL"] = 19)] = "ACL";
      e[(e["REPORT"] = 20)] = "REPORT";
      e[(e["MKACTIVITY"] = 21)] = "MKACTIVITY";
      e[(e["CHECKOUT"] = 22)] = "CHECKOUT";
      e[(e["MERGE"] = 23)] = "MERGE";
      e[(e["M-SEARCH"] = 24)] = "M-SEARCH";
      e[(e["NOTIFY"] = 25)] = "NOTIFY";
      e[(e["SUBSCRIBE"] = 26)] = "SUBSCRIBE";
      e[(e["UNSUBSCRIBE"] = 27)] = "UNSUBSCRIBE";
      e[(e["PATCH"] = 28)] = "PATCH";
      e[(e["PURGE"] = 29)] = "PURGE";
      e[(e["MKCALENDAR"] = 30)] = "MKCALENDAR";
      e[(e["LINK"] = 31)] = "LINK";
      e[(e["UNLINK"] = 32)] = "UNLINK";
      e[(e["SOURCE"] = 33)] = "SOURCE";
      e[(e["PRI"] = 34)] = "PRI";
      e[(e["DESCRIBE"] = 35)] = "DESCRIBE";
      e[(e["ANNOUNCE"] = 36)] = "ANNOUNCE";
      e[(e["SETUP"] = 37)] = "SETUP";
      e[(e["PLAY"] = 38)] = "PLAY";
      e[(e["PAUSE"] = 39)] = "PAUSE";
      e[(e["TEARDOWN"] = 40)] = "TEARDOWN";
      e[(e["GET_PARAMETER"] = 41)] = "GET_PARAMETER";
      e[(e["SET_PARAMETER"] = 42)] = "SET_PARAMETER";
      e[(e["REDIRECT"] = 43)] = "REDIRECT";
      e[(e["RECORD"] = 44)] = "RECORD";
      e[(e["FLUSH"] = 45)] = "FLUSH";
    })((A = t.METHODS || (t.METHODS = {})));
    t.METHODS_HTTP = [
      A.DELETE,
      A.GET,
      A.HEAD,
      A.POST,
      A.PUT,
      A.CONNECT,
      A.OPTIONS,
      A.TRACE,
      A.COPY,
      A.LOCK,
      A.MKCOL,
      A.MOVE,
      A.PROPFIND,
      A.PROPPATCH,
      A.SEARCH,
      A.UNLOCK,
      A.BIND,
      A.REBIND,
      A.UNBIND,
      A.ACL,
      A.REPORT,
      A.MKACTIVITY,
      A.CHECKOUT,
      A.MERGE,
      A["M-SEARCH"],
      A.NOTIFY,
      A.SUBSCRIBE,
      A.UNSUBSCRIBE,
      A.PATCH,
      A.PURGE,
      A.MKCALENDAR,
      A.LINK,
      A.UNLINK,
      A.PRI,
      A.SOURCE,
    ];
    t.METHODS_ICE = [A.SOURCE];
    t.METHODS_RTSP = [
      A.OPTIONS,
      A.DESCRIBE,
      A.ANNOUNCE,
      A.SETUP,
      A.PLAY,
      A.PAUSE,
      A.TEARDOWN,
      A.GET_PARAMETER,
      A.SET_PARAMETER,
      A.REDIRECT,
      A.RECORD,
      A.FLUSH,
      A.GET,
      A.POST,
    ];
    t.METHOD_MAP = n.enumToMap(A);
    t.H_METHOD_MAP = {};
    Object.keys(t.METHOD_MAP).forEach((e) => {
      if (/^H/.test(e)) {
        t.H_METHOD_MAP[e] = t.METHOD_MAP[e];
      }
    });
    var c;
    (function (e) {
      e[(e["SAFE"] = 0)] = "SAFE";
      e[(e["SAFE_WITH_CB"] = 1)] = "SAFE_WITH_CB";
      e[(e["UNSAFE"] = 2)] = "UNSAFE";
    })((c = t.FINISH || (t.FINISH = {})));
    t.ALPHA = [];
    for (let e = "A".charCodeAt(0); e <= "Z".charCodeAt(0); e++) {
      t.ALPHA.push(String.fromCharCode(e));
      t.ALPHA.push(String.fromCharCode(e + 32));
    }
    t.NUM_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9 };
    t.HEX_MAP = {
      0: 0,
      1: 1,
      2: 2,
      3: 3,
      4: 4,
      5: 5,
      6: 6,
      7: 7,
      8: 8,
      9: 9,
      A: 10,
      B: 11,
      C: 12,
      D: 13,
      E: 14,
      F: 15,
      a: 10,
      b: 11,
      c: 12,
      d: 13,
      e: 14,
      f: 15,
    };
    t.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
    t.ALPHANUM = t.ALPHA.concat(t.NUM);
    t.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
    t.USERINFO_CHARS = t.ALPHANUM.concat(t.MARK).concat(["%", ";", ":", "&", "=", "+", "$", ","]);
    t.STRICT_URL_CHAR = [
      "!",
      '"',
      "$",
      "%",
      "&",
      "'",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      ":",
      ";",
      "<",
      "=",
      ">",
      "@",
      "[",
      "\\",
      "]",
      "^",
      "_",
      "`",
      "{",
      "|",
      "}",
      "~",
    ].concat(t.ALPHANUM);
    t.URL_CHAR = t.STRICT_URL_CHAR.concat(["\t", "\f"]);
    for (let e = 128; e <= 255; e++) {
      t.URL_CHAR.push(e);
    }
    t.HEX = t.NUM.concat(["a", "b", "c", "d", "e", "f", "A", "B", "C", "D", "E", "F"]);
    t.STRICT_TOKEN = ["!", "#", "$", "%", "&", "'", "*", "+", "-", ".", "^", "_", "`", "|", "~"].concat(t.ALPHANUM);
    t.TOKEN = t.STRICT_TOKEN.concat([" "]);
    t.HEADER_CHARS = ["\t"];
    for (let e = 32; e <= 255; e++) {
      if (e !== 127) {
        t.HEADER_CHARS.push(e);
      }
    }
    t.CONNECTION_TOKEN_CHARS = t.HEADER_CHARS.filter((e) => e !== 44);
    t.MAJOR = t.NUM_MAP;
    t.MINOR = t.MAJOR;
    var u;
    (function (e) {
      e[(e["GENERAL"] = 0)] = "GENERAL";
      e[(e["CONNECTION"] = 1)] = "CONNECTION";
      e[(e["CONTENT_LENGTH"] = 2)] = "CONTENT_LENGTH";
      e[(e["TRANSFER_ENCODING"] = 3)] = "TRANSFER_ENCODING";
      e[(e["UPGRADE"] = 4)] = "UPGRADE";
      e[(e["CONNECTION_KEEP_ALIVE"] = 5)] = "CONNECTION_KEEP_ALIVE";
      e[(e["CONNECTION_CLOSE"] = 6)] = "CONNECTION_CLOSE";
      e[(e["CONNECTION_UPGRADE"] = 7)] = "CONNECTION_UPGRADE";
      e[(e["TRANSFER_ENCODING_CHUNKED"] = 8)] = "TRANSFER_ENCODING_CHUNKED";
    })((u = t.HEADER_STATE || (t.HEADER_STATE = {})));
    t.SPECIAL_HEADERS = {
      connection: u.CONNECTION,
      "content-length": u.CONTENT_LENGTH,
      "proxy-connection": u.CONNECTION,
      "transfer-encoding": u.TRANSFER_ENCODING,
      upgrade: u.UPGRADE,
    };
  },
  63870: (e) => {
    e.exports =
      "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG1AbYBtwHLAcoBuAHJAbkByAG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBxQHGAQDcAQtBACEQDMYBC0EOIRAMxQELQQ0hEAzEAQtBDyEQDMMBC0EQIRAMwgELQRMhEAzBAQtBFCEQDMABC0EVIRAMvwELQRYhEAy+AQtBFyEQDL0BC0EYIRAMvAELQRkhEAy7AQtBGiEQDLoBC0EbIRAMuQELQRwhEAy4AQtBCCEQDLcBC0EdIRAMtgELQSAhEAy1AQtBHyEQDLQBC0EHIRAMswELQSEhEAyyAQtBIiEQDLEBC0EeIRAMsAELQSMhEAyvAQtBEiEQDK4BC0ERIRAMrQELQSQhEAysAQtBJSEQDKsBC0EmIRAMqgELQSchEAypAQtBwwEhEAyoAQtBKSEQDKcBC0ErIRAMpgELQSwhEAylAQtBLSEQDKQBC0EuIRAMowELQS8hEAyiAQtBxAEhEAyhAQtBMCEQDKABC0E0IRAMnwELQQwhEAyeAQtBMSEQDJ0BC0EyIRAMnAELQTMhEAybAQtBOSEQDJoBC0E1IRAMmQELQcUBIRAMmAELQQshEAyXAQtBOiEQDJYBC0E2IRAMlQELQQohEAyUAQtBNyEQDJMBC0E4IRAMkgELQTwhEAyRAQtBOyEQDJABC0E9IRAMjwELQQkhEAyOAQtBKCEQDI0BC0E+IRAMjAELQT8hEAyLAQtBwAAhEAyKAQtBwQAhEAyJAQtBwgAhEAyIAQtBwwAhEAyHAQtBxAAhEAyGAQtBxQAhEAyFAQtBxgAhEAyEAQtBKiEQDIMBC0HHACEQDIIBC0HIACEQDIEBC0HJACEQDIABC0HKACEQDH8LQcsAIRAMfgtBzQAhEAx9C0HMACEQDHwLQc4AIRAMewtBzwAhEAx6C0HQACEQDHkLQdEAIRAMeAtB0gAhEAx3C0HTACEQDHYLQdQAIRAMdQtB1gAhEAx0C0HVACEQDHMLQQYhEAxyC0HXACEQDHELQQUhEAxwC0HYACEQDG8LQQQhEAxuC0HZACEQDG0LQdoAIRAMbAtB2wAhEAxrC0HcACEQDGoLQQMhEAxpC0HdACEQDGgLQd4AIRAMZwtB3wAhEAxmC0HhACEQDGULQeAAIRAMZAtB4gAhEAxjC0HjACEQDGILQQIhEAxhC0HkACEQDGALQeUAIRAMXwtB5gAhEAxeC0HnACEQDF0LQegAIRAMXAtB6QAhEAxbC0HqACEQDFoLQesAIRAMWQtB7AAhEAxYC0HtACEQDFcLQe4AIRAMVgtB7wAhEAxVC0HwACEQDFQLQfEAIRAMUwtB8gAhEAxSC0HzACEQDFELQfQAIRAMUAtB9QAhEAxPC0H2ACEQDE4LQfcAIRAMTQtB+AAhEAxMC0H5ACEQDEsLQfoAIRAMSgtB+wAhEAxJC0H8ACEQDEgLQf0AIRAMRwtB/gAhEAxGC0H/ACEQDEULQYABIRAMRAtBgQEhEAxDC0GCASEQDEILQYMBIRAMQQtBhAEhEAxAC0GFASEQDD8LQYYBIRAMPgtBhwEhEAw9C0GIASEQDDwLQYkBIRAMOwtBigEhEAw6C0GLASEQDDkLQYwBIRAMOAtBjQEhEAw3C0GOASEQDDYLQY8BIRAMNQtBkAEhEAw0C0GRASEQDDMLQZIBIRAMMgtBkwEhEAwxC0GUASEQDDALQZUBIRAMLwtBlgEhEAwuC0GXASEQDC0LQZgBIRAMLAtBmQEhEAwrC0GaASEQDCoLQZsBIRAMKQtBnAEhEAwoC0GdASEQDCcLQZ4BIRAMJgtBnwEhEAwlC0GgASEQDCQLQaEBIRAMIwtBogEhEAwiC0GjASEQDCELQaQBIRAMIAtBpQEhEAwfC0GmASEQDB4LQacBIRAMHQtBqAEhEAwcC0GpASEQDBsLQaoBIRAMGgtBqwEhEAwZC0GsASEQDBgLQa0BIRAMFwtBrgEhEAwWC0EBIRAMFQtBrwEhEAwUC0GwASEQDBMLQbEBIRAMEgtBswEhEAwRC0GyASEQDBALQbQBIRAMDwtBtQEhEAwOC0G2ASEQDA0LQbcBIRAMDAtBuAEhEAwLC0G5ASEQDAoLQboBIRAMCQtBuwEhEAwIC0HGASEQDAcLQbwBIRAMBgtBvQEhEAwFC0G+ASEQDAQLQb8BIRAMAwtBwAEhEAwCC0HCASEQDAELQcEBIRALA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAUNgIUIAAgATYCDEEAIRAMogELIABBADYCHCAAIBQ2AhQgAEHDj4CAADYCECAAQQc2AgxBACEQDKEBCyAAQQA2AhwgACABNgIUIABBw4+AgAA2AhAgAEEHNgIMQQAhEAygAQtBACEQIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgwMnwELIABBADYCHCAAIBQ2AhQgAEGMnICAADYCECAAQQc2AgxBACEQDJ4BCyAAQQA2AhwgACAUNgIUIABB/pGAgAA2AhAgAEEHNgIMQQAhEAydAQsgAEEANgIcIAAgATYCFCAAQY6bgIAANgIQIABBBjYCDEEAIRAMnAELIBBBFUYNVyAAQQA2AhwgACABNgIUIABBzI6AgAA2AhAgAEEgNgIMQQAhEAybAQsgAEEANgIAIBBBAWohAUEkIRALIAAgEDoAKSAAKAIEIRAgAEEANgIEIAAgECABEKuAgIAAIhANVCABIQEMPgsgAEEANgIAC0EAIRAgAEEANgIcIAAgBDYCFCAAQfGbgIAANgIQIABBBjYCDAyXAQsgAUEVRg1QIABBADYCHCAAIAU2AhQgAEHwjICAADYCECAAQRs2AgxBACEQDJYBCyAAKAIEIQUgAEEANgIEIAAgBSAQEKmAgIAAIgUNASAQQQFqIQULQa0BIRAMewsgAEHBATYCHCAAIAU2AgwgACAQQQFqNgIUQQAhEAyTAQsgACgCBCEGIABBADYCBCAAIAYgEBCpgICAACIGDQEgEEEBaiEGC0GuASEQDHgLIABBwgE2AhwgACAGNgIMIAAgEEEBajYCFEEAIRAMkAELIABBADYCHCAAIAc2AhQgAEGXi4CAADYCECAAQQ02AgxBACEQDI8BCyAAQQA2AhwgACAINgIUIABB45CAgAA2AhAgAEEJNgIMQQAhEAyOAQsgAEEANgIcIAAgCDYCFCAAQZSNgIAANgIQIABBITYCDEEAIRAMjQELQQEhFkEAIRdBACEUQQEhEAsgACAQOgArIAlBAWohCAJAAkAgAC0ALUEQcQ0AAkACQAJAIAAtACoOAwEAAgQLIBZFDQMMAgsgFA0BDAILIBdFDQELIAAoAgQhECAAQQA2AgQgACAQIAgQrYCAgAAiEEUNPSAAQckBNgIcIAAgCDYCFCAAIBA2AgxBACEQDIwBCyAAKAIEIQQgAEEANgIEIAAgBCAIEK2AgIAAIgRFDXYgAEHKATYCHCAAIAg2AhQgACAENgIMQQAhEAyLAQsgACgCBCEEIABBADYCBCAAIAQgCRCtgICAACIERQ10IABBywE2AhwgACAJNgIUIAAgBDYCDEEAIRAMigELIAAoAgQhBCAAQQA2AgQgACAEIAoQrYCAgAAiBEUNciAAQc0BNgIcIAAgCjYCFCAAIAQ2AgxBACEQDIkBCwJAIAstAABBUGoiEEH/AXFBCk8NACAAIBA6ACogC0EBaiEKQbYBIRAMcAsgACgCBCEEIABBADYCBCAAIAQgCxCtgICAACIERQ1wIABBzwE2AhwgACALNgIUIAAgBDYCDEEAIRAMiAELIABBADYCHCAAIAQ2AhQgAEGQs4CAADYCECAAQQg2AgwgAEEANgIAQQAhEAyHAQsgAUEVRg0/IABBADYCHCAAIAw2AhQgAEHMjoCAADYCECAAQSA2AgxBACEQDIYBCyAAQYEEOwEoIAAoAgQhECAAQgA3AwAgACAQIAxBAWoiDBCrgICAACIQRQ04IABB0wE2AhwgACAMNgIUIAAgEDYCDEEAIRAMhQELIABBADYCAAtBACEQIABBADYCHCAAIAQ2AhQgAEHYm4CAADYCECAAQQg2AgwMgwELIAAoAgQhECAAQgA3AwAgACAQIAtBAWoiCxCrgICAACIQDQFBxgEhEAxpCyAAQQI6ACgMVQsgAEHVATYCHCAAIAs2AhQgACAQNgIMQQAhEAyAAQsgEEEVRg03IABBADYCHCAAIAQ2AhQgAEGkjICAADYCECAAQRA2AgxBACEQDH8LIAAtADRBAUcNNCAAIAQgAhC8gICAACIQRQ00IBBBFUcNNSAAQdwBNgIcIAAgBDYCFCAAQdWWgIAANgIQIABBFTYCDEEAIRAMfgtBACEQIABBADYCHCAAQa+LgIAANgIQIABBAjYCDCAAIBRBAWo2AhQMfQtBACEQDGMLQQIhEAxiC0ENIRAMYQtBDyEQDGALQSUhEAxfC0ETIRAMXgtBFSEQDF0LQRYhEAxcC0EXIRAMWwtBGCEQDFoLQRkhEAxZC0EaIRAMWAtBGyEQDFcLQRwhEAxWC0EdIRAMVQtBHyEQDFQLQSEhEAxTC0EjIRAMUgtBxgAhEAxRC0EuIRAMUAtBLyEQDE8LQTshEAxOC0E9IRAMTQtByAAhEAxMC0HJACEQDEsLQcsAIRAMSgtBzAAhEAxJC0HOACEQDEgLQdEAIRAMRwtB1QAhEAxGC0HYACEQDEULQdkAIRAMRAtB2wAhEAxDC0HkACEQDEILQeUAIRAMQQtB8QAhEAxAC0H0ACEQDD8LQY0BIRAMPgtBlwEhEAw9C0GpASEQDDwLQawBIRAMOwtBwAEhEAw6C0G5ASEQDDkLQa8BIRAMOAtBsQEhEAw3C0GyASEQDDYLQbQBIRAMNQtBtQEhEAw0C0G6ASEQDDMLQb0BIRAMMgtBvwEhEAwxC0HBASEQDDALIABBADYCHCAAIAQ2AhQgAEHpi4CAADYCECAAQR82AgxBACEQDEgLIABB2wE2AhwgACAENgIUIABB+paAgAA2AhAgAEEVNgIMQQAhEAxHCyAAQfgANgIcIAAgDDYCFCAAQcqYgIAANgIQIABBFTYCDEEAIRAMRgsgAEHRADYCHCAAIAU2AhQgAEGwl4CAADYCECAAQRU2AgxBACEQDEULIABB+QA2AhwgACABNgIUIAAgEDYCDEEAIRAMRAsgAEH4ADYCHCAAIAE2AhQgAEHKmICAADYCECAAQRU2AgxBACEQDEMLIABB5AA2AhwgACABNgIUIABB45eAgAA2AhAgAEEVNgIMQQAhEAxCCyAAQdcANgIcIAAgATYCFCAAQcmXgIAANgIQIABBFTYCDEEAIRAMQQsgAEEANgIcIAAgATYCFCAAQbmNgIAANgIQIABBGjYCDEEAIRAMQAsgAEHCADYCHCAAIAE2AhQgAEHjmICAADYCECAAQRU2AgxBACEQDD8LIABBADYCBCAAIA8gDxCxgICAACIERQ0BIABBOjYCHCAAIAQ2AgwgACAPQQFqNgIUQQAhEAw+CyAAKAIEIQQgAEEANgIEAkAgACAEIAEQsYCAgAAiBEUNACAAQTs2AhwgACAENgIMIAAgAUEBajYCFEEAIRAMPgsgAUEBaiEBDC0LIA9BAWohAQwtCyAAQQA2AhwgACAPNgIUIABB5JKAgAA2AhAgAEEENgIMQQAhEAw7CyAAQTY2AhwgACAENgIUIAAgAjYCDEEAIRAMOgsgAEEuNgIcIAAgDjYCFCAAIAQ2AgxBACEQDDkLIABB0AA2AhwgACABNgIUIABBkZiAgAA2AhAgAEEVNgIMQQAhEAw4CyANQQFqIQEMLAsgAEEVNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMNgsgAEEbNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNQsgAEEPNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMNAsgAEELNgIcIAAgATYCFCAAQZGXgIAANgIQIABBFTYCDEEAIRAMMwsgAEEaNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMgsgAEELNgIcIAAgATYCFCAAQYKZgIAANgIQIABBFTYCDEEAIRAMMQsgAEEKNgIcIAAgATYCFCAAQeSWgIAANgIQIABBFTYCDEEAIRAMMAsgAEEeNgIcIAAgATYCFCAAQfmXgIAANgIQIABBFTYCDEEAIRAMLwsgAEEANgIcIAAgEDYCFCAAQdqNgIAANgIQIABBFDYCDEEAIRAMLgsgAEEENgIcIAAgATYCFCAAQbCYgIAANgIQIABBFTYCDEEAIRAMLQsgAEEANgIAIAtBAWohCwtBuAEhEAwSCyAAQQA2AgAgEEEBaiEBQfUAIRAMEQsgASEBAkAgAC0AKUEFRw0AQeMAIRAMEQtB4gAhEAwQC0EAIRAgAEEANgIcIABB5JGAgAA2AhAgAEEHNgIMIAAgFEEBajYCFAwoCyAAQQA2AgAgF0EBaiEBQcAAIRAMDgtBASEBCyAAIAE6ACwgAEEANgIAIBdBAWohAQtBKCEQDAsLIAEhAQtBOCEQDAkLAkAgASIPIAJGDQADQAJAIA8tAABBgL6AgABqLQAAIgFBAUYNACABQQJHDQMgD0EBaiEBDAQLIA9BAWoiDyACRw0AC0E+IRAMIgtBPiEQDCELIABBADoALCAPIQEMAQtBCyEQDAYLQTohEAwFCyABQQFqIQFBLSEQDAQLIAAgAToALCAAQQA2AgAgFkEBaiEBQQwhEAwDCyAAQQA2AgAgF0EBaiEBQQohEAwCCyAAQQA2AgALIABBADoALCANIQFBCSEQDAALC0EAIRAgAEEANgIcIAAgCzYCFCAAQc2QgIAANgIQIABBCTYCDAwXC0EAIRAgAEEANgIcIAAgCjYCFCAAQemKgIAANgIQIABBCTYCDAwWC0EAIRAgAEEANgIcIAAgCTYCFCAAQbeQgIAANgIQIABBCTYCDAwVC0EAIRAgAEEANgIcIAAgCDYCFCAAQZyRgIAANgIQIABBCTYCDAwUC0EAIRAgAEEANgIcIAAgATYCFCAAQc2QgIAANgIQIABBCTYCDAwTC0EAIRAgAEEANgIcIAAgATYCFCAAQemKgIAANgIQIABBCTYCDAwSC0EAIRAgAEEANgIcIAAgATYCFCAAQbeQgIAANgIQIABBCTYCDAwRC0EAIRAgAEEANgIcIAAgATYCFCAAQZyRgIAANgIQIABBCTYCDAwQC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwPC0EAIRAgAEEANgIcIAAgATYCFCAAQZeVgIAANgIQIABBDzYCDAwOC0EAIRAgAEEANgIcIAAgATYCFCAAQcCSgIAANgIQIABBCzYCDAwNC0EAIRAgAEEANgIcIAAgATYCFCAAQZWJgIAANgIQIABBCzYCDAwMC0EAIRAgAEEANgIcIAAgATYCFCAAQeGPgIAANgIQIABBCjYCDAwLC0EAIRAgAEEANgIcIAAgATYCFCAAQfuPgIAANgIQIABBCjYCDAwKC0EAIRAgAEEANgIcIAAgATYCFCAAQfGZgIAANgIQIABBAjYCDAwJC0EAIRAgAEEANgIcIAAgATYCFCAAQcSUgIAANgIQIABBAjYCDAwIC0EAIRAgAEEANgIcIAAgATYCFCAAQfKVgIAANgIQIABBAjYCDAwHCyAAQQI2AhwgACABNgIUIABBnJqAgAA2AhAgAEEWNgIMQQAhEAwGC0EBIRAMBQtB1AAhECABIgQgAkYNBCADQQhqIAAgBCACQdjCgIAAQQoQxYCAgAAgAygCDCEEIAMoAggOAwEEAgALEMqAgIAAAAsgAEEANgIcIABBtZqAgAA2AhAgAEEXNgIMIAAgBEEBajYCFEEAIRAMAgsgAEEANgIcIAAgBDYCFCAAQcqagIAANgIQIABBCTYCDEEAIRAMAQsCQCABIgQgAkcNAEEiIRAMAQsgAEGJgICAADYCCCAAIAQ2AgRBISEQCyADQRBqJICAgIAAIBALrwEBAn8gASgCACEGAkACQCACIANGDQAgBCAGaiEEIAYgA2ogAmshByACIAZBf3MgBWoiBmohBQNAAkAgAi0AACAELQAARg0AQQIhBAwDCwJAIAYNAEEAIQQgBSECDAMLIAZBf2ohBiAEQQFqIQQgAkEBaiICIANHDQALIAchBiADIQILIABBATYCACABIAY2AgAgACACNgIEDwsgAUEANgIAIAAgBDYCACAAIAI2AgQLCgAgABDHgICAAAvyNgELfyOAgICAAEEQayIBJICAgIAAAkBBACgCoNCAgAANAEEAEMuAgIAAQYDUhIAAayICQdkASQ0AQQAhAwJAQQAoAuDTgIAAIgQNAEEAQn83AuzTgIAAQQBCgICEgICAwAA3AuTTgIAAQQAgAUEIakFwcUHYqtWqBXMiBDYC4NOAgABBAEEANgL004CAAEEAQQA2AsTTgIAAC0EAIAI2AszTgIAAQQBBgNSEgAA2AsjTgIAAQQBBgNSEgAA2ApjQgIAAQQAgBDYCrNCAgABBAEF/NgKo0ICAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALQYDUhIAAQXhBgNSEgABrQQ9xQQBBgNSEgABBCGpBD3EbIgNqIgRBBGogAkFIaiIFIANrIgNBAXI2AgBBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAQYDUhIAAIAVqQTg2AgQLAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKI0ICAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQACQAJAIANBAXEgBHJBAXMiBUEDdCIEQbDQgIAAaiIDIARBuNCAgABqKAIAIgQoAggiAkcNAEEAIAZBfiAFd3E2AojQgIAADAELIAMgAjYCCCACIAM2AgwLIARBCGohAyAEIAVBA3QiBUEDcjYCBCAEIAVqIgQgBCgCBEEBcjYCBAwMCyACQQAoApDQgIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgRBA3QiA0Gw0ICAAGoiBSADQbjQgIAAaigCACIDKAIIIgBHDQBBACAGQX4gBHdxIgY2AojQgIAADAELIAUgADYCCCAAIAU2AgwLIAMgAkEDcjYCBCADIARBA3QiBGogBCACayIFNgIAIAMgAmoiACAFQQFyNgIEAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQQCQAJAIAZBASAHQQN2dCIIcQ0AQQAgBiAIcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIICyADQQhqIQNBACAANgKc0ICAAEEAIAU2ApDQgIAADAwLQQAoAozQgIAAIglFDQEgCUEAIAlrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqQQJ0QbjSgIAAaigCACIAKAIEQXhxIAJrIQQgACEFAkADQAJAIAUoAhAiAw0AIAVBFGooAgAiA0UNAgsgAygCBEF4cSACayIFIAQgBSAESSIFGyEEIAMgACAFGyEAIAMhBQwACwsgACgCGCEKAkAgACgCDCIIIABGDQAgACgCCCIDQQAoApjQgIAASRogCCADNgIIIAMgCDYCDAwLCwJAIABBFGoiBSgCACIDDQAgACgCECIDRQ0DIABBEGohBQsDQCAFIQsgAyIIQRRqIgUoAgAiAw0AIAhBEGohBSAIKAIQIgMNAAsgC0EANgIADAoLQX8hAiAAQb9/Sw0AIABBE2oiA0FwcSECQQAoAozQgIAAIgdFDQBBACELAkAgAkGAAkkNAEEfIQsgAkH///8HSw0AIANBCHYiAyADQYD+P2pBEHZBCHEiA3QiBCAEQYDgH2pBEHZBBHEiBHQiBSAFQYCAD2pBEHZBAnEiBXRBD3YgAyAEciAFcmsiA0EBdCACIANBFWp2QQFxckEcaiELC0EAIAJrIQQCQAJAAkACQCALQQJ0QbjSgIAAaigCACIFDQBBACEDQQAhCAwBC0EAIQMgAkEAQRkgC0EBdmsgC0EfRht0IQBBACEIA0ACQCAFKAIEQXhxIAJrIgYgBE8NACAGIQQgBSEIIAYNAEEAIQQgBSEIIAUhAwwDCyADIAVBFGooAgAiBiAGIAUgAEEddkEEcWpBEGooAgAiBUYbIAMgBhshAyAAQQF0IQAgBQ0ACwsCQCADIAhyDQBBACEIQQIgC3QiA0EAIANrciAHcSIDRQ0DIANBACADa3FBf2oiAyADQQx2QRBxIgN2IgVBBXZBCHEiACADciAFIAB2IgNBAnZBBHEiBXIgAyAFdiIDQQF2QQJxIgVyIAMgBXYiA0EBdkEBcSIFciADIAV2akECdEG40oCAAGooAgAhAwsgA0UNAQsDQCADKAIEQXhxIAJrIgYgBEkhAAJAIAMoAhAiBQ0AIANBFGooAgAhBQsgBiAEIAAbIQQgAyAIIAAbIQggBSEDIAUNAAsLIAhFDQAgBEEAKAKQ0ICAACACa08NACAIKAIYIQsCQCAIKAIMIgAgCEYNACAIKAIIIgNBACgCmNCAgABJGiAAIAM2AgggAyAANgIMDAkLAkAgCEEUaiIFKAIAIgMNACAIKAIQIgNFDQMgCEEQaiEFCwNAIAUhBiADIgBBFGoiBSgCACIDDQAgAEEQaiEFIAAoAhAiAw0ACyAGQQA2AgAMCAsCQEEAKAKQ0ICAACIDIAJJDQBBACgCnNCAgAAhBAJAAkAgAyACayIFQRBJDQAgBCACaiIAIAVBAXI2AgRBACAFNgKQ0ICAAEEAIAA2ApzQgIAAIAQgA2ogBTYCACAEIAJBA3I2AgQMAQsgBCADQQNyNgIEIAQgA2oiAyADKAIEQQFyNgIEQQBBADYCnNCAgABBAEEANgKQ0ICAAAsgBEEIaiEDDAoLAkBBACgClNCAgAAiACACTQ0AQQAoAqDQgIAAIgMgAmoiBCAAIAJrIgVBAXI2AgRBACAFNgKU0ICAAEEAIAQ2AqDQgIAAIAMgAkEDcjYCBCADQQhqIQMMCgsCQAJAQQAoAuDTgIAARQ0AQQAoAujTgIAAIQQMAQtBAEJ/NwLs04CAAEEAQoCAhICAgMAANwLk04CAAEEAIAFBDGpBcHFB2KrVqgVzNgLg04CAAEEAQQA2AvTTgIAAQQBBADYCxNOAgABBgIAEIQQLQQAhAwJAIAQgAkHHAGoiB2oiBkEAIARrIgtxIgggAksNAEEAQTA2AvjTgIAADAoLAkBBACgCwNOAgAAiA0UNAAJAQQAoArjTgIAAIgQgCGoiBSAETQ0AIAUgA00NAQtBACEDQQBBMDYC+NOAgAAMCgtBAC0AxNOAgABBBHENBAJAAkACQEEAKAKg0ICAACIERQ0AQcjTgIAAIQMDQAJAIAMoAgAiBSAESw0AIAUgAygCBGogBEsNAwsgAygCCCIDDQALC0EAEMuAgIAAIgBBf0YNBSAIIQYCQEEAKALk04CAACIDQX9qIgQgAHFFDQAgCCAAayAEIABqQQAgA2txaiEGCyAGIAJNDQUgBkH+////B0sNBQJAQQAoAsDTgIAAIgNFDQBBACgCuNOAgAAiBCAGaiIFIARNDQYgBSADSw0GCyAGEMuAgIAAIgMgAEcNAQwHCyAGIABrIAtxIgZB/v///wdLDQQgBhDLgICAACIAIAMoAgAgAygCBGpGDQMgACEDCwJAIANBf0YNACACQcgAaiAGTQ0AAkAgByAGa0EAKALo04CAACIEakEAIARrcSIEQf7///8HTQ0AIAMhAAwHCwJAIAQQy4CAgABBf0YNACAEIAZqIQYgAyEADAcLQQAgBmsQy4CAgAAaDAQLIAMhACADQX9HDQUMAwtBACEIDAcLQQAhAAwFCyAAQX9HDQILQQBBACgCxNOAgABBBHI2AsTTgIAACyAIQf7///8HSw0BIAgQy4CAgAAhAEEAEMuAgIAAIQMgAEF/Rg0BIANBf0YNASAAIANPDQEgAyAAayIGIAJBOGpNDQELQQBBACgCuNOAgAAgBmoiAzYCuNOAgAACQCADQQAoArzTgIAATQ0AQQAgAzYCvNOAgAALAkACQAJAAkBBACgCoNCAgAAiBEUNAEHI04CAACEDA0AgACADKAIAIgUgAygCBCIIakYNAiADKAIIIgMNAAwDCwsCQAJAQQAoApjQgIAAIgNFDQAgACADTw0BC0EAIAA2ApjQgIAAC0EAIQNBACAGNgLM04CAAEEAIAA2AsjTgIAAQQBBfzYCqNCAgABBAEEAKALg04CAADYCrNCAgABBAEEANgLU04CAAANAIANBxNCAgABqIANBuNCAgABqIgQ2AgAgBCADQbDQgIAAaiIFNgIAIANBvNCAgABqIAU2AgAgA0HM0ICAAGogA0HA0ICAAGoiBTYCACAFIAQ2AgAgA0HU0ICAAGogA0HI0ICAAGoiBDYCACAEIAU2AgAgA0HQ0ICAAGogBDYCACADQSBqIgNBgAJHDQALIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgQgBkFIaiIFIANrIgNBAXI2AgRBAEEAKALw04CAADYCpNCAgABBACADNgKU0ICAAEEAIAQ2AqDQgIAAIAAgBWpBODYCBAwCCyADLQAMQQhxDQAgBCAFSQ0AIAQgAE8NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoApTQgIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKALw04CAADYCpNCAgABBACAFNgKU0ICAAEEAIAA2AqDQgIAAIAQgC2pBODYCBAwBCwJAIABBACgCmNCAgAAiCE8NAEEAIAA2ApjQgIAAIAAhCAsgACAGaiEFQcjTgIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgBUYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtByNOAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiCyACQQNyNgIEIAVBeCAFa0EPcUEAIAVBCGpBD3EbaiIGIAsgAmoiAmshAwJAIAYgBEcNAEEAIAI2AqDQgIAAQQBBACgClNCAgAAgA2oiAzYClNCAgAAgAiADQQFyNgIEDAMLAkAgBkEAKAKc0ICAAEcNAEEAIAI2ApzQgIAAQQBBACgCkNCAgAAgA2oiAzYCkNCAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAYoAgQiBEEDcUEBRw0AIARBeHEhBwJAAkAgBEH/AUsNACAGKAIIIgUgBEEDdiIIQQN0QbDQgIAAaiIARhoCQCAGKAIMIgQgBUcNAEEAQQAoAojQgIAAQX4gCHdxNgKI0ICAAAwCCyAEIABGGiAEIAU2AgggBSAENgIMDAELIAYoAhghCQJAAkAgBigCDCIAIAZGDQAgBigCCCIEIAhJGiAAIAQ2AgggBCAANgIMDAELAkAgBkEUaiIEKAIAIgUNACAGQRBqIgQoAgAiBQ0AQQAhAAwBCwNAIAQhCCAFIgBBFGoiBCgCACIFDQAgAEEQaiEEIAAoAhAiBQ0ACyAIQQA2AgALIAlFDQACQAJAIAYgBigCHCIFQQJ0QbjSgIAAaiIEKAIARw0AIAQgADYCACAADQFBAEEAKAKM0ICAAEF+IAV3cTYCjNCAgAAMAgsgCUEQQRQgCSgCECAGRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgBigCECIERQ0AIAAgBDYCECAEIAA2AhgLIAYoAhQiBEUNACAAQRRqIAQ2AgAgBCAANgIYCyAHIANqIQMgBiAHaiIGKAIEIQQLIAYgBEF+cTYCBCACIANqIAM2AgAgAiADQQFyNgIEAkAgA0H/AUsNACADQXhxQbDQgIAAaiEEAkACQEEAKAKI0ICAACIFQQEgA0EDdnQiA3ENAEEAIAUgA3I2AojQgIAAIAQhAwwBCyAEKAIIIQMLIAMgAjYCDCAEIAI2AgggAiAENgIMIAIgAzYCCAwDC0EfIQQCQCADQf///wdLDQAgA0EIdiIEIARBgP4/akEQdkEIcSIEdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiAEIAVyIAByayIEQQF0IAMgBEEVanZBAXFyQRxqIQQLIAIgBDYCHCACQgA3AhAgBEECdEG40oCAAGohBQJAQQAoAozQgIAAIgBBASAEdCIIcQ0AIAUgAjYCAEEAIAAgCHI2AozQgIAAIAIgBTYCGCACIAI2AgggAiACNgIMDAMLIANBAEEZIARBAXZrIARBH0YbdCEEIAUoAgAhAANAIAAiBSgCBEF4cSADRg0CIARBHXYhACAEQQF0IQQgBSAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBTYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBkFIaiIIIANrIgNBAXI2AgQgACAIakE4NgIEIAQgBUE3IAVrQQ9xQQAgBUFJakEPcRtqQUFqIgggCCAEQRBqSRsiCEEjNgIEQQBBACgC8NOAgAA2AqTQgIAAQQAgAzYClNCAgABBACALNgKg0ICAACAIQRBqQQApAtDTgIAANwIAIAhBACkCyNOAgAA3AghBACAIQQhqNgLQ04CAAEEAIAY2AszTgIAAQQAgADYCyNOAgABBAEEANgLU04CAACAIQSRqIQMDQCADQQc2AgAgA0EEaiIDIAVJDQALIAggBEYNAyAIIAgoAgRBfnE2AgQgCCAIIARrIgA2AgAgBCAAQQFyNgIEAkAgAEH/AUsNACAAQXhxQbDQgIAAaiEDAkACQEEAKAKI0ICAACIFQQEgAEEDdnQiAHENAEEAIAUgAHI2AojQgIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAAQf///wdLDQAgAEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIIIAhBgIAPakEQdkECcSIIdEEPdiADIAVyIAhyayIDQQF0IAAgA0EVanZBAXFyQRxqIQMLIAQgAzYCHCAEQgA3AhAgA0ECdEG40oCAAGohBQJAQQAoAozQgIAAIghBASADdCIGcQ0AIAUgBDYCAEEAIAggBnI2AozQgIAAIAQgBTYCGCAEIAQ2AgggBCAENgIMDAQLIABBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhCANAIAgiBSgCBEF4cSAARg0DIANBHXYhCCADQQF0IQMgBSAIQQRxakEQaiIGKAIAIggNAAsgBiAENgIAIAQgBTYCGCAEIAQ2AgwgBCAENgIIDAMLIAUoAggiAyACNgIMIAUgAjYCCCACQQA2AhggAiAFNgIMIAIgAzYCCAsgC0EIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQQA2AhggBCAFNgIMIAQgAzYCCAtBACgClNCAgAAiAyACTQ0AQQAoAqDQgIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgKU0ICAAEEAIAU2AqDQgIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYC+NOAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEG40oCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKM0ICAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgCCADaiIDIAMoAgRBAXI2AgQMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEF4cUGw0ICAAGohAwJAAkBBACgCiNCAgAAiBUEBIARBA3Z0IgRxDQBBACAFIARyNgKI0ICAACADIQQMAQsgAygCCCEECyAEIAA2AgwgAyAANgIIIAAgAzYCDCAAIAQ2AggMAQtBHyEDAkAgBEH///8HSw0AIARBCHYiAyADQYD+P2pBEHZBCHEiA3QiBSAFQYDgH2pBEHZBBHEiBXQiAiACQYCAD2pBEHZBAnEiAnRBD3YgAyAFciACcmsiA0EBdCAEIANBFWp2QQFxckEcaiEDCyAAIAM2AhwgAEIANwIQIANBAnRBuNKAgABqIQUCQCAHQQEgA3QiAnENACAFIAA2AgBBACAHIAJyNgKM0ICAACAAIAU2AhggACAANgIIIAAgADYCDAwBCyAEQQBBGSADQQF2ayADQR9GG3QhAyAFKAIAIQICQANAIAIiBSgCBEF4cSAERg0BIANBHXYhAiADQQF0IQMgBSACQQRxakEQaiIGKAIAIgINAAsgBiAANgIAIAAgBTYCGCAAIAA2AgwgACAANgIIDAELIAUoAggiAyAANgIMIAUgADYCCCAAQQA2AhggACAFNgIMIAAgAzYCCAsgCEEIaiEDDAELAkAgCkUNAAJAAkAgACAAKAIcIgVBAnRBuNKAgABqIgMoAgBHDQAgAyAINgIAIAgNAUEAIAlBfiAFd3E2AozQgIAADAILIApBEEEUIAooAhAgAEYbaiAINgIAIAhFDQELIAggCjYCGAJAIAAoAhAiA0UNACAIIAM2AhAgAyAINgIYCyAAQRRqKAIAIgNFDQAgCEEUaiADNgIAIAMgCDYCGAsCQAJAIARBD0sNACAAIAQgAmoiA0EDcjYCBCAAIANqIgMgAygCBEEBcjYCBAwBCyAAIAJqIgUgBEEBcjYCBCAAIAJBA3I2AgQgBSAEaiAENgIAAkAgB0UNACAHQXhxQbDQgIAAaiECQQAoApzQgIAAIQMCQAJAQQEgB0EDdnQiCCAGcQ0AQQAgCCAGcjYCiNCAgAAgAiEIDAELIAIoAgghCAsgCCADNgIMIAIgAzYCCCADIAI2AgwgAyAINgIIC0EAIAU2ApzQgIAAQQAgBDYCkNCAgAALIABBCGohAwsgAUEQaiSAgICAACADCwoAIAAQyYCAgAAL4g0BB38CQCAARQ0AIABBeGoiASAAQXxqKAIAIgJBeHEiAGohAwJAIAJBAXENACACQQNxRQ0BIAEgASgCACICayIBQQAoApjQgIAAIgRJDQEgAiAAaiEAAkAgAUEAKAKc0ICAAEYNAAJAIAJB/wFLDQAgASgCCCIEIAJBA3YiBUEDdEGw0ICAAGoiBkYaAkAgASgCDCICIARHDQBBAEEAKAKI0ICAAEF+IAV3cTYCiNCAgAAMAwsgAiAGRhogAiAENgIIIAQgAjYCDAwCCyABKAIYIQcCQAJAIAEoAgwiBiABRg0AIAEoAggiAiAESRogBiACNgIIIAIgBjYCDAwBCwJAIAFBFGoiAigCACIEDQAgAUEQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0BAkACQCABIAEoAhwiBEECdEG40oCAAGoiAigCAEcNACACIAY2AgAgBg0BQQBBACgCjNCAgABBfiAEd3E2AozQgIAADAMLIAdBEEEUIAcoAhAgAUYbaiAGNgIAIAZFDQILIAYgBzYCGAJAIAEoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyABKAIUIgJFDQEgBkEUaiACNgIAIAIgBjYCGAwBCyADKAIEIgJBA3FBA0cNACADIAJBfnE2AgRBACAANgKQ0ICAACABIABqIAA2AgAgASAAQQFyNgIEDwsgASADTw0AIAMoAgQiAkEBcUUNAAJAAkAgAkECcQ0AAkAgA0EAKAKg0ICAAEcNAEEAIAE2AqDQgIAAQQBBACgClNCAgAAgAGoiADYClNCAgAAgASAAQQFyNgIEIAFBACgCnNCAgABHDQNBAEEANgKQ0ICAAEEAQQA2ApzQgIAADwsCQCADQQAoApzQgIAARw0AQQAgATYCnNCAgABBAEEAKAKQ0ICAACAAaiIANgKQ0ICAACABIABBAXI2AgQgASAAaiAANgIADwsgAkF4cSAAaiEAAkACQCACQf8BSw0AIAMoAggiBCACQQN2IgVBA3RBsNCAgABqIgZGGgJAIAMoAgwiAiAERw0AQQBBACgCiNCAgABBfiAFd3E2AojQgIAADAILIAIgBkYaIAIgBDYCCCAEIAI2AgwMAQsgAygCGCEHAkACQCADKAIMIgYgA0YNACADKAIIIgJBACgCmNCAgABJGiAGIAI2AgggAiAGNgIMDAELAkAgA0EUaiICKAIAIgQNACADQRBqIgIoAgAiBA0AQQAhBgwBCwNAIAIhBSAEIgZBFGoiAigCACIEDQAgBkEQaiECIAYoAhAiBA0ACyAFQQA2AgALIAdFDQACQAJAIAMgAygCHCIEQQJ0QbjSgIAAaiICKAIARw0AIAIgBjYCACAGDQFBAEEAKAKM0ICAAEF+IAR3cTYCjNCAgAAMAgsgB0EQQRQgBygCECADRhtqIAY2AgAgBkUNAQsgBiAHNgIYAkAgAygCECICRQ0AIAYgAjYCECACIAY2AhgLIAMoAhQiAkUNACAGQRRqIAI2AgAgAiAGNgIYCyABIABqIAA2AgAgASAAQQFyNgIEIAFBACgCnNCAgABHDQFBACAANgKQ0ICAAA8LIAMgAkF+cTYCBCABIABqIAA2AgAgASAAQQFyNgIECwJAIABB/wFLDQAgAEF4cUGw0ICAAGohAgJAAkBBACgCiNCAgAAiBEEBIABBA3Z0IgBxDQBBACAEIAByNgKI0ICAACACIQAMAQsgAigCCCEACyAAIAE2AgwgAiABNgIIIAEgAjYCDCABIAA2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAEgAjYCHCABQgA3AhAgAkECdEG40oCAAGohBAJAAkBBACgCjNCAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCjNCAgAAgASAENgIYIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABIAQ2AhggASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEANgIYIAEgBDYCDCABIAA2AggLQQBBACgCqNCAgABBf2oiAUF/IAEbNgKo0ICAAAsLBAAAAAtOAAJAIAANAD8AQRB0DwsCQCAAQf//A3ENACAAQX9MDQACQCAAQRB2QAAiAEF/Rw0AQQBBMDYC+NOAgABBfw8LIABBEHQPCxDKgICAAAAL8gICA38BfgJAIAJFDQAgACABOgAAIAIgAGoiA0F/aiABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBfWogAToAACADQX5qIAE6AAAgAkEHSQ0AIAAgAToAAyADQXxqIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIFayICQSBJDQAgAa1CgYCAgBB+IQYgAyAFaiEBA0AgASAGNwMYIAEgBjcDECABIAY3AwggASAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAALC45IAQBBgAgLhkgBAAAAAgAAAAMAAAAAAAAAAAAAAAQAAAAFAAAAAAAAAAAAAAAGAAAABwAAAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fcmVzZXRgIGNhbGxiYWNrIGVycm9yAGBvbl9jaHVua19oZWFkZXJgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
  },
  53434: (e) => {
    e.exports =
      "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
  },
  50172: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t.enumToMap = void 0;
    function enumToMap(e) {
      const t = {};
      Object.keys(e).forEach((r) => {
        const n = e[r];
        if (typeof n === "number") {
          t[r] = n;
        }
      });
      return t;
    }
    t.enumToMap = enumToMap;
  },
  47501: (e, t, r) => {
    const { kClients: n } = r(36443);
    const o = r(59965);
    const {
      kAgent: s,
      kMockAgentSet: i,
      kMockAgentGet: a,
      kDispatches: A,
      kIsMockActive: c,
      kNetConnect: u,
      kGetNetConnect: l,
      kOptions: p,
      kFactory: d,
    } = r(91117);
    const g = r(47365);
    const m = r(94004);
    const { matchValue: h, buildMockOptions: E } = r(53397);
    const { InvalidArgumentError: I, UndiciError: y } = r(68707);
    const C = r(28611);
    const b = r(91529);
    const Q = r(56142);
    class FakeWeakRef {
      constructor(e) {
        this.value = e;
      }
      deref() {
        return this.value;
      }
    }
    class MockAgent extends C {
      constructor(e) {
        super(e);
        this[u] = true;
        this[c] = true;
        if (e && e.agent && typeof e.agent.dispatch !== "function") {
          throw new I("Argument opts.agent must implement Agent");
        }
        const t = e && e.agent ? e.agent : new o(e);
        this[s] = t;
        this[n] = t[n];
        this[p] = E(e);
      }
      get(e) {
        let t = this[a](e);
        if (!t) {
          t = this[d](e);
          this[i](e, t);
        }
        return t;
      }
      dispatch(e, t) {
        this.get(e.origin);
        return this[s].dispatch(e, t);
      }
      async close() {
        await this[s].close();
        this[n].clear();
      }
      deactivate() {
        this[c] = false;
      }
      activate() {
        this[c] = true;
      }
      enableNetConnect(e) {
        if (typeof e === "string" || typeof e === "function" || e instanceof RegExp) {
          if (Array.isArray(this[u])) {
            this[u].push(e);
          } else {
            this[u] = [e];
          }
        } else if (typeof e === "undefined") {
          this[u] = true;
        } else {
          throw new I("Unsupported matcher. Must be one of String|Function|RegExp.");
        }
      }
      disableNetConnect() {
        this[u] = false;
      }
      get isMockActive() {
        return this[c];
      }
      [i](e, t) {
        this[n].set(e, new FakeWeakRef(t));
      }
      [d](e) {
        const t = Object.assign({ agent: this }, this[p]);
        return this[p] && this[p].connections === 1 ? new g(e, t) : new m(e, t);
      }
      [a](e) {
        const t = this[n].get(e);
        if (t) {
          return t.deref();
        }
        if (typeof e !== "string") {
          const t = this[d]("http://localhost:9999");
          this[i](e, t);
          return t;
        }
        for (const [t, r] of Array.from(this[n])) {
          const n = r.deref();
          if (n && typeof t !== "string" && h(t, e)) {
            const t = this[d](e);
            this[i](e, t);
            t[A] = n[A];
            return t;
          }
        }
      }
      [l]() {
        return this[u];
      }
      pendingInterceptors() {
        const e = this[n];
        return Array.from(e.entries())
          .flatMap(([e, t]) => t.deref()[A].map((t) => ({ ...t, origin: e })))
          .filter(({ pending: e }) => e);
      }
      assertNoPendingInterceptors({ pendingInterceptorsFormatter: e = new Q() } = {}) {
        const t = this.pendingInterceptors();
        if (t.length === 0) {
          return;
        }
        const r = new b("interceptor", "interceptors").pluralize(t.length);
        throw new y(`\n${r.count} ${r.noun} ${r.is} pending:\n\n${e.format(t)}\n`.trim());
      }
    }
    e.exports = MockAgent;
  },
  47365: (e, t, r) => {
    const { promisify: n } = r(39023);
    const o = r(86197);
    const { buildMockDispatch: s } = r(53397);
    const { kDispatches: i, kMockAgent: a, kClose: A, kOriginalClose: c, kOrigin: u, kOriginalDispatch: l, kConnected: p } = r(91117);
    const { MockInterceptor: d } = r(31511);
    const g = r(36443);
    const { InvalidArgumentError: m } = r(68707);
    class MockClient extends o {
      constructor(e, t) {
        super(e, t);
        if (!t || !t.agent || typeof t.agent.dispatch !== "function") {
          throw new m("Argument opts.agent must implement Agent");
        }
        this[a] = t.agent;
        this[u] = e;
        this[i] = [];
        this[p] = 1;
        this[l] = this.dispatch;
        this[c] = this.close.bind(this);
        this.dispatch = s.call(this);
        this.close = this[A];
      }
      get [g.kConnected]() {
        return this[p];
      }
      intercept(e) {
        return new d(e, this[i]);
      }
      async [A]() {
        await n(this[c])();
        this[p] = 0;
        this[a][g.kClients].delete(this[u]);
      }
    }
    e.exports = MockClient;
  },
  52429: (e, t, r) => {
    const { UndiciError: n } = r(68707);
    class MockNotMatchedError extends n {
      constructor(e) {
        super(e);
        Error.captureStackTrace(this, MockNotMatchedError);
        this.name = "MockNotMatchedError";
        this.message = e || "The request does not match any registered mock dispatches";
        this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED";
      }
    }
    e.exports = { MockNotMatchedError: MockNotMatchedError };
  },
  31511: (e, t, r) => {
    const { getResponseData: n, buildKey: o, addMockDispatch: s } = r(53397);
    const { kDispatches: i, kDispatchKey: a, kDefaultHeaders: A, kDefaultTrailers: c, kContentLength: u, kMockDispatch: l } = r(91117);
    const { InvalidArgumentError: p } = r(68707);
    const { buildURL: d } = r(3440);
    class MockScope {
      constructor(e) {
        this[l] = e;
      }
      delay(e) {
        if (typeof e !== "number" || !Number.isInteger(e) || e <= 0) {
          throw new p("waitInMs must be a valid integer > 0");
        }
        this[l].delay = e;
        return this;
      }
      persist() {
        this[l].persist = true;
        return this;
      }
      times(e) {
        if (typeof e !== "number" || !Number.isInteger(e) || e <= 0) {
          throw new p("repeatTimes must be a valid integer > 0");
        }
        this[l].times = e;
        return this;
      }
    }
    class MockInterceptor {
      constructor(e, t) {
        if (typeof e !== "object") {
          throw new p("opts must be an object");
        }
        if (typeof e.path === "undefined") {
          throw new p("opts.path must be defined");
        }
        if (typeof e.method === "undefined") {
          e.method = "GET";
        }
        if (typeof e.path === "string") {
          if (e.query) {
            e.path = d(e.path, e.query);
          } else {
            const t = new URL(e.path, "data://");
            e.path = t.pathname + t.search;
          }
        }
        if (typeof e.method === "string") {
          e.method = e.method.toUpperCase();
        }
        this[a] = o(e);
        this[i] = t;
        this[A] = {};
        this[c] = {};
        this[u] = false;
      }
      createMockScopeDispatchData(e, t, r = {}) {
        const o = n(t);
        const s = this[u] ? { "content-length": o.length } : {};
        const i = { ...this[A], ...s, ...r.headers };
        const a = { ...this[c], ...r.trailers };
        return { statusCode: e, data: t, headers: i, trailers: a };
      }
      validateReplyParameters(e, t, r) {
        if (typeof e === "undefined") {
          throw new p("statusCode must be defined");
        }
        if (typeof t === "undefined") {
          throw new p("data must be defined");
        }
        if (typeof r !== "object") {
          throw new p("responseOptions must be an object");
        }
      }
      reply(e) {
        if (typeof e === "function") {
          const wrappedDefaultsCallback = (t) => {
            const r = e(t);
            if (typeof r !== "object") {
              throw new p("reply options callback must return an object");
            }
            const { statusCode: n, data: o = "", responseOptions: s = {} } = r;
            this.validateReplyParameters(n, o, s);
            return { ...this.createMockScopeDispatchData(n, o, s) };
          };
          const t = s(this[i], this[a], wrappedDefaultsCallback);
          return new MockScope(t);
        }
        const [t, r = "", n = {}] = [...arguments];
        this.validateReplyParameters(t, r, n);
        const o = this.createMockScopeDispatchData(t, r, n);
        const A = s(this[i], this[a], o);
        return new MockScope(A);
      }
      replyWithError(e) {
        if (typeof e === "undefined") {
          throw new p("error must be defined");
        }
        const t = s(this[i], this[a], { error: e });
        return new MockScope(t);
      }
      defaultReplyHeaders(e) {
        if (typeof e === "undefined") {
          throw new p("headers must be defined");
        }
        this[A] = e;
        return this;
      }
      defaultReplyTrailers(e) {
        if (typeof e === "undefined") {
          throw new p("trailers must be defined");
        }
        this[c] = e;
        return this;
      }
      replyContentLength() {
        this[u] = true;
        return this;
      }
    }
    e.exports.MockInterceptor = MockInterceptor;
    e.exports.MockScope = MockScope;
  },
  94004: (e, t, r) => {
    const { promisify: n } = r(39023);
    const o = r(35076);
    const { buildMockDispatch: s } = r(53397);
    const { kDispatches: i, kMockAgent: a, kClose: A, kOriginalClose: c, kOrigin: u, kOriginalDispatch: l, kConnected: p } = r(91117);
    const { MockInterceptor: d } = r(31511);
    const g = r(36443);
    const { InvalidArgumentError: m } = r(68707);
    class MockPool extends o {
      constructor(e, t) {
        super(e, t);
        if (!t || !t.agent || typeof t.agent.dispatch !== "function") {
          throw new m("Argument opts.agent must implement Agent");
        }
        this[a] = t.agent;
        this[u] = e;
        this[i] = [];
        this[p] = 1;
        this[l] = this.dispatch;
        this[c] = this.close.bind(this);
        this.dispatch = s.call(this);
        this.close = this[A];
      }
      get [g.kConnected]() {
        return this[p];
      }
      intercept(e) {
        return new d(e, this[i]);
      }
      async [A]() {
        await n(this[c])();
        this[p] = 0;
        this[a][g.kClients].delete(this[u]);
      }
    }
    e.exports = MockPool;
  },
  91117: (e) => {
    e.exports = {
      kAgent: Symbol("agent"),
      kOptions: Symbol("options"),
      kFactory: Symbol("factory"),
      kDispatches: Symbol("dispatches"),
      kDispatchKey: Symbol("dispatch key"),
      kDefaultHeaders: Symbol("default headers"),
      kDefaultTrailers: Symbol("default trailers"),
      kContentLength: Symbol("content length"),
      kMockAgent: Symbol("mock agent"),
      kMockAgentSet: Symbol("mock agent set"),
      kMockAgentGet: Symbol("mock agent get"),
      kMockDispatch: Symbol("mock dispatch"),
      kClose: Symbol("close"),
      kOriginalClose: Symbol("original agent close"),
      kOrigin: Symbol("origin"),
      kIsMockActive: Symbol("is mock active"),
      kNetConnect: Symbol("net connect"),
      kGetNetConnect: Symbol("get net connect"),
      kConnected: Symbol("connected"),
    };
  },
  53397: (e, t, r) => {
    const { MockNotMatchedError: n } = r(52429);
    const { kDispatches: o, kMockAgent: s, kOriginalDispatch: i, kOrigin: a, kGetNetConnect: A } = r(91117);
    const { buildURL: c, nop: u } = r(3440);
    const { STATUS_CODES: l } = r(58611);
    const {
      types: { isPromise: p },
    } = r(39023);
    function matchValue(e, t) {
      if (typeof e === "string") {
        return e === t;
      }
      if (e instanceof RegExp) {
        return e.test(t);
      }
      if (typeof e === "function") {
        return e(t) === true;
      }
      return false;
    }
    function lowerCaseEntries(e) {
      return Object.fromEntries(Object.entries(e).map(([e, t]) => [e.toLocaleLowerCase(), t]));
    }
    function getHeaderByName(e, t) {
      if (Array.isArray(e)) {
        for (let r = 0; r < e.length; r += 2) {
          if (e[r].toLocaleLowerCase() === t.toLocaleLowerCase()) {
            return e[r + 1];
          }
        }
        return undefined;
      } else if (typeof e.get === "function") {
        return e.get(t);
      } else {
        return lowerCaseEntries(e)[t.toLocaleLowerCase()];
      }
    }
    function buildHeadersFromArray(e) {
      const t = e.slice();
      const r = [];
      for (let e = 0; e < t.length; e += 2) {
        r.push([t[e], t[e + 1]]);
      }
      return Object.fromEntries(r);
    }
    function matchHeaders(e, t) {
      if (typeof e.headers === "function") {
        if (Array.isArray(t)) {
          t = buildHeadersFromArray(t);
        }
        return e.headers(t ? lowerCaseEntries(t) : {});
      }
      if (typeof e.headers === "undefined") {
        return true;
      }
      if (typeof t !== "object" || typeof e.headers !== "object") {
        return false;
      }
      for (const [r, n] of Object.entries(e.headers)) {
        const e = getHeaderByName(t, r);
        if (!matchValue(n, e)) {
          return false;
        }
      }
      return true;
    }
    function safeUrl(e) {
      if (typeof e !== "string") {
        return e;
      }
      const t = e.split("?");
      if (t.length !== 2) {
        return e;
      }
      const r = new URLSearchParams(t.pop());
      r.sort();
      return [...t, r.toString()].join("?");
    }
    function matchKey(e, { path: t, method: r, body: n, headers: o }) {
      const s = matchValue(e.path, t);
      const i = matchValue(e.method, r);
      const a = typeof e.body !== "undefined" ? matchValue(e.body, n) : true;
      const A = matchHeaders(e, o);
      return s && i && a && A;
    }
    function getResponseData(e) {
      if (Buffer.isBuffer(e)) {
        return e;
      } else if (typeof e === "object") {
        return JSON.stringify(e);
      } else {
        return e.toString();
      }
    }
    function getMockDispatch(e, t) {
      const r = t.query ? c(t.path, t.query) : t.path;
      const o = typeof r === "string" ? safeUrl(r) : r;
      let s = e.filter(({ consumed: e }) => !e).filter(({ path: e }) => matchValue(safeUrl(e), o));
      if (s.length === 0) {
        throw new n(`Mock dispatch not matched for path '${o}'`);
      }
      s = s.filter(({ method: e }) => matchValue(e, t.method));
      if (s.length === 0) {
        throw new n(`Mock dispatch not matched for method '${t.method}'`);
      }
      s = s.filter(({ body: e }) => (typeof e !== "undefined" ? matchValue(e, t.body) : true));
      if (s.length === 0) {
        throw new n(`Mock dispatch not matched for body '${t.body}'`);
      }
      s = s.filter((e) => matchHeaders(e, t.headers));
      if (s.length === 0) {
        throw new n(`Mock dispatch not matched for headers '${typeof t.headers === "object" ? JSON.stringify(t.headers) : t.headers}'`);
      }
      return s[0];
    }
    function addMockDispatch(e, t, r) {
      const n = { timesInvoked: 0, times: 1, persist: false, consumed: false };
      const o = typeof r === "function" ? { callback: r } : { ...r };
      const s = { ...n, ...t, pending: true, data: { error: null, ...o } };
      e.push(s);
      return s;
    }
    function deleteMockDispatch(e, t) {
      const r = e.findIndex((e) => {
        if (!e.consumed) {
          return false;
        }
        return matchKey(e, t);
      });
      if (r !== -1) {
        e.splice(r, 1);
      }
    }
    function buildKey(e) {
      const { path: t, method: r, body: n, headers: o, query: s } = e;
      return { path: t, method: r, body: n, headers: o, query: s };
    }
    function generateKeyValues(e) {
      return Object.entries(e).reduce(
        (e, [t, r]) => [...e, Buffer.from(`${t}`), Array.isArray(r) ? r.map((e) => Buffer.from(`${e}`)) : Buffer.from(`${r}`)],
        []
      );
    }
    function getStatusText(e) {
      return l[e] || "unknown";
    }
    async function getResponse(e) {
      const t = [];
      for await (const r of e) {
        t.push(r);
      }
      return Buffer.concat(t).toString("utf8");
    }
    function mockDispatch(e, t) {
      const r = buildKey(e);
      const n = getMockDispatch(this[o], r);
      n.timesInvoked++;
      if (n.data.callback) {
        n.data = { ...n.data, ...n.data.callback(e) };
      }
      const {
        data: { statusCode: s, data: i, headers: a, trailers: A, error: c },
        delay: l,
        persist: d,
      } = n;
      const { timesInvoked: g, times: m } = n;
      n.consumed = !d && g >= m;
      n.pending = g < m;
      if (c !== null) {
        deleteMockDispatch(this[o], r);
        t.onError(c);
        return true;
      }
      if (typeof l === "number" && l > 0) {
        setTimeout(() => {
          handleReply(this[o]);
        }, l);
      } else {
        handleReply(this[o]);
      }
      function handleReply(n, o = i) {
        const c = Array.isArray(e.headers) ? buildHeadersFromArray(e.headers) : e.headers;
        const l = typeof o === "function" ? o({ ...e, headers: c }) : o;
        if (p(l)) {
          l.then((e) => handleReply(n, e));
          return;
        }
        const d = getResponseData(l);
        const g = generateKeyValues(a);
        const m = generateKeyValues(A);
        t.abort = u;
        t.onHeaders(s, g, resume, getStatusText(s));
        t.onData(Buffer.from(d));
        t.onComplete(m);
        deleteMockDispatch(n, r);
      }
      function resume() {}
      return true;
    }
    function buildMockDispatch() {
      const e = this[s];
      const t = this[a];
      const r = this[i];
      return function dispatch(o, s) {
        if (e.isMockActive) {
          try {
            mockDispatch.call(this, o, s);
          } catch (i) {
            if (i instanceof n) {
              const a = e[A]();
              if (a === false) {
                throw new n(`${i.message}: subsequent request to origin ${t} was not allowed (net.connect disabled)`);
              }
              if (checkNetConnect(a, t)) {
                r.call(this, o, s);
              } else {
                throw new n(`${i.message}: subsequent request to origin ${t} was not allowed (net.connect is not enabled for this origin)`);
              }
            } else {
              throw i;
            }
          }
        } else {
          r.call(this, o, s);
        }
      };
    }
    function checkNetConnect(e, t) {
      const r = new URL(t);
      if (e === true) {
        return true;
      } else if (Array.isArray(e) && e.some((e) => matchValue(e, r.host))) {
        return true;
      }
      return false;
    }
    function buildMockOptions(e) {
      if (e) {
        const { agent: t, ...r } = e;
        return r;
      }
    }
    e.exports = {
      getResponseData: getResponseData,
      getMockDispatch: getMockDispatch,
      addMockDispatch: addMockDispatch,
      deleteMockDispatch: deleteMockDispatch,
      buildKey: buildKey,
      generateKeyValues: generateKeyValues,
      matchValue: matchValue,
      getResponse: getResponse,
      getStatusText: getStatusText,
      mockDispatch: mockDispatch,
      buildMockDispatch: buildMockDispatch,
      checkNetConnect: checkNetConnect,
      buildMockOptions: buildMockOptions,
      getHeaderByName: getHeaderByName,
    };
  },
  56142: (e, t, r) => {
    const { Transform: n } = r(2203);
    const { Console: o } = r(64236);
    e.exports = class PendingInterceptorsFormatter {
      constructor({ disableColors: e } = {}) {
        this.transform = new n({
          transform(e, t, r) {
            r(null, e);
          },
        });
        this.logger = new o({ stdout: this.transform, inspectOptions: { colors: !e && !process.env.CI } });
      }
      format(e) {
        const t = e.map(({ method: e, path: t, data: { statusCode: r }, persist: n, times: o, timesInvoked: s, origin: i }) => ({
          Method: e,
          Origin: i,
          Path: t,
          "Status code": r,
          Persistent: n ? "✅" : "❌",
          Invocations: s,
          Remaining: n ? Infinity : o - s,
        }));
        this.logger.table(t);
        return this.transform.read().toString();
      }
    };
  },
  91529: (e) => {
    const t = { pronoun: "it", is: "is", was: "was", this: "this" };
    const r = { pronoun: "they", is: "are", was: "were", this: "these" };
    e.exports = class Pluralizer {
      constructor(e, t) {
        this.singular = e;
        this.plural = t;
      }
      pluralize(e) {
        const n = e === 1;
        const o = n ? t : r;
        const s = n ? this.singular : this.plural;
        return { ...o, count: e, noun: s };
      }
    };
  },
  34869: (e) => {
    const t = 2048;
    const r = t - 1;
    class FixedCircularBuffer {
      constructor() {
        this.bottom = 0;
        this.top = 0;
        this.list = new Array(t);
        this.next = null;
      }
      isEmpty() {
        return this.top === this.bottom;
      }
      isFull() {
        return ((this.top + 1) & r) === this.bottom;
      }
      push(e) {
        this.list[this.top] = e;
        this.top = (this.top + 1) & r;
      }
      shift() {
        const e = this.list[this.bottom];
        if (e === undefined) return null;
        this.list[this.bottom] = undefined;
        this.bottom = (this.bottom + 1) & r;
        return e;
      }
    }
    e.exports = class FixedQueue {
      constructor() {
        this.head = this.tail = new FixedCircularBuffer();
      }
      isEmpty() {
        return this.head.isEmpty();
      }
      push(e) {
        if (this.head.isFull()) {
          this.head = this.head.next = new FixedCircularBuffer();
        }
        this.head.push(e);
      }
      shift() {
        const e = this.tail;
        const t = e.shift();
        if (e.isEmpty() && e.next !== null) {
          this.tail = e.next;
        }
        return t;
      }
    };
  },
  58640: (e, t, r) => {
    const n = r(50001);
    const o = r(34869);
    const { kConnected: s, kSize: i, kRunning: a, kPending: A, kQueued: c, kBusy: u, kFree: l, kUrl: p, kClose: d, kDestroy: g, kDispatch: m } = r(36443);
    const h = r(24622);
    const E = Symbol("clients");
    const I = Symbol("needDrain");
    const y = Symbol("queue");
    const C = Symbol("closed resolve");
    const b = Symbol("onDrain");
    const Q = Symbol("onConnect");
    const B = Symbol("onDisconnect");
    const T = Symbol("onConnectionError");
    const v = Symbol("get dispatcher");
    const w = Symbol("add client");
    const _ = Symbol("remove client");
    const R = Symbol("stats");
    class PoolBase extends n {
      constructor() {
        super();
        this[y] = new o();
        this[E] = [];
        this[c] = 0;
        const e = this;
        this[b] = function onDrain(t, r) {
          const n = e[y];
          let o = false;
          while (!o) {
            const t = n.shift();
            if (!t) {
              break;
            }
            e[c]--;
            o = !this.dispatch(t.opts, t.handler);
          }
          this[I] = o;
          if (!this[I] && e[I]) {
            e[I] = false;
            e.emit("drain", t, [e, ...r]);
          }
          if (e[C] && n.isEmpty()) {
            Promise.all(e[E].map((e) => e.close())).then(e[C]);
          }
        };
        this[Q] = (t, r) => {
          e.emit("connect", t, [e, ...r]);
        };
        this[B] = (t, r, n) => {
          e.emit("disconnect", t, [e, ...r], n);
        };
        this[T] = (t, r, n) => {
          e.emit("connectionError", t, [e, ...r], n);
        };
        this[R] = new h(this);
      }
      get [u]() {
        return this[I];
      }
      get [s]() {
        return this[E].filter((e) => e[s]).length;
      }
      get [l]() {
        return this[E].filter((e) => e[s] && !e[I]).length;
      }
      get [A]() {
        let e = this[c];
        for (const { [A]: t } of this[E]) {
          e += t;
        }
        return e;
      }
      get [a]() {
        let e = 0;
        for (const { [a]: t } of this[E]) {
          e += t;
        }
        return e;
      }
      get [i]() {
        let e = this[c];
        for (const { [i]: t } of this[E]) {
          e += t;
        }
        return e;
      }
      get stats() {
        return this[R];
      }
      async [d]() {
        if (this[y].isEmpty()) {
          return Promise.all(this[E].map((e) => e.close()));
        } else {
          return new Promise((e) => {
            this[C] = e;
          });
        }
      }
      async [g](e) {
        while (true) {
          const t = this[y].shift();
          if (!t) {
            break;
          }
          t.handler.onError(e);
        }
        return Promise.all(this[E].map((t) => t.destroy(e)));
      }
      [m](e, t) {
        const r = this[v]();
        if (!r) {
          this[I] = true;
          this[y].push({ opts: e, handler: t });
          this[c]++;
        } else if (!r.dispatch(e, t)) {
          r[I] = true;
          this[I] = !this[v]();
        }
        return !this[I];
      }
      [w](e) {
        e.on("drain", this[b]).on("connect", this[Q]).on("disconnect", this[B]).on("connectionError", this[T]);
        this[E].push(e);
        if (this[I]) {
          process.nextTick(() => {
            if (this[I]) {
              this[b](e[p], [this, e]);
            }
          });
        }
        return this;
      }
      [_](e) {
        e.close(() => {
          const t = this[E].indexOf(e);
          if (t !== -1) {
            this[E].splice(t, 1);
          }
        });
        this[I] = this[E].some((e) => !e[I] && e.closed !== true && e.destroyed !== true);
      }
    }
    e.exports = { PoolBase: PoolBase, kClients: E, kNeedDrain: I, kAddClient: w, kRemoveClient: _, kGetDispatcher: v };
  },
  24622: (e, t, r) => {
    const { kFree: n, kConnected: o, kPending: s, kQueued: i, kRunning: a, kSize: A } = r(36443);
    const c = Symbol("pool");
    class PoolStats {
      constructor(e) {
        this[c] = e;
      }
      get connected() {
        return this[c][o];
      }
      get free() {
        return this[c][n];
      }
      get pending() {
        return this[c][s];
      }
      get queued() {
        return this[c][i];
      }
      get running() {
        return this[c][a];
      }
      get size() {
        return this[c][A];
      }
    }
    e.exports = PoolStats;
  },
  35076: (e, t, r) => {
    const { PoolBase: n, kClients: o, kNeedDrain: s, kAddClient: i, kGetDispatcher: a } = r(58640);
    const A = r(86197);
    const { InvalidArgumentError: c } = r(68707);
    const u = r(3440);
    const { kUrl: l, kInterceptors: p } = r(36443);
    const d = r(59136);
    const g = Symbol("options");
    const m = Symbol("connections");
    const h = Symbol("factory");
    function defaultFactory(e, t) {
      return new A(e, t);
    }
    class Pool extends n {
      constructor(
        e,
        {
          connections: t,
          factory: r = defaultFactory,
          connect: n,
          connectTimeout: o,
          tls: s,
          maxCachedSessions: i,
          socketPath: a,
          autoSelectFamily: A,
          autoSelectFamilyAttemptTimeout: E,
          allowH2: I,
          ...y
        } = {}
      ) {
        super();
        if (t != null && (!Number.isFinite(t) || t < 0)) {
          throw new c("invalid connections");
        }
        if (typeof r !== "function") {
          throw new c("factory must be a function.");
        }
        if (n != null && typeof n !== "function" && typeof n !== "object") {
          throw new c("connect must be a function or an object");
        }
        if (typeof n !== "function") {
          n = d({
            ...s,
            maxCachedSessions: i,
            allowH2: I,
            socketPath: a,
            timeout: o,
            ...(u.nodeHasAutoSelectFamily && A ? { autoSelectFamily: A, autoSelectFamilyAttemptTimeout: E } : undefined),
            ...n,
          });
        }
        this[p] = y.interceptors && y.interceptors.Pool && Array.isArray(y.interceptors.Pool) ? y.interceptors.Pool : [];
        this[m] = t || null;
        this[l] = u.parseOrigin(e);
        this[g] = { ...u.deepClone(y), connect: n, allowH2: I };
        this[g].interceptors = y.interceptors ? { ...y.interceptors } : undefined;
        this[h] = r;
      }
      [a]() {
        let e = this[o].find((e) => !e[s]);
        if (e) {
          return e;
        }
        if (!this[m] || this[o].length < this[m]) {
          e = this[h](this[l], this[g]);
          this[i](e);
        }
        return e;
      }
    }
    e.exports = Pool;
  },
  22720: (e, t, r) => {
    const { kProxy: n, kClose: o, kDestroy: s, kInterceptors: i } = r(36443);
    const { URL: a } = r(87016);
    const A = r(59965);
    const c = r(35076);
    const u = r(50001);
    const { InvalidArgumentError: l, RequestAbortedError: p } = r(68707);
    const d = r(59136);
    const g = Symbol("proxy agent");
    const m = Symbol("proxy client");
    const h = Symbol("proxy headers");
    const E = Symbol("request tls settings");
    const I = Symbol("proxy tls settings");
    const y = Symbol("connect endpoint function");
    function defaultProtocolPort(e) {
      return e === "https:" ? 443 : 80;
    }
    function buildProxyOptions(e) {
      if (typeof e === "string") {
        e = { uri: e };
      }
      if (!e || !e.uri) {
        throw new l("Proxy opts.uri is mandatory");
      }
      return { uri: e.uri, protocol: e.protocol || "https" };
    }
    function defaultFactory(e, t) {
      return new c(e, t);
    }
    class ProxyAgent extends u {
      constructor(e) {
        super(e);
        this[n] = buildProxyOptions(e);
        this[g] = new A(e);
        this[i] = e.interceptors && e.interceptors.ProxyAgent && Array.isArray(e.interceptors.ProxyAgent) ? e.interceptors.ProxyAgent : [];
        if (typeof e === "string") {
          e = { uri: e };
        }
        if (!e || !e.uri) {
          throw new l("Proxy opts.uri is mandatory");
        }
        const { clientFactory: t = defaultFactory } = e;
        if (typeof t !== "function") {
          throw new l("Proxy opts.clientFactory must be a function.");
        }
        this[E] = e.requestTls;
        this[I] = e.proxyTls;
        this[h] = e.headers || {};
        const r = new a(e.uri);
        const { origin: o, port: s, host: c, username: u, password: C } = r;
        if (e.auth && e.token) {
          throw new l("opts.auth cannot be used in combination with opts.token");
        } else if (e.auth) {
          this[h]["proxy-authorization"] = `Basic ${e.auth}`;
        } else if (e.token) {
          this[h]["proxy-authorization"] = e.token;
        } else if (u && C) {
          this[h]["proxy-authorization"] = `Basic ${Buffer.from(`${decodeURIComponent(u)}:${decodeURIComponent(C)}`).toString("base64")}`;
        }
        const b = d({ ...e.proxyTls });
        this[y] = d({ ...e.requestTls });
        this[m] = t(r, { connect: b });
        this[g] = new A({
          ...e,
          connect: async (e, t) => {
            let r = e.host;
            if (!e.port) {
              r += `:${defaultProtocolPort(e.protocol)}`;
            }
            try {
              const { socket: n, statusCode: i } = await this[m].connect({ origin: o, port: s, path: r, signal: e.signal, headers: { ...this[h], host: c } });
              if (i !== 200) {
                n.on("error", () => {}).destroy();
                t(new p(`Proxy response (${i}) !== 200 when HTTP Tunneling`));
              }
              if (e.protocol !== "https:") {
                t(null, n);
                return;
              }
              let a;
              if (this[E]) {
                a = this[E].servername;
              } else {
                a = e.servername;
              }
              this[y]({ ...e, servername: a, httpSocket: n }, t);
            } catch (e) {
              t(e);
            }
          },
        });
      }
      dispatch(e, t) {
        const { host: r } = new a(e.origin);
        const n = buildHeaders(e.headers);
        throwIfProxyAuthIsSent(n);
        return this[g].dispatch({ ...e, headers: { ...n, host: r } }, t);
      }
      async [o]() {
        await this[g].close();
        await this[m].close();
      }
      async [s]() {
        await this[g].destroy();
        await this[m].destroy();
      }
    }
    function buildHeaders(e) {
      if (Array.isArray(e)) {
        const t = {};
        for (let r = 0; r < e.length; r += 2) {
          t[e[r]] = e[r + 1];
        }
        return t;
      }
      return e;
    }
    function throwIfProxyAuthIsSent(e) {
      const t = e && Object.keys(e).find((e) => e.toLowerCase() === "proxy-authorization");
      if (t) {
        throw new l("Proxy-Authorization should be sent in ProxyAgent constructor");
      }
    }
    e.exports = ProxyAgent;
  },
  28804: (e) => {
    let t = Date.now();
    let r;
    const n = [];
    function onTimeout() {
      t = Date.now();
      let e = n.length;
      let r = 0;
      while (r < e) {
        const o = n[r];
        if (o.state === 0) {
          o.state = t + o.delay;
        } else if (o.state > 0 && t >= o.state) {
          o.state = -1;
          o.callback(o.opaque);
        }
        if (o.state === -1) {
          o.state = -2;
          if (r !== e - 1) {
            n[r] = n.pop();
          } else {
            n.pop();
          }
          e -= 1;
        } else {
          r += 1;
        }
      }
      if (n.length > 0) {
        refreshTimeout();
      }
    }
    function refreshTimeout() {
      if (r && r.refresh) {
        r.refresh();
      } else {
        clearTimeout(r);
        r = setTimeout(onTimeout, 1e3);
        if (r.unref) {
          r.unref();
        }
      }
    }
    class Timeout {
      constructor(e, t, r) {
        this.callback = e;
        this.delay = t;
        this.opaque = r;
        this.state = -2;
        this.refresh();
      }
      refresh() {
        if (this.state === -2) {
          n.push(this);
          if (!r || n.length === 1) {
            refreshTimeout();
          }
        }
        this.state = 0;
      }
      clear() {
        this.state = -1;
      }
    }
    e.exports = {
      setTimeout(e, t, r) {
        return t < 1e3 ? setTimeout(e, t, r) : new Timeout(e, t, r);
      },
      clearTimeout(e) {
        if (e instanceof Timeout) {
          e.clear();
        } else {
          clearTimeout(e);
        }
      },
    };
  },
  68550: (e, t, r) => {
    const n = r(31637);
    const { uid: o, states: s } = r(45913);
    const { kReadyState: i, kSentClose: a, kByteParser: A, kReceivedClose: c } = r(62933);
    const { fireEvent: u, failWebsocketConnection: l } = r(3574);
    const { CloseEvent: p } = r(46255);
    const { makeRequest: d } = r(25194);
    const { fetching: g } = r(12315);
    const { Headers: m } = r(26349);
    const { getGlobalDispatcher: h } = r(32581);
    const { kHeadersList: E } = r(36443);
    const I = {};
    I.open = n.channel("undici:websocket:open");
    I.close = n.channel("undici:websocket:close");
    I.socketError = n.channel("undici:websocket:socket_error");
    let y;
    try {
      y = r(76982);
    } catch {}
    function establishWebSocketConnection(e, t, r, n, s) {
      const i = e;
      i.protocol = e.protocol === "ws:" ? "http:" : "https:";
      const a = d({
        urlList: [i],
        serviceWorkers: "none",
        referrer: "no-referrer",
        mode: "websocket",
        credentials: "include",
        cache: "no-store",
        redirect: "error",
      });
      if (s.headers) {
        const e = new m(s.headers)[E];
        a.headersList = e;
      }
      const A = y.randomBytes(16).toString("base64");
      a.headersList.append("sec-websocket-key", A);
      a.headersList.append("sec-websocket-version", "13");
      for (const e of t) {
        a.headersList.append("sec-websocket-protocol", e);
      }
      const c = "";
      const u = g({
        request: a,
        useParallelQueue: true,
        dispatcher: s.dispatcher ?? h(),
        processResponse(e) {
          if (e.type === "error" || e.status !== 101) {
            l(r, "Received network error or non-101 status code.");
            return;
          }
          if (t.length !== 0 && !e.headersList.get("Sec-WebSocket-Protocol")) {
            l(r, "Server did not respond with sent protocols.");
            return;
          }
          if (e.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
            l(r, 'Server did not set Upgrade header to "websocket".');
            return;
          }
          if (e.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
            l(r, 'Server did not set Connection header to "upgrade".');
            return;
          }
          const s = e.headersList.get("Sec-WebSocket-Accept");
          const i = y
            .createHash("sha1")
            .update(A + o)
            .digest("base64");
          if (s !== i) {
            l(r, "Incorrect hash received in Sec-WebSocket-Accept header.");
            return;
          }
          const u = e.headersList.get("Sec-WebSocket-Extensions");
          if (u !== null && u !== c) {
            l(r, "Received different permessage-deflate than the one set.");
            return;
          }
          const p = e.headersList.get("Sec-WebSocket-Protocol");
          if (p !== null && p !== a.headersList.get("Sec-WebSocket-Protocol")) {
            l(r, "Protocol was not set in the opening handshake.");
            return;
          }
          e.socket.on("data", onSocketData);
          e.socket.on("close", onSocketClose);
          e.socket.on("error", onSocketError);
          if (I.open.hasSubscribers) {
            I.open.publish({ address: e.socket.address(), protocol: p, extensions: u });
          }
          n(e);
        },
      });
      return u;
    }
    function onSocketData(e) {
      if (!this.ws[A].write(e)) {
        this.pause();
      }
    }
    function onSocketClose() {
      const { ws: e } = this;
      const t = e[a] && e[c];
      let r = 1005;
      let n = "";
      const o = e[A].closingInfo;
      if (o) {
        r = o.code ?? 1005;
        n = o.reason;
      } else if (!e[a]) {
        r = 1006;
      }
      e[i] = s.CLOSED;
      u("close", e, p, { wasClean: t, code: r, reason: n });
      if (I.close.hasSubscribers) {
        I.close.publish({ websocket: e, code: r, reason: n });
      }
    }
    function onSocketError(e) {
      const { ws: t } = this;
      t[i] = s.CLOSING;
      if (I.socketError.hasSubscribers) {
        I.socketError.publish(e);
      }
      this.destroy();
    }
    e.exports = { establishWebSocketConnection: establishWebSocketConnection };
  },
  45913: (e) => {
    const t = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    const r = { enumerable: true, writable: false, configurable: false };
    const n = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 };
    const o = { CONTINUATION: 0, TEXT: 1, BINARY: 2, CLOSE: 8, PING: 9, PONG: 10 };
    const s = 2 ** 16 - 1;
    const i = { INFO: 0, PAYLOADLENGTH_16: 2, PAYLOADLENGTH_64: 3, READ_DATA: 4 };
    const a = Buffer.allocUnsafe(0);
    e.exports = { uid: t, staticPropertyDescriptors: r, states: n, opcodes: o, maxUnsigned16Bit: s, parserStates: i, emptyBuffer: a };
  },
  46255: (e, t, r) => {
    const { webidl: n } = r(74222);
    const { kEnumerableProperty: o } = r(3440);
    const { MessagePort: s } = r(28167);
    class MessageEvent extends Event {
      #s;
      constructor(e, t = {}) {
        n.argumentLengthCheck(arguments, 1, { header: "MessageEvent constructor" });
        e = n.converters.DOMString(e);
        t = n.converters.MessageEventInit(t);
        super(e, t);
        this.#s = t;
      }
      get data() {
        n.brandCheck(this, MessageEvent);
        return this.#s.data;
      }
      get origin() {
        n.brandCheck(this, MessageEvent);
        return this.#s.origin;
      }
      get lastEventId() {
        n.brandCheck(this, MessageEvent);
        return this.#s.lastEventId;
      }
      get source() {
        n.brandCheck(this, MessageEvent);
        return this.#s.source;
      }
      get ports() {
        n.brandCheck(this, MessageEvent);
        if (!Object.isFrozen(this.#s.ports)) {
          Object.freeze(this.#s.ports);
        }
        return this.#s.ports;
      }
      initMessageEvent(e, t = false, r = false, o = null, s = "", i = "", a = null, A = []) {
        n.brandCheck(this, MessageEvent);
        n.argumentLengthCheck(arguments, 1, { header: "MessageEvent.initMessageEvent" });
        return new MessageEvent(e, { bubbles: t, cancelable: r, data: o, origin: s, lastEventId: i, source: a, ports: A });
      }
    }
    class CloseEvent extends Event {
      #s;
      constructor(e, t = {}) {
        n.argumentLengthCheck(arguments, 1, { header: "CloseEvent constructor" });
        e = n.converters.DOMString(e);
        t = n.converters.CloseEventInit(t);
        super(e, t);
        this.#s = t;
      }
      get wasClean() {
        n.brandCheck(this, CloseEvent);
        return this.#s.wasClean;
      }
      get code() {
        n.brandCheck(this, CloseEvent);
        return this.#s.code;
      }
      get reason() {
        n.brandCheck(this, CloseEvent);
        return this.#s.reason;
      }
    }
    class ErrorEvent extends Event {
      #s;
      constructor(e, t) {
        n.argumentLengthCheck(arguments, 1, { header: "ErrorEvent constructor" });
        super(e, t);
        e = n.converters.DOMString(e);
        t = n.converters.ErrorEventInit(t ?? {});
        this.#s = t;
      }
      get message() {
        n.brandCheck(this, ErrorEvent);
        return this.#s.message;
      }
      get filename() {
        n.brandCheck(this, ErrorEvent);
        return this.#s.filename;
      }
      get lineno() {
        n.brandCheck(this, ErrorEvent);
        return this.#s.lineno;
      }
      get colno() {
        n.brandCheck(this, ErrorEvent);
        return this.#s.colno;
      }
      get error() {
        n.brandCheck(this, ErrorEvent);
        return this.#s.error;
      }
    }
    Object.defineProperties(MessageEvent.prototype, {
      [Symbol.toStringTag]: { value: "MessageEvent", configurable: true },
      data: o,
      origin: o,
      lastEventId: o,
      source: o,
      ports: o,
      initMessageEvent: o,
    });
    Object.defineProperties(CloseEvent.prototype, { [Symbol.toStringTag]: { value: "CloseEvent", configurable: true }, reason: o, code: o, wasClean: o });
    Object.defineProperties(ErrorEvent.prototype, {
      [Symbol.toStringTag]: { value: "ErrorEvent", configurable: true },
      message: o,
      filename: o,
      lineno: o,
      colno: o,
      error: o,
    });
    n.converters.MessagePort = n.interfaceConverter(s);
    n.converters["sequence<MessagePort>"] = n.sequenceConverter(n.converters.MessagePort);
    const i = [
      { key: "bubbles", converter: n.converters.boolean, defaultValue: false },
      { key: "cancelable", converter: n.converters.boolean, defaultValue: false },
      { key: "composed", converter: n.converters.boolean, defaultValue: false },
    ];
    n.converters.MessageEventInit = n.dictionaryConverter([
      ...i,
      { key: "data", converter: n.converters.any, defaultValue: null },
      { key: "origin", converter: n.converters.USVString, defaultValue: "" },
      { key: "lastEventId", converter: n.converters.DOMString, defaultValue: "" },
      { key: "source", converter: n.nullableConverter(n.converters.MessagePort), defaultValue: null },
      {
        key: "ports",
        converter: n.converters["sequence<MessagePort>"],
        get defaultValue() {
          return [];
        },
      },
    ]);
    n.converters.CloseEventInit = n.dictionaryConverter([
      ...i,
      { key: "wasClean", converter: n.converters.boolean, defaultValue: false },
      { key: "code", converter: n.converters["unsigned short"], defaultValue: 0 },
      { key: "reason", converter: n.converters.USVString, defaultValue: "" },
    ]);
    n.converters.ErrorEventInit = n.dictionaryConverter([
      ...i,
      { key: "message", converter: n.converters.DOMString, defaultValue: "" },
      { key: "filename", converter: n.converters.USVString, defaultValue: "" },
      { key: "lineno", converter: n.converters["unsigned long"], defaultValue: 0 },
      { key: "colno", converter: n.converters["unsigned long"], defaultValue: 0 },
      { key: "error", converter: n.converters.any },
    ]);
    e.exports = { MessageEvent: MessageEvent, CloseEvent: CloseEvent, ErrorEvent: ErrorEvent };
  },
  31237: (e, t, r) => {
    const { maxUnsigned16Bit: n } = r(45913);
    let o;
    try {
      o = r(76982);
    } catch {}
    class WebsocketFrameSend {
      constructor(e) {
        this.frameData = e;
        this.maskKey = o.randomBytes(4);
      }
      createFrame(e) {
        const t = this.frameData?.byteLength ?? 0;
        let r = t;
        let o = 6;
        if (t > n) {
          o += 8;
          r = 127;
        } else if (t > 125) {
          o += 2;
          r = 126;
        }
        const s = Buffer.allocUnsafe(t + o);
        s[0] = s[1] = 0;
        s[0] |= 128;
        s[0] = (s[0] & 240) + e;
        /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */ s[o - 4] = this.maskKey[0];
        s[o - 3] = this.maskKey[1];
        s[o - 2] = this.maskKey[2];
        s[o - 1] = this.maskKey[3];
        s[1] = r;
        if (r === 126) {
          s.writeUInt16BE(t, 2);
        } else if (r === 127) {
          s[2] = s[3] = 0;
          s.writeUIntBE(t, 4, 6);
        }
        s[1] |= 128;
        for (let e = 0; e < t; e++) {
          s[o + e] = this.frameData[e] ^ this.maskKey[e % 4];
        }
        return s;
      }
    }
    e.exports = { WebsocketFrameSend: WebsocketFrameSend };
  },
  43171: (e, t, r) => {
    const { Writable: n } = r(2203);
    const o = r(31637);
    const { parserStates: s, opcodes: i, states: a, emptyBuffer: A } = r(45913);
    const { kReadyState: c, kSentClose: u, kResponse: l, kReceivedClose: p } = r(62933);
    const { isValidStatusCode: d, failWebsocketConnection: g, websocketMessageReceived: m } = r(3574);
    const { WebsocketFrameSend: h } = r(31237);
    const E = {};
    E.ping = o.channel("undici:websocket:ping");
    E.pong = o.channel("undici:websocket:pong");
    class ByteParser extends n {
      #i = [];
      #a = 0;
      #A = s.INFO;
      #c = {};
      #u = [];
      constructor(e) {
        super();
        this.ws = e;
      }
      _write(e, t, r) {
        this.#i.push(e);
        this.#a += e.length;
        this.run(r);
      }
      run(e) {
        while (true) {
          if (this.#A === s.INFO) {
            if (this.#a < 2) {
              return e();
            }
            const t = this.consume(2);
            this.#c.fin = (t[0] & 128) !== 0;
            this.#c.opcode = t[0] & 15;
            this.#c.originalOpcode ??= this.#c.opcode;
            this.#c.fragmented = !this.#c.fin && this.#c.opcode !== i.CONTINUATION;
            if (this.#c.fragmented && this.#c.opcode !== i.BINARY && this.#c.opcode !== i.TEXT) {
              g(this.ws, "Invalid frame type was fragmented.");
              return;
            }
            const r = t[1] & 127;
            if (r <= 125) {
              this.#c.payloadLength = r;
              this.#A = s.READ_DATA;
            } else if (r === 126) {
              this.#A = s.PAYLOADLENGTH_16;
            } else if (r === 127) {
              this.#A = s.PAYLOADLENGTH_64;
            }
            if (this.#c.fragmented && r > 125) {
              g(this.ws, "Fragmented frame exceeded 125 bytes.");
              return;
            } else if ((this.#c.opcode === i.PING || this.#c.opcode === i.PONG || this.#c.opcode === i.CLOSE) && r > 125) {
              g(this.ws, "Payload length for control frame exceeded 125 bytes.");
              return;
            } else if (this.#c.opcode === i.CLOSE) {
              if (r === 1) {
                g(this.ws, "Received close frame with a 1-byte body.");
                return;
              }
              const e = this.consume(r);
              this.#c.closeInfo = this.parseCloseBody(false, e);
              if (!this.ws[u]) {
                const e = Buffer.allocUnsafe(2);
                e.writeUInt16BE(this.#c.closeInfo.code, 0);
                const t = new h(e);
                this.ws[l].socket.write(t.createFrame(i.CLOSE), (e) => {
                  if (!e) {
                    this.ws[u] = true;
                  }
                });
              }
              this.ws[c] = a.CLOSING;
              this.ws[p] = true;
              this.end();
              return;
            } else if (this.#c.opcode === i.PING) {
              const t = this.consume(r);
              if (!this.ws[p]) {
                const e = new h(t);
                this.ws[l].socket.write(e.createFrame(i.PONG));
                if (E.ping.hasSubscribers) {
                  E.ping.publish({ payload: t });
                }
              }
              this.#A = s.INFO;
              if (this.#a > 0) {
                continue;
              } else {
                e();
                return;
              }
            } else if (this.#c.opcode === i.PONG) {
              const t = this.consume(r);
              if (E.pong.hasSubscribers) {
                E.pong.publish({ payload: t });
              }
              if (this.#a > 0) {
                continue;
              } else {
                e();
                return;
              }
            }
          } else if (this.#A === s.PAYLOADLENGTH_16) {
            if (this.#a < 2) {
              return e();
            }
            const t = this.consume(2);
            this.#c.payloadLength = t.readUInt16BE(0);
            this.#A = s.READ_DATA;
          } else if (this.#A === s.PAYLOADLENGTH_64) {
            if (this.#a < 8) {
              return e();
            }
            const t = this.consume(8);
            const r = t.readUInt32BE(0);
            if (r > 2 ** 31 - 1) {
              g(this.ws, "Received payload length > 2^31 bytes.");
              return;
            }
            const n = t.readUInt32BE(4);
            this.#c.payloadLength = (r << 8) + n;
            this.#A = s.READ_DATA;
          } else if (this.#A === s.READ_DATA) {
            if (this.#a < this.#c.payloadLength) {
              return e();
            } else if (this.#a >= this.#c.payloadLength) {
              const e = this.consume(this.#c.payloadLength);
              this.#u.push(e);
              if (!this.#c.fragmented || (this.#c.fin && this.#c.opcode === i.CONTINUATION)) {
                const e = Buffer.concat(this.#u);
                m(this.ws, this.#c.originalOpcode, e);
                this.#c = {};
                this.#u.length = 0;
              }
              this.#A = s.INFO;
            }
          }
          if (this.#a > 0) {
            continue;
          } else {
            e();
            break;
          }
        }
      }
      consume(e) {
        if (e > this.#a) {
          return null;
        } else if (e === 0) {
          return A;
        }
        if (this.#i[0].length === e) {
          this.#a -= this.#i[0].length;
          return this.#i.shift();
        }
        const t = Buffer.allocUnsafe(e);
        let r = 0;
        while (r !== e) {
          const n = this.#i[0];
          const { length: o } = n;
          if (o + r === e) {
            t.set(this.#i.shift(), r);
            break;
          } else if (o + r > e) {
            t.set(n.subarray(0, e - r), r);
            this.#i[0] = n.subarray(e - r);
            break;
          } else {
            t.set(this.#i.shift(), r);
            r += n.length;
          }
        }
        this.#a -= e;
        return t;
      }
      parseCloseBody(e, t) {
        let r;
        if (t.length >= 2) {
          r = t.readUInt16BE(0);
        }
        if (e) {
          if (!d(r)) {
            return null;
          }
          return { code: r };
        }
        let n = t.subarray(2);
        if (n[0] === 239 && n[1] === 187 && n[2] === 191) {
          n = n.subarray(3);
        }
        if (r !== undefined && !d(r)) {
          return null;
        }
        try {
          n = new TextDecoder("utf-8", { fatal: true }).decode(n);
        } catch {
          return null;
        }
        return { code: r, reason: n };
      }
      get closingInfo() {
        return this.#c.closeInfo;
      }
    }
    e.exports = { ByteParser: ByteParser };
  },
  62933: (e) => {
    e.exports = {
      kWebSocketURL: Symbol("url"),
      kReadyState: Symbol("ready state"),
      kController: Symbol("controller"),
      kResponse: Symbol("response"),
      kBinaryType: Symbol("binary type"),
      kSentClose: Symbol("sent close"),
      kReceivedClose: Symbol("received close"),
      kByteParser: Symbol("byte parser"),
    };
  },
  3574: (e, t, r) => {
    const { kReadyState: n, kController: o, kResponse: s, kBinaryType: i, kWebSocketURL: a } = r(62933);
    const { states: A, opcodes: c } = r(45913);
    const { MessageEvent: u, ErrorEvent: l } = r(46255);
    function isEstablished(e) {
      return e[n] === A.OPEN;
    }
    function isClosing(e) {
      return e[n] === A.CLOSING;
    }
    function isClosed(e) {
      return e[n] === A.CLOSED;
    }
    function fireEvent(e, t, r = Event, n) {
      const o = new r(e, n);
      t.dispatchEvent(o);
    }
    function websocketMessageReceived(e, t, r) {
      if (e[n] !== A.OPEN) {
        return;
      }
      let o;
      if (t === c.TEXT) {
        try {
          o = new TextDecoder("utf-8", { fatal: true }).decode(r);
        } catch {
          failWebsocketConnection(e, "Received invalid UTF-8 in text frame.");
          return;
        }
      } else if (t === c.BINARY) {
        if (e[i] === "blob") {
          o = new Blob([r]);
        } else {
          o = new Uint8Array(r).buffer;
        }
      }
      fireEvent("message", e, u, { origin: e[a].origin, data: o });
    }
    function isValidSubprotocol(e) {
      if (e.length === 0) {
        return false;
      }
      for (const t of e) {
        const e = t.charCodeAt(0);
        if (
          e < 33 ||
          e > 126 ||
          t === "(" ||
          t === ")" ||
          t === "<" ||
          t === ">" ||
          t === "@" ||
          t === "," ||
          t === ";" ||
          t === ":" ||
          t === "\\" ||
          t === '"' ||
          t === "/" ||
          t === "[" ||
          t === "]" ||
          t === "?" ||
          t === "=" ||
          t === "{" ||
          t === "}" ||
          e === 32 ||
          e === 9
        ) {
          return false;
        }
      }
      return true;
    }
    function isValidStatusCode(e) {
      if (e >= 1e3 && e < 1015) {
        return e !== 1004 && e !== 1005 && e !== 1006;
      }
      return e >= 3e3 && e <= 4999;
    }
    function failWebsocketConnection(e, t) {
      const { [o]: r, [s]: n } = e;
      r.abort();
      if (n?.socket && !n.socket.destroyed) {
        n.socket.destroy();
      }
      if (t) {
        fireEvent("error", e, l, { error: new Error(t) });
      }
    }
    e.exports = {
      isEstablished: isEstablished,
      isClosing: isClosing,
      isClosed: isClosed,
      fireEvent: fireEvent,
      isValidSubprotocol: isValidSubprotocol,
      isValidStatusCode: isValidStatusCode,
      failWebsocketConnection: failWebsocketConnection,
      websocketMessageReceived: websocketMessageReceived,
    };
  },
  55171: (e, t, r) => {
    const { webidl: n } = r(74222);
    const { DOMException: o } = r(87326);
    const { URLSerializer: s } = r(94322);
    const { getGlobalOrigin: i } = r(75628);
    const { staticPropertyDescriptors: a, states: A, opcodes: c, emptyBuffer: u } = r(45913);
    const { kWebSocketURL: l, kReadyState: p, kController: d, kBinaryType: g, kResponse: m, kSentClose: h, kByteParser: E } = r(62933);
    const { isEstablished: I, isClosing: y, isValidSubprotocol: C, failWebsocketConnection: b, fireEvent: Q } = r(3574);
    const { establishWebSocketConnection: B } = r(68550);
    const { WebsocketFrameSend: T } = r(31237);
    const { ByteParser: v } = r(43171);
    const { kEnumerableProperty: w, isBlobLike: _ } = r(3440);
    const { getGlobalDispatcher: R } = r(32581);
    const { types: O } = r(39023);
    let F = false;
    class WebSocket extends EventTarget {
      #l = { open: null, error: null, close: null, message: null };
      #p = 0;
      #d = "";
      #f = "";
      constructor(e, t = []) {
        super();
        n.argumentLengthCheck(arguments, 1, { header: "WebSocket constructor" });
        if (!F) {
          F = true;
          process.emitWarning("WebSockets are experimental, expect them to change at any time.", { code: "UNDICI-WS" });
        }
        const r = n.converters["DOMString or sequence<DOMString> or WebSocketInit"](t);
        e = n.converters.USVString(e);
        t = r.protocols;
        const s = i();
        let a;
        try {
          a = new URL(e, s);
        } catch (e) {
          throw new o(e, "SyntaxError");
        }
        if (a.protocol === "http:") {
          a.protocol = "ws:";
        } else if (a.protocol === "https:") {
          a.protocol = "wss:";
        }
        if (a.protocol !== "ws:" && a.protocol !== "wss:") {
          throw new o(`Expected a ws: or wss: protocol, got ${a.protocol}`, "SyntaxError");
        }
        if (a.hash || a.href.endsWith("#")) {
          throw new o("Got fragment", "SyntaxError");
        }
        if (typeof t === "string") {
          t = [t];
        }
        if (t.length !== new Set(t.map((e) => e.toLowerCase())).size) {
          throw new o("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        if (t.length > 0 && !t.every((e) => C(e))) {
          throw new o("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
        }
        this[l] = new URL(a.href);
        this[d] = B(a, t, this, (e) => this.#g(e), r);
        this[p] = WebSocket.CONNECTING;
        this[g] = "blob";
      }
      close(e = undefined, t = undefined) {
        n.brandCheck(this, WebSocket);
        if (e !== undefined) {
          e = n.converters["unsigned short"](e, { clamp: true });
        }
        if (t !== undefined) {
          t = n.converters.USVString(t);
        }
        if (e !== undefined) {
          if (e !== 1e3 && (e < 3e3 || e > 4999)) {
            throw new o("invalid code", "InvalidAccessError");
          }
        }
        let r = 0;
        if (t !== undefined) {
          r = Buffer.byteLength(t);
          if (r > 123) {
            throw new o(`Reason must be less than 123 bytes; received ${r}`, "SyntaxError");
          }
        }
        if (this[p] === WebSocket.CLOSING || this[p] === WebSocket.CLOSED) {
        } else if (!I(this)) {
          b(this, "Connection was closed before it was established.");
          this[p] = WebSocket.CLOSING;
        } else if (!y(this)) {
          const n = new T();
          if (e !== undefined && t === undefined) {
            n.frameData = Buffer.allocUnsafe(2);
            n.frameData.writeUInt16BE(e, 0);
          } else if (e !== undefined && t !== undefined) {
            n.frameData = Buffer.allocUnsafe(2 + r);
            n.frameData.writeUInt16BE(e, 0);
            n.frameData.write(t, 2, "utf-8");
          } else {
            n.frameData = u;
          }
          const o = this[m].socket;
          o.write(n.createFrame(c.CLOSE), (e) => {
            if (!e) {
              this[h] = true;
            }
          });
          this[p] = A.CLOSING;
        } else {
          this[p] = WebSocket.CLOSING;
        }
      }
      send(e) {
        n.brandCheck(this, WebSocket);
        n.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" });
        e = n.converters.WebSocketSendData(e);
        if (this[p] === WebSocket.CONNECTING) {
          throw new o("Sent before connected.", "InvalidStateError");
        }
        if (!I(this) || y(this)) {
          return;
        }
        const t = this[m].socket;
        if (typeof e === "string") {
          const r = Buffer.from(e);
          const n = new T(r);
          const o = n.createFrame(c.TEXT);
          this.#p += r.byteLength;
          t.write(o, () => {
            this.#p -= r.byteLength;
          });
        } else if (O.isArrayBuffer(e)) {
          const r = Buffer.from(e);
          const n = new T(r);
          const o = n.createFrame(c.BINARY);
          this.#p += r.byteLength;
          t.write(o, () => {
            this.#p -= r.byteLength;
          });
        } else if (ArrayBuffer.isView(e)) {
          const r = Buffer.from(e, e.byteOffset, e.byteLength);
          const n = new T(r);
          const o = n.createFrame(c.BINARY);
          this.#p += r.byteLength;
          t.write(o, () => {
            this.#p -= r.byteLength;
          });
        } else if (_(e)) {
          const r = new T();
          e.arrayBuffer().then((e) => {
            const n = Buffer.from(e);
            r.frameData = n;
            const o = r.createFrame(c.BINARY);
            this.#p += n.byteLength;
            t.write(o, () => {
              this.#p -= n.byteLength;
            });
          });
        }
      }
      get readyState() {
        n.brandCheck(this, WebSocket);
        return this[p];
      }
      get bufferedAmount() {
        n.brandCheck(this, WebSocket);
        return this.#p;
      }
      get url() {
        n.brandCheck(this, WebSocket);
        return s(this[l]);
      }
      get extensions() {
        n.brandCheck(this, WebSocket);
        return this.#f;
      }
      get protocol() {
        n.brandCheck(this, WebSocket);
        return this.#d;
      }
      get onopen() {
        n.brandCheck(this, WebSocket);
        return this.#l.open;
      }
      set onopen(e) {
        n.brandCheck(this, WebSocket);
        if (this.#l.open) {
          this.removeEventListener("open", this.#l.open);
        }
        if (typeof e === "function") {
          this.#l.open = e;
          this.addEventListener("open", e);
        } else {
          this.#l.open = null;
        }
      }
      get onerror() {
        n.brandCheck(this, WebSocket);
        return this.#l.error;
      }
      set onerror(e) {
        n.brandCheck(this, WebSocket);
        if (this.#l.error) {
          this.removeEventListener("error", this.#l.error);
        }
        if (typeof e === "function") {
          this.#l.error = e;
          this.addEventListener("error", e);
        } else {
          this.#l.error = null;
        }
      }
      get onclose() {
        n.brandCheck(this, WebSocket);
        return this.#l.close;
      }
      set onclose(e) {
        n.brandCheck(this, WebSocket);
        if (this.#l.close) {
          this.removeEventListener("close", this.#l.close);
        }
        if (typeof e === "function") {
          this.#l.close = e;
          this.addEventListener("close", e);
        } else {
          this.#l.close = null;
        }
      }
      get onmessage() {
        n.brandCheck(this, WebSocket);
        return this.#l.message;
      }
      set onmessage(e) {
        n.brandCheck(this, WebSocket);
        if (this.#l.message) {
          this.removeEventListener("message", this.#l.message);
        }
        if (typeof e === "function") {
          this.#l.message = e;
          this.addEventListener("message", e);
        } else {
          this.#l.message = null;
        }
      }
      get binaryType() {
        n.brandCheck(this, WebSocket);
        return this[g];
      }
      set binaryType(e) {
        n.brandCheck(this, WebSocket);
        if (e !== "blob" && e !== "arraybuffer") {
          this[g] = "blob";
        } else {
          this[g] = e;
        }
      }
      #g(e) {
        this[m] = e;
        const t = new v(this);
        t.on("drain", function onParserDrain() {
          this.ws[m].socket.resume();
        });
        e.socket.ws = this;
        this[E] = t;
        this[p] = A.OPEN;
        const r = e.headersList.get("sec-websocket-extensions");
        if (r !== null) {
          this.#f = r;
        }
        const n = e.headersList.get("sec-websocket-protocol");
        if (n !== null) {
          this.#d = n;
        }
        Q("open", this);
      }
    }
    WebSocket.CONNECTING = WebSocket.prototype.CONNECTING = A.CONNECTING;
    WebSocket.OPEN = WebSocket.prototype.OPEN = A.OPEN;
    WebSocket.CLOSING = WebSocket.prototype.CLOSING = A.CLOSING;
    WebSocket.CLOSED = WebSocket.prototype.CLOSED = A.CLOSED;
    Object.defineProperties(WebSocket.prototype, {
      CONNECTING: a,
      OPEN: a,
      CLOSING: a,
      CLOSED: a,
      url: w,
      readyState: w,
      bufferedAmount: w,
      onopen: w,
      onerror: w,
      onclose: w,
      close: w,
      onmessage: w,
      binaryType: w,
      send: w,
      extensions: w,
      protocol: w,
      [Symbol.toStringTag]: { value: "WebSocket", writable: false, enumerable: false, configurable: true },
    });
    Object.defineProperties(WebSocket, { CONNECTING: a, OPEN: a, CLOSING: a, CLOSED: a });
    n.converters["sequence<DOMString>"] = n.sequenceConverter(n.converters.DOMString);
    n.converters["DOMString or sequence<DOMString>"] = function (e) {
      if (n.util.Type(e) === "Object" && Symbol.iterator in e) {
        return n.converters["sequence<DOMString>"](e);
      }
      return n.converters.DOMString(e);
    };
    n.converters.WebSocketInit = n.dictionaryConverter([
      {
        key: "protocols",
        converter: n.converters["DOMString or sequence<DOMString>"],
        get defaultValue() {
          return [];
        },
      },
      {
        key: "dispatcher",
        converter: (e) => e,
        get defaultValue() {
          return R();
        },
      },
      { key: "headers", converter: n.nullableConverter(n.converters.HeadersInit) },
    ]);
    n.converters["DOMString or sequence<DOMString> or WebSocketInit"] = function (e) {
      if (n.util.Type(e) === "Object" && !(Symbol.iterator in e)) {
        return n.converters.WebSocketInit(e);
      }
      return { protocols: n.converters["DOMString or sequence<DOMString>"](e) };
    };
    n.converters.WebSocketSendData = function (e) {
      if (n.util.Type(e) === "Object") {
        if (_(e)) {
          return n.converters.Blob(e, { strict: false });
        }
        if (ArrayBuffer.isView(e) || O.isAnyArrayBuffer(e)) {
          return n.converters.BufferSource(e);
        }
      }
      return n.converters.USVString(e);
    };
    e.exports = { WebSocket: WebSocket };
  },
  33843: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    function getUserAgent() {
      if (typeof navigator === "object" && "userAgent" in navigator) {
        return navigator.userAgent;
      }
      if (typeof process === "object" && process.version !== undefined) {
        return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
      }
      return "<environment undetectable>";
    }
    t.getUserAgent = getUserAgent;
  },
  12048: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    Object.defineProperty(t, "v1", {
      enumerable: true,
      get: function () {
        return n.default;
      },
    });
    Object.defineProperty(t, "v3", {
      enumerable: true,
      get: function () {
        return o.default;
      },
    });
    Object.defineProperty(t, "v4", {
      enumerable: true,
      get: function () {
        return s.default;
      },
    });
    Object.defineProperty(t, "v5", {
      enumerable: true,
      get: function () {
        return i.default;
      },
    });
    Object.defineProperty(t, "NIL", {
      enumerable: true,
      get: function () {
        return a.default;
      },
    });
    Object.defineProperty(t, "version", {
      enumerable: true,
      get: function () {
        return A.default;
      },
    });
    Object.defineProperty(t, "validate", {
      enumerable: true,
      get: function () {
        return c.default;
      },
    });
    Object.defineProperty(t, "stringify", {
      enumerable: true,
      get: function () {
        return u.default;
      },
    });
    Object.defineProperty(t, "parse", {
      enumerable: true,
      get: function () {
        return l.default;
      },
    });
    var n = _interopRequireDefault(r(6415));
    var o = _interopRequireDefault(r(51697));
    var s = _interopRequireDefault(r(4676));
    var i = _interopRequireDefault(r(69771));
    var a = _interopRequireDefault(r(37723));
    var A = _interopRequireDefault(r(15868));
    var c = _interopRequireDefault(r(36200));
    var u = _interopRequireDefault(r(37597));
    var l = _interopRequireDefault(r(17267));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
  },
  10216: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var n = _interopRequireDefault(r(76982));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function md5(e) {
      if (Array.isArray(e)) {
        e = Buffer.from(e);
      } else if (typeof e === "string") {
        e = Buffer.from(e, "utf8");
      }
      return n.default.createHash("md5").update(e).digest();
    }
    var o = md5;
    t["default"] = o;
  },
  37723: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var r = "00000000-0000-0000-0000-000000000000";
    t["default"] = r;
  },
  17267: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var n = _interopRequireDefault(r(36200));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function parse(e) {
      if (!(0, n.default)(e)) {
        throw TypeError("Invalid UUID");
      }
      let t;
      const r = new Uint8Array(16);
      r[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24;
      r[1] = (t >>> 16) & 255;
      r[2] = (t >>> 8) & 255;
      r[3] = t & 255;
      r[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8;
      r[5] = t & 255;
      r[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8;
      r[7] = t & 255;
      r[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8;
      r[9] = t & 255;
      r[10] = ((t = parseInt(e.slice(24, 36), 16)) / 1099511627776) & 255;
      r[11] = (t / 4294967296) & 255;
      r[12] = (t >>> 24) & 255;
      r[13] = (t >>> 16) & 255;
      r[14] = (t >>> 8) & 255;
      r[15] = t & 255;
      return r;
    }
    var o = parse;
    t["default"] = o;
  },
  67879: (e, t) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var r = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    t["default"] = r;
  },
  12973: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = rng;
    var n = _interopRequireDefault(r(76982));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    const o = new Uint8Array(256);
    let s = o.length;
    function rng() {
      if (s > o.length - 16) {
        n.default.randomFillSync(o);
        s = 0;
      }
      return o.slice(s, (s += 16));
    }
  },
  507: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var n = _interopRequireDefault(r(76982));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function sha1(e) {
      if (Array.isArray(e)) {
        e = Buffer.from(e);
      } else if (typeof e === "string") {
        e = Buffer.from(e, "utf8");
      }
      return n.default.createHash("sha1").update(e).digest();
    }
    var o = sha1;
    t["default"] = o;
  },
  37597: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var n = _interopRequireDefault(r(36200));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    const o = [];
    for (let e = 0; e < 256; ++e) {
      o.push((e + 256).toString(16).substr(1));
    }
    function stringify(e, t = 0) {
      const r = (
        o[e[t + 0]] +
        o[e[t + 1]] +
        o[e[t + 2]] +
        o[e[t + 3]] +
        "-" +
        o[e[t + 4]] +
        o[e[t + 5]] +
        "-" +
        o[e[t + 6]] +
        o[e[t + 7]] +
        "-" +
        o[e[t + 8]] +
        o[e[t + 9]] +
        "-" +
        o[e[t + 10]] +
        o[e[t + 11]] +
        o[e[t + 12]] +
        o[e[t + 13]] +
        o[e[t + 14]] +
        o[e[t + 15]]
      ).toLowerCase();
      if (!(0, n.default)(r)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return r;
    }
    var s = stringify;
    t["default"] = s;
  },
  6415: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var n = _interopRequireDefault(r(12973));
    var o = _interopRequireDefault(r(37597));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    let s;
    let i;
    let a = 0;
    let A = 0;
    function v1(e, t, r) {
      let c = (t && r) || 0;
      const u = t || new Array(16);
      e = e || {};
      let l = e.node || s;
      let p = e.clockseq !== undefined ? e.clockseq : i;
      if (l == null || p == null) {
        const t = e.random || (e.rng || n.default)();
        if (l == null) {
          l = s = [t[0] | 1, t[1], t[2], t[3], t[4], t[5]];
        }
        if (p == null) {
          p = i = ((t[6] << 8) | t[7]) & 16383;
        }
      }
      let d = e.msecs !== undefined ? e.msecs : Date.now();
      let g = e.nsecs !== undefined ? e.nsecs : A + 1;
      const m = d - a + (g - A) / 1e4;
      if (m < 0 && e.clockseq === undefined) {
        p = (p + 1) & 16383;
      }
      if ((m < 0 || d > a) && e.nsecs === undefined) {
        g = 0;
      }
      if (g >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      a = d;
      A = g;
      i = p;
      d += 122192928e5;
      const h = ((d & 268435455) * 1e4 + g) % 4294967296;
      u[c++] = (h >>> 24) & 255;
      u[c++] = (h >>> 16) & 255;
      u[c++] = (h >>> 8) & 255;
      u[c++] = h & 255;
      const E = ((d / 4294967296) * 1e4) & 268435455;
      u[c++] = (E >>> 8) & 255;
      u[c++] = E & 255;
      u[c++] = ((E >>> 24) & 15) | 16;
      u[c++] = (E >>> 16) & 255;
      u[c++] = (p >>> 8) | 128;
      u[c++] = p & 255;
      for (let e = 0; e < 6; ++e) {
        u[c + e] = l[e];
      }
      return t || (0, o.default)(u);
    }
    var c = v1;
    t["default"] = c;
  },
  51697: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var n = _interopRequireDefault(r(92930));
    var o = _interopRequireDefault(r(10216));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    const s = (0, n.default)("v3", 48, o.default);
    var i = s;
    t["default"] = i;
  },
  92930: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = _default;
    t.URL = t.DNS = void 0;
    var n = _interopRequireDefault(r(37597));
    var o = _interopRequireDefault(r(17267));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function stringToBytes(e) {
      e = unescape(encodeURIComponent(e));
      const t = [];
      for (let r = 0; r < e.length; ++r) {
        t.push(e.charCodeAt(r));
      }
      return t;
    }
    const s = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    t.DNS = s;
    const i = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    t.URL = i;
    function _default(e, t, r) {
      function generateUUID(e, s, i, a) {
        if (typeof e === "string") {
          e = stringToBytes(e);
        }
        if (typeof s === "string") {
          s = (0, o.default)(s);
        }
        if (s.length !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let A = new Uint8Array(16 + e.length);
        A.set(s);
        A.set(e, s.length);
        A = r(A);
        A[6] = (A[6] & 15) | t;
        A[8] = (A[8] & 63) | 128;
        if (i) {
          a = a || 0;
          for (let e = 0; e < 16; ++e) {
            i[a + e] = A[e];
          }
          return i;
        }
        return (0, n.default)(A);
      }
      try {
        generateUUID.name = e;
      } catch (e) {}
      generateUUID.DNS = s;
      generateUUID.URL = i;
      return generateUUID;
    }
  },
  4676: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var n = _interopRequireDefault(r(12973));
    var o = _interopRequireDefault(r(37597));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function v4(e, t, r) {
      e = e || {};
      const s = e.random || (e.rng || n.default)();
      s[6] = (s[6] & 15) | 64;
      s[8] = (s[8] & 63) | 128;
      if (t) {
        r = r || 0;
        for (let e = 0; e < 16; ++e) {
          t[r + e] = s[e];
        }
        return t;
      }
      return (0, o.default)(s);
    }
    var s = v4;
    t["default"] = s;
  },
  69771: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var n = _interopRequireDefault(r(92930));
    var o = _interopRequireDefault(r(507));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    const s = (0, n.default)("v5", 80, o.default);
    var i = s;
    t["default"] = i;
  },
  36200: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var n = _interopRequireDefault(r(67879));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function validate(e) {
      return typeof e === "string" && n.default.test(e);
    }
    var o = validate;
    t["default"] = o;
  },
  15868: (e, t, r) => {
    Object.defineProperty(t, "__esModule", { value: true });
    t["default"] = void 0;
    var n = _interopRequireDefault(r(36200));
    function _interopRequireDefault(e) {
      return e && e.__esModule ? e : { default: e };
    }
    function version(e) {
      if (!(0, n.default)(e)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(e.substr(14, 1), 16);
    }
    var o = version;
    t["default"] = o;
  },
  58264: (e) => {
    e.exports = wrappy;
    function wrappy(e, t) {
      if (e && t) return wrappy(e)(t);
      if (typeof e !== "function") throw new TypeError("need wrapper function");
      Object.keys(e).forEach(function (t) {
        wrapper[t] = e[t];
      });
      return wrapper;
      function wrapper() {
        var t = new Array(arguments.length);
        for (var r = 0; r < t.length; r++) {
          t[r] = arguments[r];
        }
        var n = e.apply(this, t);
        var o = t[t.length - 1];
        if (typeof n === "function" && n !== o) {
          Object.keys(o).forEach(function (e) {
            n[e] = o[e];
          });
        }
        return n;
      }
    }
  },
  42613: (t) => {
    t.exports = e(import.meta.url)("assert");
  },
  90290: (t) => {
    t.exports = e(import.meta.url)("async_hooks");
  },
  20181: (t) => {
    t.exports = e(import.meta.url)("buffer");
  },
  64236: (t) => {
    t.exports = e(import.meta.url)("console");
  },
  76982: (t) => {
    t.exports = e(import.meta.url)("crypto");
  },
  31637: (t) => {
    t.exports = e(import.meta.url)("diagnostics_channel");
  },
  24434: (t) => {
    t.exports = e(import.meta.url)("events");
  },
  79896: (t) => {
    t.exports = e(import.meta.url)("fs");
  },
  58611: (t) => {
    t.exports = e(import.meta.url)("http");
  },
  85675: (t) => {
    t.exports = e(import.meta.url)("http2");
  },
  65692: (t) => {
    t.exports = e(import.meta.url)("https");
  },
  69278: (t) => {
    t.exports = e(import.meta.url)("net");
  },
  78474: (t) => {
    t.exports = e(import.meta.url)("node:events");
  },
  57075: (t) => {
    t.exports = e(import.meta.url)("node:stream");
  },
  57975: (t) => {
    t.exports = e(import.meta.url)("node:util");
  },
  70857: (t) => {
    t.exports = e(import.meta.url)("os");
  },
  16928: (t) => {
    t.exports = e(import.meta.url)("path");
  },
  82987: (t) => {
    t.exports = e(import.meta.url)("perf_hooks");
  },
  83480: (t) => {
    t.exports = e(import.meta.url)("querystring");
  },
  2203: (t) => {
    t.exports = e(import.meta.url)("stream");
  },
  63774: (t) => {
    t.exports = e(import.meta.url)("stream/web");
  },
  13193: (t) => {
    t.exports = e(import.meta.url)("string_decoder");
  },
  64756: (t) => {
    t.exports = e(import.meta.url)("tls");
  },
  87016: (t) => {
    t.exports = e(import.meta.url)("url");
  },
  39023: (t) => {
    t.exports = e(import.meta.url)("util");
  },
  98253: (t) => {
    t.exports = e(import.meta.url)("util/types");
  },
  28167: (t) => {
    t.exports = e(import.meta.url)("worker_threads");
  },
  43106: (t) => {
    t.exports = e(import.meta.url)("zlib");
  },
  27182: (e, t, r) => {
    const n = r(57075).Writable;
    const o = r(57975).inherits;
    const s = r(84136);
    const i = r(50612);
    const a = r(62271);
    const A = 45;
    const c = Buffer.from("-");
    const u = Buffer.from("\r\n");
    const EMPTY_FN = function () {};
    function Dicer(e) {
      if (!(this instanceof Dicer)) {
        return new Dicer(e);
      }
      n.call(this, e);
      if (!e || (!e.headerFirst && typeof e.boundary !== "string")) {
        throw new TypeError("Boundary required");
      }
      if (typeof e.boundary === "string") {
        this.setBoundary(e.boundary);
      } else {
        this._bparser = undefined;
      }
      this._headerFirst = e.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = undefined;
      this._cb = undefined;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: e.partHwm };
      this._pause = false;
      const t = this;
      this._hparser = new a(e);
      this._hparser.on("header", function (e) {
        t._inHeader = false;
        t._part.emit("header", e);
      });
    }
    o(Dicer, n);
    Dicer.prototype.emit = function (e) {
      if (e === "finish" && !this._realFinish) {
        if (!this._finished) {
          const e = this;
          process.nextTick(function () {
            e.emit("error", new Error("Unexpected end of multipart data"));
            if (e._part && !e._ignoreData) {
              const t = e._isPreamble ? "Preamble" : "Part";
              e._part.emit("error", new Error(t + " terminated early due to unexpected end of multipart data"));
              e._part.push(null);
              process.nextTick(function () {
                e._realFinish = true;
                e.emit("finish");
                e._realFinish = false;
              });
              return;
            }
            e._realFinish = true;
            e.emit("finish");
            e._realFinish = false;
          });
        }
      } else {
        n.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function (e, t, r) {
      if (!this._hparser && !this._bparser) {
        return r();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new i(this._partOpts);
          if (this.listenerCount("preamble") !== 0) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const t = this._hparser.push(e);
        if (!this._inHeader && t !== undefined && t < e.length) {
          e = e.slice(t);
        } else {
          return r();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(u);
        this._firstWrite = false;
      }
      this._bparser.push(e);
      if (this._pause) {
        this._cb = r;
      } else {
        r();
      }
    };
    Dicer.prototype.reset = function () {
      this._part = undefined;
      this._bparser = undefined;
      this._hparser = undefined;
    };
    Dicer.prototype.setBoundary = function (e) {
      const t = this;
      this._bparser = new s("\r\n--" + e);
      this._bparser.on("info", function (e, r, n, o) {
        t._oninfo(e, r, n, o);
      });
    };
    Dicer.prototype._ignore = function () {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function (e, t, r, n) {
      let o;
      const s = this;
      let a = 0;
      let u;
      let l = true;
      if (!this._part && this._justMatched && t) {
        while (this._dashes < 2 && r + a < n) {
          if (t[r + a] === A) {
            ++a;
            ++this._dashes;
          } else {
            if (this._dashes) {
              o = c;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (r + a < n && this.listenerCount("trailer") !== 0) {
            this.emit("trailer", t.slice(r + a, n));
          }
          this.reset();
          this._finished = true;
          if (s._parts === 0) {
            s._realFinish = true;
            s.emit("finish");
            s._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new i(this._partOpts);
        this._part._read = function (e) {
          s._unpause();
        };
        if (this._isPreamble && this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (t && r < n && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (o) {
            l = this._part.push(o);
          }
          l = this._part.push(t.slice(r, n));
          if (!l) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (o) {
            this._hparser.push(o);
          }
          u = this._hparser.push(t.slice(r, n));
          if (!this._inHeader && u !== undefined && u < n) {
            this._oninfo(false, t, r + u, n);
          }
        }
      }
      if (e) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (r !== n) {
            ++this._parts;
            this._part.on("end", function () {
              if (--s._parts === 0) {
                if (s._finished) {
                  s._realFinish = true;
                  s.emit("finish");
                  s._realFinish = false;
                } else {
                  s._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = undefined;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function () {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const e = this._cb;
        this._cb = undefined;
        e();
      }
    };
    e.exports = Dicer;
  },
  62271: (e, t, r) => {
    const n = r(78474).EventEmitter;
    const o = r(57975).inherits;
    const s = r(22393);
    const i = r(84136);
    const a = Buffer.from("\r\n\r\n");
    const A = /\r\n/g;
    const c = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(e) {
      n.call(this);
      e = e || {};
      const t = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = s(e, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = s(e, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new i(a);
      this.ss.on("info", function (e, r, n, o) {
        if (r && !t.maxed) {
          if (t.nread + o - n >= t.maxHeaderSize) {
            o = t.maxHeaderSize - t.nread + n;
            t.nread = t.maxHeaderSize;
            t.maxed = true;
          } else {
            t.nread += o - n;
          }
          t.buffer += r.toString("binary", n, o);
        }
        if (e) {
          t._finish();
        }
      });
    }
    o(HeaderParser, n);
    HeaderParser.prototype.push = function (e) {
      const t = this.ss.push(e);
      if (this.finished) {
        return t;
      }
    };
    HeaderParser.prototype.reset = function () {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function () {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const e = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", e);
    };
    HeaderParser.prototype._parseHeader = function () {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const e = this.buffer.split(A);
      const t = e.length;
      let r, n;
      for (var o = 0; o < t; ++o) {
        if (e[o].length === 0) {
          continue;
        }
        if (e[o][0] === "\t" || e[o][0] === " ") {
          if (n) {
            this.header[n][this.header[n].length - 1] += e[o];
            continue;
          }
        }
        const t = e[o].indexOf(":");
        if (t === -1 || t === 0) {
          return;
        }
        r = c.exec(e[o]);
        n = r[1].toLowerCase();
        this.header[n] = this.header[n] || [];
        this.header[n].push(r[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    e.exports = HeaderParser;
  },
  50612: (e, t, r) => {
    const n = r(57975).inherits;
    const o = r(57075).Readable;
    function PartStream(e) {
      o.call(this, e);
    }
    n(PartStream, o);
    PartStream.prototype._read = function (e) {};
    e.exports = PartStream;
  },
  84136: (e, t, r) => {
    const n = r(78474).EventEmitter;
    const o = r(57975).inherits;
    function SBMH(e) {
      if (typeof e === "string") {
        e = Buffer.from(e);
      }
      if (!Buffer.isBuffer(e)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const t = e.length;
      if (t === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (t > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Array(256).fill(t);
      this._lookbehind_size = 0;
      this._needle = e;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(t);
      for (var r = 0; r < t - 1; ++r) {
        this._occ[e[r]] = t - 1 - r;
      }
    }
    o(SBMH, n);
    SBMH.prototype.reset = function () {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function (e, t) {
      if (!Buffer.isBuffer(e)) {
        e = Buffer.from(e, "binary");
      }
      const r = e.length;
      this._bufpos = t || 0;
      let n;
      while (n !== r && this.matches < this.maxMatches) {
        n = this._sbmh_feed(e);
      }
      return n;
    };
    SBMH.prototype._sbmh_feed = function (e) {
      const t = e.length;
      const r = this._needle;
      const n = r.length;
      const o = r[n - 1];
      let s = -this._lookbehind_size;
      let i;
      if (s < 0) {
        while (s < 0 && s <= t - n) {
          i = this._sbmh_lookup_char(e, s + n - 1);
          if (i === o && this._sbmh_memcmp(e, s, n - 1)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return (this._bufpos = s + n);
          }
          s += this._occ[i];
        }
        if (s < 0) {
          while (s < 0 && !this._sbmh_memcmp(e, s, t - s)) {
            ++s;
          }
        }
        if (s >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const r = this._lookbehind_size + s;
          if (r > 0) {
            this.emit("info", false, this._lookbehind, 0, r);
          }
          this._lookbehind.copy(this._lookbehind, 0, r, this._lookbehind_size - r);
          this._lookbehind_size -= r;
          e.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += t;
          this._bufpos = t;
          return t;
        }
      }
      s += (s >= 0) * this._bufpos;
      if (e.indexOf(r, s) !== -1) {
        s = e.indexOf(r, s);
        ++this.matches;
        if (s > 0) {
          this.emit("info", true, e, this._bufpos, s);
        } else {
          this.emit("info", true);
        }
        return (this._bufpos = s + n);
      } else {
        s = t - n;
      }
      while (s < t && (e[s] !== r[0] || Buffer.compare(e.subarray(s, s + t - s), r.subarray(0, t - s)) !== 0)) {
        ++s;
      }
      if (s < t) {
        e.copy(this._lookbehind, 0, s, s + (t - s));
        this._lookbehind_size = t - s;
      }
      if (s > 0) {
        this.emit("info", false, e, this._bufpos, s < t ? s : t);
      }
      this._bufpos = t;
      return t;
    };
    SBMH.prototype._sbmh_lookup_char = function (e, t) {
      return t < 0 ? this._lookbehind[this._lookbehind_size + t] : e[t];
    };
    SBMH.prototype._sbmh_memcmp = function (e, t, r) {
      for (var n = 0; n < r; ++n) {
        if (this._sbmh_lookup_char(e, t + n) !== this._needle[n]) {
          return false;
        }
      }
      return true;
    };
    e.exports = SBMH;
  },
  89581: (e, t, r) => {
    const n = r(57075).Writable;
    const { inherits: o } = r(57975);
    const s = r(27182);
    const i = r(41192);
    const a = r(80855);
    const A = r(8929);
    function Busboy(e) {
      if (!(this instanceof Busboy)) {
        return new Busboy(e);
      }
      if (typeof e !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof e.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof e.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const { headers: t, ...r } = e;
      this.opts = { autoDestroy: false, ...r };
      n.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(t);
      this._finished = false;
    }
    o(Busboy, n);
    Busboy.prototype.emit = function (e) {
      if (e === "finish") {
        if (!this._done) {
          this._parser?.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      n.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function (e) {
      const t = A(e["content-type"]);
      const r = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers: e,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: t,
        preservePath: this.opts.preservePath,
      };
      if (i.detect.test(t[0])) {
        return new i(this, r);
      }
      if (a.detect.test(t[0])) {
        return new a(this, r);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function (e, t, r) {
      this._parser.write(e, r);
    };
    e.exports = Busboy;
    e.exports["default"] = Busboy;
    e.exports.Busboy = Busboy;
    e.exports.Dicer = s;
  },
  41192: (e, t, r) => {
    const { Readable: n } = r(57075);
    const { inherits: o } = r(57975);
    const s = r(27182);
    const i = r(8929);
    const a = r(72747);
    const A = r(20692);
    const c = r(22393);
    const u = /^boundary$/i;
    const l = /^form-data$/i;
    const p = /^charset$/i;
    const d = /^filename$/i;
    const g = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(e, t) {
      let r;
      let n;
      const o = this;
      let m;
      const h = t.limits;
      const E = t.isPartAFile || ((e, t, r) => t === "application/octet-stream" || r !== undefined);
      const I = t.parsedConType || [];
      const y = t.defCharset || "utf8";
      const C = t.preservePath;
      const b = { highWaterMark: t.fileHwm };
      for (r = 0, n = I.length; r < n; ++r) {
        if (Array.isArray(I[r]) && u.test(I[r][0])) {
          m = I[r][1];
          break;
        }
      }
      function checkFinished() {
        if (D === 0 && N && !e._done) {
          N = false;
          o.end();
        }
      }
      if (typeof m !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const Q = c(h, "fieldSize", 1 * 1024 * 1024);
      const B = c(h, "fileSize", Infinity);
      const T = c(h, "files", Infinity);
      const v = c(h, "fields", Infinity);
      const w = c(h, "parts", Infinity);
      const _ = c(h, "headerPairs", 2e3);
      const R = c(h, "headerSize", 80 * 1024);
      let O = 0;
      let F = 0;
      let D = 0;
      let k;
      let S;
      let N = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = undefined;
      this._nparts = 0;
      this._boy = e;
      const P = { boundary: m, maxHeaderPairs: _, maxHeaderSize: R, partHwm: b.highWaterMark, highWaterMark: t.highWaterMark };
      this.parser = new s(P);
      this.parser
        .on("drain", function () {
          o._needDrain = false;
          if (o._cb && !o._pause) {
            const e = o._cb;
            o._cb = undefined;
            e();
          }
        })
        .on("part", function onPart(t) {
          if (++o._nparts > w) {
            o.parser.removeListener("part", onPart);
            o.parser.on("part", skipPart);
            e.hitPartsLimit = true;
            e.emit("partsLimit");
            return skipPart(t);
          }
          if (S) {
            const e = S;
            e.emit("end");
            e.removeAllListeners("end");
          }
          t.on("header", function (s) {
            let c;
            let u;
            let m;
            let h;
            let I;
            let w;
            let _ = 0;
            if (s["content-type"]) {
              m = i(s["content-type"][0]);
              if (m[0]) {
                c = m[0].toLowerCase();
                for (r = 0, n = m.length; r < n; ++r) {
                  if (p.test(m[r][0])) {
                    h = m[r][1].toLowerCase();
                    break;
                  }
                }
              }
            }
            if (c === undefined) {
              c = "text/plain";
            }
            if (h === undefined) {
              h = y;
            }
            if (s["content-disposition"]) {
              m = i(s["content-disposition"][0]);
              if (!l.test(m[0])) {
                return skipPart(t);
              }
              for (r = 0, n = m.length; r < n; ++r) {
                if (g.test(m[r][0])) {
                  u = m[r][1];
                } else if (d.test(m[r][0])) {
                  w = m[r][1];
                  if (!C) {
                    w = A(w);
                  }
                }
              }
            } else {
              return skipPart(t);
            }
            if (s["content-transfer-encoding"]) {
              I = s["content-transfer-encoding"][0].toLowerCase();
            } else {
              I = "7bit";
            }
            let R, N;
            if (E(u, c, w)) {
              if (O === T) {
                if (!e.hitFilesLimit) {
                  e.hitFilesLimit = true;
                  e.emit("filesLimit");
                }
                return skipPart(t);
              }
              ++O;
              if (e.listenerCount("file") === 0) {
                o.parser._ignore();
                return;
              }
              ++D;
              const r = new FileStream(b);
              k = r;
              r.on("end", function () {
                --D;
                o._pause = false;
                checkFinished();
                if (o._cb && !o._needDrain) {
                  const e = o._cb;
                  o._cb = undefined;
                  e();
                }
              });
              r._read = function (e) {
                if (!o._pause) {
                  return;
                }
                o._pause = false;
                if (o._cb && !o._needDrain) {
                  const e = o._cb;
                  o._cb = undefined;
                  e();
                }
              };
              e.emit("file", u, r, w, I, c);
              R = function (e) {
                if ((_ += e.length) > B) {
                  const n = B - _ + e.length;
                  if (n > 0) {
                    r.push(e.slice(0, n));
                  }
                  r.truncated = true;
                  r.bytesRead = B;
                  t.removeAllListeners("data");
                  r.emit("limit");
                  return;
                } else if (!r.push(e)) {
                  o._pause = true;
                }
                r.bytesRead = _;
              };
              N = function () {
                k = undefined;
                r.push(null);
              };
            } else {
              if (F === v) {
                if (!e.hitFieldsLimit) {
                  e.hitFieldsLimit = true;
                  e.emit("fieldsLimit");
                }
                return skipPart(t);
              }
              ++F;
              ++D;
              let r = "";
              let n = false;
              S = t;
              R = function (e) {
                if ((_ += e.length) > Q) {
                  const o = Q - (_ - e.length);
                  r += e.toString("binary", 0, o);
                  n = true;
                  t.removeAllListeners("data");
                } else {
                  r += e.toString("binary");
                }
              };
              N = function () {
                S = undefined;
                if (r.length) {
                  r = a(r, "binary", h);
                }
                e.emit("field", u, r, false, n, I, c);
                --D;
                checkFinished();
              };
            }
            t._readableState.sync = false;
            t.on("data", R);
            t.on("end", N);
          }).on("error", function (e) {
            if (k) {
              k.emit("error", e);
            }
          });
        })
        .on("error", function (t) {
          e.emit("error", t);
        })
        .on("finish", function () {
          N = true;
          checkFinished();
        });
    }
    Multipart.prototype.write = function (e, t) {
      const r = this.parser.write(e);
      if (r && !this._pause) {
        t();
      } else {
        this._needDrain = !r;
        this._cb = t;
      }
    };
    Multipart.prototype.end = function () {
      const e = this;
      if (e.parser.writable) {
        e.parser.end();
      } else if (!e._boy._done) {
        process.nextTick(function () {
          e._boy._done = true;
          e._boy.emit("finish");
        });
      }
    };
    function skipPart(e) {
      e.resume();
    }
    function FileStream(e) {
      n.call(this, e);
      this.bytesRead = 0;
      this.truncated = false;
    }
    o(FileStream, n);
    FileStream.prototype._read = function (e) {};
    e.exports = Multipart;
  },
  80855: (e, t, r) => {
    const n = r(11496);
    const o = r(72747);
    const s = r(22393);
    const i = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(e, t) {
      const r = t.limits;
      const o = t.parsedConType;
      this.boy = e;
      this.fieldSizeLimit = s(r, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = s(r, "fieldNameSize", 100);
      this.fieldsLimit = s(r, "fields", Infinity);
      let a;
      for (var A = 0, c = o.length; A < c; ++A) {
        if (Array.isArray(o[A]) && i.test(o[A][0])) {
          a = o[A][1].toLowerCase();
          break;
        }
      }
      if (a === undefined) {
        a = t.defCharset || "utf8";
      }
      this.decoder = new n();
      this.charset = a;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    UrlEncoded.prototype.write = function (e, t) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return t();
      }
      let r;
      let n;
      let s;
      let i = 0;
      const a = e.length;
      while (i < a) {
        if (this._state === "key") {
          r = n = undefined;
          for (s = i; s < a; ++s) {
            if (!this._checkingBytes) {
              ++i;
            }
            if (e[s] === 61) {
              r = s;
              break;
            } else if (e[s] === 38) {
              n = s;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (r !== undefined) {
            if (r > i) {
              this._key += this.decoder.write(e.toString("binary", i, r));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            i = r + 1;
          } else if (n !== undefined) {
            ++this._fields;
            let r;
            const s = this._keyTrunc;
            if (n > i) {
              r = this._key += this.decoder.write(e.toString("binary", i, n));
            } else {
              r = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (r.length) {
              this.boy.emit("field", o(r, "binary", this.charset), "", s, false);
            }
            i = n + 1;
            if (this._fields === this.fieldsLimit) {
              return t();
            }
          } else if (this._hitLimit) {
            if (s > i) {
              this._key += this.decoder.write(e.toString("binary", i, s));
            }
            i = s;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (i < a) {
              this._key += this.decoder.write(e.toString("binary", i));
            }
            i = a;
          }
        } else {
          n = undefined;
          for (s = i; s < a; ++s) {
            if (!this._checkingBytes) {
              ++i;
            }
            if (e[s] === 38) {
              n = s;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (n !== undefined) {
            ++this._fields;
            if (n > i) {
              this._val += this.decoder.write(e.toString("binary", i, n));
            }
            this.boy.emit("field", o(this._key, "binary", this.charset), o(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            i = n + 1;
            if (this._fields === this.fieldsLimit) {
              return t();
            }
          } else if (this._hitLimit) {
            if (s > i) {
              this._val += this.decoder.write(e.toString("binary", i, s));
            }
            i = s;
            if ((this._val === "" && this.fieldSizeLimit === 0) || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (i < a) {
              this._val += this.decoder.write(e.toString("binary", i));
            }
            i = a;
          }
        }
      }
      t();
    };
    UrlEncoded.prototype.end = function () {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit("field", o(this._key, "binary", this.charset), "", this._keyTrunc, false);
      } else if (this._state === "val") {
        this.boy.emit("field", o(this._key, "binary", this.charset), o(this._val, "binary", this.charset), this._keyTrunc, this._valTrunc);
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    e.exports = UrlEncoded;
  },
  11496: (e) => {
    const t = /\+/g;
    const r = [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1,
      1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ];
    function Decoder() {
      this.buffer = undefined;
    }
    Decoder.prototype.write = function (e) {
      e = e.replace(t, " ");
      let n = "";
      let o = 0;
      let s = 0;
      const i = e.length;
      for (; o < i; ++o) {
        if (this.buffer !== undefined) {
          if (!r[e.charCodeAt(o)]) {
            n += "%" + this.buffer;
            this.buffer = undefined;
            --o;
          } else {
            this.buffer += e[o];
            ++s;
            if (this.buffer.length === 2) {
              n += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = undefined;
            }
          }
        } else if (e[o] === "%") {
          if (o > s) {
            n += e.substring(s, o);
            s = o;
          }
          this.buffer = "";
          ++s;
        }
      }
      if (s < i && this.buffer === undefined) {
        n += e.substring(s);
      }
      return n;
    };
    Decoder.prototype.reset = function () {
      this.buffer = undefined;
    };
    e.exports = Decoder;
  },
  20692: (e) => {
    e.exports = function basename(e) {
      if (typeof e !== "string") {
        return "";
      }
      for (var t = e.length - 1; t >= 0; --t) {
        switch (e.charCodeAt(t)) {
          case 47:
          case 92:
            e = e.slice(t + 1);
            return e === ".." || e === "." ? "" : e;
        }
      }
      return e === ".." || e === "." ? "" : e;
    };
  },
  72747: function (e) {
    const t = new TextDecoder("utf-8");
    const r = new Map([
      ["utf-8", t],
      ["utf8", t],
    ]);
    function getDecoder(e) {
      let t;
      while (true) {
        switch (e) {
          case "utf-8":
          case "utf8":
            return n.utf8;
          case "latin1":
          case "ascii":
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return n.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return n.utf16le;
          case "base64":
            return n.base64;
          default:
            if (t === undefined) {
              t = true;
              e = e.toLowerCase();
              continue;
            }
            return n.other.bind(e);
        }
      }
    }
    const n = {
      utf8: (e, t) => {
        if (e.length === 0) {
          return "";
        }
        if (typeof e === "string") {
          e = Buffer.from(e, t);
        }
        return e.utf8Slice(0, e.length);
      },
      latin1: (e, t) => {
        if (e.length === 0) {
          return "";
        }
        if (typeof e === "string") {
          return e;
        }
        return e.latin1Slice(0, e.length);
      },
      utf16le: (e, t) => {
        if (e.length === 0) {
          return "";
        }
        if (typeof e === "string") {
          e = Buffer.from(e, t);
        }
        return e.ucs2Slice(0, e.length);
      },
      base64: (e, t) => {
        if (e.length === 0) {
          return "";
        }
        if (typeof e === "string") {
          e = Buffer.from(e, t);
        }
        return e.base64Slice(0, e.length);
      },
      other: (e, t) => {
        if (e.length === 0) {
          return "";
        }
        if (typeof e === "string") {
          e = Buffer.from(e, t);
        }
        if (r.has(this.toString())) {
          try {
            return r.get(this).decode(e);
          } catch {}
        }
        return typeof e === "string" ? e : e.toString();
      },
    };
    function decodeText(e, t, r) {
      if (e) {
        return getDecoder(r)(e, t);
      }
      return e;
    }
    e.exports = decodeText;
  },
  22393: (e) => {
    e.exports = function getLimit(e, t, r) {
      if (!e || e[t] === undefined || e[t] === null) {
        return r;
      }
      if (typeof e[t] !== "number" || isNaN(e[t])) {
        throw new TypeError("Limit " + t + " is not a valid number");
      }
      return e[t];
    };
  },
  8929: (e, t, r) => {
    const n = r(72747);
    const o = /%[a-fA-F0-9][a-fA-F0-9]/g;
    const s = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "",
      "%08": "\b",
      "%09": "\t",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "",
      "%1B": "",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "",
      "%7F": "",
      "%80": "",
      "%81": "",
      "%82": "",
      "%83": "",
      "%84": "",
      "%85": "",
      "%86": "",
      "%87": "",
      "%88": "",
      "%89": "",
      "%8a": "",
      "%8A": "",
      "%8b": "",
      "%8B": "",
      "%8c": "",
      "%8C": "",
      "%8d": "",
      "%8D": "",
      "%8e": "",
      "%8E": "",
      "%8f": "",
      "%8F": "",
      "%90": "",
      "%91": "",
      "%92": "",
      "%93": "",
      "%94": "",
      "%95": "",
      "%96": "",
      "%97": "",
      "%98": "",
      "%99": "",
      "%9a": "",
      "%9A": "",
      "%9b": "",
      "%9B": "",
      "%9c": "",
      "%9C": "",
      "%9d": "",
      "%9D": "",
      "%9e": "",
      "%9E": "",
      "%9f": "",
      "%9F": "",
      "%a0": " ",
      "%A0": " ",
      "%a1": "¡",
      "%A1": "¡",
      "%a2": "¢",
      "%A2": "¢",
      "%a3": "£",
      "%A3": "£",
      "%a4": "¤",
      "%A4": "¤",
      "%a5": "¥",
      "%A5": "¥",
      "%a6": "¦",
      "%A6": "¦",
      "%a7": "§",
      "%A7": "§",
      "%a8": "¨",
      "%A8": "¨",
      "%a9": "©",
      "%A9": "©",
      "%aa": "ª",
      "%Aa": "ª",
      "%aA": "ª",
      "%AA": "ª",
      "%ab": "«",
      "%Ab": "«",
      "%aB": "«",
      "%AB": "«",
      "%ac": "¬",
      "%Ac": "¬",
      "%aC": "¬",
      "%AC": "¬",
      "%ad": "­",
      "%Ad": "­",
      "%aD": "­",
      "%AD": "­",
      "%ae": "®",
      "%Ae": "®",
      "%aE": "®",
      "%AE": "®",
      "%af": "¯",
      "%Af": "¯",
      "%aF": "¯",
      "%AF": "¯",
      "%b0": "°",
      "%B0": "°",
      "%b1": "±",
      "%B1": "±",
      "%b2": "²",
      "%B2": "²",
      "%b3": "³",
      "%B3": "³",
      "%b4": "´",
      "%B4": "´",
      "%b5": "µ",
      "%B5": "µ",
      "%b6": "¶",
      "%B6": "¶",
      "%b7": "·",
      "%B7": "·",
      "%b8": "¸",
      "%B8": "¸",
      "%b9": "¹",
      "%B9": "¹",
      "%ba": "º",
      "%Ba": "º",
      "%bA": "º",
      "%BA": "º",
      "%bb": "»",
      "%Bb": "»",
      "%bB": "»",
      "%BB": "»",
      "%bc": "¼",
      "%Bc": "¼",
      "%bC": "¼",
      "%BC": "¼",
      "%bd": "½",
      "%Bd": "½",
      "%bD": "½",
      "%BD": "½",
      "%be": "¾",
      "%Be": "¾",
      "%bE": "¾",
      "%BE": "¾",
      "%bf": "¿",
      "%Bf": "¿",
      "%bF": "¿",
      "%BF": "¿",
      "%c0": "À",
      "%C0": "À",
      "%c1": "Á",
      "%C1": "Á",
      "%c2": "Â",
      "%C2": "Â",
      "%c3": "Ã",
      "%C3": "Ã",
      "%c4": "Ä",
      "%C4": "Ä",
      "%c5": "Å",
      "%C5": "Å",
      "%c6": "Æ",
      "%C6": "Æ",
      "%c7": "Ç",
      "%C7": "Ç",
      "%c8": "È",
      "%C8": "È",
      "%c9": "É",
      "%C9": "É",
      "%ca": "Ê",
      "%Ca": "Ê",
      "%cA": "Ê",
      "%CA": "Ê",
      "%cb": "Ë",
      "%Cb": "Ë",
      "%cB": "Ë",
      "%CB": "Ë",
      "%cc": "Ì",
      "%Cc": "Ì",
      "%cC": "Ì",
      "%CC": "Ì",
      "%cd": "Í",
      "%Cd": "Í",
      "%cD": "Í",
      "%CD": "Í",
      "%ce": "Î",
      "%Ce": "Î",
      "%cE": "Î",
      "%CE": "Î",
      "%cf": "Ï",
      "%Cf": "Ï",
      "%cF": "Ï",
      "%CF": "Ï",
      "%d0": "Ð",
      "%D0": "Ð",
      "%d1": "Ñ",
      "%D1": "Ñ",
      "%d2": "Ò",
      "%D2": "Ò",
      "%d3": "Ó",
      "%D3": "Ó",
      "%d4": "Ô",
      "%D4": "Ô",
      "%d5": "Õ",
      "%D5": "Õ",
      "%d6": "Ö",
      "%D6": "Ö",
      "%d7": "×",
      "%D7": "×",
      "%d8": "Ø",
      "%D8": "Ø",
      "%d9": "Ù",
      "%D9": "Ù",
      "%da": "Ú",
      "%Da": "Ú",
      "%dA": "Ú",
      "%DA": "Ú",
      "%db": "Û",
      "%Db": "Û",
      "%dB": "Û",
      "%DB": "Û",
      "%dc": "Ü",
      "%Dc": "Ü",
      "%dC": "Ü",
      "%DC": "Ü",
      "%dd": "Ý",
      "%Dd": "Ý",
      "%dD": "Ý",
      "%DD": "Ý",
      "%de": "Þ",
      "%De": "Þ",
      "%dE": "Þ",
      "%DE": "Þ",
      "%df": "ß",
      "%Df": "ß",
      "%dF": "ß",
      "%DF": "ß",
      "%e0": "à",
      "%E0": "à",
      "%e1": "á",
      "%E1": "á",
      "%e2": "â",
      "%E2": "â",
      "%e3": "ã",
      "%E3": "ã",
      "%e4": "ä",
      "%E4": "ä",
      "%e5": "å",
      "%E5": "å",
      "%e6": "æ",
      "%E6": "æ",
      "%e7": "ç",
      "%E7": "ç",
      "%e8": "è",
      "%E8": "è",
      "%e9": "é",
      "%E9": "é",
      "%ea": "ê",
      "%Ea": "ê",
      "%eA": "ê",
      "%EA": "ê",
      "%eb": "ë",
      "%Eb": "ë",
      "%eB": "ë",
      "%EB": "ë",
      "%ec": "ì",
      "%Ec": "ì",
      "%eC": "ì",
      "%EC": "ì",
      "%ed": "í",
      "%Ed": "í",
      "%eD": "í",
      "%ED": "í",
      "%ee": "î",
      "%Ee": "î",
      "%eE": "î",
      "%EE": "î",
      "%ef": "ï",
      "%Ef": "ï",
      "%eF": "ï",
      "%EF": "ï",
      "%f0": "ð",
      "%F0": "ð",
      "%f1": "ñ",
      "%F1": "ñ",
      "%f2": "ò",
      "%F2": "ò",
      "%f3": "ó",
      "%F3": "ó",
      "%f4": "ô",
      "%F4": "ô",
      "%f5": "õ",
      "%F5": "õ",
      "%f6": "ö",
      "%F6": "ö",
      "%f7": "÷",
      "%F7": "÷",
      "%f8": "ø",
      "%F8": "ø",
      "%f9": "ù",
      "%F9": "ù",
      "%fa": "ú",
      "%Fa": "ú",
      "%fA": "ú",
      "%FA": "ú",
      "%fb": "û",
      "%Fb": "û",
      "%fB": "û",
      "%FB": "û",
      "%fc": "ü",
      "%Fc": "ü",
      "%fC": "ü",
      "%FC": "ü",
      "%fd": "ý",
      "%Fd": "ý",
      "%fD": "ý",
      "%FD": "ý",
      "%fe": "þ",
      "%Fe": "þ",
      "%fE": "þ",
      "%FE": "þ",
      "%ff": "ÿ",
      "%Ff": "ÿ",
      "%fF": "ÿ",
      "%FF": "ÿ",
    };
    function encodedReplacer(e) {
      return s[e];
    }
    const i = 0;
    const a = 1;
    const A = 2;
    const c = 3;
    function parseParams(e) {
      const t = [];
      let r = i;
      let s = "";
      let u = false;
      let l = false;
      let p = 0;
      let d = "";
      const g = e.length;
      for (var m = 0; m < g; ++m) {
        const g = e[m];
        if (g === "\\" && u) {
          if (l) {
            l = false;
          } else {
            l = true;
            continue;
          }
        } else if (g === '"') {
          if (!l) {
            if (u) {
              u = false;
              r = i;
            } else {
              u = true;
            }
            continue;
          } else {
            l = false;
          }
        } else {
          if (l && u) {
            d += "\\";
          }
          l = false;
          if ((r === A || r === c) && g === "'") {
            if (r === A) {
              r = c;
              s = d.substring(1);
            } else {
              r = a;
            }
            d = "";
            continue;
          } else if (r === i && (g === "*" || g === "=") && t.length) {
            r = g === "*" ? A : a;
            t[p] = [d, undefined];
            d = "";
            continue;
          } else if (!u && g === ";") {
            r = i;
            if (s) {
              if (d.length) {
                d = n(d.replace(o, encodedReplacer), "binary", s);
              }
              s = "";
            } else if (d.length) {
              d = n(d, "binary", "utf8");
            }
            if (t[p] === undefined) {
              t[p] = d;
            } else {
              t[p][1] = d;
            }
            d = "";
            ++p;
            continue;
          } else if (!u && (g === " " || g === "\t")) {
            continue;
          }
        }
        d += g;
      }
      if (s && d.length) {
        d = n(d.replace(o, encodedReplacer), "binary", s);
      } else if (d) {
        d = n(d, "binary", "utf8");
      }
      if (t[p] === undefined) {
        if (d) {
          t[p] = d;
        }
      } else {
        t[p][1] = d;
      }
      return t;
    }
    e.exports = parseParams;
  },
  80056: (e) => {
    e.exports = JSON.parse(
      '{"name":"dotenv","version":"16.4.5","description":"Loads environment variables from .env file","main":"lib/main.js","types":"lib/main.d.ts","exports":{".":{"types":"./lib/main.d.ts","require":"./lib/main.js","default":"./lib/main.js"},"./config":"./config.js","./config.js":"./config.js","./lib/env-options":"./lib/env-options.js","./lib/env-options.js":"./lib/env-options.js","./lib/cli-options":"./lib/cli-options.js","./lib/cli-options.js":"./lib/cli-options.js","./package.json":"./package.json"},"scripts":{"dts-check":"tsc --project tests/types/tsconfig.json","lint":"standard","lint-readme":"standard-markdown","pretest":"npm run lint && npm run dts-check","test":"tap tests/*.js --100 -Rspec","test:coverage":"tap --coverage-report=lcov","prerelease":"npm test","release":"standard-version"},"repository":{"type":"git","url":"git://github.com/motdotla/dotenv.git"},"funding":"https://dotenvx.com","keywords":["dotenv","env",".env","environment","variables","config","settings"],"readmeFilename":"README.md","license":"BSD-2-Clause","devDependencies":{"@definitelytyped/dtslint":"^0.0.133","@types/node":"^18.11.3","decache":"^4.6.1","sinon":"^14.0.1","standard":"^17.0.0","standard-markdown":"^7.1.0","standard-version":"^9.5.0","tap":"^16.3.0","tar":"^6.1.11","typescript":"^4.8.4"},"engines":{"node":">=12"},"browser":{"fs":false}}'
    );
  },
};
var r = {};
function __nccwpck_require__(e) {
  var n = r[e];
  if (n !== undefined) {
    return n.exports;
  }
  var o = (r[e] = { exports: {} });
  var s = true;
  try {
    t[e].call(o.exports, o, o.exports, __nccwpck_require__);
    s = false;
  } finally {
    if (s) delete r[e];
  }
  return o.exports;
}
(() => {
  __nccwpck_require__.n = (e) => {
    var t = e && e.__esModule ? () => e["default"] : () => e;
    __nccwpck_require__.d(t, { a: t });
    return t;
  };
})();
(() => {
  __nccwpck_require__.d = (e, t) => {
    for (var r in t) {
      if (__nccwpck_require__.o(t, r) && !__nccwpck_require__.o(e, r)) {
        Object.defineProperty(e, r, { enumerable: true, get: t[r] });
      }
    }
  };
})();
(() => {
  __nccwpck_require__.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t);
})();
(() => {
  __nccwpck_require__.r = (e) => {
    if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
      Object.defineProperty(e, Symbol.toStringTag, { value: "Module" });
    }
    Object.defineProperty(e, "__esModule", { value: true });
  };
})();
if (typeof __nccwpck_require__ !== "undefined")
  __nccwpck_require__.ab = new URL(".", import.meta.url).pathname.slice(import.meta.url.match(/^file:\/\/\/\w:/) ? 1 : 0, -1) + "/";
var n = {};
var o = {};
__nccwpck_require__.r(o);
__nccwpck_require__.d(o, {
  Any: () => any_Any,
  Array: () => array_Array,
  AsyncIterator: () => async_iterator_AsyncIterator,
  Awaited: () => awaited_Awaited,
  BigInt: () => bigint_BigInt,
  Boolean: () => boolean_Boolean,
  Capitalize: () => capitalize_Capitalize,
  Composite: () => composite_Composite,
  Const: () => const_Const,
  Constructor: () => constructor_Constructor,
  ConstructorParameters: () => constructor_parameters_ConstructorParameters,
  Date: () => date_Date,
  Deref: () => deref_deref_Deref,
  Enum: () => enum_Enum,
  Exclude: () => exclude_Exclude,
  Extends: () => extends_Extends,
  Extract: () => extract_Extract,
  Function: () => src_Function,
  Index: () => indexed_Index,
  InstanceType: () => instance_type_InstanceType,
  Integer: () => integer_Integer,
  Intersect: () => intersect_Intersect,
  Iterator: () => iterator_Iterator,
  KeyOf: () => keyof_KeyOf,
  Literal: () => literal_Literal,
  Lowercase: () => lowercase_Lowercase,
  Mapped: () => mapped_Mapped,
  Never: () => never_Never,
  Not: () => not_Not,
  Null: () => null_Null,
  Number: () => number_Number,
  Object: () => T,
  Omit: () => omit_Omit,
  Optional: () => optional_Optional,
  Parameters: () => parameters_Parameters,
  Partial: () => partial_Partial,
  Pick: () => pick_Pick,
  Promise: () => promise_Promise,
  Readonly: () => readonly_Readonly,
  ReadonlyOptional: () => readonly_optional_ReadonlyOptional,
  Record: () => record_Record,
  Recursive: () => recursive_Recursive,
  Ref: () => ref_Ref,
  RegExp: () => regexp_RegExp,
  Required: () => required_Required,
  Rest: () => rest_Rest,
  ReturnType: () => return_type_ReturnType,
  Strict: () => strict_Strict,
  String: () => string_String,
  Symbol: () => symbol_Symbol,
  TemplateLiteral: () => template_literal_TemplateLiteral,
  Transform: () => transform_Transform,
  Tuple: () => tuple_Tuple,
  Uint8Array: () => uint8array_Uint8Array,
  Uncapitalize: () => uncapitalize_Uncapitalize,
  Undefined: () => undefined_Undefined,
  Union: () => union_Union,
  Unknown: () => unknown_Unknown,
  Unsafe: () => unsafe_Unsafe,
  Uppercase: () => uppercase_Uppercase,
  Void: () => void_Void,
});
var s = __nccwpck_require__(37484);
var i = __nccwpck_require__(93228);
var a = __nccwpck_require__(18889);
var A = __nccwpck_require__(65772);
function IsAsyncIterator(e) {
  return IsObject(e) && Symbol.asyncIterator in e;
}
function IsIterator(e) {
  return IsObject(e) && Symbol.iterator in e;
}
function IsStandardObject(e) {
  return IsObject(e) && (Object.getPrototypeOf(e) === Object.prototype || Object.getPrototypeOf(e) === null);
}
function IsInstanceObject(e) {
  return IsObject(e) && !IsArray(e) && IsFunction(e.constructor) && e.constructor.name !== "Object";
}
function IsPromise(e) {
  return e instanceof Promise;
}
function IsDate(e) {
  return e instanceof Date && Number.isFinite(e.getTime());
}
function IsMap(e) {
  return e instanceof globalThis.Map;
}
function IsSet(e) {
  return e instanceof globalThis.Set;
}
function IsRegExp(e) {
  return e instanceof globalThis.RegExp;
}
function IsTypedArray(e) {
  return ArrayBuffer.isView(e);
}
function IsInt8Array(e) {
  return e instanceof globalThis.Int8Array;
}
function IsUint8Array(e) {
  return e instanceof globalThis.Uint8Array;
}
function IsUint8ClampedArray(e) {
  return e instanceof globalThis.Uint8ClampedArray;
}
function IsInt16Array(e) {
  return e instanceof globalThis.Int16Array;
}
function IsUint16Array(e) {
  return e instanceof globalThis.Uint16Array;
}
function IsInt32Array(e) {
  return e instanceof globalThis.Int32Array;
}
function IsUint32Array(e) {
  return e instanceof globalThis.Uint32Array;
}
function IsFloat32Array(e) {
  return e instanceof globalThis.Float32Array;
}
function IsFloat64Array(e) {
  return e instanceof globalThis.Float64Array;
}
function IsBigInt64Array(e) {
  return e instanceof globalThis.BigInt64Array;
}
function IsBigUint64Array(e) {
  return e instanceof globalThis.BigUint64Array;
}
function HasPropertyKey(e, t) {
  return t in e;
}
function IsObject(e) {
  return e !== null && typeof e === "object";
}
function IsArray(e) {
  return Array.isArray(e) && !ArrayBuffer.isView(e);
}
function IsUndefined(e) {
  return e === undefined;
}
function IsNull(e) {
  return e === null;
}
function IsBoolean(e) {
  return typeof e === "boolean";
}
function IsNumber(e) {
  return typeof e === "number";
}
function IsInteger(e) {
  return Number.isInteger(e);
}
function IsBigInt(e) {
  return typeof e === "bigint";
}
function IsString(e) {
  return typeof e === "string";
}
function IsFunction(e) {
  return typeof e === "function";
}
function IsSymbol(e) {
  return typeof e === "symbol";
}
function IsValueType(e) {
  return IsBigInt(e) || IsBoolean(e) || IsNull(e) || IsNumber(e) || IsString(e) || IsSymbol(e) || IsUndefined(e);
}
var c;
(function (e) {
  e.ExactOptionalPropertyTypes = false;
  e.AllowArrayObject = false;
  e.AllowNaN = false;
  e.AllowNullVoid = false;
  function IsExactOptionalProperty(t, r) {
    return e.ExactOptionalPropertyTypes ? r in t : t[r] !== undefined;
  }
  e.IsExactOptionalProperty = IsExactOptionalProperty;
  function IsObjectLike(t) {
    const r = IsObject(t);
    return e.AllowArrayObject ? r : r && !IsArray(t);
  }
  e.IsObjectLike = IsObjectLike;
  function IsRecordLike(e) {
    return IsObjectLike(e) && !(e instanceof Date) && !(e instanceof Uint8Array);
  }
  e.IsRecordLike = IsRecordLike;
  function IsNumberLike(t) {
    return e.AllowNaN ? IsNumber(t) : Number.isFinite(t);
  }
  e.IsNumberLike = IsNumberLike;
  function IsVoidLike(t) {
    const r = IsUndefined(t);
    return e.AllowNullVoid ? r || t === null : r;
  }
  e.IsVoidLike = IsVoidLike;
})(c || (c = {}));
const u = new Map();
function Entries() {
  return new Map(u);
}
function Clear() {
  return u.clear();
}
function Delete(e) {
  return u.delete(e);
}
function Has(e) {
  return u.has(e);
}
function format_Set(e, t) {
  u.set(e, t);
}
function Get(e) {
  return u.get(e);
}
const l = new Map();
function type_Entries() {
  return new Map(l);
}
function type_Clear() {
  return l.clear();
}
function type_Delete(e) {
  return l.delete(e);
}
function type_Has(e) {
  return l.has(e);
}
function type_Set(e, t) {
  l.set(e, t);
}
function type_Get(e) {
  return l.get(e);
}
const p = Symbol.for("TypeBox.Transform");
const d = Symbol.for("TypeBox.Readonly");
const g = Symbol.for("TypeBox.Optional");
const m = Symbol.for("TypeBox.Hint");
const h = Symbol.for("TypeBox.Kind");
function unsafe_Unsafe(e = {}) {
  return { ...e, [h]: e[h] ?? "Unsafe" };
}
class TypeBoxError extends Error {
  constructor(e) {
    super(e);
  }
}
class TypeSystemDuplicateTypeKind extends TypeBoxError {
  constructor(e) {
    super(`Duplicate type kind '${e}' detected`);
  }
}
class TypeSystemDuplicateFormat extends TypeBoxError {
  constructor(e) {
    super(`Duplicate string format '${e}' detected`);
  }
}
var E;
(function (e) {
  function Type(e, t) {
    if (type_Has(e)) throw new TypeSystemDuplicateTypeKind(e);
    type_Set(e, t);
    return (t = {}) => unsafe_Unsafe({ ...t, [h]: e });
  }
  e.Type = Type;
  function Format(e, t) {
    if (Has(e)) throw new TypeSystemDuplicateFormat(e);
    format_Set(e, t);
    return e;
  }
  e.Format = Format;
})(E || (E = {}));
function MappedKey(e) {
  return { [Kind]: "MappedKey", keys: e };
}
function MappedResult(e) {
  return { [h]: "MappedResult", properties: e };
}
function value_IsAsyncIterator(e) {
  return value_IsObject(e) && !value_IsArray(e) && !value_IsUint8Array(e) && Symbol.asyncIterator in e;
}
function value_IsArray(e) {
  return Array.isArray(e);
}
function value_IsBigInt(e) {
  return typeof e === "bigint";
}
function value_IsBoolean(e) {
  return typeof e === "boolean";
}
function value_IsDate(e) {
  return e instanceof globalThis.Date;
}
function value_IsFunction(e) {
  return typeof e === "function";
}
function value_IsIterator(e) {
  return value_IsObject(e) && !value_IsArray(e) && !value_IsUint8Array(e) && Symbol.iterator in e;
}
function value_IsNull(e) {
  return e === null;
}
function value_IsNumber(e) {
  return typeof e === "number";
}
function value_IsObject(e) {
  return typeof e === "object" && e !== null;
}
function value_IsRegExp(e) {
  return e instanceof globalThis.RegExp;
}
function value_IsString(e) {
  return typeof e === "string";
}
function value_IsSymbol(e) {
  return typeof e === "symbol";
}
function value_IsUint8Array(e) {
  return e instanceof globalThis.Uint8Array;
}
function value_IsUndefined(e) {
  return e === undefined;
}
function ArrayType(e) {
  return e.map((e) => Visit(e));
}
function DateType(e) {
  return new Date(e.getTime());
}
function Uint8ArrayType(e) {
  return new Uint8Array(e);
}
function RegExpType(e) {
  return new RegExp(e.source, e.flags);
}
function ObjectType(e) {
  const t = {};
  for (const r of Object.getOwnPropertyNames(e)) {
    t[r] = Visit(e[r]);
  }
  for (const r of Object.getOwnPropertySymbols(e)) {
    t[r] = Visit(e[r]);
  }
  return t;
}
function Visit(e) {
  return value_IsArray(e)
    ? ArrayType(e)
    : value_IsDate(e)
      ? DateType(e)
      : value_IsUint8Array(e)
        ? Uint8ArrayType(e)
        : value_IsRegExp(e)
          ? RegExpType(e)
          : value_IsObject(e)
            ? ObjectType(e)
            : e;
}
function Clone(e) {
  return Visit(e);
}
function CloneRest(e) {
  return e.map((e) => CloneType(e));
}
function CloneType(e, t = {}) {
  return { ...Clone(e), ...t };
}
function DiscardKey(e, t) {
  const { [t]: r, ...n } = e;
  return n;
}
function Discard(e, t) {
  return t.reduce((e, t) => DiscardKey(e, t), e);
}
function array_Array(e, t = {}) {
  return { ...t, [h]: "Array", type: "array", items: CloneType(e) };
}
function async_iterator_AsyncIterator(e, t = {}) {
  return { ...t, [h]: "AsyncIterator", type: "AsyncIterator", items: CloneType(e) };
}
function constructor_Constructor(e, t, r) {
  return { ...r, [h]: "Constructor", type: "Constructor", parameters: CloneRest(e), returns: CloneType(t) };
}
function src_Function(e, t, r) {
  return { ...r, [h]: "Function", type: "Function", parameters: CloneRest(e), returns: CloneType(t) };
}
function never_Never(e = {}) {
  return { ...e, [h]: "Never", not: {} };
}
function IsReadonly(e) {
  return value_IsObject(e) && e[d] === "Readonly";
}
function IsOptional(e) {
  return value_IsObject(e) && e[g] === "Optional";
}
function IsAny(e) {
  return IsKindOf(e, "Any");
}
function kind_IsArray(e) {
  return IsKindOf(e, "Array");
}
function kind_IsAsyncIterator(e) {
  return IsKindOf(e, "AsyncIterator");
}
function kind_IsBigInt(e) {
  return IsKindOf(e, "BigInt");
}
function kind_IsBoolean(e) {
  return IsKindOf(e, "Boolean");
}
function IsConstructor(e) {
  return IsKindOf(e, "Constructor");
}
function kind_IsDate(e) {
  return IsKindOf(e, "Date");
}
function kind_IsFunction(e) {
  return IsKindOf(e, "Function");
}
function kind_IsInteger(e) {
  return IsKindOf(e, "Integer");
}
function IsProperties(e) {
  return ValueGuard.IsObject(e);
}
function IsIntersect(e) {
  return IsKindOf(e, "Intersect");
}
function kind_IsIterator(e) {
  return IsKindOf(e, "Iterator");
}
function IsKindOf(e, t) {
  return value_IsObject(e) && h in e && e[h] === t;
}
function IsLiteralString(e) {
  return IsLiteral(e) && ValueGuard.IsString(e.const);
}
function IsLiteralNumber(e) {
  return IsLiteral(e) && ValueGuard.IsNumber(e.const);
}
function IsLiteralBoolean(e) {
  return IsLiteral(e) && ValueGuard.IsBoolean(e.const);
}
function IsLiteral(e) {
  return IsKindOf(e, "Literal");
}
function IsMappedKey(e) {
  return IsKindOf(e, "MappedKey");
}
function IsMappedResult(e) {
  return IsKindOf(e, "MappedResult");
}
function IsNever(e) {
  return IsKindOf(e, "Never");
}
function IsNot(e) {
  return IsKindOf(e, "Not");
}
function kind_IsNull(e) {
  return IsKindOf(e, "Null");
}
function kind_IsNumber(e) {
  return IsKindOf(e, "Number");
}
function kind_IsObject(e) {
  return IsKindOf(e, "Object");
}
function kind_IsPromise(e) {
  return IsKindOf(e, "Promise");
}
function IsRecord(e) {
  return IsKindOf(e, "Record");
}
function IsRecursive(e) {
  return ValueGuard.IsObject(e) && Hint in e && e[Hint] === "Recursive";
}
function IsRef(e) {
  return IsKindOf(e, "Ref");
}
function kind_IsRegExp(e) {
  return IsKindOf(e, "RegExp");
}
function kind_IsString(e) {
  return IsKindOf(e, "String");
}
function kind_IsSymbol(e) {
  return IsKindOf(e, "Symbol");
}
function IsTemplateLiteral(e) {
  return IsKindOf(e, "TemplateLiteral");
}
function IsThis(e) {
  return IsKindOf(e, "This");
}
function IsTransform(e) {
  return value_IsObject(e) && p in e;
}
function IsTuple(e) {
  return IsKindOf(e, "Tuple");
}
function kind_IsUndefined(e) {
  return IsKindOf(e, "Undefined");
}
function IsUnion(e) {
  return IsKindOf(e, "Union");
}
function kind_IsUint8Array(e) {
  return IsKindOf(e, "Uint8Array");
}
function IsUnknown(e) {
  return IsKindOf(e, "Unknown");
}
function IsUnsafe(e) {
  return IsKindOf(e, "Unsafe");
}
function IsVoid(e) {
  return IsKindOf(e, "Void");
}
function IsKind(e) {
  return value_IsObject(e) && h in e && value_IsString(e[h]);
}
function IsSchema(e) {
  return (
    IsAny(e) ||
    kind_IsArray(e) ||
    kind_IsBoolean(e) ||
    kind_IsBigInt(e) ||
    kind_IsAsyncIterator(e) ||
    IsConstructor(e) ||
    kind_IsDate(e) ||
    kind_IsFunction(e) ||
    kind_IsInteger(e) ||
    IsIntersect(e) ||
    kind_IsIterator(e) ||
    IsLiteral(e) ||
    IsMappedKey(e) ||
    IsMappedResult(e) ||
    IsNever(e) ||
    IsNot(e) ||
    kind_IsNull(e) ||
    kind_IsNumber(e) ||
    kind_IsObject(e) ||
    kind_IsPromise(e) ||
    IsRecord(e) ||
    IsRef(e) ||
    kind_IsRegExp(e) ||
    kind_IsString(e) ||
    kind_IsSymbol(e) ||
    IsTemplateLiteral(e) ||
    IsThis(e) ||
    IsTuple(e) ||
    kind_IsUndefined(e) ||
    IsUnion(e) ||
    kind_IsUint8Array(e) ||
    IsUnknown(e) ||
    IsUnsafe(e) ||
    IsVoid(e) ||
    IsKind(e)
  );
}
function RemoveOptional(e) {
  return Discard(CloneType(e), [g]);
}
function AddOptional(e) {
  return { ...CloneType(e), [g]: "Optional" };
}
function OptionalWithFlag(e, t) {
  return t === false ? RemoveOptional(e) : AddOptional(e);
}
function optional_Optional(e, t) {
  const r = t ?? true;
  return IsMappedResult(e) ? OptionalFromMappedResult(e, r) : OptionalWithFlag(e, r);
}
function FromProperties(e, t) {
  const r = {};
  for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = optional_Optional(e[n], t);
  return r;
}
function FromMappedResult(e, t) {
  return FromProperties(e.properties, t);
}
function OptionalFromMappedResult(e, t) {
  const r = FromMappedResult(e, t);
  return MappedResult(r);
}
function IntersectCreate(e, t) {
  const r = e.every((e) => kind_IsObject(e));
  const n = IsSchema(t.unevaluatedProperties) ? { unevaluatedProperties: CloneType(t.unevaluatedProperties) } : {};
  return t.unevaluatedProperties === false || IsSchema(t.unevaluatedProperties) || r
    ? { ...t, ...n, [h]: "Intersect", type: "object", allOf: CloneRest(e) }
    : { ...t, ...n, [h]: "Intersect", allOf: CloneRest(e) };
}
function IsIntersectOptional(e) {
  return e.every((e) => IsOptional(e));
}
function RemoveOptionalFromType(e) {
  return Discard(e, [g]);
}
function RemoveOptionalFromRest(e) {
  return e.map((e) => (IsOptional(e) ? RemoveOptionalFromType(e) : e));
}
function ResolveIntersect(e, t) {
  return IsIntersectOptional(e) ? optional_Optional(IntersectCreate(RemoveOptionalFromRest(e), t)) : IntersectCreate(RemoveOptionalFromRest(e), t);
}
function IntersectEvaluated(e, t = {}) {
  if (e.length === 0) return never_Never(t);
  if (e.length === 1) return CloneType(e[0], t);
  if (e.some((e) => IsTransform(e))) throw new Error("Cannot intersect transform types");
  return ResolveIntersect(e, t);
}
function intersect_Intersect(e, t = {}) {
  if (e.length === 0) return never_Never(t);
  if (e.length === 1) return CloneType(e[0], t);
  if (e.some((e) => IsTransform(e))) throw new Error("Cannot intersect transform types");
  return IntersectCreate(e, t);
}
function UnionCreate(e, t) {
  return { ...t, [h]: "Union", anyOf: CloneRest(e) };
}
function IsUnionOptional(e) {
  return e.some((e) => IsOptional(e));
}
function union_evaluated_RemoveOptionalFromRest(e) {
  return e.map((e) => (IsOptional(e) ? union_evaluated_RemoveOptionalFromType(e) : e));
}
function union_evaluated_RemoveOptionalFromType(e) {
  return Discard(e, [g]);
}
function ResolveUnion(e, t) {
  return IsUnionOptional(e)
    ? optional_Optional(UnionCreate(union_evaluated_RemoveOptionalFromRest(e), t))
    : UnionCreate(union_evaluated_RemoveOptionalFromRest(e), t);
}
function UnionEvaluated(e, t = {}) {
  return e.length === 0 ? never_Never(t) : e.length === 1 ? CloneType(e[0], t) : ResolveUnion(e, t);
}
function union_Union(e, t = {}) {
  return e.length === 0 ? never_Never(t) : e.length === 1 ? CloneType(e[0], t) : UnionCreate(e, t);
}
class TemplateLiteralParserError extends TypeBoxError {}
function Unescape(e) {
  return e.replace(/\\\$/g, "$").replace(/\\\*/g, "*").replace(/\\\^/g, "^").replace(/\\\|/g, "|").replace(/\\\(/g, "(").replace(/\\\)/g, ")");
}
function IsNonEscaped(e, t, r) {
  return e[t] === r && e.charCodeAt(t - 1) !== 92;
}
function IsOpenParen(e, t) {
  return IsNonEscaped(e, t, "(");
}
function IsCloseParen(e, t) {
  return IsNonEscaped(e, t, ")");
}
function IsSeparator(e, t) {
  return IsNonEscaped(e, t, "|");
}
function IsGroup(e) {
  if (!(IsOpenParen(e, 0) && IsCloseParen(e, e.length - 1))) return false;
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    if (IsOpenParen(e, r)) t += 1;
    if (IsCloseParen(e, r)) t -= 1;
    if (t === 0 && r !== e.length - 1) return false;
  }
  return true;
}
function InGroup(e) {
  return e.slice(1, e.length - 1);
}
function IsPrecedenceOr(e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    if (IsOpenParen(e, r)) t += 1;
    if (IsCloseParen(e, r)) t -= 1;
    if (IsSeparator(e, r) && t === 0) return true;
  }
  return false;
}
function IsPrecedenceAnd(e) {
  for (let t = 0; t < e.length; t++) {
    if (IsOpenParen(e, t)) return true;
  }
  return false;
}
function Or(e) {
  let [t, r] = [0, 0];
  const n = [];
  for (let o = 0; o < e.length; o++) {
    if (IsOpenParen(e, o)) t += 1;
    if (IsCloseParen(e, o)) t -= 1;
    if (IsSeparator(e, o) && t === 0) {
      const t = e.slice(r, o);
      if (t.length > 0) n.push(TemplateLiteralParse(t));
      r = o + 1;
    }
  }
  const o = e.slice(r);
  if (o.length > 0) n.push(TemplateLiteralParse(o));
  if (n.length === 0) return { type: "const", const: "" };
  if (n.length === 1) return n[0];
  return { type: "or", expr: n };
}
function And(e) {
  function Group(e, t) {
    if (!IsOpenParen(e, t)) throw new TemplateLiteralParserError(`TemplateLiteralParser: Index must point to open parens`);
    let r = 0;
    for (let n = t; n < e.length; n++) {
      if (IsOpenParen(e, n)) r += 1;
      if (IsCloseParen(e, n)) r -= 1;
      if (r === 0) return [t, n];
    }
    throw new TemplateLiteralParserError(`TemplateLiteralParser: Unclosed group parens in expression`);
  }
  function Range(e, t) {
    for (let r = t; r < e.length; r++) {
      if (IsOpenParen(e, r)) return [t, r];
    }
    return [t, e.length];
  }
  const t = [];
  for (let r = 0; r < e.length; r++) {
    if (IsOpenParen(e, r)) {
      const [n, o] = Group(e, r);
      const s = e.slice(n, o + 1);
      t.push(TemplateLiteralParse(s));
      r = o;
    } else {
      const [n, o] = Range(e, r);
      const s = e.slice(n, o);
      if (s.length > 0) t.push(TemplateLiteralParse(s));
      r = o - 1;
    }
  }
  return t.length === 0 ? { type: "const", const: "" } : t.length === 1 ? t[0] : { type: "and", expr: t };
}
function TemplateLiteralParse(e) {
  return IsGroup(e) ? TemplateLiteralParse(InGroup(e)) : IsPrecedenceOr(e) ? Or(e) : IsPrecedenceAnd(e) ? And(e) : { type: "const", const: Unescape(e) };
}
function TemplateLiteralParseExact(e) {
  return TemplateLiteralParse(e.slice(1, e.length - 1));
}
class TemplateLiteralFiniteError extends TypeBoxError {}
function IsNumberExpression(e) {
  return (
    e.type === "or" &&
    e.expr.length === 2 &&
    e.expr[0].type === "const" &&
    e.expr[0].const === "0" &&
    e.expr[1].type === "const" &&
    e.expr[1].const === "[1-9][0-9]*"
  );
}
function IsBooleanExpression(e) {
  return (
    e.type === "or" &&
    e.expr.length === 2 &&
    e.expr[0].type === "const" &&
    e.expr[0].const === "true" &&
    e.expr[1].type === "const" &&
    e.expr[1].const === "false"
  );
}
function IsStringExpression(e) {
  return e.type === "const" && e.const === ".*";
}
function IsTemplateLiteralExpressionFinite(e) {
  return IsNumberExpression(e) || IsStringExpression(e)
    ? false
    : IsBooleanExpression(e)
      ? true
      : e.type === "and"
        ? e.expr.every((e) => IsTemplateLiteralExpressionFinite(e))
        : e.type === "or"
          ? e.expr.every((e) => IsTemplateLiteralExpressionFinite(e))
          : e.type === "const"
            ? true
            : (() => {
                throw new TemplateLiteralFiniteError(`Unknown expression type`);
              })();
}
function IsTemplateLiteralFinite(e) {
  const t = TemplateLiteralParseExact(e.pattern);
  return IsTemplateLiteralExpressionFinite(t);
}
class TemplateLiteralGenerateError extends TypeBoxError {}
function* GenerateReduce(e) {
  if (e.length === 1) return yield* e[0];
  for (const t of e[0]) {
    for (const r of GenerateReduce(e.slice(1))) {
      yield `${t}${r}`;
    }
  }
}
function* GenerateAnd(e) {
  return yield* GenerateReduce(e.expr.map((e) => [...TemplateLiteralExpressionGenerate(e)]));
}
function* GenerateOr(e) {
  for (const t of e.expr) yield* TemplateLiteralExpressionGenerate(t);
}
function* GenerateConst(e) {
  return yield e.const;
}
function* TemplateLiteralExpressionGenerate(e) {
  return e.type === "and"
    ? yield* GenerateAnd(e)
    : e.type === "or"
      ? yield* GenerateOr(e)
      : e.type === "const"
        ? yield* GenerateConst(e)
        : (() => {
            throw new TemplateLiteralGenerateError("Unknown expression");
          })();
}
function TemplateLiteralGenerate(e) {
  const t = TemplateLiteralParseExact(e.pattern);
  return IsTemplateLiteralExpressionFinite(t) ? [...TemplateLiteralExpressionGenerate(t)] : [];
}
function literal_Literal(e, t = {}) {
  return { ...t, [h]: "Literal", const: e, type: typeof e };
}
function boolean_Boolean(e = {}) {
  return { ...e, [h]: "Boolean", type: "boolean" };
}
function bigint_BigInt(e = {}) {
  return { ...e, [h]: "BigInt", type: "bigint" };
}
function number_Number(e = {}) {
  return { ...e, [h]: "Number", type: "number" };
}
function string_String(e = {}) {
  return { ...e, [h]: "String", type: "string" };
}
function* FromUnion(e) {
  const t = e.trim().replace(/"|'/g, "");
  return t === "boolean"
    ? yield boolean_Boolean()
    : t === "number"
      ? yield number_Number()
      : t === "bigint"
        ? yield bigint_BigInt()
        : t === "string"
          ? yield string_String()
          : yield (() => {
              const e = t.split("|").map((e) => literal_Literal(e.trim()));
              return e.length === 0 ? never_Never() : e.length === 1 ? e[0] : UnionEvaluated(e);
            })();
}
function* FromTerminal(e) {
  if (e[1] !== "{") {
    const t = literal_Literal("$");
    const r = FromSyntax(e.slice(1));
    return yield* [t, ...r];
  }
  for (let t = 2; t < e.length; t++) {
    if (e[t] === "}") {
      const r = FromUnion(e.slice(2, t));
      const n = FromSyntax(e.slice(t + 1));
      return yield* [...r, ...n];
    }
  }
  yield literal_Literal(e);
}
function* FromSyntax(e) {
  for (let t = 0; t < e.length; t++) {
    if (e[t] === "$") {
      const r = literal_Literal(e.slice(0, t));
      const n = FromTerminal(e.slice(t));
      return yield* [r, ...n];
    }
  }
  yield literal_Literal(e);
}
function TemplateLiteralSyntax(e) {
  return [...FromSyntax(e)];
}
const I = "(true|false)";
const y = "(0|[1-9][0-9]*)";
const C = "(.*)";
const b = null && `^${I}$`;
const Q = `^${y}$`;
const B = `^${C}$`;
class TemplateLiteralPatternError extends TypeBoxError {}
function Escape(e) {
  return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function pattern_Visit(e, t) {
  return IsTemplateLiteral(e)
    ? e.pattern.slice(1, e.pattern.length - 1)
    : IsUnion(e)
      ? `(${e.anyOf.map((e) => pattern_Visit(e, t)).join("|")})`
      : kind_IsNumber(e)
        ? `${t}${y}`
        : kind_IsInteger(e)
          ? `${t}${y}`
          : kind_IsBigInt(e)
            ? `${t}${y}`
            : kind_IsString(e)
              ? `${t}${C}`
              : IsLiteral(e)
                ? `${t}${Escape(e.const.toString())}`
                : kind_IsBoolean(e)
                  ? `${t}${I}`
                  : (() => {
                      throw new TemplateLiteralPatternError(`Unexpected Kind '${e[h]}'`);
                    })();
}
function TemplateLiteralPattern(e) {
  return `^${e.map((e) => pattern_Visit(e, "")).join("")}$`;
}
function TemplateLiteralToUnion(e) {
  const t = TemplateLiteralGenerate(e);
  const r = t.map((e) => literal_Literal(e));
  return UnionEvaluated(r);
}
function template_literal_TemplateLiteral(e, t = {}) {
  const r = value_IsString(e) ? TemplateLiteralPattern(TemplateLiteralSyntax(e)) : TemplateLiteralPattern(e);
  return { ...t, [h]: "TemplateLiteral", type: "string", pattern: r };
}
function FromTemplateLiteral(e) {
  const t = TemplateLiteralGenerate(e);
  return t.map((e) => e.toString());
}
function indexed_property_keys_FromUnion(e) {
  const t = [];
  for (const r of e) t.push(...IndexPropertyKeys(r));
  return t;
}
function FromLiteral(e) {
  return [e.toString()];
}
function IndexPropertyKeys(e) {
  return [
    ...new Set(
      IsTemplateLiteral(e)
        ? FromTemplateLiteral(e)
        : IsUnion(e)
          ? indexed_property_keys_FromUnion(e.anyOf)
          : IsLiteral(e)
            ? FromLiteral(e.const)
            : kind_IsNumber(e)
              ? ["[number]"]
              : kind_IsInteger(e)
                ? ["[number]"]
                : []
    ),
  ];
}
function indexed_from_mapped_result_FromProperties(e, t, r) {
  const n = {};
  for (const o of Object.getOwnPropertyNames(t)) {
    n[o] = indexed_Index(e, IndexPropertyKeys(t[o]), r);
  }
  return n;
}
function indexed_from_mapped_result_FromMappedResult(e, t, r) {
  return indexed_from_mapped_result_FromProperties(e, t.properties, r);
}
function IndexFromMappedResult(e, t, r) {
  const n = indexed_from_mapped_result_FromMappedResult(e, t, r);
  return MappedResult(n);
}
function FromRest(e, t) {
  return e.map((e) => IndexFromPropertyKey(e, t));
}
function FromIntersectRest(e) {
  return e.filter((e) => !IsNever(e));
}
function FromIntersect(e, t) {
  return IntersectEvaluated(FromIntersectRest(FromRest(e, t)));
}
function FromUnionRest(e) {
  return e.some((e) => IsNever(e)) ? [] : e;
}
function indexed_FromUnion(e, t) {
  return UnionEvaluated(FromUnionRest(FromRest(e, t)));
}
function FromTuple(e, t) {
  return t in e ? e[t] : t === "[number]" ? UnionEvaluated(e) : never_Never();
}
function FromArray(e, t) {
  return t === "[number]" ? e : never_Never();
}
function FromProperty(e, t) {
  return t in e ? e[t] : never_Never();
}
function IndexFromPropertyKey(e, t) {
  return IsIntersect(e)
    ? FromIntersect(e.allOf, t)
    : IsUnion(e)
      ? indexed_FromUnion(e.anyOf, t)
      : IsTuple(e)
        ? FromTuple(e.items ?? [], t)
        : kind_IsArray(e)
          ? FromArray(e.items, t)
          : kind_IsObject(e)
            ? FromProperty(e.properties, t)
            : never_Never();
}
function IndexFromPropertyKeys(e, t) {
  return t.map((t) => IndexFromPropertyKey(e, t));
}
function FromSchema(e, t) {
  return UnionEvaluated(IndexFromPropertyKeys(e, t));
}
function indexed_Index(e, t, r = {}) {
  return IsMappedResult(t)
    ? CloneType(IndexFromMappedResult(e, t, r))
    : IsMappedKey(t)
      ? CloneType(IndexFromMappedKey(e, t, r))
      : IsSchema(t)
        ? CloneType(FromSchema(e, IndexPropertyKeys(t)), r)
        : CloneType(FromSchema(e, t), r);
}
function MappedIndexPropertyKey(e, t, r) {
  return { [t]: indexed_Index(e, [t], r) };
}
function MappedIndexPropertyKeys(e, t, r) {
  return t.reduce((t, n) => ({ ...t, ...MappedIndexPropertyKey(e, n, r) }), {});
}
function MappedIndexProperties(e, t, r) {
  return MappedIndexPropertyKeys(e, t.keys, r);
}
function IndexFromMappedKey(e, t, r) {
  const n = MappedIndexProperties(e, t, r);
  return MappedResult(n);
}
function iterator_Iterator(e, t = {}) {
  return { ...t, [h]: "Iterator", type: "Iterator", items: CloneType(e) };
}
function _Object(e, t = {}) {
  const r = globalThis.Object.getOwnPropertyNames(e);
  const n = r.filter((t) => IsOptional(e[t]));
  const o = r.filter((e) => !n.includes(e));
  const s = IsSchema(t.additionalProperties) ? { additionalProperties: CloneType(t.additionalProperties) } : {};
  const i = {};
  for (const t of r) i[t] = CloneType(e[t]);
  return o.length > 0
    ? { ...t, ...s, [h]: "Object", type: "object", properties: i, required: o }
    : { ...t, ...s, [h]: "Object", type: "object", properties: i };
}
const T = _Object;
function promise_Promise(e, t = {}) {
  return { ...t, [h]: "Promise", type: "Promise", item: CloneType(e) };
}
function RemoveReadonly(e) {
  return Discard(CloneType(e), [d]);
}
function AddReadonly(e) {
  return { ...CloneType(e), [d]: "Readonly" };
}
function ReadonlyWithFlag(e, t) {
  return t === false ? RemoveReadonly(e) : AddReadonly(e);
}
function readonly_Readonly(e, t) {
  const r = t ?? true;
  return IsMappedResult(e) ? ReadonlyFromMappedResult(e, r) : ReadonlyWithFlag(e, r);
}
function readonly_from_mapped_result_FromProperties(e, t) {
  const r = {};
  for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = readonly_Readonly(e[n], t);
  return r;
}
function readonly_from_mapped_result_FromMappedResult(e, t) {
  return readonly_from_mapped_result_FromProperties(e.properties, t);
}
function ReadonlyFromMappedResult(e, t) {
  const r = readonly_from_mapped_result_FromMappedResult(e, t);
  return MappedResult(r);
}
function tuple_Tuple(e, t = {}) {
  const [r, n, o] = [false, e.length, e.length];
  return e.length > 0
    ? { ...t, [h]: "Tuple", type: "array", items: CloneRest(e), additionalItems: r, minItems: n, maxItems: o }
    : { ...t, [h]: "Tuple", type: "array", minItems: n, maxItems: o };
}
function SetIncludes(e, t) {
  return e.includes(t);
}
function SetIsSubset(e, t) {
  return e.every((e) => SetIncludes(t, e));
}
function SetDistinct(e) {
  return [...new Set(e)];
}
function SetIntersect(e, t) {
  return e.filter((e) => t.includes(e));
}
function SetUnion(e, t) {
  return [...e, ...t];
}
function SetComplement(e, t) {
  return e.filter((e) => !t.includes(e));
}
function SetIntersectManyResolve(e, t) {
  return e.reduce((e, t) => SetIntersect(e, t), t);
}
function SetIntersectMany(e) {
  return e.length === 1 ? e[0] : e.length > 1 ? SetIntersectManyResolve(e.slice(1), e[0]) : [];
}
function SetUnionMany(e) {
  const t = [];
  for (const r of e) t.push(...r);
  return t;
}
function mapped_FromMappedResult(e, t) {
  return e in t ? FromSchemaType(e, t[e]) : MappedResult(t);
}
function MappedKeyToKnownMappedResultProperties(e) {
  return { [e]: literal_Literal(e) };
}
function MappedKeyToUnknownMappedResultProperties(e) {
  const t = {};
  for (const r of e) t[r] = literal_Literal(r);
  return t;
}
function MappedKeyToMappedResultProperties(e, t) {
  return SetIncludes(t, e) ? MappedKeyToKnownMappedResultProperties(e) : MappedKeyToUnknownMappedResultProperties(t);
}
function FromMappedKey(e, t) {
  const r = MappedKeyToMappedResultProperties(e, t);
  return mapped_FromMappedResult(e, r);
}
function mapped_FromRest(e, t) {
  return t.map((t) => FromSchemaType(e, t));
}
function mapped_FromProperties(e, t) {
  const r = {};
  for (const n of globalThis.Object.getOwnPropertyNames(t)) r[n] = FromSchemaType(e, t[n]);
  return r;
}
function FromSchemaType(e, t) {
  return IsOptional(t)
    ? optional_Optional(FromSchemaType(e, Discard(t, [g])))
    : IsReadonly(t)
      ? readonly_Readonly(FromSchemaType(e, Discard(t, [d])))
      : IsMappedResult(t)
        ? mapped_FromMappedResult(e, t.properties)
        : IsMappedKey(t)
          ? FromMappedKey(e, t.keys)
          : IsConstructor(t)
            ? constructor_Constructor(mapped_FromRest(e, t.parameters), FromSchemaType(e, t.returns))
            : kind_IsFunction(t)
              ? src_Function(mapped_FromRest(e, t.parameters), FromSchemaType(e, t.returns))
              : kind_IsAsyncIterator(t)
                ? async_iterator_AsyncIterator(FromSchemaType(e, t.items))
                : kind_IsIterator(t)
                  ? iterator_Iterator(FromSchemaType(e, t.items))
                  : IsIntersect(t)
                    ? intersect_Intersect(mapped_FromRest(e, t.allOf))
                    : IsUnion(t)
                      ? union_Union(mapped_FromRest(e, t.anyOf))
                      : IsTuple(t)
                        ? tuple_Tuple(mapped_FromRest(e, t.items ?? []))
                        : kind_IsObject(t)
                          ? T(mapped_FromProperties(e, t.properties))
                          : kind_IsArray(t)
                            ? array_Array(FromSchemaType(e, t.items))
                            : kind_IsPromise(t)
                              ? promise_Promise(FromSchemaType(e, t.item))
                              : t;
}
function MappedFunctionReturnType(e, t) {
  const r = {};
  for (const n of e) r[n] = FromSchemaType(n, t);
  return r;
}
function mapped_Mapped(e, t, r = {}) {
  const n = IsSchema(e) ? IndexPropertyKeys(e) : e;
  const o = t({ [h]: "MappedKey", keys: n });
  const s = MappedFunctionReturnType(n, o);
  return CloneType(T(s), r);
}
function keyof_property_keys_FromRest(e) {
  const t = [];
  for (const r of e) t.push(KeyOfPropertyKeys(r));
  return t;
}
function keyof_property_keys_FromIntersect(e) {
  const t = keyof_property_keys_FromRest(e);
  const r = SetUnionMany(t);
  return r;
}
function keyof_property_keys_FromUnion(e) {
  const t = keyof_property_keys_FromRest(e);
  const r = SetIntersectMany(t);
  return r;
}
function keyof_property_keys_FromTuple(e) {
  return e.map((e, t) => t.toString());
}
function keyof_property_keys_FromArray(e) {
  return ["[number]"];
}
function keyof_property_keys_FromProperties(e) {
  return globalThis.Object.getOwnPropertyNames(e);
}
function FromPatternProperties(e) {
  if (!v) return [];
  const t = globalThis.Object.getOwnPropertyNames(e);
  return t.map((e) => (e[0] === "^" && e[e.length - 1] === "$" ? e.slice(1, e.length - 1) : e));
}
function KeyOfPropertyKeys(e) {
  return IsIntersect(e)
    ? keyof_property_keys_FromIntersect(e.allOf)
    : IsUnion(e)
      ? keyof_property_keys_FromUnion(e.anyOf)
      : IsTuple(e)
        ? keyof_property_keys_FromTuple(e.items ?? [])
        : kind_IsArray(e)
          ? keyof_property_keys_FromArray(e.items)
          : kind_IsObject(e)
            ? keyof_property_keys_FromProperties(e.properties)
            : IsRecord(e)
              ? FromPatternProperties(e.patternProperties)
              : [];
}
let v = false;
function KeyOfPattern(e) {
  v = true;
  const t = KeyOfPropertyKeys(e);
  v = false;
  const r = t.map((e) => `(${e})`);
  return `^(${r.join("|")})$`;
}
function KeyOfPropertyKeysToRest(e) {
  return e.map((e) => (e === "[number]" ? number_Number() : literal_Literal(e)));
}
function keyof_KeyOf(e, t = {}) {
  if (IsMappedResult(e)) {
    return KeyOfFromMappedResult(e, t);
  } else {
    const r = KeyOfPropertyKeys(e);
    const n = KeyOfPropertyKeysToRest(r);
    const o = UnionEvaluated(n);
    return CloneType(o, t);
  }
}
function keyof_from_mapped_result_FromProperties(e, t) {
  const r = {};
  for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = keyof_KeyOf(e[n], t);
  return r;
}
function keyof_from_mapped_result_FromMappedResult(e, t) {
  return keyof_from_mapped_result_FromProperties(e.properties, t);
}
function KeyOfFromMappedResult(e, t) {
  const r = keyof_from_mapped_result_FromMappedResult(e, t);
  return MappedResult(r);
}
function KeyOfPropertyEntries(e) {
  const t = KeyOfPropertyKeys(e);
  const r = IndexFromPropertyKeys(e, t);
  return t.map((e, n) => [t[n], r[n]]);
}
function extends_undefined_Intersect(e) {
  return e.allOf.every((e) => ExtendsUndefinedCheck(e));
}
function extends_undefined_Union(e) {
  return e.anyOf.some((e) => ExtendsUndefinedCheck(e));
}
function extends_undefined_Not(e) {
  return !ExtendsUndefinedCheck(e.not);
}
function ExtendsUndefinedCheck(e) {
  return e[h] === "Intersect"
    ? extends_undefined_Intersect(e)
    : e[h] === "Union"
      ? extends_undefined_Union(e)
      : e[h] === "Not"
        ? extends_undefined_Not(e)
        : e[h] === "Undefined"
          ? true
          : false;
}
function DefaultErrorFunction(e) {
  switch (e.errorType) {
    case P.ArrayContains:
      return "Expected array to contain at least one matching value";
    case P.ArrayMaxContains:
      return `Expected array to contain no more than ${e.schema.maxContains} matching values`;
    case P.ArrayMinContains:
      return `Expected array to contain at least ${e.schema.minContains} matching values`;
    case P.ArrayMaxItems:
      return `Expected array length to be less or equal to ${e.schema.maxItems}`;
    case P.ArrayMinItems:
      return `Expected array length to be greater or equal to ${e.schema.minItems}`;
    case P.ArrayUniqueItems:
      return "Expected array elements to be unique";
    case P.Array:
      return "Expected array";
    case P.AsyncIterator:
      return "Expected AsyncIterator";
    case P.BigIntExclusiveMaximum:
      return `Expected bigint to be less than ${e.schema.exclusiveMaximum}`;
    case P.BigIntExclusiveMinimum:
      return `Expected bigint to be greater than ${e.schema.exclusiveMinimum}`;
    case P.BigIntMaximum:
      return `Expected bigint to be less or equal to ${e.schema.maximum}`;
    case P.BigIntMinimum:
      return `Expected bigint to be greater or equal to ${e.schema.minimum}`;
    case P.BigIntMultipleOf:
      return `Expected bigint to be a multiple of ${e.schema.multipleOf}`;
    case P.BigInt:
      return "Expected bigint";
    case P.Boolean:
      return "Expected boolean";
    case P.DateExclusiveMinimumTimestamp:
      return `Expected Date timestamp to be greater than ${e.schema.exclusiveMinimumTimestamp}`;
    case P.DateExclusiveMaximumTimestamp:
      return `Expected Date timestamp to be less than ${e.schema.exclusiveMaximumTimestamp}`;
    case P.DateMinimumTimestamp:
      return `Expected Date timestamp to be greater or equal to ${e.schema.minimumTimestamp}`;
    case P.DateMaximumTimestamp:
      return `Expected Date timestamp to be less or equal to ${e.schema.maximumTimestamp}`;
    case P.DateMultipleOfTimestamp:
      return `Expected Date timestamp to be a multiple of ${e.schema.multipleOfTimestamp}`;
    case P.Date:
      return "Expected Date";
    case P.Function:
      return "Expected function";
    case P.IntegerExclusiveMaximum:
      return `Expected integer to be less than ${e.schema.exclusiveMaximum}`;
    case P.IntegerExclusiveMinimum:
      return `Expected integer to be greater than ${e.schema.exclusiveMinimum}`;
    case P.IntegerMaximum:
      return `Expected integer to be less or equal to ${e.schema.maximum}`;
    case P.IntegerMinimum:
      return `Expected integer to be greater or equal to ${e.schema.minimum}`;
    case P.IntegerMultipleOf:
      return `Expected integer to be a multiple of ${e.schema.multipleOf}`;
    case P.Integer:
      return "Expected integer";
    case P.IntersectUnevaluatedProperties:
      return "Unexpected property";
    case P.Intersect:
      return "Expected all values to match";
    case P.Iterator:
      return "Expected Iterator";
    case P.Literal:
      return `Expected ${typeof e.schema.const === "string" ? `'${e.schema.const}'` : e.schema.const}`;
    case P.Never:
      return "Never";
    case P.Not:
      return "Value should not match";
    case P.Null:
      return "Expected null";
    case P.NumberExclusiveMaximum:
      return `Expected number to be less than ${e.schema.exclusiveMaximum}`;
    case P.NumberExclusiveMinimum:
      return `Expected number to be greater than ${e.schema.exclusiveMinimum}`;
    case P.NumberMaximum:
      return `Expected number to be less or equal to ${e.schema.maximum}`;
    case P.NumberMinimum:
      return `Expected number to be greater or equal to ${e.schema.minimum}`;
    case P.NumberMultipleOf:
      return `Expected number to be a multiple of ${e.schema.multipleOf}`;
    case P.Number:
      return "Expected number";
    case P.Object:
      return "Expected object";
    case P.ObjectAdditionalProperties:
      return "Unexpected property";
    case P.ObjectMaxProperties:
      return `Expected object to have no more than ${e.schema.maxProperties} properties`;
    case P.ObjectMinProperties:
      return `Expected object to have at least ${e.schema.minProperties} properties`;
    case P.ObjectRequiredProperty:
      return "Required property";
    case P.Promise:
      return "Expected Promise";
    case P.RegExp:
      return "Expected string to match regular expression";
    case P.StringFormatUnknown:
      return `Unknown format '${e.schema.format}'`;
    case P.StringFormat:
      return `Expected string to match '${e.schema.format}' format`;
    case P.StringMaxLength:
      return `Expected string length less or equal to ${e.schema.maxLength}`;
    case P.StringMinLength:
      return `Expected string length greater or equal to ${e.schema.minLength}`;
    case P.StringPattern:
      return `Expected string to match '${e.schema.pattern}'`;
    case P.String:
      return "Expected string";
    case P.Symbol:
      return "Expected symbol";
    case P.TupleLength:
      return `Expected tuple to have ${e.schema.maxItems || 0} elements`;
    case P.Tuple:
      return "Expected tuple";
    case P.Uint8ArrayMaxByteLength:
      return `Expected byte length less or equal to ${e.schema.maxByteLength}`;
    case P.Uint8ArrayMinByteLength:
      return `Expected byte length greater or equal to ${e.schema.minByteLength}`;
    case P.Uint8Array:
      return "Expected Uint8Array";
    case P.Undefined:
      return "Expected undefined";
    case P.Union:
      return "Expected union value";
    case P.Void:
      return "Expected void";
    case P.Kind:
      return `Expected kind '${e.schema[h]}'`;
    default:
      return "Unknown error type";
  }
}
let w = DefaultErrorFunction;
function SetErrorFunction(e) {
  w = e;
}
function GetErrorFunction() {
  return w;
}
class TypeDereferenceError extends TypeBoxError {
  schema;
  constructor(e) {
    super(`Unable to dereference schema with $id '${e.$id}'`);
    this.schema = e;
  }
}
function Resolve(e, t) {
  const r = t.find((t) => t.$id === e.$ref);
  if (r === undefined) throw new TypeDereferenceError(e);
  return deref_Deref(r, t);
}
function deref_Deref(e, t) {
  return e[h] === "This" || e[h] === "Ref" ? Resolve(e, t) : e;
}
class ValueHashError extends TypeBoxError {
  value;
  constructor(e) {
    super(`Unable to hash value`);
    this.value = e;
  }
}
var _;
(function (e) {
  e[(e["Undefined"] = 0)] = "Undefined";
  e[(e["Null"] = 1)] = "Null";
  e[(e["Boolean"] = 2)] = "Boolean";
  e[(e["Number"] = 3)] = "Number";
  e[(e["String"] = 4)] = "String";
  e[(e["Object"] = 5)] = "Object";
  e[(e["Array"] = 6)] = "Array";
  e[(e["Date"] = 7)] = "Date";
  e[(e["Uint8Array"] = 8)] = "Uint8Array";
  e[(e["Symbol"] = 9)] = "Symbol";
  e[(e["BigInt"] = 10)] = "BigInt";
})(_ || (_ = {}));
let R = BigInt("14695981039346656037");
const [O, F] = [BigInt("1099511628211"), BigInt("2") ** BigInt("64")];
const D = Array.from({ length: 256 }).map((e, t) => BigInt(t));
const k = new Float64Array(1);
const S = new DataView(k.buffer);
const N = new Uint8Array(k.buffer);
function* NumberToBytes(e) {
  const t = e === 0 ? 1 : Math.ceil(Math.floor(Math.log2(e) + 1) / 8);
  for (let r = 0; r < t; r++) {
    yield (e >> (8 * (t - 1 - r))) & 255;
  }
}
function hash_ArrayType(e) {
  FNV1A64(_.Array);
  for (const t of e) {
    hash_Visit(t);
  }
}
function BooleanType(e) {
  FNV1A64(_.Boolean);
  FNV1A64(e ? 1 : 0);
}
function BigIntType(e) {
  FNV1A64(_.BigInt);
  S.setBigInt64(0, e);
  for (const e of N) {
    FNV1A64(e);
  }
}
function hash_DateType(e) {
  FNV1A64(_.Date);
  hash_Visit(e.getTime());
}
function NullType(e) {
  FNV1A64(_.Null);
}
function NumberType(e) {
  FNV1A64(_.Number);
  S.setFloat64(0, e);
  for (const e of N) {
    FNV1A64(e);
  }
}
function hash_ObjectType(e) {
  FNV1A64(_.Object);
  for (const t of globalThis.Object.getOwnPropertyNames(e).sort()) {
    hash_Visit(t);
    hash_Visit(e[t]);
  }
}
function StringType(e) {
  FNV1A64(_.String);
  for (let t = 0; t < e.length; t++) {
    for (const r of NumberToBytes(e.charCodeAt(t))) {
      FNV1A64(r);
    }
  }
}
function SymbolType(e) {
  FNV1A64(_.Symbol);
  hash_Visit(e.description);
}
function hash_Uint8ArrayType(e) {
  FNV1A64(_.Uint8Array);
  for (let t = 0; t < e.length; t++) {
    FNV1A64(e[t]);
  }
}
function UndefinedType(e) {
  return FNV1A64(_.Undefined);
}
function hash_Visit(e) {
  if (IsArray(e)) return hash_ArrayType(e);
  if (IsBoolean(e)) return BooleanType(e);
  if (IsBigInt(e)) return BigIntType(e);
  if (IsDate(e)) return hash_DateType(e);
  if (IsNull(e)) return NullType(e);
  if (IsNumber(e)) return NumberType(e);
  if (IsStandardObject(e)) return hash_ObjectType(e);
  if (IsString(e)) return StringType(e);
  if (IsSymbol(e)) return SymbolType(e);
  if (IsUint8Array(e)) return hash_Uint8ArrayType(e);
  if (IsUndefined(e)) return UndefinedType(e);
  throw new ValueHashError(e);
}
function FNV1A64(e) {
  R = R ^ D[e];
  R = (R * O) % F;
}
function Hash(e) {
  R = BigInt("14695981039346656037");
  hash_Visit(e);
  return R;
}
var P;
(function (e) {
  e[(e["ArrayContains"] = 0)] = "ArrayContains";
  e[(e["ArrayMaxContains"] = 1)] = "ArrayMaxContains";
  e[(e["ArrayMaxItems"] = 2)] = "ArrayMaxItems";
  e[(e["ArrayMinContains"] = 3)] = "ArrayMinContains";
  e[(e["ArrayMinItems"] = 4)] = "ArrayMinItems";
  e[(e["ArrayUniqueItems"] = 5)] = "ArrayUniqueItems";
  e[(e["Array"] = 6)] = "Array";
  e[(e["AsyncIterator"] = 7)] = "AsyncIterator";
  e[(e["BigIntExclusiveMaximum"] = 8)] = "BigIntExclusiveMaximum";
  e[(e["BigIntExclusiveMinimum"] = 9)] = "BigIntExclusiveMinimum";
  e[(e["BigIntMaximum"] = 10)] = "BigIntMaximum";
  e[(e["BigIntMinimum"] = 11)] = "BigIntMinimum";
  e[(e["BigIntMultipleOf"] = 12)] = "BigIntMultipleOf";
  e[(e["BigInt"] = 13)] = "BigInt";
  e[(e["Boolean"] = 14)] = "Boolean";
  e[(e["DateExclusiveMaximumTimestamp"] = 15)] = "DateExclusiveMaximumTimestamp";
  e[(e["DateExclusiveMinimumTimestamp"] = 16)] = "DateExclusiveMinimumTimestamp";
  e[(e["DateMaximumTimestamp"] = 17)] = "DateMaximumTimestamp";
  e[(e["DateMinimumTimestamp"] = 18)] = "DateMinimumTimestamp";
  e[(e["DateMultipleOfTimestamp"] = 19)] = "DateMultipleOfTimestamp";
  e[(e["Date"] = 20)] = "Date";
  e[(e["Function"] = 21)] = "Function";
  e[(e["IntegerExclusiveMaximum"] = 22)] = "IntegerExclusiveMaximum";
  e[(e["IntegerExclusiveMinimum"] = 23)] = "IntegerExclusiveMinimum";
  e[(e["IntegerMaximum"] = 24)] = "IntegerMaximum";
  e[(e["IntegerMinimum"] = 25)] = "IntegerMinimum";
  e[(e["IntegerMultipleOf"] = 26)] = "IntegerMultipleOf";
  e[(e["Integer"] = 27)] = "Integer";
  e[(e["IntersectUnevaluatedProperties"] = 28)] = "IntersectUnevaluatedProperties";
  e[(e["Intersect"] = 29)] = "Intersect";
  e[(e["Iterator"] = 30)] = "Iterator";
  e[(e["Kind"] = 31)] = "Kind";
  e[(e["Literal"] = 32)] = "Literal";
  e[(e["Never"] = 33)] = "Never";
  e[(e["Not"] = 34)] = "Not";
  e[(e["Null"] = 35)] = "Null";
  e[(e["NumberExclusiveMaximum"] = 36)] = "NumberExclusiveMaximum";
  e[(e["NumberExclusiveMinimum"] = 37)] = "NumberExclusiveMinimum";
  e[(e["NumberMaximum"] = 38)] = "NumberMaximum";
  e[(e["NumberMinimum"] = 39)] = "NumberMinimum";
  e[(e["NumberMultipleOf"] = 40)] = "NumberMultipleOf";
  e[(e["Number"] = 41)] = "Number";
  e[(e["ObjectAdditionalProperties"] = 42)] = "ObjectAdditionalProperties";
  e[(e["ObjectMaxProperties"] = 43)] = "ObjectMaxProperties";
  e[(e["ObjectMinProperties"] = 44)] = "ObjectMinProperties";
  e[(e["ObjectRequiredProperty"] = 45)] = "ObjectRequiredProperty";
  e[(e["Object"] = 46)] = "Object";
  e[(e["Promise"] = 47)] = "Promise";
  e[(e["RegExp"] = 48)] = "RegExp";
  e[(e["StringFormatUnknown"] = 49)] = "StringFormatUnknown";
  e[(e["StringFormat"] = 50)] = "StringFormat";
  e[(e["StringMaxLength"] = 51)] = "StringMaxLength";
  e[(e["StringMinLength"] = 52)] = "StringMinLength";
  e[(e["StringPattern"] = 53)] = "StringPattern";
  e[(e["String"] = 54)] = "String";
  e[(e["Symbol"] = 55)] = "Symbol";
  e[(e["TupleLength"] = 56)] = "TupleLength";
  e[(e["Tuple"] = 57)] = "Tuple";
  e[(e["Uint8ArrayMaxByteLength"] = 58)] = "Uint8ArrayMaxByteLength";
  e[(e["Uint8ArrayMinByteLength"] = 59)] = "Uint8ArrayMinByteLength";
  e[(e["Uint8Array"] = 60)] = "Uint8Array";
  e[(e["Undefined"] = 61)] = "Undefined";
  e[(e["Union"] = 62)] = "Union";
  e[(e["Void"] = 63)] = "Void";
})(P || (P = {}));
class ValueErrorsUnknownTypeError extends TypeBoxError {
  schema;
  constructor(e) {
    super("Unknown type");
    this.schema = e;
  }
}
function EscapeKey(e) {
  return e.replace(/~/g, "~0").replace(/\//g, "~1");
}
function IsDefined(e) {
  return e !== undefined;
}
class ValueErrorIterator {
  iterator;
  constructor(e) {
    this.iterator = e;
  }
  [Symbol.iterator]() {
    return this.iterator;
  }
  First() {
    const e = this.iterator.next();
    return e.done ? undefined : e.value;
  }
}
function Create(e, t, r, n) {
  return { type: e, schema: t, path: r, value: n, message: GetErrorFunction()({ errorType: e, path: r, schema: t, value: n }) };
}
function* FromAny(e, t, r, n) {}
function* errors_FromArray(e, t, r, n) {
  if (!IsArray(n)) {
    return yield Create(P.Array, e, r, n);
  }
  if (IsDefined(e.minItems) && !(n.length >= e.minItems)) {
    yield Create(P.ArrayMinItems, e, r, n);
  }
  if (IsDefined(e.maxItems) && !(n.length <= e.maxItems)) {
    yield Create(P.ArrayMaxItems, e, r, n);
  }
  for (let o = 0; o < n.length; o++) {
    yield* errors_Visit(e.items, t, `${r}/${o}`, n[o]);
  }
  if (
    e.uniqueItems === true &&
    !(function () {
      const e = new Set();
      for (const t of n) {
        const r = Hash(t);
        if (e.has(r)) {
          return false;
        } else {
          e.add(r);
        }
      }
      return true;
    })()
  ) {
    yield Create(P.ArrayUniqueItems, e, r, n);
  }
  if (!(IsDefined(e.contains) || IsDefined(e.minContains) || IsDefined(e.maxContains))) {
    return;
  }
  const o = IsDefined(e.contains) ? e.contains : never_Never();
  const s = n.reduce((e, n, s) => (errors_Visit(o, t, `${r}${s}`, n).next().done === true ? e + 1 : e), 0);
  if (s === 0) {
    yield Create(P.ArrayContains, e, r, n);
  }
  if (IsNumber(e.minContains) && s < e.minContains) {
    yield Create(P.ArrayMinContains, e, r, n);
  }
  if (IsNumber(e.maxContains) && s > e.maxContains) {
    yield Create(P.ArrayMaxContains, e, r, n);
  }
}
function* FromAsyncIterator(e, t, r, n) {
  if (!IsAsyncIterator(n)) yield Create(P.AsyncIterator, e, r, n);
}
function* FromBigInt(e, t, r, n) {
  if (!IsBigInt(n)) return yield Create(P.BigInt, e, r, n);
  if (IsDefined(e.exclusiveMaximum) && !(n < e.exclusiveMaximum)) {
    yield Create(P.BigIntExclusiveMaximum, e, r, n);
  }
  if (IsDefined(e.exclusiveMinimum) && !(n > e.exclusiveMinimum)) {
    yield Create(P.BigIntExclusiveMinimum, e, r, n);
  }
  if (IsDefined(e.maximum) && !(n <= e.maximum)) {
    yield Create(P.BigIntMaximum, e, r, n);
  }
  if (IsDefined(e.minimum) && !(n >= e.minimum)) {
    yield Create(P.BigIntMinimum, e, r, n);
  }
  if (IsDefined(e.multipleOf) && !(n % e.multipleOf === BigInt(0))) {
    yield Create(P.BigIntMultipleOf, e, r, n);
  }
}
function* FromBoolean(e, t, r, n) {
  if (!IsBoolean(n)) yield Create(P.Boolean, e, r, n);
}
function* FromConstructor(e, t, r, n) {
  yield* errors_Visit(e.returns, t, r, n.prototype);
}
function* FromDate(e, t, r, n) {
  if (!IsDate(n)) return yield Create(P.Date, e, r, n);
  if (IsDefined(e.exclusiveMaximumTimestamp) && !(n.getTime() < e.exclusiveMaximumTimestamp)) {
    yield Create(P.DateExclusiveMaximumTimestamp, e, r, n);
  }
  if (IsDefined(e.exclusiveMinimumTimestamp) && !(n.getTime() > e.exclusiveMinimumTimestamp)) {
    yield Create(P.DateExclusiveMinimumTimestamp, e, r, n);
  }
  if (IsDefined(e.maximumTimestamp) && !(n.getTime() <= e.maximumTimestamp)) {
    yield Create(P.DateMaximumTimestamp, e, r, n);
  }
  if (IsDefined(e.minimumTimestamp) && !(n.getTime() >= e.minimumTimestamp)) {
    yield Create(P.DateMinimumTimestamp, e, r, n);
  }
  if (IsDefined(e.multipleOfTimestamp) && !(n.getTime() % e.multipleOfTimestamp === 0)) {
    yield Create(P.DateMultipleOfTimestamp, e, r, n);
  }
}
function* FromFunction(e, t, r, n) {
  if (!IsFunction(n)) yield Create(P.Function, e, r, n);
}
function* FromInteger(e, t, r, n) {
  if (!IsInteger(n)) return yield Create(P.Integer, e, r, n);
  if (IsDefined(e.exclusiveMaximum) && !(n < e.exclusiveMaximum)) {
    yield Create(P.IntegerExclusiveMaximum, e, r, n);
  }
  if (IsDefined(e.exclusiveMinimum) && !(n > e.exclusiveMinimum)) {
    yield Create(P.IntegerExclusiveMinimum, e, r, n);
  }
  if (IsDefined(e.maximum) && !(n <= e.maximum)) {
    yield Create(P.IntegerMaximum, e, r, n);
  }
  if (IsDefined(e.minimum) && !(n >= e.minimum)) {
    yield Create(P.IntegerMinimum, e, r, n);
  }
  if (IsDefined(e.multipleOf) && !(n % e.multipleOf === 0)) {
    yield Create(P.IntegerMultipleOf, e, r, n);
  }
}
function* errors_FromIntersect(e, t, r, n) {
  for (const o of e.allOf) {
    const s = errors_Visit(o, t, r, n).next();
    if (!s.done) {
      yield Create(P.Intersect, e, r, n);
      yield s.value;
    }
  }
  if (e.unevaluatedProperties === false) {
    const t = new RegExp(KeyOfPattern(e));
    for (const o of Object.getOwnPropertyNames(n)) {
      if (!t.test(o)) {
        yield Create(P.IntersectUnevaluatedProperties, e, `${r}/${o}`, n);
      }
    }
  }
  if (typeof e.unevaluatedProperties === "object") {
    const o = new RegExp(KeyOfPattern(e));
    for (const s of Object.getOwnPropertyNames(n)) {
      if (!o.test(s)) {
        const o = errors_Visit(e.unevaluatedProperties, t, `${r}/${s}`, n[s]).next();
        if (!o.done) yield o.value;
      }
    }
  }
}
function* FromIterator(e, t, r, n) {
  if (!IsIterator(n)) yield Create(P.Iterator, e, r, n);
}
function* errors_FromLiteral(e, t, r, n) {
  if (!(n === e.const)) yield Create(P.Literal, e, r, n);
}
function* FromNever(e, t, r, n) {
  yield Create(P.Never, e, r, n);
}
function* FromNot(e, t, r, n) {
  if (errors_Visit(e.not, t, r, n).next().done === true) yield Create(P.Not, e, r, n);
}
function* FromNull(e, t, r, n) {
  if (!IsNull(n)) yield Create(P.Null, e, r, n);
}
function* FromNumber(e, t, r, n) {
  if (!c.IsNumberLike(n)) return yield Create(P.Number, e, r, n);
  if (IsDefined(e.exclusiveMaximum) && !(n < e.exclusiveMaximum)) {
    yield Create(P.NumberExclusiveMaximum, e, r, n);
  }
  if (IsDefined(e.exclusiveMinimum) && !(n > e.exclusiveMinimum)) {
    yield Create(P.NumberExclusiveMinimum, e, r, n);
  }
  if (IsDefined(e.maximum) && !(n <= e.maximum)) {
    yield Create(P.NumberMaximum, e, r, n);
  }
  if (IsDefined(e.minimum) && !(n >= e.minimum)) {
    yield Create(P.NumberMinimum, e, r, n);
  }
  if (IsDefined(e.multipleOf) && !(n % e.multipleOf === 0)) {
    yield Create(P.NumberMultipleOf, e, r, n);
  }
}
function* FromObject(e, t, r, n) {
  if (!c.IsObjectLike(n)) return yield Create(P.Object, e, r, n);
  if (IsDefined(e.minProperties) && !(Object.getOwnPropertyNames(n).length >= e.minProperties)) {
    yield Create(P.ObjectMinProperties, e, r, n);
  }
  if (IsDefined(e.maxProperties) && !(Object.getOwnPropertyNames(n).length <= e.maxProperties)) {
    yield Create(P.ObjectMaxProperties, e, r, n);
  }
  const o = Array.isArray(e.required) ? e.required : [];
  const s = Object.getOwnPropertyNames(e.properties);
  const i = Object.getOwnPropertyNames(n);
  for (const t of o) {
    if (i.includes(t)) continue;
    yield Create(P.ObjectRequiredProperty, e.properties[t], `${r}/${EscapeKey(t)}`, undefined);
  }
  if (e.additionalProperties === false) {
    for (const t of i) {
      if (!s.includes(t)) {
        yield Create(P.ObjectAdditionalProperties, e, `${r}/${EscapeKey(t)}`, n[t]);
      }
    }
  }
  if (typeof e.additionalProperties === "object") {
    for (const o of i) {
      if (s.includes(o)) continue;
      yield* errors_Visit(e.additionalProperties, t, `${r}/${EscapeKey(o)}`, n[o]);
    }
  }
  for (const o of s) {
    const s = e.properties[o];
    if (e.required && e.required.includes(o)) {
      yield* errors_Visit(s, t, `${r}/${EscapeKey(o)}`, n[o]);
      if (ExtendsUndefinedCheck(e) && !(o in n)) {
        yield Create(P.ObjectRequiredProperty, s, `${r}/${EscapeKey(o)}`, undefined);
      }
    } else {
      if (c.IsExactOptionalProperty(n, o)) {
        yield* errors_Visit(s, t, `${r}/${EscapeKey(o)}`, n[o]);
      }
    }
  }
}
function* FromPromise(e, t, r, n) {
  if (!IsPromise(n)) yield Create(P.Promise, e, r, n);
}
function* FromRecord(e, t, r, n) {
  if (!c.IsRecordLike(n)) return yield Create(P.Object, e, r, n);
  if (IsDefined(e.minProperties) && !(Object.getOwnPropertyNames(n).length >= e.minProperties)) {
    yield Create(P.ObjectMinProperties, e, r, n);
  }
  if (IsDefined(e.maxProperties) && !(Object.getOwnPropertyNames(n).length <= e.maxProperties)) {
    yield Create(P.ObjectMaxProperties, e, r, n);
  }
  const [o, s] = Object.entries(e.patternProperties)[0];
  const i = new RegExp(o);
  for (const [e, o] of Object.entries(n)) {
    if (i.test(e)) yield* errors_Visit(s, t, `${r}/${EscapeKey(e)}`, o);
  }
  if (typeof e.additionalProperties === "object") {
    for (const [o, s] of Object.entries(n)) {
      if (!i.test(o)) yield* errors_Visit(e.additionalProperties, t, `${r}/${EscapeKey(o)}`, s);
    }
  }
  if (e.additionalProperties === false) {
    for (const [t, o] of Object.entries(n)) {
      if (i.test(t)) continue;
      return yield Create(P.ObjectAdditionalProperties, e, `${r}/${EscapeKey(t)}`, o);
    }
  }
}
function* FromRef(e, t, r, n) {
  yield* errors_Visit(deref_Deref(e, t), t, r, n);
}
function* FromRegExp(e, t, r, n) {
  if (!IsString(n)) return yield Create(P.String, e, r, n);
  if (IsDefined(e.minLength) && !(n.length >= e.minLength)) {
    yield Create(P.StringMinLength, e, r, n);
  }
  if (IsDefined(e.maxLength) && !(n.length <= e.maxLength)) {
    yield Create(P.StringMaxLength, e, r, n);
  }
  const o = new RegExp(e.source, e.flags);
  if (!o.test(n)) {
    return yield Create(P.RegExp, e, r, n);
  }
}
function* FromString(e, t, r, n) {
  if (!IsString(n)) return yield Create(P.String, e, r, n);
  if (IsDefined(e.minLength) && !(n.length >= e.minLength)) {
    yield Create(P.StringMinLength, e, r, n);
  }
  if (IsDefined(e.maxLength) && !(n.length <= e.maxLength)) {
    yield Create(P.StringMaxLength, e, r, n);
  }
  if (IsString(e.pattern)) {
    const t = new RegExp(e.pattern);
    if (!t.test(n)) {
      yield Create(P.StringPattern, e, r, n);
    }
  }
  if (IsString(e.format)) {
    if (!Has(e.format)) {
      yield Create(P.StringFormatUnknown, e, r, n);
    } else {
      const t = Get(e.format);
      if (!t(n)) {
        yield Create(P.StringFormat, e, r, n);
      }
    }
  }
}
function* FromSymbol(e, t, r, n) {
  if (!IsSymbol(n)) yield Create(P.Symbol, e, r, n);
}
function* errors_FromTemplateLiteral(e, t, r, n) {
  if (!IsString(n)) return yield Create(P.String, e, r, n);
  const o = new RegExp(e.pattern);
  if (!o.test(n)) {
    yield Create(P.StringPattern, e, r, n);
  }
}
function* FromThis(e, t, r, n) {
  yield* errors_Visit(deref_Deref(e, t), t, r, n);
}
function* errors_FromTuple(e, t, r, n) {
  if (!IsArray(n)) return yield Create(P.Tuple, e, r, n);
  if (e.items === undefined && !(n.length === 0)) {
    return yield Create(P.TupleLength, e, r, n);
  }
  if (!(n.length === e.maxItems)) {
    return yield Create(P.TupleLength, e, r, n);
  }
  if (!e.items) {
    return;
  }
  for (let o = 0; o < e.items.length; o++) {
    yield* errors_Visit(e.items[o], t, `${r}/${o}`, n[o]);
  }
}
function* FromUndefined(e, t, r, n) {
  if (!IsUndefined(n)) yield Create(P.Undefined, e, r, n);
}
function* errors_FromUnion(e, t, r, n) {
  let o = 0;
  for (const s of e.anyOf) {
    const e = [...errors_Visit(s, t, r, n)];
    if (e.length === 0) return;
    o += e.length;
  }
  if (o > 0) {
    yield Create(P.Union, e, r, n);
  }
}
function* FromUint8Array(e, t, r, n) {
  if (!IsUint8Array(n)) return yield Create(P.Uint8Array, e, r, n);
  if (IsDefined(e.maxByteLength) && !(n.length <= e.maxByteLength)) {
    yield Create(P.Uint8ArrayMaxByteLength, e, r, n);
  }
  if (IsDefined(e.minByteLength) && !(n.length >= e.minByteLength)) {
    yield Create(P.Uint8ArrayMinByteLength, e, r, n);
  }
}
function* FromUnknown(e, t, r, n) {}
function* FromVoid(e, t, r, n) {
  if (!c.IsVoidLike(n)) yield Create(P.Void, e, r, n);
}
function* FromKind(e, t, r, n) {
  const o = type_Get(e[h]);
  if (!o(e, n)) yield Create(P.Kind, e, r, n);
}
function* errors_Visit(e, t, r, n) {
  const o = IsDefined(e.$id) ? [...t, e] : t;
  const s = e;
  switch (s[h]) {
    case "Any":
      return yield* FromAny(s, o, r, n);
    case "Array":
      return yield* errors_FromArray(s, o, r, n);
    case "AsyncIterator":
      return yield* FromAsyncIterator(s, o, r, n);
    case "BigInt":
      return yield* FromBigInt(s, o, r, n);
    case "Boolean":
      return yield* FromBoolean(s, o, r, n);
    case "Constructor":
      return yield* FromConstructor(s, o, r, n);
    case "Date":
      return yield* FromDate(s, o, r, n);
    case "Function":
      return yield* FromFunction(s, o, r, n);
    case "Integer":
      return yield* FromInteger(s, o, r, n);
    case "Intersect":
      return yield* errors_FromIntersect(s, o, r, n);
    case "Iterator":
      return yield* FromIterator(s, o, r, n);
    case "Literal":
      return yield* errors_FromLiteral(s, o, r, n);
    case "Never":
      return yield* FromNever(s, o, r, n);
    case "Not":
      return yield* FromNot(s, o, r, n);
    case "Null":
      return yield* FromNull(s, o, r, n);
    case "Number":
      return yield* FromNumber(s, o, r, n);
    case "Object":
      return yield* FromObject(s, o, r, n);
    case "Promise":
      return yield* FromPromise(s, o, r, n);
    case "Record":
      return yield* FromRecord(s, o, r, n);
    case "Ref":
      return yield* FromRef(s, o, r, n);
    case "RegExp":
      return yield* FromRegExp(s, o, r, n);
    case "String":
      return yield* FromString(s, o, r, n);
    case "Symbol":
      return yield* FromSymbol(s, o, r, n);
    case "TemplateLiteral":
      return yield* errors_FromTemplateLiteral(s, o, r, n);
    case "This":
      return yield* FromThis(s, o, r, n);
    case "Tuple":
      return yield* errors_FromTuple(s, o, r, n);
    case "Undefined":
      return yield* FromUndefined(s, o, r, n);
    case "Union":
      return yield* errors_FromUnion(s, o, r, n);
    case "Uint8Array":
      return yield* FromUint8Array(s, o, r, n);
    case "Unknown":
      return yield* FromUnknown(s, o, r, n);
    case "Void":
      return yield* FromVoid(s, o, r, n);
    default:
      if (!type_Has(s[h])) throw new ValueErrorsUnknownTypeError(e);
      return yield* FromKind(s, o, r, n);
  }
}
function Errors(...e) {
  const t = e.length === 3 ? errors_Visit(e[0], e[1], "", e[2]) : errors_Visit(e[0], [], "", e[1]);
  return new ValueErrorIterator(t);
}
function any_Any(e = {}) {
  return { ...e, [h]: "Any" };
}
function unknown_Unknown(e = {}) {
  return { ...e, [h]: "Unknown" };
}
class TypeGuardUnknownTypeError extends TypeBoxError {}
const L = [
  "Any",
  "Array",
  "AsyncIterator",
  "BigInt",
  "Boolean",
  "Constructor",
  "Date",
  "Enum",
  "Function",
  "Integer",
  "Intersect",
  "Iterator",
  "Literal",
  "MappedKey",
  "MappedResult",
  "Not",
  "Null",
  "Number",
  "Object",
  "Promise",
  "Record",
  "Ref",
  "RegExp",
  "String",
  "Symbol",
  "TemplateLiteral",
  "This",
  "Tuple",
  "Undefined",
  "Union",
  "Uint8Array",
  "Unknown",
  "Void",
];
function IsPattern(e) {
  try {
    new RegExp(e);
    return true;
  } catch {
    return false;
  }
}
function IsControlCharacterFree(e) {
  if (!value_IsString(e)) return false;
  for (let t = 0; t < e.length; t++) {
    const r = e.charCodeAt(t);
    if ((r >= 7 && r <= 13) || r === 27 || r === 127) {
      return false;
    }
  }
  return true;
}
function IsAdditionalProperties(e) {
  return IsOptionalBoolean(e) || type_IsSchema(e);
}
function IsOptionalBigInt(e) {
  return value_IsUndefined(e) || value_IsBigInt(e);
}
function IsOptionalNumber(e) {
  return value_IsUndefined(e) || value_IsNumber(e);
}
function IsOptionalBoolean(e) {
  return value_IsUndefined(e) || value_IsBoolean(e);
}
function IsOptionalString(e) {
  return value_IsUndefined(e) || value_IsString(e);
}
function IsOptionalPattern(e) {
  return value_IsUndefined(e) || (value_IsString(e) && IsControlCharacterFree(e) && IsPattern(e));
}
function IsOptionalFormat(e) {
  return value_IsUndefined(e) || (value_IsString(e) && IsControlCharacterFree(e));
}
function IsOptionalSchema(e) {
  return value_IsUndefined(e) || type_IsSchema(e);
}
function type_IsReadonly(e) {
  return value_IsObject(e) && e[d] === "Readonly";
}
function type_IsOptional(e) {
  return value_IsObject(e) && e[g] === "Optional";
}
function type_IsAny(e) {
  return type_IsKindOf(e, "Any") && IsOptionalString(e.$id);
}
function type_IsArray(e) {
  return (
    type_IsKindOf(e, "Array") &&
    e.type === "array" &&
    IsOptionalString(e.$id) &&
    type_IsSchema(e.items) &&
    IsOptionalNumber(e.minItems) &&
    IsOptionalNumber(e.maxItems) &&
    IsOptionalBoolean(e.uniqueItems) &&
    IsOptionalSchema(e.contains) &&
    IsOptionalNumber(e.minContains) &&
    IsOptionalNumber(e.maxContains)
  );
}
function type_IsAsyncIterator(e) {
  return type_IsKindOf(e, "AsyncIterator") && e.type === "AsyncIterator" && IsOptionalString(e.$id) && type_IsSchema(e.items);
}
function type_IsBigInt(e) {
  return (
    type_IsKindOf(e, "BigInt") &&
    e.type === "bigint" &&
    IsOptionalString(e.$id) &&
    IsOptionalBigInt(e.exclusiveMaximum) &&
    IsOptionalBigInt(e.exclusiveMinimum) &&
    IsOptionalBigInt(e.maximum) &&
    IsOptionalBigInt(e.minimum) &&
    IsOptionalBigInt(e.multipleOf)
  );
}
function type_IsBoolean(e) {
  return type_IsKindOf(e, "Boolean") && e.type === "boolean" && IsOptionalString(e.$id);
}
function type_IsConstructor(e) {
  return (
    type_IsKindOf(e, "Constructor") &&
    e.type === "Constructor" &&
    IsOptionalString(e.$id) &&
    value_IsArray(e.parameters) &&
    e.parameters.every((e) => type_IsSchema(e)) &&
    type_IsSchema(e.returns)
  );
}
function type_IsDate(e) {
  return (
    type_IsKindOf(e, "Date") &&
    e.type === "Date" &&
    IsOptionalString(e.$id) &&
    IsOptionalNumber(e.exclusiveMaximumTimestamp) &&
    IsOptionalNumber(e.exclusiveMinimumTimestamp) &&
    IsOptionalNumber(e.maximumTimestamp) &&
    IsOptionalNumber(e.minimumTimestamp) &&
    IsOptionalNumber(e.multipleOfTimestamp)
  );
}
function type_IsFunction(e) {
  return (
    type_IsKindOf(e, "Function") &&
    e.type === "Function" &&
    IsOptionalString(e.$id) &&
    value_IsArray(e.parameters) &&
    e.parameters.every((e) => type_IsSchema(e)) &&
    type_IsSchema(e.returns)
  );
}
function type_IsInteger(e) {
  return (
    type_IsKindOf(e, "Integer") &&
    e.type === "integer" &&
    IsOptionalString(e.$id) &&
    IsOptionalNumber(e.exclusiveMaximum) &&
    IsOptionalNumber(e.exclusiveMinimum) &&
    IsOptionalNumber(e.maximum) &&
    IsOptionalNumber(e.minimum) &&
    IsOptionalNumber(e.multipleOf)
  );
}
function type_IsProperties(e) {
  return value_IsObject(e) && Object.entries(e).every(([e, t]) => IsControlCharacterFree(e) && type_IsSchema(t));
}
function type_IsIntersect(e) {
  return (
    type_IsKindOf(e, "Intersect") &&
    (value_IsString(e.type) && e.type !== "object" ? false : true) &&
    value_IsArray(e.allOf) &&
    e.allOf.every((e) => type_IsSchema(e) && !type_IsTransform(e)) &&
    IsOptionalString(e.type) &&
    (IsOptionalBoolean(e.unevaluatedProperties) || IsOptionalSchema(e.unevaluatedProperties)) &&
    IsOptionalString(e.$id)
  );
}
function type_IsIterator(e) {
  return type_IsKindOf(e, "Iterator") && e.type === "Iterator" && IsOptionalString(e.$id) && type_IsSchema(e.items);
}
function type_IsKindOf(e, t) {
  return value_IsObject(e) && h in e && e[h] === t;
}
function type_IsLiteralString(e) {
  return type_IsLiteral(e) && value_IsString(e.const);
}
function type_IsLiteralNumber(e) {
  return type_IsLiteral(e) && value_IsNumber(e.const);
}
function type_IsLiteralBoolean(e) {
  return type_IsLiteral(e) && value_IsBoolean(e.const);
}
function type_IsLiteral(e) {
  return type_IsKindOf(e, "Literal") && IsOptionalString(e.$id) && IsLiteralValue(e.const);
}
function IsLiteralValue(e) {
  return value_IsBoolean(e) || value_IsNumber(e) || value_IsString(e);
}
function type_IsMappedKey(e) {
  return type_IsKindOf(e, "MappedKey") && value_IsArray(e.keys) && e.keys.every((e) => value_IsNumber(e) || value_IsString(e));
}
function type_IsMappedResult(e) {
  return type_IsKindOf(e, "MappedResult") && type_IsProperties(e.properties);
}
function type_IsNever(e) {
  return type_IsKindOf(e, "Never") && value_IsObject(e.not) && Object.getOwnPropertyNames(e.not).length === 0;
}
function type_IsNot(e) {
  return type_IsKindOf(e, "Not") && type_IsSchema(e.not);
}
function type_IsNull(e) {
  return type_IsKindOf(e, "Null") && e.type === "null" && IsOptionalString(e.$id);
}
function type_IsNumber(e) {
  return (
    type_IsKindOf(e, "Number") &&
    e.type === "number" &&
    IsOptionalString(e.$id) &&
    IsOptionalNumber(e.exclusiveMaximum) &&
    IsOptionalNumber(e.exclusiveMinimum) &&
    IsOptionalNumber(e.maximum) &&
    IsOptionalNumber(e.minimum) &&
    IsOptionalNumber(e.multipleOf)
  );
}
function type_IsObject(e) {
  return (
    type_IsKindOf(e, "Object") &&
    e.type === "object" &&
    IsOptionalString(e.$id) &&
    type_IsProperties(e.properties) &&
    IsAdditionalProperties(e.additionalProperties) &&
    IsOptionalNumber(e.minProperties) &&
    IsOptionalNumber(e.maxProperties)
  );
}
function type_IsPromise(e) {
  return type_IsKindOf(e, "Promise") && e.type === "Promise" && IsOptionalString(e.$id) && type_IsSchema(e.item);
}
function type_IsRecord(e) {
  return (
    type_IsKindOf(e, "Record") &&
    e.type === "object" &&
    IsOptionalString(e.$id) &&
    IsAdditionalProperties(e.additionalProperties) &&
    value_IsObject(e.patternProperties) &&
    ((e) => {
      const t = Object.getOwnPropertyNames(e.patternProperties);
      return t.length === 1 && IsPattern(t[0]) && value_IsObject(e.patternProperties) && type_IsSchema(e.patternProperties[t[0]]);
    })(e)
  );
}
function type_IsRecursive(e) {
  return value_IsObject(e) && m in e && e[m] === "Recursive";
}
function type_IsRef(e) {
  return type_IsKindOf(e, "Ref") && IsOptionalString(e.$id) && value_IsString(e.$ref);
}
function type_IsRegExp(e) {
  return (
    type_IsKindOf(e, "RegExp") &&
    IsOptionalString(e.$id) &&
    value_IsString(e.source) &&
    value_IsString(e.flags) &&
    IsOptionalNumber(e.maxLength) &&
    IsOptionalNumber(e.minLength)
  );
}
function type_IsString(e) {
  return (
    type_IsKindOf(e, "String") &&
    e.type === "string" &&
    IsOptionalString(e.$id) &&
    IsOptionalNumber(e.minLength) &&
    IsOptionalNumber(e.maxLength) &&
    IsOptionalPattern(e.pattern) &&
    IsOptionalFormat(e.format)
  );
}
function type_IsSymbol(e) {
  return type_IsKindOf(e, "Symbol") && e.type === "symbol" && IsOptionalString(e.$id);
}
function type_IsTemplateLiteral(e) {
  return (
    type_IsKindOf(e, "TemplateLiteral") && e.type === "string" && value_IsString(e.pattern) && e.pattern[0] === "^" && e.pattern[e.pattern.length - 1] === "$"
  );
}
function type_IsThis(e) {
  return type_IsKindOf(e, "This") && IsOptionalString(e.$id) && value_IsString(e.$ref);
}
function type_IsTransform(e) {
  return value_IsObject(e) && p in e;
}
function type_IsTuple(e) {
  return (
    type_IsKindOf(e, "Tuple") &&
    e.type === "array" &&
    IsOptionalString(e.$id) &&
    value_IsNumber(e.minItems) &&
    value_IsNumber(e.maxItems) &&
    e.minItems === e.maxItems &&
    ((value_IsUndefined(e.items) && value_IsUndefined(e.additionalItems) && e.minItems === 0) ||
      (value_IsArray(e.items) && e.items.every((e) => type_IsSchema(e))))
  );
}
function type_IsUndefined(e) {
  return type_IsKindOf(e, "Undefined") && e.type === "undefined" && IsOptionalString(e.$id);
}
function IsUnionLiteral(e) {
  return type_IsUnion(e) && e.anyOf.every((e) => type_IsLiteralString(e) || type_IsLiteralNumber(e));
}
function type_IsUnion(e) {
  return type_IsKindOf(e, "Union") && IsOptionalString(e.$id) && value_IsObject(e) && value_IsArray(e.anyOf) && e.anyOf.every((e) => type_IsSchema(e));
}
function type_IsUint8Array(e) {
  return (
    type_IsKindOf(e, "Uint8Array") &&
    e.type === "Uint8Array" &&
    IsOptionalString(e.$id) &&
    IsOptionalNumber(e.minByteLength) &&
    IsOptionalNumber(e.maxByteLength)
  );
}
function type_IsUnknown(e) {
  return type_IsKindOf(e, "Unknown") && IsOptionalString(e.$id);
}
function type_IsUnsafe(e) {
  return type_IsKindOf(e, "Unsafe");
}
function type_IsVoid(e) {
  return type_IsKindOf(e, "Void") && e.type === "void" && IsOptionalString(e.$id);
}
function type_IsKind(e) {
  return value_IsObject(e) && h in e && value_IsString(e[h]) && !L.includes(e[h]);
}
function type_IsSchema(e) {
  return (
    value_IsObject(e) &&
    (type_IsAny(e) ||
      type_IsArray(e) ||
      type_IsBoolean(e) ||
      type_IsBigInt(e) ||
      type_IsAsyncIterator(e) ||
      type_IsConstructor(e) ||
      type_IsDate(e) ||
      type_IsFunction(e) ||
      type_IsInteger(e) ||
      type_IsIntersect(e) ||
      type_IsIterator(e) ||
      type_IsLiteral(e) ||
      type_IsMappedKey(e) ||
      type_IsMappedResult(e) ||
      type_IsNever(e) ||
      type_IsNot(e) ||
      type_IsNull(e) ||
      type_IsNumber(e) ||
      type_IsObject(e) ||
      type_IsPromise(e) ||
      type_IsRecord(e) ||
      type_IsRef(e) ||
      type_IsRegExp(e) ||
      type_IsString(e) ||
      type_IsSymbol(e) ||
      type_IsTemplateLiteral(e) ||
      type_IsThis(e) ||
      type_IsTuple(e) ||
      type_IsUndefined(e) ||
      type_IsUnion(e) ||
      type_IsUint8Array(e) ||
      type_IsUnknown(e) ||
      type_IsUnsafe(e) ||
      type_IsVoid(e) ||
      type_IsKind(e))
  );
}
class ExtendsResolverError extends TypeBoxError {}
var U;
(function (e) {
  e[(e["Union"] = 0)] = "Union";
  e[(e["True"] = 1)] = "True";
  e[(e["False"] = 2)] = "False";
})(U || (U = {}));
function IntoBooleanResult(e) {
  return e === U.False ? e : U.True;
}
function Throw(e) {
  throw new ExtendsResolverError(e);
}
function IsStructuralRight(e) {
  return type_IsNever(e) || type_IsIntersect(e) || type_IsUnion(e) || type_IsUnknown(e) || type_IsAny(e);
}
function StructuralRight(e, t) {
  return type_IsNever(t)
    ? FromNeverRight(e, t)
    : type_IsIntersect(t)
      ? FromIntersectRight(e, t)
      : type_IsUnion(t)
        ? FromUnionRight(e, t)
        : type_IsUnknown(t)
          ? FromUnknownRight(e, t)
          : type_IsAny(t)
            ? FromAnyRight(e, t)
            : Throw("StructuralRight");
}
function FromAnyRight(e, t) {
  return U.True;
}
function extends_check_FromAny(e, t) {
  return type_IsIntersect(t)
    ? FromIntersectRight(e, t)
    : type_IsUnion(t) && t.anyOf.some((e) => type_IsAny(e) || type_IsUnknown(e))
      ? U.True
      : type_IsUnion(t)
        ? U.Union
        : type_IsUnknown(t)
          ? U.True
          : type_IsAny(t)
            ? U.True
            : U.Union;
}
function FromArrayRight(e, t) {
  return type_IsUnknown(e) ? U.False : type_IsAny(e) ? U.Union : type_IsNever(e) ? U.True : U.False;
}
function extends_check_FromArray(e, t) {
  return type_IsObject(t) && IsObjectArrayLike(t)
    ? U.True
    : IsStructuralRight(t)
      ? StructuralRight(e, t)
      : !type_IsArray(t)
        ? U.False
        : IntoBooleanResult(extends_check_Visit(e.items, t.items));
}
function extends_check_FromAsyncIterator(e, t) {
  return IsStructuralRight(t) ? StructuralRight(e, t) : !type_IsAsyncIterator(t) ? U.False : IntoBooleanResult(extends_check_Visit(e.items, t.items));
}
function extends_check_FromBigInt(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : type_IsRecord(t)
        ? FromRecordRight(e, t)
        : type_IsBigInt(t)
          ? U.True
          : U.False;
}
function FromBooleanRight(e, t) {
  return type_IsLiteralBoolean(e) ? U.True : type_IsBoolean(e) ? U.True : U.False;
}
function extends_check_FromBoolean(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : type_IsRecord(t)
        ? FromRecordRight(e, t)
        : type_IsBoolean(t)
          ? U.True
          : U.False;
}
function extends_check_FromConstructor(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : !type_IsConstructor(t)
        ? U.False
        : e.parameters.length > t.parameters.length
          ? U.False
          : !e.parameters.every((e, r) => IntoBooleanResult(extends_check_Visit(t.parameters[r], e)) === U.True)
            ? U.False
            : IntoBooleanResult(extends_check_Visit(e.returns, t.returns));
}
function extends_check_FromDate(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : type_IsRecord(t)
        ? FromRecordRight(e, t)
        : type_IsDate(t)
          ? U.True
          : U.False;
}
function extends_check_FromFunction(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : !type_IsFunction(t)
        ? U.False
        : e.parameters.length > t.parameters.length
          ? U.False
          : !e.parameters.every((e, r) => IntoBooleanResult(extends_check_Visit(t.parameters[r], e)) === U.True)
            ? U.False
            : IntoBooleanResult(extends_check_Visit(e.returns, t.returns));
}
function FromIntegerRight(e, t) {
  return type_IsLiteral(e) && value_IsNumber(e.const) ? U.True : type_IsNumber(e) || type_IsInteger(e) ? U.True : U.False;
}
function extends_check_FromInteger(e, t) {
  return type_IsInteger(t) || type_IsNumber(t)
    ? U.True
    : IsStructuralRight(t)
      ? StructuralRight(e, t)
      : type_IsObject(t)
        ? FromObjectRight(e, t)
        : type_IsRecord(t)
          ? FromRecordRight(e, t)
          : U.False;
}
function FromIntersectRight(e, t) {
  return t.allOf.every((t) => extends_check_Visit(e, t) === U.True) ? U.True : U.False;
}
function extends_check_FromIntersect(e, t) {
  return e.allOf.some((e) => extends_check_Visit(e, t) === U.True) ? U.True : U.False;
}
function extends_check_FromIterator(e, t) {
  return IsStructuralRight(t) ? StructuralRight(e, t) : !type_IsIterator(t) ? U.False : IntoBooleanResult(extends_check_Visit(e.items, t.items));
}
function extends_check_FromLiteral(e, t) {
  return type_IsLiteral(t) && t.const === e.const
    ? U.True
    : IsStructuralRight(t)
      ? StructuralRight(e, t)
      : type_IsObject(t)
        ? FromObjectRight(e, t)
        : type_IsRecord(t)
          ? FromRecordRight(e, t)
          : type_IsString(t)
            ? FromStringRight(e, t)
            : type_IsNumber(t)
              ? FromNumberRight(e, t)
              : type_IsInteger(t)
                ? FromIntegerRight(e, t)
                : type_IsBoolean(t)
                  ? FromBooleanRight(e, t)
                  : U.False;
}
function FromNeverRight(e, t) {
  return U.False;
}
function extends_check_FromNever(e, t) {
  return U.True;
}
function UnwrapTNot(e) {
  let [t, r] = [e, 0];
  while (true) {
    if (!type_IsNot(t)) break;
    t = t.not;
    r += 1;
  }
  return r % 2 === 0 ? t : unknown_Unknown();
}
function extends_check_FromNot(e, t) {
  return type_IsNot(e) ? extends_check_Visit(UnwrapTNot(e), t) : type_IsNot(t) ? extends_check_Visit(e, UnwrapTNot(t)) : Throw("Invalid fallthrough for Not");
}
function extends_check_FromNull(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : type_IsRecord(t)
        ? FromRecordRight(e, t)
        : type_IsNull(t)
          ? U.True
          : U.False;
}
function FromNumberRight(e, t) {
  return type_IsLiteralNumber(e) ? U.True : type_IsNumber(e) || type_IsInteger(e) ? U.True : U.False;
}
function extends_check_FromNumber(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : type_IsRecord(t)
        ? FromRecordRight(e, t)
        : type_IsInteger(t) || type_IsNumber(t)
          ? U.True
          : U.False;
}
function IsObjectPropertyCount(e, t) {
  return Object.getOwnPropertyNames(e.properties).length === t;
}
function IsObjectStringLike(e) {
  return IsObjectArrayLike(e);
}
function IsObjectSymbolLike(e) {
  return (
    IsObjectPropertyCount(e, 0) ||
    (IsObjectPropertyCount(e, 1) &&
      "description" in e.properties &&
      type_IsUnion(e.properties.description) &&
      e.properties.description.anyOf.length === 2 &&
      ((type_IsString(e.properties.description.anyOf[0]) && type_IsUndefined(e.properties.description.anyOf[1])) ||
        (type_IsString(e.properties.description.anyOf[1]) && type_IsUndefined(e.properties.description.anyOf[0]))))
  );
}
function IsObjectNumberLike(e) {
  return IsObjectPropertyCount(e, 0);
}
function IsObjectBooleanLike(e) {
  return IsObjectPropertyCount(e, 0);
}
function IsObjectBigIntLike(e) {
  return IsObjectPropertyCount(e, 0);
}
function IsObjectDateLike(e) {
  return IsObjectPropertyCount(e, 0);
}
function IsObjectUint8ArrayLike(e) {
  return IsObjectArrayLike(e);
}
function IsObjectFunctionLike(e) {
  const t = number_Number();
  return (
    IsObjectPropertyCount(e, 0) ||
    (IsObjectPropertyCount(e, 1) && "length" in e.properties && IntoBooleanResult(extends_check_Visit(e.properties["length"], t)) === U.True)
  );
}
function IsObjectConstructorLike(e) {
  return IsObjectPropertyCount(e, 0);
}
function IsObjectArrayLike(e) {
  const t = number_Number();
  return (
    IsObjectPropertyCount(e, 0) ||
    (IsObjectPropertyCount(e, 1) && "length" in e.properties && IntoBooleanResult(extends_check_Visit(e.properties["length"], t)) === U.True)
  );
}
function IsObjectPromiseLike(e) {
  const t = src_Function([any_Any()], any_Any());
  return (
    IsObjectPropertyCount(e, 0) ||
    (IsObjectPropertyCount(e, 1) && "then" in e.properties && IntoBooleanResult(extends_check_Visit(e.properties["then"], t)) === U.True)
  );
}
function Property(e, t) {
  return extends_check_Visit(e, t) === U.False ? U.False : type_IsOptional(e) && !type_IsOptional(t) ? U.False : U.True;
}
function FromObjectRight(e, t) {
  return type_IsUnknown(e)
    ? U.False
    : type_IsAny(e)
      ? U.Union
      : type_IsNever(e) ||
          (type_IsLiteralString(e) && IsObjectStringLike(t)) ||
          (type_IsLiteralNumber(e) && IsObjectNumberLike(t)) ||
          (type_IsLiteralBoolean(e) && IsObjectBooleanLike(t)) ||
          (type_IsSymbol(e) && IsObjectSymbolLike(t)) ||
          (type_IsBigInt(e) && IsObjectBigIntLike(t)) ||
          (type_IsString(e) && IsObjectStringLike(t)) ||
          (type_IsSymbol(e) && IsObjectSymbolLike(t)) ||
          (type_IsNumber(e) && IsObjectNumberLike(t)) ||
          (type_IsInteger(e) && IsObjectNumberLike(t)) ||
          (type_IsBoolean(e) && IsObjectBooleanLike(t)) ||
          (type_IsUint8Array(e) && IsObjectUint8ArrayLike(t)) ||
          (type_IsDate(e) && IsObjectDateLike(t)) ||
          (type_IsConstructor(e) && IsObjectConstructorLike(t)) ||
          (type_IsFunction(e) && IsObjectFunctionLike(t))
        ? U.True
        : type_IsRecord(e) && type_IsString(RecordKey(e))
          ? (() => (t[m] === "Record" ? U.True : U.False))()
          : type_IsRecord(e) && type_IsNumber(RecordKey(e))
            ? (() => (IsObjectPropertyCount(t, 0) ? U.True : U.False))()
            : U.False;
}
function extends_check_FromObject(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsRecord(t)
      ? FromRecordRight(e, t)
      : !type_IsObject(t)
        ? U.False
        : (() => {
            for (const r of Object.getOwnPropertyNames(t.properties)) {
              if (!(r in e.properties) && !type_IsOptional(t.properties[r])) {
                return U.False;
              }
              if (type_IsOptional(t.properties[r])) {
                return U.True;
              }
              if (Property(e.properties[r], t.properties[r]) === U.False) {
                return U.False;
              }
            }
            return U.True;
          })();
}
function extends_check_FromPromise(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t) && IsObjectPromiseLike(t)
      ? U.True
      : !type_IsPromise(t)
        ? U.False
        : IntoBooleanResult(extends_check_Visit(e.item, t.item));
}
function RecordKey(e) {
  return Q in e.patternProperties ? number_Number() : B in e.patternProperties ? string_String() : Throw("Unknown record key pattern");
}
function RecordValue(e) {
  return Q in e.patternProperties ? e.patternProperties[Q] : B in e.patternProperties ? e.patternProperties[B] : Throw("Unable to get record value schema");
}
function FromRecordRight(e, t) {
  const [r, n] = [RecordKey(t), RecordValue(t)];
  return type_IsLiteralString(e) && type_IsNumber(r) && IntoBooleanResult(extends_check_Visit(e, n)) === U.True
    ? U.True
    : type_IsUint8Array(e) && type_IsNumber(r)
      ? extends_check_Visit(e, n)
      : type_IsString(e) && type_IsNumber(r)
        ? extends_check_Visit(e, n)
        : type_IsArray(e) && type_IsNumber(r)
          ? extends_check_Visit(e, n)
          : type_IsObject(e)
            ? (() => {
                for (const t of Object.getOwnPropertyNames(e.properties)) {
                  if (Property(n, e.properties[t]) === U.False) {
                    return U.False;
                  }
                }
                return U.True;
              })()
            : U.False;
}
function extends_check_FromRecord(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : !type_IsRecord(t)
        ? U.False
        : extends_check_Visit(RecordValue(e), RecordValue(t));
}
function extends_check_FromRegExp(e, t) {
  const r = type_IsRegExp(e) ? string_String() : e;
  const n = type_IsRegExp(t) ? string_String() : t;
  return extends_check_Visit(r, n);
}
function FromStringRight(e, t) {
  return type_IsLiteral(e) && value_IsString(e.const) ? U.True : type_IsString(e) ? U.True : U.False;
}
function extends_check_FromString(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : type_IsRecord(t)
        ? FromRecordRight(e, t)
        : type_IsString(t)
          ? U.True
          : U.False;
}
function extends_check_FromSymbol(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : type_IsRecord(t)
        ? FromRecordRight(e, t)
        : type_IsSymbol(t)
          ? U.True
          : U.False;
}
function extends_check_FromTemplateLiteral(e, t) {
  return type_IsTemplateLiteral(e)
    ? extends_check_Visit(TemplateLiteralToUnion(e), t)
    : type_IsTemplateLiteral(t)
      ? extends_check_Visit(e, TemplateLiteralToUnion(t))
      : Throw("Invalid fallthrough for TemplateLiteral");
}
function IsArrayOfTuple(e, t) {
  return type_IsArray(t) && e.items !== undefined && e.items.every((e) => extends_check_Visit(e, t.items) === U.True);
}
function FromTupleRight(e, t) {
  return type_IsNever(e) ? U.True : type_IsUnknown(e) ? U.False : type_IsAny(e) ? U.Union : U.False;
}
function extends_check_FromTuple(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t) && IsObjectArrayLike(t)
      ? U.True
      : type_IsArray(t) && IsArrayOfTuple(e, t)
        ? U.True
        : !type_IsTuple(t)
          ? U.False
          : (value_IsUndefined(e.items) && !value_IsUndefined(t.items)) || (!value_IsUndefined(e.items) && value_IsUndefined(t.items))
            ? U.False
            : value_IsUndefined(e.items) && !value_IsUndefined(t.items)
              ? U.True
              : e.items.every((e, r) => extends_check_Visit(e, t.items[r]) === U.True)
                ? U.True
                : U.False;
}
function extends_check_FromUint8Array(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : type_IsRecord(t)
        ? FromRecordRight(e, t)
        : type_IsUint8Array(t)
          ? U.True
          : U.False;
}
function extends_check_FromUndefined(e, t) {
  return IsStructuralRight(t)
    ? StructuralRight(e, t)
    : type_IsObject(t)
      ? FromObjectRight(e, t)
      : type_IsRecord(t)
        ? FromRecordRight(e, t)
        : type_IsVoid(t)
          ? FromVoidRight(e, t)
          : type_IsUndefined(t)
            ? U.True
            : U.False;
}
function FromUnionRight(e, t) {
  return t.anyOf.some((t) => extends_check_Visit(e, t) === U.True) ? U.True : U.False;
}
function extends_check_FromUnion(e, t) {
  return e.anyOf.every((e) => extends_check_Visit(e, t) === U.True) ? U.True : U.False;
}
function FromUnknownRight(e, t) {
  return U.True;
}
function extends_check_FromUnknown(e, t) {
  return type_IsNever(t)
    ? FromNeverRight(e, t)
    : type_IsIntersect(t)
      ? FromIntersectRight(e, t)
      : type_IsUnion(t)
        ? FromUnionRight(e, t)
        : type_IsAny(t)
          ? FromAnyRight(e, t)
          : type_IsString(t)
            ? FromStringRight(e, t)
            : type_IsNumber(t)
              ? FromNumberRight(e, t)
              : type_IsInteger(t)
                ? FromIntegerRight(e, t)
                : type_IsBoolean(t)
                  ? FromBooleanRight(e, t)
                  : type_IsArray(t)
                    ? FromArrayRight(e, t)
                    : type_IsTuple(t)
                      ? FromTupleRight(e, t)
                      : type_IsObject(t)
                        ? FromObjectRight(e, t)
                        : type_IsUnknown(t)
                          ? U.True
                          : U.False;
}
function FromVoidRight(e, t) {
  return type_IsUndefined(e) ? U.True : type_IsUndefined(e) ? U.True : U.False;
}
function extends_check_FromVoid(e, t) {
  return type_IsIntersect(t)
    ? FromIntersectRight(e, t)
    : type_IsUnion(t)
      ? FromUnionRight(e, t)
      : type_IsUnknown(t)
        ? FromUnknownRight(e, t)
        : type_IsAny(t)
          ? FromAnyRight(e, t)
          : type_IsObject(t)
            ? FromObjectRight(e, t)
            : type_IsVoid(t)
              ? U.True
              : U.False;
}
function extends_check_Visit(e, t) {
  return type_IsTemplateLiteral(e) || type_IsTemplateLiteral(t)
    ? extends_check_FromTemplateLiteral(e, t)
    : type_IsRegExp(e) || type_IsRegExp(t)
      ? extends_check_FromRegExp(e, t)
      : type_IsNot(e) || type_IsNot(t)
        ? extends_check_FromNot(e, t)
        : type_IsAny(e)
          ? extends_check_FromAny(e, t)
          : type_IsArray(e)
            ? extends_check_FromArray(e, t)
            : type_IsBigInt(e)
              ? extends_check_FromBigInt(e, t)
              : type_IsBoolean(e)
                ? extends_check_FromBoolean(e, t)
                : type_IsAsyncIterator(e)
                  ? extends_check_FromAsyncIterator(e, t)
                  : type_IsConstructor(e)
                    ? extends_check_FromConstructor(e, t)
                    : type_IsDate(e)
                      ? extends_check_FromDate(e, t)
                      : type_IsFunction(e)
                        ? extends_check_FromFunction(e, t)
                        : type_IsInteger(e)
                          ? extends_check_FromInteger(e, t)
                          : type_IsIntersect(e)
                            ? extends_check_FromIntersect(e, t)
                            : type_IsIterator(e)
                              ? extends_check_FromIterator(e, t)
                              : type_IsLiteral(e)
                                ? extends_check_FromLiteral(e, t)
                                : type_IsNever(e)
                                  ? extends_check_FromNever(e, t)
                                  : type_IsNull(e)
                                    ? extends_check_FromNull(e, t)
                                    : type_IsNumber(e)
                                      ? extends_check_FromNumber(e, t)
                                      : type_IsObject(e)
                                        ? extends_check_FromObject(e, t)
                                        : type_IsRecord(e)
                                          ? extends_check_FromRecord(e, t)
                                          : type_IsString(e)
                                            ? extends_check_FromString(e, t)
                                            : type_IsSymbol(e)
                                              ? extends_check_FromSymbol(e, t)
                                              : type_IsTuple(e)
                                                ? extends_check_FromTuple(e, t)
                                                : type_IsPromise(e)
                                                  ? extends_check_FromPromise(e, t)
                                                  : type_IsUint8Array(e)
                                                    ? extends_check_FromUint8Array(e, t)
                                                    : type_IsUndefined(e)
                                                      ? extends_check_FromUndefined(e, t)
                                                      : type_IsUnion(e)
                                                        ? extends_check_FromUnion(e, t)
                                                        : type_IsUnknown(e)
                                                          ? extends_check_FromUnknown(e, t)
                                                          : type_IsVoid(e)
                                                            ? extends_check_FromVoid(e, t)
                                                            : Throw(`Unknown left type operand '${e[h]}'`);
}
function ExtendsCheck(e, t) {
  return extends_check_Visit(e, t);
}
function extends_from_mapped_result_FromProperties(e, t, r, n, o) {
  const s = {};
  for (const i of globalThis.Object.getOwnPropertyNames(e)) s[i] = extends_Extends(e[i], t, r, n, o);
  return s;
}
function extends_from_mapped_result_FromMappedResult(e, t, r, n, o) {
  return extends_from_mapped_result_FromProperties(e.properties, t, r, n, o);
}
function ExtendsFromMappedResult(e, t, r, n, o) {
  const s = extends_from_mapped_result_FromMappedResult(e, t, r, n, o);
  return MappedResult(s);
}
function ExtendsResolve(e, t, r, n) {
  const o = ExtendsCheck(e, t);
  return o === U.Union ? union_Union([r, n]) : o === U.True ? r : n;
}
function extends_Extends(e, t, r, n, o = {}) {
  return IsMappedResult(e)
    ? ExtendsFromMappedResult(e, t, r, n, o)
    : IsMappedKey(e)
      ? CloneType(ExtendsFromMappedKey(e, t, r, n, o))
      : CloneType(ExtendsResolve(e, t, r, n), o);
}
function FromPropertyKey(e, t, r, n, o) {
  return { [e]: extends_Extends(literal_Literal(e), t, r, n, o) };
}
function FromPropertyKeys(e, t, r, n, o) {
  return e.reduce((e, s) => ({ ...e, ...FromPropertyKey(s, t, r, n, o) }), {});
}
function extends_from_mapped_key_FromMappedKey(e, t, r, n, o) {
  return FromPropertyKeys(e.keys, t, r, n, o);
}
function ExtendsFromMappedKey(e, t, r, n, o) {
  const s = extends_from_mapped_key_FromMappedKey(e, t, r, n, o);
  return MappedResult(s);
}
class ValueCheckUnknownTypeError extends TypeBoxError {
  schema;
  constructor(e) {
    super(`Unknown type`);
    this.schema = e;
  }
}
function IsAnyOrUnknown(e) {
  return e[h] === "Any" || e[h] === "Unknown";
}
function check_IsDefined(e) {
  return e !== undefined;
}
function check_FromAny(e, t, r) {
  return true;
}
function check_FromArray(e, t, r) {
  if (!IsArray(r)) return false;
  if (check_IsDefined(e.minItems) && !(r.length >= e.minItems)) {
    return false;
  }
  if (check_IsDefined(e.maxItems) && !(r.length <= e.maxItems)) {
    return false;
  }
  if (!r.every((r) => check_Visit(e.items, t, r))) {
    return false;
  }
  if (
    e.uniqueItems === true &&
    !(function () {
      const e = new Set();
      for (const t of r) {
        const r = Hash(t);
        if (e.has(r)) {
          return false;
        } else {
          e.add(r);
        }
      }
      return true;
    })()
  ) {
    return false;
  }
  if (!(check_IsDefined(e.contains) || IsNumber(e.minContains) || IsNumber(e.maxContains))) {
    return true;
  }
  const n = check_IsDefined(e.contains) ? e.contains : never_Never();
  const o = r.reduce((e, r) => (check_Visit(n, t, r) ? e + 1 : e), 0);
  if (o === 0) {
    return false;
  }
  if (IsNumber(e.minContains) && o < e.minContains) {
    return false;
  }
  if (IsNumber(e.maxContains) && o > e.maxContains) {
    return false;
  }
  return true;
}
function check_FromAsyncIterator(e, t, r) {
  return IsAsyncIterator(r);
}
function check_FromBigInt(e, t, r) {
  if (!IsBigInt(r)) return false;
  if (check_IsDefined(e.exclusiveMaximum) && !(r < e.exclusiveMaximum)) {
    return false;
  }
  if (check_IsDefined(e.exclusiveMinimum) && !(r > e.exclusiveMinimum)) {
    return false;
  }
  if (check_IsDefined(e.maximum) && !(r <= e.maximum)) {
    return false;
  }
  if (check_IsDefined(e.minimum) && !(r >= e.minimum)) {
    return false;
  }
  if (check_IsDefined(e.multipleOf) && !(r % e.multipleOf === BigInt(0))) {
    return false;
  }
  return true;
}
function check_FromBoolean(e, t, r) {
  return IsBoolean(r);
}
function check_FromConstructor(e, t, r) {
  return check_Visit(e.returns, t, r.prototype);
}
function check_FromDate(e, t, r) {
  if (!IsDate(r)) return false;
  if (check_IsDefined(e.exclusiveMaximumTimestamp) && !(r.getTime() < e.exclusiveMaximumTimestamp)) {
    return false;
  }
  if (check_IsDefined(e.exclusiveMinimumTimestamp) && !(r.getTime() > e.exclusiveMinimumTimestamp)) {
    return false;
  }
  if (check_IsDefined(e.maximumTimestamp) && !(r.getTime() <= e.maximumTimestamp)) {
    return false;
  }
  if (check_IsDefined(e.minimumTimestamp) && !(r.getTime() >= e.minimumTimestamp)) {
    return false;
  }
  if (check_IsDefined(e.multipleOfTimestamp) && !(r.getTime() % e.multipleOfTimestamp === 0)) {
    return false;
  }
  return true;
}
function check_FromFunction(e, t, r) {
  return IsFunction(r);
}
function check_FromInteger(e, t, r) {
  if (!IsInteger(r)) {
    return false;
  }
  if (check_IsDefined(e.exclusiveMaximum) && !(r < e.exclusiveMaximum)) {
    return false;
  }
  if (check_IsDefined(e.exclusiveMinimum) && !(r > e.exclusiveMinimum)) {
    return false;
  }
  if (check_IsDefined(e.maximum) && !(r <= e.maximum)) {
    return false;
  }
  if (check_IsDefined(e.minimum) && !(r >= e.minimum)) {
    return false;
  }
  if (check_IsDefined(e.multipleOf) && !(r % e.multipleOf === 0)) {
    return false;
  }
  return true;
}
function check_FromIntersect(e, t, r) {
  const n = e.allOf.every((e) => check_Visit(e, t, r));
  if (e.unevaluatedProperties === false) {
    const t = new RegExp(KeyOfPattern(e));
    const o = Object.getOwnPropertyNames(r).every((e) => t.test(e));
    return n && o;
  } else if (type_IsSchema(e.unevaluatedProperties)) {
    const o = new RegExp(KeyOfPattern(e));
    const s = Object.getOwnPropertyNames(r).every((n) => o.test(n) || check_Visit(e.unevaluatedProperties, t, r[n]));
    return n && s;
  } else {
    return n;
  }
}
function check_FromIterator(e, t, r) {
  return IsIterator(r);
}
function check_FromLiteral(e, t, r) {
  return r === e.const;
}
function check_FromNever(e, t, r) {
  return false;
}
function check_FromNot(e, t, r) {
  return !check_Visit(e.not, t, r);
}
function check_FromNull(e, t, r) {
  return IsNull(r);
}
function check_FromNumber(e, t, r) {
  if (!c.IsNumberLike(r)) return false;
  if (check_IsDefined(e.exclusiveMaximum) && !(r < e.exclusiveMaximum)) {
    return false;
  }
  if (check_IsDefined(e.exclusiveMinimum) && !(r > e.exclusiveMinimum)) {
    return false;
  }
  if (check_IsDefined(e.minimum) && !(r >= e.minimum)) {
    return false;
  }
  if (check_IsDefined(e.maximum) && !(r <= e.maximum)) {
    return false;
  }
  if (check_IsDefined(e.multipleOf) && !(r % e.multipleOf === 0)) {
    return false;
  }
  return true;
}
function check_FromObject(e, t, r) {
  if (!c.IsObjectLike(r)) return false;
  if (check_IsDefined(e.minProperties) && !(Object.getOwnPropertyNames(r).length >= e.minProperties)) {
    return false;
  }
  if (check_IsDefined(e.maxProperties) && !(Object.getOwnPropertyNames(r).length <= e.maxProperties)) {
    return false;
  }
  const n = Object.getOwnPropertyNames(e.properties);
  for (const o of n) {
    const n = e.properties[o];
    if (e.required && e.required.includes(o)) {
      if (!check_Visit(n, t, r[o])) {
        return false;
      }
      if ((ExtendsUndefinedCheck(n) || IsAnyOrUnknown(n)) && !(o in r)) {
        return false;
      }
    } else {
      if (c.IsExactOptionalProperty(r, o) && !check_Visit(n, t, r[o])) {
        return false;
      }
    }
  }
  if (e.additionalProperties === false) {
    const t = Object.getOwnPropertyNames(r);
    if (e.required && e.required.length === n.length && t.length === n.length) {
      return true;
    } else {
      return t.every((e) => n.includes(e));
    }
  } else if (typeof e.additionalProperties === "object") {
    const o = Object.getOwnPropertyNames(r);
    return o.every((o) => n.includes(o) || check_Visit(e.additionalProperties, t, r[o]));
  } else {
    return true;
  }
}
function check_FromPromise(e, t, r) {
  return IsPromise(r);
}
function check_FromRecord(e, t, r) {
  if (!c.IsRecordLike(r)) {
    return false;
  }
  if (check_IsDefined(e.minProperties) && !(Object.getOwnPropertyNames(r).length >= e.minProperties)) {
    return false;
  }
  if (check_IsDefined(e.maxProperties) && !(Object.getOwnPropertyNames(r).length <= e.maxProperties)) {
    return false;
  }
  const [n, o] = Object.entries(e.patternProperties)[0];
  const s = new RegExp(n);
  const i = Object.entries(r).every(([e, r]) => (s.test(e) ? check_Visit(o, t, r) : true));
  const a =
    typeof e.additionalProperties === "object" ? Object.entries(r).every(([r, n]) => (!s.test(r) ? check_Visit(e.additionalProperties, t, n) : true)) : true;
  const A = e.additionalProperties === false ? Object.getOwnPropertyNames(r).every((e) => s.test(e)) : true;
  return i && a && A;
}
function check_FromRef(e, t, r) {
  return check_Visit(deref_Deref(e, t), t, r);
}
function check_FromRegExp(e, t, r) {
  const n = new RegExp(e.source, e.flags);
  if (check_IsDefined(e.minLength)) {
    if (!(r.length >= e.minLength)) return false;
  }
  if (check_IsDefined(e.maxLength)) {
    if (!(r.length <= e.maxLength)) return false;
  }
  return n.test(r);
}
function check_FromString(e, t, r) {
  if (!IsString(r)) {
    return false;
  }
  if (check_IsDefined(e.minLength)) {
    if (!(r.length >= e.minLength)) return false;
  }
  if (check_IsDefined(e.maxLength)) {
    if (!(r.length <= e.maxLength)) return false;
  }
  if (check_IsDefined(e.pattern)) {
    const t = new RegExp(e.pattern);
    if (!t.test(r)) return false;
  }
  if (check_IsDefined(e.format)) {
    if (!Has(e.format)) return false;
    const t = Get(e.format);
    return t(r);
  }
  return true;
}
function check_FromSymbol(e, t, r) {
  return IsSymbol(r);
}
function check_FromTemplateLiteral(e, t, r) {
  return IsString(r) && new RegExp(e.pattern).test(r);
}
function check_FromThis(e, t, r) {
  return check_Visit(deref_Deref(e, t), t, r);
}
function check_FromTuple(e, t, r) {
  if (!IsArray(r)) {
    return false;
  }
  if (e.items === undefined && !(r.length === 0)) {
    return false;
  }
  if (!(r.length === e.maxItems)) {
    return false;
  }
  if (!e.items) {
    return true;
  }
  for (let n = 0; n < e.items.length; n++) {
    if (!check_Visit(e.items[n], t, r[n])) return false;
  }
  return true;
}
function check_FromUndefined(e, t, r) {
  return IsUndefined(r);
}
function check_FromUnion(e, t, r) {
  return e.anyOf.some((e) => check_Visit(e, t, r));
}
function check_FromUint8Array(e, t, r) {
  if (!IsUint8Array(r)) {
    return false;
  }
  if (check_IsDefined(e.maxByteLength) && !(r.length <= e.maxByteLength)) {
    return false;
  }
  if (check_IsDefined(e.minByteLength) && !(r.length >= e.minByteLength)) {
    return false;
  }
  return true;
}
function check_FromUnknown(e, t, r) {
  return true;
}
function check_FromVoid(e, t, r) {
  return c.IsVoidLike(r);
}
function check_FromKind(e, t, r) {
  if (!type_Has(e[h])) return false;
  const n = type_Get(e[h]);
  return n(e, r);
}
function check_Visit(e, t, r) {
  const n = check_IsDefined(e.$id) ? [...t, e] : t;
  const o = e;
  switch (o[h]) {
    case "Any":
      return check_FromAny(o, n, r);
    case "Array":
      return check_FromArray(o, n, r);
    case "AsyncIterator":
      return check_FromAsyncIterator(o, n, r);
    case "BigInt":
      return check_FromBigInt(o, n, r);
    case "Boolean":
      return check_FromBoolean(o, n, r);
    case "Constructor":
      return check_FromConstructor(o, n, r);
    case "Date":
      return check_FromDate(o, n, r);
    case "Function":
      return check_FromFunction(o, n, r);
    case "Integer":
      return check_FromInteger(o, n, r);
    case "Intersect":
      return check_FromIntersect(o, n, r);
    case "Iterator":
      return check_FromIterator(o, n, r);
    case "Literal":
      return check_FromLiteral(o, n, r);
    case "Never":
      return check_FromNever(o, n, r);
    case "Not":
      return check_FromNot(o, n, r);
    case "Null":
      return check_FromNull(o, n, r);
    case "Number":
      return check_FromNumber(o, n, r);
    case "Object":
      return check_FromObject(o, n, r);
    case "Promise":
      return check_FromPromise(o, n, r);
    case "Record":
      return check_FromRecord(o, n, r);
    case "Ref":
      return check_FromRef(o, n, r);
    case "RegExp":
      return check_FromRegExp(o, n, r);
    case "String":
      return check_FromString(o, n, r);
    case "Symbol":
      return check_FromSymbol(o, n, r);
    case "TemplateLiteral":
      return check_FromTemplateLiteral(o, n, r);
    case "This":
      return check_FromThis(o, n, r);
    case "Tuple":
      return check_FromTuple(o, n, r);
    case "Undefined":
      return check_FromUndefined(o, n, r);
    case "Union":
      return check_FromUnion(o, n, r);
    case "Uint8Array":
      return check_FromUint8Array(o, n, r);
    case "Unknown":
      return check_FromUnknown(o, n, r);
    case "Void":
      return check_FromVoid(o, n, r);
    default:
      if (!type_Has(o[h])) throw new ValueCheckUnknownTypeError(o);
      return check_FromKind(o, n, r);
  }
}
function Check(...e) {
  return e.length === 3 ? check_Visit(e[0], e[1], e[2]) : check_Visit(e[0], [], e[1]);
}
function clone_ObjectType(e) {
  const t = {};
  for (const r of Object.getOwnPropertyNames(e)) {
    t[r] = clone_Clone(e[r]);
  }
  for (const r of Object.getOwnPropertySymbols(e)) {
    t[r] = clone_Clone(e[r]);
  }
  return t;
}
function clone_ArrayType(e) {
  return e.map((e) => clone_Clone(e));
}
function TypedArrayType(e) {
  return e.slice();
}
function clone_DateType(e) {
  return new Date(e.toISOString());
}
function ValueType(e) {
  return e;
}
function clone_Clone(e) {
  if (IsArray(e)) return clone_ArrayType(e);
  if (IsDate(e)) return clone_DateType(e);
  if (IsStandardObject(e)) return clone_ObjectType(e);
  if (IsTypedArray(e)) return TypedArrayType(e);
  if (IsValueType(e)) return ValueType(e);
  throw new Error("ValueClone: Unable to clone value");
}
class ValueCreateError extends TypeBoxError {
  schema;
  constructor(e, t) {
    super(t);
    this.schema = e;
  }
}
function FromDefault(e) {
  return typeof e === "function" ? e : clone_Clone(e);
}
function create_FromAny(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return {};
  }
}
function create_FromArray(e, t) {
  if (e.uniqueItems === true && !HasPropertyKey(e, "default")) {
    throw new ValueCreateError(e, "Array with the uniqueItems constraint requires a default value");
  } else if ("contains" in e && !HasPropertyKey(e, "default")) {
    throw new ValueCreateError(e, "Array with the contains constraint requires a default value");
  } else if ("default" in e) {
    return FromDefault(e.default);
  } else if (e.minItems !== undefined) {
    return Array.from({ length: e.minItems }).map((r) => create_Visit(e.items, t));
  } else {
    return [];
  }
}
function create_FromAsyncIterator(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return (async function* () {})();
  }
}
function create_FromBigInt(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return BigInt(0);
  }
}
function create_FromBoolean(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return false;
  }
}
function create_FromConstructor(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    const r = create_Visit(e.returns, t);
    if (typeof r === "object" && !Array.isArray(r)) {
      return class {
        constructor() {
          for (const [e, t] of Object.entries(r)) {
            const r = this;
            r[e] = t;
          }
        }
      };
    } else {
      return class {};
    }
  }
}
function create_FromDate(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else if (e.minimumTimestamp !== undefined) {
    return new Date(e.minimumTimestamp);
  } else {
    return new Date();
  }
}
function create_FromFunction(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return () => create_Visit(e.returns, t);
  }
}
function create_FromInteger(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else if (e.minimum !== undefined) {
    return e.minimum;
  } else {
    return 0;
  }
}
function create_FromIntersect(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    const r = e.allOf.reduce((e, r) => {
      const n = create_Visit(r, t);
      return typeof n === "object" ? { ...e, ...n } : n;
    }, {});
    if (!Check(e, t, r)) throw new ValueCreateError(e, "Intersect produced invalid value. Consider using a default value.");
    return r;
  }
}
function create_FromIterator(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return (function* () {})();
  }
}
function create_FromLiteral(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return e.const;
  }
}
function create_FromNever(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    throw new ValueCreateError(e, "Never types cannot be created. Consider using a default value.");
  }
}
function create_FromNot(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    throw new ValueCreateError(e, "Not types must have a default value");
  }
}
function create_FromNull(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return null;
  }
}
function create_FromNumber(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else if (e.minimum !== undefined) {
    return e.minimum;
  } else {
    return 0;
  }
}
function create_FromObject(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    const r = new Set(e.required);
    const n = {};
    for (const [o, s] of Object.entries(e.properties)) {
      if (!r.has(o)) continue;
      n[o] = create_Visit(s, t);
    }
    return n;
  }
}
function create_FromPromise(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return Promise.resolve(create_Visit(e.item, t));
  }
}
function create_FromRecord(e, t) {
  const [r, n] = Object.entries(e.patternProperties)[0];
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else if (!(r === B || r === Q)) {
    const e = r.slice(1, r.length - 1).split("|");
    const o = {};
    for (const r of e) o[r] = create_Visit(n, t);
    return o;
  } else {
    return {};
  }
}
function create_FromRef(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return create_Visit(deref_Deref(e, t), t);
  }
}
function create_FromRegExp(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    throw new ValueCreateError(e, "RegExp types cannot be created. Consider using a default value.");
  }
}
function create_FromString(e, t) {
  if (e.pattern !== undefined) {
    if (!HasPropertyKey(e, "default")) {
      throw new ValueCreateError(e, "String types with patterns must specify a default value");
    } else {
      return FromDefault(e.default);
    }
  } else if (e.format !== undefined) {
    if (!HasPropertyKey(e, "default")) {
      throw new ValueCreateError(e, "String types with formats must specify a default value");
    } else {
      return FromDefault(e.default);
    }
  } else {
    if (HasPropertyKey(e, "default")) {
      return FromDefault(e.default);
    } else if (e.minLength !== undefined) {
      return Array.from({ length: e.minLength })
        .map(() => " ")
        .join("");
    } else {
      return "";
    }
  }
}
function create_FromSymbol(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else if ("value" in e) {
    return Symbol.for(e.value);
  } else {
    return Symbol();
  }
}
function create_FromTemplateLiteral(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  }
  if (!IsTemplateLiteralFinite(e))
    throw new ValueCreateError(e, "Can only create template literals that produce a finite variants. Consider using a default value.");
  const r = TemplateLiteralGenerate(e);
  return r[0];
}
function create_FromThis(e, t) {
  if (G++ > M) throw new ValueCreateError(e, "Cannot create recursive type as it appears possibly infinite. Consider using a default.");
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return create_Visit(deref_Deref(e, t), t);
  }
}
function create_FromTuple(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  }
  if (e.items === undefined) {
    return [];
  } else {
    return Array.from({ length: e.minItems }).map((r, n) => create_Visit(e.items[n], t));
  }
}
function create_FromUndefined(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return undefined;
  }
}
function create_FromUnion(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else if (e.anyOf.length === 0) {
    throw new Error("ValueCreate.Union: Cannot create Union with zero variants");
  } else {
    return create_Visit(e.anyOf[0], t);
  }
}
function create_FromUint8Array(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else if (e.minByteLength !== undefined) {
    return new Uint8Array(e.minByteLength);
  } else {
    return new Uint8Array(0);
  }
}
function create_FromUnknown(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return {};
  }
}
function create_FromVoid(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    return void 0;
  }
}
function create_FromKind(e, t) {
  if (HasPropertyKey(e, "default")) {
    return FromDefault(e.default);
  } else {
    throw new Error("User defined types must specify a default value");
  }
}
function create_Visit(e, t) {
  const r = IsString(e.$id) ? [...t, e] : t;
  const n = e;
  switch (n[h]) {
    case "Any":
      return create_FromAny(n, r);
    case "Array":
      return create_FromArray(n, r);
    case "AsyncIterator":
      return create_FromAsyncIterator(n, r);
    case "BigInt":
      return create_FromBigInt(n, r);
    case "Boolean":
      return create_FromBoolean(n, r);
    case "Constructor":
      return create_FromConstructor(n, r);
    case "Date":
      return create_FromDate(n, r);
    case "Function":
      return create_FromFunction(n, r);
    case "Integer":
      return create_FromInteger(n, r);
    case "Intersect":
      return create_FromIntersect(n, r);
    case "Iterator":
      return create_FromIterator(n, r);
    case "Literal":
      return create_FromLiteral(n, r);
    case "Never":
      return create_FromNever(n, r);
    case "Not":
      return create_FromNot(n, r);
    case "Null":
      return create_FromNull(n, r);
    case "Number":
      return create_FromNumber(n, r);
    case "Object":
      return create_FromObject(n, r);
    case "Promise":
      return create_FromPromise(n, r);
    case "Record":
      return create_FromRecord(n, r);
    case "Ref":
      return create_FromRef(n, r);
    case "RegExp":
      return create_FromRegExp(n, r);
    case "String":
      return create_FromString(n, r);
    case "Symbol":
      return create_FromSymbol(n, r);
    case "TemplateLiteral":
      return create_FromTemplateLiteral(n, r);
    case "This":
      return create_FromThis(n, r);
    case "Tuple":
      return create_FromTuple(n, r);
    case "Undefined":
      return create_FromUndefined(n, r);
    case "Union":
      return create_FromUnion(n, r);
    case "Uint8Array":
      return create_FromUint8Array(n, r);
    case "Unknown":
      return create_FromUnknown(n, r);
    case "Void":
      return create_FromVoid(n, r);
    default:
      if (!type_Has(n[h])) throw new ValueCreateError(n, "Unknown type");
      return create_FromKind(n, r);
  }
}
const M = 512;
let G = 0;
function create_Create(...e) {
  G = 0;
  return e.length === 2 ? create_Visit(e[0], e[1]) : create_Visit(e[0], []);
}
class ValueCastError extends TypeBoxError {
  schema;
  constructor(e, t) {
    super(t);
    this.schema = e;
  }
}
function ScoreUnion(e, t, r) {
  if (e[h] === "Object" && typeof r === "object" && !IsNull(r)) {
    const n = e;
    const o = Object.getOwnPropertyNames(r);
    const s = Object.entries(n.properties);
    const [i, a] = [1 / s.length, s.length];
    return s.reduce((e, [n, s]) => {
      const A = s[h] === "Literal" && s.const === r[n] ? a : 0;
      const c = Check(s, t, r[n]) ? i : 0;
      const u = o.includes(n) ? i : 0;
      return e + (A + c + u);
    }, 0);
  } else {
    return Check(e, t, r) ? 1 : 0;
  }
}
function SelectUnion(e, t, r) {
  const n = e.anyOf.map((e) => deref_Deref(e, t));
  let [o, s] = [n[0], 0];
  for (const e of n) {
    const n = ScoreUnion(e, t, r);
    if (n > s) {
      o = e;
      s = n;
    }
  }
  return o;
}
function CastUnion(e, t, r) {
  if ("default" in e) {
    return typeof r === "function" ? e.default : clone_Clone(e.default);
  } else {
    const n = SelectUnion(e, t, r);
    return Cast(n, t, r);
  }
}
function DefaultClone(e, t, r) {
  return Check(e, t, r) ? clone_Clone(r) : create_Create(e, t);
}
function Default(e, t, r) {
  return Check(e, t, r) ? r : create_Create(e, t);
}
function cast_FromArray(e, t, r) {
  if (Check(e, t, r)) return clone_Clone(r);
  const n = IsArray(r) ? clone_Clone(r) : create_Create(e, t);
  const o = IsNumber(e.minItems) && n.length < e.minItems ? [...n, ...Array.from({ length: e.minItems - n.length }, () => null)] : n;
  const s = IsNumber(e.maxItems) && o.length > e.maxItems ? o.slice(0, e.maxItems) : o;
  const i = s.map((r) => cast_Visit(e.items, t, r));
  if (e.uniqueItems !== true) return i;
  const a = [...new Set(i)];
  if (!Check(e, t, a)) throw new ValueCastError(e, "Array cast produced invalid data due to uniqueItems constraint");
  return a;
}
function cast_FromConstructor(e, t, r) {
  if (Check(e, t, r)) return create_Create(e, t);
  const n = new Set(e.returns.required || []);
  const result = function () {};
  for (const [o, s] of Object.entries(e.returns.properties)) {
    if (!n.has(o) && r.prototype[o] === undefined) continue;
    result.prototype[o] = cast_Visit(s, t, r.prototype[o]);
  }
  return result;
}
function cast_FromIntersect(e, t, r) {
  const n = create_Create(e, t);
  const o = IsStandardObject(n) && IsStandardObject(r) ? { ...n, ...r } : r;
  return Check(e, t, o) ? o : create_Create(e, t);
}
function cast_FromNever(e, t, r) {
  throw new ValueCastError(e, "Never types cannot be cast");
}
function cast_FromObject(e, t, r) {
  if (Check(e, t, r)) return r;
  if (r === null || typeof r !== "object") return create_Create(e, t);
  const n = new Set(e.required || []);
  const o = {};
  for (const [s, i] of Object.entries(e.properties)) {
    if (!n.has(s) && r[s] === undefined) continue;
    o[s] = cast_Visit(i, t, r[s]);
  }
  if (typeof e.additionalProperties === "object") {
    const n = Object.getOwnPropertyNames(e.properties);
    for (const s of Object.getOwnPropertyNames(r)) {
      if (n.includes(s)) continue;
      o[s] = cast_Visit(e.additionalProperties, t, r[s]);
    }
  }
  return o;
}
function cast_FromRecord(e, t, r) {
  if (Check(e, t, r)) return clone_Clone(r);
  if (r === null || typeof r !== "object" || Array.isArray(r) || r instanceof Date) return create_Create(e, t);
  const n = Object.getOwnPropertyNames(e.patternProperties)[0];
  const o = e.patternProperties[n];
  const s = {};
  for (const [e, n] of Object.entries(r)) {
    s[e] = cast_Visit(o, t, n);
  }
  return s;
}
function cast_FromRef(e, t, r) {
  return cast_Visit(deref_Deref(e, t), t, r);
}
function cast_FromThis(e, t, r) {
  return cast_Visit(deref_Deref(e, t), t, r);
}
function cast_FromTuple(e, t, r) {
  if (Check(e, t, r)) return clone_Clone(r);
  if (!IsArray(r)) return create_Create(e, t);
  if (e.items === undefined) return [];
  return e.items.map((e, n) => cast_Visit(e, t, r[n]));
}
function cast_FromUnion(e, t, r) {
  return Check(e, t, r) ? clone_Clone(r) : CastUnion(e, t, r);
}
function cast_Visit(e, t, r) {
  const n = IsString(e.$id) ? [...t, e] : t;
  const o = e;
  switch (e[h]) {
    case "Array":
      return cast_FromArray(o, n, r);
    case "Constructor":
      return cast_FromConstructor(o, n, r);
    case "Intersect":
      return cast_FromIntersect(o, n, r);
    case "Never":
      return cast_FromNever(o, n, r);
    case "Object":
      return cast_FromObject(o, n, r);
    case "Record":
      return cast_FromRecord(o, n, r);
    case "Ref":
      return cast_FromRef(o, n, r);
    case "This":
      return cast_FromThis(o, n, r);
    case "Tuple":
      return cast_FromTuple(o, n, r);
    case "Union":
      return cast_FromUnion(o, n, r);
    case "Date":
    case "Symbol":
    case "Uint8Array":
      return DefaultClone(e, t, r);
    default:
      return Default(o, n, r);
  }
}
function Cast(...e) {
  return e.length === 3 ? cast_Visit(e[0], e[1], e[2]) : cast_Visit(e[0], [], e[1]);
}
function IsCheckable(e) {
  return type_IsSchema(e) && e[h] !== "Unsafe";
}
function clean_FromArray(e, t, r) {
  if (!IsArray(r)) return r;
  return r.map((r) => clean_Visit(e.items, t, r));
}
function clean_FromIntersect(e, t, r) {
  const n = e.unevaluatedProperties;
  const o = e.allOf.map((e) => clean_Visit(e, t, clone_Clone(r)));
  const s = o.reduce((e, t) => (IsObject(t) ? { ...e, ...t } : t), {});
  if (!IsObject(r) || !IsObject(s) || !type_IsSchema(n)) return s;
  const i = KeyOfPropertyKeys(e);
  for (const e of Object.getOwnPropertyNames(r)) {
    if (i.includes(e)) continue;
    if (Check(n, t, r[e])) {
      s[e] = clean_Visit(n, t, r[e]);
    }
  }
  return s;
}
function clean_FromObject(e, t, r) {
  if (!IsObject(r) || IsArray(r)) return r;
  const n = e.additionalProperties;
  for (const o of Object.getOwnPropertyNames(r)) {
    if (o in e.properties) {
      r[o] = clean_Visit(e.properties[o], t, r[o]);
      continue;
    }
    if (type_IsSchema(n) && Check(n, t, r[o])) {
      r[o] = clean_Visit(n, t, r[o]);
      continue;
    }
    delete r[o];
  }
  return r;
}
function clean_FromRecord(e, t, r) {
  if (!IsObject(r)) return r;
  const n = e.additionalProperties;
  const o = Object.getOwnPropertyNames(r);
  const [s, i] = Object.entries(e.patternProperties)[0];
  const a = new RegExp(s);
  for (const e of o) {
    if (a.test(e)) {
      r[e] = clean_Visit(i, t, r[e]);
      continue;
    }
    if (type_IsSchema(n) && Check(n, t, r[e])) {
      r[e] = clean_Visit(n, t, r[e]);
      continue;
    }
    delete r[e];
  }
  return r;
}
function clean_FromRef(e, t, r) {
  return clean_Visit(deref_Deref(e, t), t, r);
}
function clean_FromThis(e, t, r) {
  return clean_Visit(deref_Deref(e, t), t, r);
}
function clean_FromTuple(e, t, r) {
  if (!IsArray(r)) return r;
  if (IsUndefined(e.items)) return [];
  const n = Math.min(r.length, e.items.length);
  for (let o = 0; o < n; o++) {
    r[o] = clean_Visit(e.items[o], t, r[o]);
  }
  return r.length > n ? r.slice(0, n) : r;
}
function clean_FromUnion(e, t, r) {
  for (const n of e.anyOf) {
    if (IsCheckable(n) && Check(n, t, r)) {
      return clean_Visit(n, t, r);
    }
  }
  return r;
}
function clean_Visit(e, t, r) {
  const n = IsString(e.$id) ? [...t, e] : t;
  const o = e;
  switch (o[h]) {
    case "Array":
      return clean_FromArray(o, n, r);
    case "Intersect":
      return clean_FromIntersect(o, n, r);
    case "Object":
      return clean_FromObject(o, n, r);
    case "Record":
      return clean_FromRecord(o, n, r);
    case "Ref":
      return clean_FromRef(o, n, r);
    case "This":
      return clean_FromThis(o, n, r);
    case "Tuple":
      return clean_FromTuple(o, n, r);
    case "Union":
      return clean_FromUnion(o, n, r);
    default:
      return r;
  }
}
function Clean(...e) {
  return e.length === 3 ? clean_Visit(e[0], e[1], e[2]) : clean_Visit(e[0], [], e[1]);
}
function IsStringNumeric(e) {
  return IsString(e) && !isNaN(e) && !isNaN(parseFloat(e));
}
function IsValueToString(e) {
  return IsBigInt(e) || IsBoolean(e) || IsNumber(e);
}
function IsValueTrue(e) {
  return e === true || (IsNumber(e) && e === 1) || (IsBigInt(e) && e === BigInt("1")) || (IsString(e) && (e.toLowerCase() === "true" || e === "1"));
}
function IsValueFalse(e) {
  return (
    e === false ||
    (IsNumber(e) && (e === 0 || Object.is(e, -0))) ||
    (IsBigInt(e) && e === BigInt("0")) ||
    (IsString(e) && (e.toLowerCase() === "false" || e === "0" || e === "-0"))
  );
}
function IsTimeStringWithTimeZone(e) {
  return IsString(e) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(e);
}
function IsTimeStringWithoutTimeZone(e) {
  return IsString(e) && /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(e);
}
function IsDateTimeStringWithTimeZone(e) {
  return IsString(e) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i.test(e);
}
function IsDateTimeStringWithoutTimeZone(e) {
  return IsString(e) && /^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)?$/i.test(e);
}
function IsDateString(e) {
  return IsString(e) && /^\d\d\d\d-[0-1]\d-[0-3]\d$/i.test(e);
}
function TryConvertLiteralString(e, t) {
  const r = TryConvertString(e);
  return r === t ? r : e;
}
function TryConvertLiteralNumber(e, t) {
  const r = TryConvertNumber(e);
  return r === t ? r : e;
}
function TryConvertLiteralBoolean(e, t) {
  const r = TryConvertBoolean(e);
  return r === t ? r : e;
}
function TryConvertLiteral(e, t) {
  return IsString(e.const)
    ? TryConvertLiteralString(t, e.const)
    : IsNumber(e.const)
      ? TryConvertLiteralNumber(t, e.const)
      : IsBoolean(e.const)
        ? TryConvertLiteralBoolean(t, e.const)
        : clone_Clone(t);
}
function TryConvertBoolean(e) {
  return IsValueTrue(e) ? true : IsValueFalse(e) ? false : e;
}
function TryConvertBigInt(e) {
  return IsStringNumeric(e) ? BigInt(parseInt(e)) : IsNumber(e) ? BigInt(e | 0) : IsValueFalse(e) ? BigInt(0) : IsValueTrue(e) ? BigInt(1) : e;
}
function TryConvertString(e) {
  return IsValueToString(e) ? e.toString() : IsSymbol(e) && e.description !== undefined ? e.description.toString() : e;
}
function TryConvertNumber(e) {
  return IsStringNumeric(e) ? parseFloat(e) : IsValueTrue(e) ? 1 : IsValueFalse(e) ? 0 : e;
}
function TryConvertInteger(e) {
  return IsStringNumeric(e) ? parseInt(e) : IsNumber(e) ? e | 0 : IsValueTrue(e) ? 1 : IsValueFalse(e) ? 0 : e;
}
function TryConvertNull(e) {
  return IsString(e) && e.toLowerCase() === "null" ? null : e;
}
function TryConvertUndefined(e) {
  return IsString(e) && e === "undefined" ? undefined : e;
}
function TryConvertDate(e) {
  return IsDate(e)
    ? e
    : IsNumber(e)
      ? new Date(e)
      : IsValueTrue(e)
        ? new Date(1)
        : IsValueFalse(e)
          ? new Date(0)
          : IsStringNumeric(e)
            ? new Date(parseInt(e))
            : IsTimeStringWithoutTimeZone(e)
              ? new Date(`1970-01-01T${e}.000Z`)
              : IsTimeStringWithTimeZone(e)
                ? new Date(`1970-01-01T${e}`)
                : IsDateTimeStringWithoutTimeZone(e)
                  ? new Date(`${e}.000Z`)
                  : IsDateTimeStringWithTimeZone(e)
                    ? new Date(e)
                    : IsDateString(e)
                      ? new Date(`${e}T00:00:00.000Z`)
                      : e;
}
function convert_Default(e) {
  return e;
}
function convert_FromArray(e, t, r) {
  const n = IsArray(r) ? r : [r];
  return n.map((r) => convert_Visit(e.items, t, r));
}
function convert_FromBigInt(e, t, r) {
  return TryConvertBigInt(r);
}
function convert_FromBoolean(e, t, r) {
  return TryConvertBoolean(r);
}
function convert_FromDate(e, t, r) {
  return TryConvertDate(r);
}
function convert_FromInteger(e, t, r) {
  return TryConvertInteger(r);
}
function convert_FromIntersect(e, t, r) {
  return e.allOf.reduce((e, r) => convert_Visit(r, t, e), r);
}
function convert_FromLiteral(e, t, r) {
  return TryConvertLiteral(e, r);
}
function convert_FromNull(e, t, r) {
  return TryConvertNull(r);
}
function convert_FromNumber(e, t, r) {
  return TryConvertNumber(r);
}
function convert_FromObject(e, t, r) {
  const n = IsObject(r);
  if (!n) return r;
  const o = {};
  for (const n of Object.keys(r)) {
    o[n] = HasPropertyKey(e.properties, n) ? convert_Visit(e.properties[n], t, r[n]) : r[n];
  }
  return o;
}
function convert_FromRecord(e, t, r) {
  const n = Object.getOwnPropertyNames(e.patternProperties)[0];
  const o = e.patternProperties[n];
  const s = {};
  for (const [e, n] of Object.entries(r)) {
    s[e] = convert_Visit(o, t, n);
  }
  return s;
}
function convert_FromRef(e, t, r) {
  return convert_Visit(deref_Deref(e, t), t, r);
}
function convert_FromString(e, t, r) {
  return TryConvertString(r);
}
function convert_FromSymbol(e, t, r) {
  return IsString(r) || IsNumber(r) ? Symbol(r) : r;
}
function convert_FromThis(e, t, r) {
  return convert_Visit(deref_Deref(e, t), t, r);
}
function convert_FromTuple(e, t, r) {
  const n = IsArray(r) && !IsUndefined(e.items);
  if (!n) return r;
  return r.map((r, n) => (n < e.items.length ? convert_Visit(e.items[n], t, r) : r));
}
function convert_FromUndefined(e, t, r) {
  return TryConvertUndefined(r);
}
function convert_FromUnion(e, t, r) {
  for (const n of e.anyOf) {
    const e = convert_Visit(n, t, r);
    if (!Check(n, t, e)) continue;
    return e;
  }
  return r;
}
function convert_Visit(e, t, r) {
  const n = IsString(e.$id) ? [...t, e] : t;
  const o = e;
  switch (e[h]) {
    case "Array":
      return convert_FromArray(o, n, r);
    case "BigInt":
      return convert_FromBigInt(o, n, r);
    case "Boolean":
      return convert_FromBoolean(o, n, r);
    case "Date":
      return convert_FromDate(o, n, r);
    case "Integer":
      return convert_FromInteger(o, n, r);
    case "Intersect":
      return convert_FromIntersect(o, n, r);
    case "Literal":
      return convert_FromLiteral(o, n, r);
    case "Null":
      return convert_FromNull(o, n, r);
    case "Number":
      return convert_FromNumber(o, n, r);
    case "Object":
      return convert_FromObject(o, n, r);
    case "Record":
      return convert_FromRecord(o, n, r);
    case "Ref":
      return convert_FromRef(o, n, r);
    case "String":
      return convert_FromString(o, n, r);
    case "Symbol":
      return convert_FromSymbol(o, n, r);
    case "This":
      return convert_FromThis(o, n, r);
    case "Tuple":
      return convert_FromTuple(o, n, r);
    case "Undefined":
      return convert_FromUndefined(o, n, r);
    case "Union":
      return convert_FromUnion(o, n, r);
    default:
      return convert_Default(r);
  }
}
function Convert(...e) {
  return e.length === 3 ? convert_Visit(e[0], e[1], e[2]) : convert_Visit(e[0], [], e[1]);
}
function ValueOrDefault(e, t) {
  return t === undefined && "default" in e ? clone_Clone(e.default) : t;
}
function default_IsCheckable(e) {
  return type_IsSchema(e) && e[h] !== "Unsafe";
}
function IsDefaultSchema(e) {
  return type_IsSchema(e) && "default" in e;
}
function default_FromArray(e, t, r) {
  const n = ValueOrDefault(e, r);
  if (!IsArray(n)) return n;
  for (let r = 0; r < n.length; r++) {
    n[r] = default_Visit(e.items, t, n[r]);
  }
  return n;
}
function default_FromIntersect(e, t, r) {
  const n = ValueOrDefault(e, r);
  return e.allOf.reduce((e, r) => {
    const o = default_Visit(r, t, n);
    return IsObject(o) ? { ...e, ...o } : o;
  }, {});
}
function default_FromObject(e, t, r) {
  const n = ValueOrDefault(e, r);
  if (!IsObject(n)) return n;
  const o = e.additionalProperties;
  const s = Object.getOwnPropertyNames(e.properties);
  for (const r of s) {
    if (!IsDefaultSchema(e.properties[r])) continue;
    n[r] = default_Visit(e.properties[r], t, n[r]);
  }
  if (!IsDefaultSchema(o)) return n;
  for (const e of Object.getOwnPropertyNames(n)) {
    if (s.includes(e)) continue;
    n[e] = default_Visit(o, t, n[e]);
  }
  return n;
}
function default_FromRecord(e, t, r) {
  const n = ValueOrDefault(e, r);
  if (!IsObject(n)) return n;
  const o = e.additionalProperties;
  const [s, i] = Object.entries(e.patternProperties)[0];
  const a = new RegExp(s);
  for (const e of Object.getOwnPropertyNames(n)) {
    if (!(a.test(e) && IsDefaultSchema(i))) continue;
    n[e] = default_Visit(i, t, n[e]);
  }
  if (!IsDefaultSchema(o)) return n;
  for (const e of Object.getOwnPropertyNames(n)) {
    if (a.test(e)) continue;
    n[e] = default_Visit(o, t, n[e]);
  }
  return n;
}
function default_FromRef(e, t, r) {
  return default_Visit(deref_Deref(e, t), t, ValueOrDefault(e, r));
}
function default_FromThis(e, t, r) {
  return default_Visit(deref_Deref(e, t), t, r);
}
function default_FromTuple(e, t, r) {
  const n = ValueOrDefault(e, r);
  if (!IsArray(n) || IsUndefined(e.items)) return n;
  const [o, s] = [e.items, Math.max(e.items.length, n.length)];
  for (let e = 0; e < s; e++) {
    if (e < o.length) n[e] = default_Visit(o[e], t, n[e]);
  }
  return n;
}
function default_FromUnion(e, t, r) {
  const n = ValueOrDefault(e, r);
  for (const r of e.anyOf) {
    const e = default_Visit(r, t, n);
    if (default_IsCheckable(r) && Check(r, e)) {
      return e;
    }
  }
  return n;
}
function default_Visit(e, t, r) {
  const n = IsString(e.$id) ? [...t, e] : t;
  const o = e;
  switch (o[h]) {
    case "Array":
      return default_FromArray(o, n, r);
    case "Intersect":
      return default_FromIntersect(o, n, r);
    case "Object":
      return default_FromObject(o, n, r);
    case "Record":
      return default_FromRecord(o, n, r);
    case "Ref":
      return default_FromRef(o, n, r);
    case "This":
      return default_FromThis(o, n, r);
    case "Tuple":
      return default_FromTuple(o, n, r);
    case "Union":
      return default_FromUnion(o, n, r);
    default:
      return ValueOrDefault(o, r);
  }
}
function default_Default(...e) {
  return e.length === 3 ? default_Visit(e[0], e[1], e[2]) : default_Visit(e[0], [], e[1]);
}
class ValuePointerRootSetError extends TypeBoxError {
  value;
  path;
  update;
  constructor(e, t, r) {
    super("Cannot set root value");
    this.value = e;
    this.path = t;
    this.update = r;
  }
}
class ValuePointerRootDeleteError extends TypeBoxError {
  value;
  path;
  constructor(e, t) {
    super("Cannot delete root value");
    this.value = e;
    this.path = t;
  }
}
function pointer_Escape(e) {
  return e.indexOf("~") === -1 ? e : e.replace(/~1/g, "/").replace(/~0/g, "~");
}
function* Format(e) {
  if (e === "") return;
  let [t, r] = [0, 0];
  for (let n = 0; n < e.length; n++) {
    const o = e.charAt(n);
    if (o === "/") {
      if (n === 0) {
        t = n + 1;
      } else {
        r = n;
        yield pointer_Escape(e.slice(t, r));
        t = n + 1;
      }
    } else {
      r = n;
    }
  }
  yield pointer_Escape(e.slice(t));
}
function pointer_Set(e, t, r) {
  if (t === "") throw new ValuePointerRootSetError(e, t, r);
  let [n, o, s] = [null, e, ""];
  for (const e of Format(t)) {
    if (o[e] === undefined) o[e] = {};
    n = o;
    o = o[e];
    s = e;
  }
  n[s] = r;
}
function pointer_Delete(e, t) {
  if (t === "") throw new ValuePointerRootDeleteError(e, t);
  let [r, n, o] = [null, e, ""];
  for (const e of Format(t)) {
    if (n[e] === undefined || n[e] === null) return;
    r = n;
    n = n[e];
    o = e;
  }
  if (Array.isArray(r)) {
    const e = parseInt(o);
    r.splice(e, 1);
  } else {
    delete r[o];
  }
}
function pointer_Has(e, t) {
  if (t === "") return true;
  let [r, n, o] = [null, e, ""];
  for (const e of Format(t)) {
    if (n[e] === undefined) return false;
    r = n;
    n = n[e];
    o = e;
  }
  return Object.getOwnPropertyNames(r).includes(o);
}
function pointer_Get(e, t) {
  if (t === "") return e;
  let r = e;
  for (const e of Format(t)) {
    if (r[e] === undefined) return undefined;
    r = r[e];
  }
  return r;
}
const x = T({ type: literal_Literal("insert"), path: string_String(), value: unknown_Unknown() });
const j = T({ type: literal_Literal("update"), path: string_String(), value: unknown_Unknown() });
const V = T({ type: literal_Literal("delete"), path: string_String() });
const H = union_Union([x, j, V]);
class ValueDeltaError extends TypeBoxError {
  value;
  constructor(e, t) {
    super(t);
    this.value = e;
  }
}
class ValueDeltaSymbolError extends ValueDeltaError {
  value;
  constructor(e) {
    super(e, "Cannot diff objects with symbol keys");
    this.value = e;
  }
}
function CreateUpdate(e, t) {
  return { type: "update", path: e, value: t };
}
function CreateInsert(e, t) {
  return { type: "insert", path: e, value: t };
}
function CreateDelete(e) {
  return { type: "delete", path: e };
}
function* delta_ObjectType(e, t, r) {
  if (!IsStandardObject(r)) return yield CreateUpdate(e, r);
  const n = [...globalThis.Object.keys(t), ...globalThis.Object.getOwnPropertySymbols(t)];
  const o = [...globalThis.Object.keys(r), ...globalThis.Object.getOwnPropertySymbols(r)];
  for (const t of n) {
    if (IsSymbol(t)) throw new ValueDeltaSymbolError(t);
    if (IsUndefined(r[t]) && o.includes(t)) yield CreateUpdate(`${e}/${globalThis.String(t)}`, undefined);
  }
  for (const n of o) {
    if (IsUndefined(t[n]) || IsUndefined(r[n])) continue;
    if (IsSymbol(n)) throw new ValueDeltaSymbolError(n);
    yield* delta_Visit(`${e}/${globalThis.String(n)}`, t[n], r[n]);
  }
  for (const n of o) {
    if (IsSymbol(n)) throw new ValueDeltaSymbolError(n);
    if (IsUndefined(t[n])) yield CreateInsert(`${e}/${globalThis.String(n)}`, r[n]);
  }
  for (const t of n.reverse()) {
    if (IsSymbol(t)) throw new ValueDeltaSymbolError(t);
    if (IsUndefined(r[t]) && !o.includes(t)) yield CreateDelete(`${e}/${globalThis.String(t)}`);
  }
}
function* delta_ArrayType(e, t, r) {
  if (!IsArray(r)) return yield CreateUpdate(e, r);
  for (let n = 0; n < Math.min(t.length, r.length); n++) {
    yield* delta_Visit(`${e}/${n}`, t[n], r[n]);
  }
  for (let n = 0; n < r.length; n++) {
    if (n < t.length) continue;
    yield CreateInsert(`${e}/${n}`, r[n]);
  }
  for (let n = t.length - 1; n >= 0; n--) {
    if (n < r.length) continue;
    yield CreateDelete(`${e}/${n}`);
  }
}
function* delta_TypedArrayType(e, t, r) {
  if (
    !IsTypedArray(r) ||
    t.length !== r.length ||
    globalThis.Object.getPrototypeOf(t).constructor.name !== globalThis.Object.getPrototypeOf(r).constructor.name
  )
    return yield CreateUpdate(e, r);
  for (let n = 0; n < Math.min(t.length, r.length); n++) {
    yield* delta_Visit(`${e}/${n}`, t[n], r[n]);
  }
}
function* delta_ValueType(e, t, r) {
  if (t === r) return;
  yield CreateUpdate(e, r);
}
function* delta_Visit(e, t, r) {
  if (IsStandardObject(t)) return yield* delta_ObjectType(e, t, r);
  if (IsArray(t)) return yield* delta_ArrayType(e, t, r);
  if (IsTypedArray(t)) return yield* delta_TypedArrayType(e, t, r);
  if (IsValueType(t)) return yield* delta_ValueType(e, t, r);
  throw new ValueDeltaError(t, "Unable to create diff edits for unknown value");
}
function Diff(e, t) {
  return [...delta_Visit("", e, t)];
}
function IsRootUpdate(e) {
  return e.length > 0 && e[0].path === "" && e[0].type === "update";
}
function IsIdentity(e) {
  return e.length === 0;
}
function Patch(e, t) {
  if (IsRootUpdate(t)) {
    return clone_Clone(t[0].value);
  }
  if (IsIdentity(t)) {
    return clone_Clone(e);
  }
  const r = clone_Clone(e);
  for (const e of t) {
    switch (e.type) {
      case "insert": {
        pointer_Set(r, e.path, e.value);
        break;
      }
      case "update": {
        pointer_Set(r, e.path, e.value);
        break;
      }
      case "delete": {
        pointer_Delete(r, e.path);
        break;
      }
    }
  }
  return r;
}
class ValueMutateError extends TypeBoxError {
  constructor(e) {
    super(e);
  }
}
function mutate_ObjectType(e, t, r, n) {
  if (!IsStandardObject(r)) {
    pointer_Set(e, t, clone_Clone(n));
  } else {
    const o = Object.getOwnPropertyNames(r);
    const s = Object.getOwnPropertyNames(n);
    for (const e of o) {
      if (!s.includes(e)) {
        delete r[e];
      }
    }
    for (const e of s) {
      if (!o.includes(e)) {
        r[e] = null;
      }
    }
    for (const o of s) {
      mutate_Visit(e, `${t}/${o}`, r[o], n[o]);
    }
  }
}
function mutate_ArrayType(e, t, r, n) {
  if (!IsArray(r)) {
    pointer_Set(e, t, clone_Clone(n));
  } else {
    for (let o = 0; o < n.length; o++) {
      mutate_Visit(e, `${t}/${o}`, r[o], n[o]);
    }
    r.splice(n.length);
  }
}
function mutate_TypedArrayType(e, t, r, n) {
  if (IsTypedArray(r) && r.length === n.length) {
    for (let e = 0; e < r.length; e++) {
      r[e] = n[e];
    }
  } else {
    pointer_Set(e, t, clone_Clone(n));
  }
}
function mutate_ValueType(e, t, r, n) {
  if (r === n) return;
  pointer_Set(e, t, n);
}
function mutate_Visit(e, t, r, n) {
  if (IsArray(n)) return mutate_ArrayType(e, t, r, n);
  if (IsTypedArray(n)) return mutate_TypedArrayType(e, t, r, n);
  if (IsStandardObject(n)) return mutate_ObjectType(e, t, r, n);
  if (IsValueType(n)) return mutate_ValueType(e, t, r, n);
}
function IsNonMutableValue(e) {
  return IsTypedArray(e) || IsValueType(e);
}
function IsMismatchedValue(e, t) {
  return (IsStandardObject(e) && IsArray(t)) || (IsArray(e) && IsStandardObject(t));
}
function Mutate(e, t) {
  if (IsNonMutableValue(e) || IsNonMutableValue(t)) throw new ValueMutateError("Only object and array types can be mutated at the root level");
  if (IsMismatchedValue(e, t)) throw new ValueMutateError("Cannot assign due type mismatch of assignable values");
  mutate_Visit(e, "", e, t);
}
class TransformDecodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(e, t, r) {
    super(`Unable to decode value as it does not match the expected schema`);
    this.schema = e;
    this.value = t;
    this.error = r;
  }
}
class TransformDecodeError extends TypeBoxError {
  schema;
  path;
  value;
  error;
  constructor(e, t, r, n) {
    super(n instanceof Error ? n.message : "Unknown error");
    this.schema = e;
    this.path = t;
    this.value = r;
    this.error = n;
  }
}
function decode_Default(e, t, r) {
  try {
    return type_IsTransform(e) ? e[p].Decode(r) : r;
  } catch (n) {
    throw new TransformDecodeError(e, t, r, n);
  }
}
function decode_FromArray(e, t, r, n) {
  return IsArray(n)
    ? decode_Default(
        e,
        r,
        n.map((n, o) => decode_Visit(e.items, t, `${r}/${o}`, n))
      )
    : decode_Default(e, r, n);
}
function decode_FromIntersect(e, t, r, n) {
  if (!IsStandardObject(n) || IsValueType(n)) return decode_Default(e, r, n);
  const o = KeyOfPropertyEntries(e);
  const s = o.map((e) => e[0]);
  const i = { ...n };
  for (const [e, n] of o)
    if (e in i) {
      i[e] = decode_Visit(n, t, `${r}/${e}`, i[e]);
    }
  if (!type_IsTransform(e.unevaluatedProperties)) {
    return decode_Default(e, r, i);
  }
  const a = Object.getOwnPropertyNames(i);
  const A = e.unevaluatedProperties;
  const c = { ...i };
  for (const e of a)
    if (!s.includes(e)) {
      c[e] = decode_Default(A, `${r}/${e}`, c[e]);
    }
  return decode_Default(e, r, c);
}
function decode_FromNot(e, t, r, n) {
  return decode_Default(e, r, decode_Visit(e.not, t, r, n));
}
function decode_FromObject(e, t, r, n) {
  if (!IsStandardObject(n)) return decode_Default(e, r, n);
  const o = KeyOfPropertyKeys(e);
  const s = { ...n };
  for (const n of o)
    if (n in s) {
      s[n] = decode_Visit(e.properties[n], t, `${r}/${n}`, s[n]);
    }
  if (!type_IsSchema(e.additionalProperties)) {
    return decode_Default(e, r, s);
  }
  const i = Object.getOwnPropertyNames(s);
  const a = e.additionalProperties;
  const A = { ...s };
  for (const e of i)
    if (!o.includes(e)) {
      A[e] = decode_Default(a, `${r}/${e}`, A[e]);
    }
  return decode_Default(e, r, A);
}
function decode_FromRecord(e, t, r, n) {
  if (!IsStandardObject(n)) return decode_Default(e, r, n);
  const o = Object.getOwnPropertyNames(e.patternProperties)[0];
  const s = new RegExp(o);
  const i = { ...n };
  for (const a of Object.getOwnPropertyNames(n))
    if (s.test(a)) {
      i[a] = decode_Visit(e.patternProperties[o], t, `${r}/${a}`, i[a]);
    }
  if (!type_IsSchema(e.additionalProperties)) {
    return decode_Default(e, r, i);
  }
  const a = Object.getOwnPropertyNames(i);
  const A = e.additionalProperties;
  const c = { ...i };
  for (const e of a)
    if (!s.test(e)) {
      c[e] = decode_Default(A, `${r}/${e}`, c[e]);
    }
  return decode_Default(e, r, c);
}
function decode_FromRef(e, t, r, n) {
  const o = deref_Deref(e, t);
  return decode_Default(e, r, decode_Visit(o, t, r, n));
}
function decode_FromThis(e, t, r, n) {
  const o = deref_Deref(e, t);
  return decode_Default(e, r, decode_Visit(o, t, r, n));
}
function decode_FromTuple(e, t, r, n) {
  return IsArray(n) && IsArray(e.items)
    ? decode_Default(
        e,
        r,
        e.items.map((e, o) => decode_Visit(e, t, `${r}/${o}`, n[o]))
      )
    : decode_Default(e, r, n);
}
function decode_FromUnion(e, t, r, n) {
  for (const o of e.anyOf) {
    if (!Check(o, t, n)) continue;
    const s = decode_Visit(o, t, r, n);
    return decode_Default(e, r, s);
  }
  return decode_Default(e, r, n);
}
function decode_Visit(e, t, r, n) {
  const o = typeof e.$id === "string" ? [...t, e] : t;
  const s = e;
  switch (e[h]) {
    case "Array":
      return decode_FromArray(s, o, r, n);
    case "Intersect":
      return decode_FromIntersect(s, o, r, n);
    case "Not":
      return decode_FromNot(s, o, r, n);
    case "Object":
      return decode_FromObject(s, o, r, n);
    case "Record":
      return decode_FromRecord(s, o, r, n);
    case "Ref":
      return decode_FromRef(s, o, r, n);
    case "Symbol":
      return decode_Default(s, r, n);
    case "This":
      return decode_FromThis(s, o, r, n);
    case "Tuple":
      return decode_FromTuple(s, o, r, n);
    case "Union":
      return decode_FromUnion(s, o, r, n);
    default:
      return decode_Default(s, r, n);
  }
}
function TransformDecode(e, t, r) {
  return decode_Visit(e, t, "", r);
}
class TransformEncodeCheckError extends TypeBoxError {
  schema;
  value;
  error;
  constructor(e, t, r) {
    super(`The encoded value does not match the expected schema`);
    this.schema = e;
    this.value = t;
    this.error = r;
  }
}
class TransformEncodeError extends TypeBoxError {
  schema;
  path;
  value;
  error;
  constructor(e, t, r, n) {
    super(`${n instanceof Error ? n.message : "Unknown error"}`);
    this.schema = e;
    this.path = t;
    this.value = r;
    this.error = n;
  }
}
function encode_Default(e, t, r) {
  try {
    return type_IsTransform(e) ? e[p].Encode(r) : r;
  } catch (n) {
    throw new TransformEncodeError(e, t, r, n);
  }
}
function encode_FromArray(e, t, r, n) {
  const o = encode_Default(e, r, n);
  return IsArray(o) ? o.map((n, o) => encode_Visit(e.items, t, `${r}/${o}`, n)) : o;
}
function encode_FromIntersect(e, t, r, n) {
  const o = encode_Default(e, r, n);
  if (!IsStandardObject(n) || IsValueType(n)) return o;
  const s = KeyOfPropertyEntries(e);
  const i = s.map((e) => e[0]);
  const a = { ...o };
  for (const [e, n] of s)
    if (e in a) {
      a[e] = encode_Visit(n, t, `${r}/${e}`, a[e]);
    }
  if (!type_IsTransform(e.unevaluatedProperties)) {
    return encode_Default(e, r, a);
  }
  const A = Object.getOwnPropertyNames(a);
  const c = e.unevaluatedProperties;
  const u = { ...a };
  for (const e of A)
    if (!i.includes(e)) {
      u[e] = encode_Default(c, `${r}/${e}`, u[e]);
    }
  return u;
}
function encode_FromNot(e, t, r, n) {
  return encode_Default(e.not, r, encode_Default(e, r, n));
}
function encode_FromObject(e, t, r, n) {
  const o = encode_Default(e, r, n);
  if (!IsStandardObject(o)) return o;
  const s = KeyOfPropertyKeys(e);
  const i = { ...o };
  for (const n of s)
    if (n in i) {
      i[n] = encode_Visit(e.properties[n], t, `${r}/${n}`, i[n]);
    }
  if (!type_IsSchema(e.additionalProperties)) {
    return i;
  }
  const a = Object.getOwnPropertyNames(i);
  const A = e.additionalProperties;
  const c = { ...i };
  for (const e of a)
    if (!s.includes(e)) {
      c[e] = encode_Default(A, `${r}/${e}`, c[e]);
    }
  return c;
}
function encode_FromRecord(e, t, r, n) {
  const o = encode_Default(e, r, n);
  if (!IsStandardObject(n)) return o;
  const s = Object.getOwnPropertyNames(e.patternProperties)[0];
  const i = new RegExp(s);
  const a = { ...o };
  for (const o of Object.getOwnPropertyNames(n))
    if (i.test(o)) {
      a[o] = encode_Visit(e.patternProperties[s], t, `${r}/${o}`, a[o]);
    }
  if (!type_IsSchema(e.additionalProperties)) {
    return encode_Default(e, r, a);
  }
  const A = Object.getOwnPropertyNames(a);
  const c = e.additionalProperties;
  const u = { ...a };
  for (const e of A)
    if (!i.test(e)) {
      u[e] = encode_Default(c, `${r}/${e}`, u[e]);
    }
  return u;
}
function encode_FromRef(e, t, r, n) {
  const o = deref_Deref(e, t);
  const s = encode_Visit(o, t, r, n);
  return encode_Default(e, r, s);
}
function encode_FromThis(e, t, r, n) {
  const o = deref_Deref(e, t);
  const s = encode_Visit(o, t, r, n);
  return encode_Default(e, r, s);
}
function encode_FromTuple(e, t, r, n) {
  const o = encode_Default(e, r, n);
  return IsArray(e.items) ? e.items.map((e, n) => encode_Visit(e, t, `${r}/${n}`, o[n])) : [];
}
function encode_FromUnion(e, t, r, n) {
  for (const o of e.anyOf) {
    if (!Check(o, t, n)) continue;
    const s = encode_Visit(o, t, r, n);
    return encode_Default(e, r, s);
  }
  for (const o of e.anyOf) {
    const s = encode_Visit(o, t, r, n);
    if (!Check(e, t, s)) continue;
    return encode_Default(e, r, s);
  }
  return encode_Default(e, r, n);
}
function encode_Visit(e, t, r, n) {
  const o = typeof e.$id === "string" ? [...t, e] : t;
  const s = e;
  switch (e[h]) {
    case "Array":
      return encode_FromArray(s, o, r, n);
    case "Intersect":
      return encode_FromIntersect(s, o, r, n);
    case "Not":
      return encode_FromNot(s, o, r, n);
    case "Object":
      return encode_FromObject(s, o, r, n);
    case "Record":
      return encode_FromRecord(s, o, r, n);
    case "Ref":
      return encode_FromRef(s, o, r, n);
    case "This":
      return encode_FromThis(s, o, r, n);
    case "Tuple":
      return encode_FromTuple(s, o, r, n);
    case "Union":
      return encode_FromUnion(s, o, r, n);
    default:
      return encode_Default(s, r, n);
  }
}
function TransformEncode(e, t, r) {
  return encode_Visit(e, t, "", r);
}
function has_FromArray(e, t) {
  return type_IsTransform(e) || has_Visit(e.items, t);
}
function has_FromAsyncIterator(e, t) {
  return type_IsTransform(e) || has_Visit(e.items, t);
}
function has_FromConstructor(e, t) {
  return type_IsTransform(e) || has_Visit(e.returns, t) || e.parameters.some((e) => has_Visit(e, t));
}
function has_FromFunction(e, t) {
  return type_IsTransform(e) || has_Visit(e.returns, t) || e.parameters.some((e) => has_Visit(e, t));
}
function has_FromIntersect(e, t) {
  return type_IsTransform(e) || type_IsTransform(e.unevaluatedProperties) || e.allOf.some((e) => has_Visit(e, t));
}
function has_FromIterator(e, t) {
  return type_IsTransform(e) || has_Visit(e.items, t);
}
function has_FromNot(e, t) {
  return type_IsTransform(e) || has_Visit(e.not, t);
}
function has_FromObject(e, t) {
  return (
    type_IsTransform(e) ||
    Object.values(e.properties).some((e) => has_Visit(e, t)) ||
    (type_IsSchema(e.additionalProperties) && has_Visit(e.additionalProperties, t))
  );
}
function has_FromPromise(e, t) {
  return type_IsTransform(e) || has_Visit(e.item, t);
}
function has_FromRecord(e, t) {
  const r = Object.getOwnPropertyNames(e.patternProperties)[0];
  const n = e.patternProperties[r];
  return type_IsTransform(e) || has_Visit(n, t) || (type_IsSchema(e.additionalProperties) && type_IsTransform(e.additionalProperties));
}
function has_FromRef(e, t) {
  if (type_IsTransform(e)) return true;
  return has_Visit(deref_Deref(e, t), t);
}
function has_FromThis(e, t) {
  if (type_IsTransform(e)) return true;
  return has_Visit(deref_Deref(e, t), t);
}
function has_FromTuple(e, t) {
  return type_IsTransform(e) || (!IsUndefined(e.items) && e.items.some((e) => has_Visit(e, t)));
}
function has_FromUnion(e, t) {
  return type_IsTransform(e) || e.anyOf.some((e) => has_Visit(e, t));
}
function has_Visit(e, t) {
  const r = IsString(e.$id) ? [...t, e] : t;
  const n = e;
  if (e.$id && Y.has(e.$id)) return false;
  if (e.$id) Y.add(e.$id);
  switch (e[h]) {
    case "Array":
      return has_FromArray(n, r);
    case "AsyncIterator":
      return has_FromAsyncIterator(n, r);
    case "Constructor":
      return has_FromConstructor(n, r);
    case "Function":
      return has_FromFunction(n, r);
    case "Intersect":
      return has_FromIntersect(n, r);
    case "Iterator":
      return has_FromIterator(n, r);
    case "Not":
      return has_FromNot(n, r);
    case "Object":
      return has_FromObject(n, r);
    case "Promise":
      return has_FromPromise(n, r);
    case "Record":
      return has_FromRecord(n, r);
    case "Ref":
      return has_FromRef(n, r);
    case "This":
      return has_FromThis(n, r);
    case "Tuple":
      return has_FromTuple(n, r);
    case "Union":
      return has_FromUnion(n, r);
    default:
      return type_IsTransform(e);
  }
}
const Y = new Set();
function HasTransform(e, t) {
  Y.clear();
  return has_Visit(e, t);
}
function equal_ObjectType(e, t) {
  if (!IsStandardObject(t)) return false;
  const r = [...Object.keys(e), ...Object.getOwnPropertySymbols(e)];
  const n = [...Object.keys(t), ...Object.getOwnPropertySymbols(t)];
  if (r.length !== n.length) return false;
  return r.every((r) => Equal(e[r], t[r]));
}
function equal_DateType(e, t) {
  return IsDate(t) && e.getTime() === t.getTime();
}
function equal_ArrayType(e, t) {
  if (!IsArray(t) || e.length !== t.length) return false;
  return e.every((e, r) => Equal(e, t[r]));
}
function equal_TypedArrayType(e, t) {
  if (!IsTypedArray(t) || e.length !== t.length || Object.getPrototypeOf(e).constructor.name !== Object.getPrototypeOf(t).constructor.name) return false;
  return e.every((e, r) => Equal(e, t[r]));
}
function equal_ValueType(e, t) {
  return e === t;
}
function Equal(e, t) {
  if (IsStandardObject(e)) return equal_ObjectType(e, t);
  if (IsDate(e)) return equal_DateType(e, t);
  if (IsTypedArray(e)) return equal_TypedArrayType(e, t);
  if (IsArray(e)) return equal_ArrayType(e, t);
  if (IsValueType(e)) return equal_ValueType(e, t);
  throw new Error("ValueEquals: Unable to compare value");
}
function value_Cast(...e) {
  return Cast.apply(Cast, e);
}
function value_Create(...e) {
  return create_Create.apply(create_Create, e);
}
function value_Check(...e) {
  return Check.apply(Check, e);
}
function value_Clean(...e) {
  return Clean.apply(Clean, e);
}
function value_Convert(...e) {
  return Convert.apply(Convert, e);
}
function value_Clone(e) {
  return clone_Clone(e);
}
function Decode(...e) {
  const [t, r, n] = e.length === 3 ? [e[0], e[1], e[2]] : [e[0], [], e[1]];
  if (!value_Check(t, r, n)) throw new TransformDecodeCheckError(t, n, value_Errors(t, r, n).First());
  return HasTransform(t, r) ? TransformDecode(t, r, n) : n;
}
function value_Default(...e) {
  return default_Default.apply(default_Default, e);
}
function Encode(...e) {
  const [t, r, n] = e.length === 3 ? [e[0], e[1], e[2]] : [e[0], [], e[1]];
  const o = HasTransform(t, r) ? TransformEncode(t, r, n) : n;
  if (!value_Check(t, r, o)) throw new TransformEncodeCheckError(t, o, value_Errors(t, r, o).First());
  return o;
}
function value_Errors(...e) {
  return Errors.apply(Errors, e);
}
function value_Equal(e, t) {
  return Equal(e, t);
}
function value_Diff(e, t) {
  return Diff(e, t);
}
function value_Hash(e) {
  return Hash(e);
}
function value_Patch(e, t) {
  return Patch(e, t);
}
function value_Mutate(e, t) {
  Mutate(e, t);
}
function awaited_FromRest(e) {
  return e.map((e) => AwaitedResolve(e));
}
function awaited_FromIntersect(e) {
  return intersect_Intersect(awaited_FromRest(e));
}
function awaited_FromUnion(e) {
  return union_Union(awaited_FromRest(e));
}
function awaited_FromPromise(e) {
  return AwaitedResolve(e);
}
function AwaitedResolve(e) {
  return IsIntersect(e) ? awaited_FromIntersect(e.allOf) : IsUnion(e) ? awaited_FromUnion(e.anyOf) : kind_IsPromise(e) ? awaited_FromPromise(e.item) : e;
}
function awaited_Awaited(e, t = {}) {
  return CloneType(AwaitedResolve(e), t);
}
function CompositeKeys(e) {
  const t = [];
  for (const r of e) t.push(...KeyOfPropertyKeys(r));
  return SetDistinct(t);
}
function FilterNever(e) {
  return e.filter((e) => !IsNever(e));
}
function CompositeProperty(e, t) {
  const r = [];
  for (const n of e) r.push(...IndexFromPropertyKeys(n, [t]));
  return FilterNever(r);
}
function CompositeProperties(e, t) {
  const r = {};
  for (const n of t) {
    r[n] = IntersectEvaluated(CompositeProperty(e, n));
  }
  return r;
}
function composite_Composite(e, t = {}) {
  const r = CompositeKeys(e);
  const n = CompositeProperties(e, r);
  const o = T(n, t);
  return o;
}
function date_Date(e = {}) {
  return { ...e, [h]: "Date", type: "Date" };
}
function null_Null(e = {}) {
  return { ...e, [h]: "Null", type: "null" };
}
function symbol_Symbol(e) {
  return { ...e, [h]: "Symbol", type: "symbol" };
}
function undefined_Undefined(e = {}) {
  return { ...e, [h]: "Undefined", type: "undefined" };
}
function uint8array_Uint8Array(e = {}) {
  return { ...e, [h]: "Uint8Array", type: "Uint8Array" };
}
function const_FromArray(e) {
  return e.map((e) => FromValue(e, false));
}
function const_FromProperties(e) {
  const t = {};
  for (const r of globalThis.Object.getOwnPropertyNames(e)) t[r] = readonly_Readonly(FromValue(e[r], false));
  return t;
}
function ConditionalReadonly(e, t) {
  return t === true ? e : readonly_Readonly(e);
}
function FromValue(e, t) {
  return value_IsAsyncIterator(e)
    ? ConditionalReadonly(any_Any(), t)
    : value_IsIterator(e)
      ? ConditionalReadonly(any_Any(), t)
      : value_IsArray(e)
        ? readonly_Readonly(tuple_Tuple(const_FromArray(e)))
        : value_IsUint8Array(e)
          ? uint8array_Uint8Array()
          : value_IsDate(e)
            ? date_Date()
            : value_IsObject(e)
              ? ConditionalReadonly(T(const_FromProperties(e)), t)
              : value_IsFunction(e)
                ? ConditionalReadonly(src_Function([], unknown_Unknown()), t)
                : value_IsUndefined(e)
                  ? undefined_Undefined()
                  : value_IsNull(e)
                    ? null_Null()
                    : value_IsSymbol(e)
                      ? symbol_Symbol()
                      : value_IsBigInt(e)
                        ? bigint_BigInt()
                        : value_IsNumber(e)
                          ? literal_Literal(e)
                          : value_IsBoolean(e)
                            ? literal_Literal(e)
                            : value_IsString(e)
                              ? literal_Literal(e)
                              : T({});
}
function const_Const(e, t = {}) {
  return CloneType(FromValue(e, true), t);
}
function constructor_parameters_ConstructorParameters(e, t = {}) {
  return tuple_Tuple(CloneRest(e.parameters), { ...t });
}
function deref_FromRest(e, t) {
  return e.map((e) => deref_deref_Deref(e, t));
}
function deref_FromProperties(e, t) {
  const r = {};
  for (const n of globalThis.Object.getOwnPropertyNames(e)) {
    r[n] = deref_deref_Deref(e[n], t);
  }
  return r;
}
function deref_FromConstructor(e, t) {
  e.parameters = deref_FromRest(e.parameters, t);
  e.returns = deref_deref_Deref(e.returns, t);
  return e;
}
function deref_FromFunction(e, t) {
  e.parameters = deref_FromRest(e.parameters, t);
  e.returns = deref_deref_Deref(e.returns, t);
  return e;
}
function deref_FromIntersect(e, t) {
  e.allOf = deref_FromRest(e.allOf, t);
  return e;
}
function deref_FromUnion(e, t) {
  e.anyOf = deref_FromRest(e.anyOf, t);
  return e;
}
function deref_FromTuple(e, t) {
  if (value_IsUndefined(e.items)) return e;
  e.items = deref_FromRest(e.items, t);
  return e;
}
function deref_FromArray(e, t) {
  e.items = deref_deref_Deref(e.items, t);
  return e;
}
function deref_FromObject(e, t) {
  e.properties = deref_FromProperties(e.properties, t);
  return e;
}
function deref_FromPromise(e, t) {
  e.item = deref_deref_Deref(e.item, t);
  return e;
}
function deref_FromAsyncIterator(e, t) {
  e.items = deref_deref_Deref(e.items, t);
  return e;
}
function deref_FromIterator(e, t) {
  e.items = deref_deref_Deref(e.items, t);
  return e;
}
function deref_FromRef(e, t) {
  const r = t.find((t) => t.$id === e.$ref);
  if (r === undefined) throw Error(`Unable to dereference schema with $id ${e.$ref}`);
  const n = Discard(r, ["$id"]);
  return deref_deref_Deref(n, t);
}
function DerefResolve(e, t) {
  return IsConstructor(e)
    ? deref_FromConstructor(e, t)
    : kind_IsFunction(e)
      ? deref_FromFunction(e, t)
      : IsIntersect(e)
        ? deref_FromIntersect(e, t)
        : IsUnion(e)
          ? deref_FromUnion(e, t)
          : IsTuple(e)
            ? deref_FromTuple(e, t)
            : kind_IsArray(e)
              ? deref_FromArray(e, t)
              : kind_IsObject(e)
                ? deref_FromObject(e, t)
                : kind_IsPromise(e)
                  ? deref_FromPromise(e, t)
                  : kind_IsAsyncIterator(e)
                    ? deref_FromAsyncIterator(e, t)
                    : kind_IsIterator(e)
                      ? deref_FromIterator(e, t)
                      : IsRef(e)
                        ? deref_FromRef(e, t)
                        : e;
}
function deref_deref_Deref(e, t) {
  return DerefResolve(CloneType(e), CloneRest(t));
}
function enum_Enum(e, t = {}) {
  if (value_IsUndefined(e)) throw new Error("Enum undefined or empty");
  const r = globalThis.Object.getOwnPropertyNames(e)
    .filter((e) => isNaN(e))
    .map((t) => e[t]);
  const n = [...new Set(r)];
  const o = n.map((e) => literal_Literal(e));
  return union_Union(o, { ...t, [m]: "Enum" });
}
function ExcludeFromTemplateLiteral(e, t) {
  return exclude_Exclude(TemplateLiteralToUnion(e), t);
}
function ExcludeRest(e, t) {
  const r = e.filter((e) => ExtendsCheck(e, t) === U.False);
  return r.length === 1 ? r[0] : union_Union(r);
}
function exclude_Exclude(e, t, r = {}) {
  if (IsTemplateLiteral(e)) return CloneType(ExcludeFromTemplateLiteral(e, t), r);
  if (IsMappedResult(e)) return CloneType(ExcludeFromMappedResult(e, t), r);
  return CloneType(IsUnion(e) ? ExcludeRest(e.anyOf, t) : ExtendsCheck(e, t) !== U.False ? never_Never() : e, r);
}
function exclude_from_mapped_result_FromProperties(e, t) {
  const r = {};
  for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = exclude_Exclude(e[n], t);
  return r;
}
function exclude_from_mapped_result_FromMappedResult(e, t) {
  return exclude_from_mapped_result_FromProperties(e.properties, t);
}
function ExcludeFromMappedResult(e, t) {
  const r = exclude_from_mapped_result_FromMappedResult(e, t);
  return MappedResult(r);
}
function ExtractFromTemplateLiteral(e, t) {
  return extract_Extract(TemplateLiteralToUnion(e), t);
}
function ExtractRest(e, t) {
  const r = e.filter((e) => ExtendsCheck(e, t) !== U.False);
  return r.length === 1 ? r[0] : union_Union(r);
}
function extract_Extract(e, t, r = {}) {
  if (IsTemplateLiteral(e)) return CloneType(ExtractFromTemplateLiteral(e, t), r);
  if (IsMappedResult(e)) return CloneType(ExtractFromMappedResult(e, t), r);
  return CloneType(IsUnion(e) ? ExtractRest(e.anyOf, t) : ExtendsCheck(e, t) !== U.False ? e : never_Never(), r);
}
function extract_from_mapped_result_FromProperties(e, t) {
  const r = {};
  for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = extract_Extract(e[n], t);
  return r;
}
function extract_from_mapped_result_FromMappedResult(e, t) {
  return extract_from_mapped_result_FromProperties(e.properties, t);
}
function ExtractFromMappedResult(e, t) {
  const r = extract_from_mapped_result_FromMappedResult(e, t);
  return MappedResult(r);
}
function integer_Integer(e = {}) {
  return { ...e, [h]: "Integer", type: "integer" };
}
function MappedIntrinsicPropertyKey(e, t, r) {
  return { [e]: Intrinsic(literal_Literal(e), t, r) };
}
function MappedIntrinsicPropertyKeys(e, t, r) {
  return e.reduce((e, n) => ({ ...e, ...MappedIntrinsicPropertyKey(n, t, r) }), {});
}
function MappedIntrinsicProperties(e, t, r) {
  return MappedIntrinsicPropertyKeys(e["keys"], t, r);
}
function IntrinsicFromMappedKey(e, t, r) {
  const n = MappedIntrinsicProperties(e, t, r);
  return MappedResult(n);
}
function ApplyUncapitalize(e) {
  const [t, r] = [e.slice(0, 1), e.slice(1)];
  return [t.toLowerCase(), r].join("");
}
function ApplyCapitalize(e) {
  const [t, r] = [e.slice(0, 1), e.slice(1)];
  return [t.toUpperCase(), r].join("");
}
function ApplyUppercase(e) {
  return e.toUpperCase();
}
function ApplyLowercase(e) {
  return e.toLowerCase();
}
function intrinsic_FromTemplateLiteral(e, t, r) {
  const n = TemplateLiteralParseExact(e.pattern);
  const o = IsTemplateLiteralExpressionFinite(n);
  if (!o) return { ...e, pattern: FromLiteralValue(e.pattern, t) };
  const s = [...TemplateLiteralExpressionGenerate(n)];
  const i = s.map((e) => literal_Literal(e));
  const a = intrinsic_FromRest(i, t);
  const A = union_Union(a);
  return template_literal_TemplateLiteral([A], r);
}
function FromLiteralValue(e, t) {
  return typeof e === "string"
    ? t === "Uncapitalize"
      ? ApplyUncapitalize(e)
      : t === "Capitalize"
        ? ApplyCapitalize(e)
        : t === "Uppercase"
          ? ApplyUppercase(e)
          : t === "Lowercase"
            ? ApplyLowercase(e)
            : e
    : e.toString();
}
function intrinsic_FromRest(e, t) {
  return e.map((e) => Intrinsic(e, t));
}
function Intrinsic(e, t, r = {}) {
  return IsMappedKey(e)
    ? IntrinsicFromMappedKey(e, t, r)
    : IsTemplateLiteral(e)
      ? intrinsic_FromTemplateLiteral(e, t, e)
      : IsUnion(e)
        ? union_Union(intrinsic_FromRest(e.anyOf, t), r)
        : IsLiteral(e)
          ? literal_Literal(FromLiteralValue(e.const, t), r)
          : e;
}
function capitalize_Capitalize(e, t = {}) {
  return Intrinsic(e, "Capitalize", t);
}
function lowercase_Lowercase(e, t = {}) {
  return Intrinsic(e, "Lowercase", t);
}
function uncapitalize_Uncapitalize(e, t = {}) {
  return Intrinsic(e, "Uncapitalize", t);
}
function uppercase_Uppercase(e, t = {}) {
  return Intrinsic(e, "Uppercase", t);
}
function not_Not(e, t) {
  return { ...t, [h]: "Not", not: CloneType(e) };
}
function omit_from_mapped_result_FromProperties(e, t, r) {
  const n = {};
  for (const o of globalThis.Object.getOwnPropertyNames(e)) n[o] = omit_Omit(e[o], t, r);
  return n;
}
function omit_from_mapped_result_FromMappedResult(e, t, r) {
  return omit_from_mapped_result_FromProperties(e.properties, t, r);
}
function OmitFromMappedResult(e, t, r) {
  const n = omit_from_mapped_result_FromMappedResult(e, t, r);
  return MappedResult(n);
}
function omit_FromIntersect(e, t) {
  return e.map((e) => OmitResolve(e, t));
}
function omit_FromUnion(e, t) {
  return e.map((e) => OmitResolve(e, t));
}
function omit_FromProperty(e, t) {
  const { [t]: r, ...n } = e;
  return n;
}
function omit_FromProperties(e, t) {
  return t.reduce((e, t) => omit_FromProperty(e, t), e);
}
function OmitResolve(e, t) {
  return IsIntersect(e)
    ? intersect_Intersect(omit_FromIntersect(e.allOf, t))
    : IsUnion(e)
      ? union_Union(omit_FromUnion(e.anyOf, t))
      : kind_IsObject(e)
        ? T(omit_FromProperties(e.properties, t))
        : T({});
}
function omit_Omit(e, t, r = {}) {
  if (IsMappedKey(t)) return OmitFromMappedKey(e, t, r);
  if (IsMappedResult(e)) return OmitFromMappedResult(e, t, r);
  const n = IsSchema(t) ? IndexPropertyKeys(t) : t;
  const o = Discard(e, [p, "$id", "required"]);
  const s = CloneType(OmitResolve(e, n), r);
  return { ...o, ...s };
}
function omit_from_mapped_key_FromPropertyKey(e, t, r) {
  return { [t]: omit_Omit(e, [t], r) };
}
function omit_from_mapped_key_FromPropertyKeys(e, t, r) {
  return t.reduce((t, n) => ({ ...t, ...omit_from_mapped_key_FromPropertyKey(e, n, r) }), {});
}
function omit_from_mapped_key_FromMappedKey(e, t, r) {
  return omit_from_mapped_key_FromPropertyKeys(e, t.keys, r);
}
function OmitFromMappedKey(e, t, r) {
  const n = omit_from_mapped_key_FromMappedKey(e, t, r);
  return MappedResult(n);
}
function parameters_Parameters(e, t = {}) {
  return tuple_Tuple(CloneRest(e.parameters), { ...t });
}
function partial_FromRest(e) {
  return e.map((e) => PartialResolve(e));
}
function partial_FromProperties(e) {
  const t = {};
  for (const r of globalThis.Object.getOwnPropertyNames(e)) t[r] = optional_Optional(e[r]);
  return t;
}
function PartialResolve(e) {
  return IsIntersect(e)
    ? intersect_Intersect(partial_FromRest(e.allOf))
    : IsUnion(e)
      ? union_Union(partial_FromRest(e.anyOf))
      : kind_IsObject(e)
        ? T(partial_FromProperties(e.properties))
        : T({});
}
function partial_Partial(e, t = {}) {
  if (IsMappedResult(e)) return PartialFromMappedResult(e, t);
  const r = Discard(e, [p, "$id", "required"]);
  const n = CloneType(PartialResolve(e), t);
  return { ...r, ...n };
}
function partial_from_mapped_result_FromProperties(e, t) {
  const r = {};
  for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = partial_Partial(e[n], t);
  return r;
}
function partial_from_mapped_result_FromMappedResult(e, t) {
  return partial_from_mapped_result_FromProperties(e.properties, t);
}
function PartialFromMappedResult(e, t) {
  const r = partial_from_mapped_result_FromMappedResult(e, t);
  return MappedResult(r);
}
function pick_from_mapped_result_FromProperties(e, t, r) {
  const n = {};
  for (const o of globalThis.Object.getOwnPropertyNames(e)) n[o] = pick_Pick(e[o], t, r);
  return n;
}
function pick_from_mapped_result_FromMappedResult(e, t, r) {
  return pick_from_mapped_result_FromProperties(e.properties, t, r);
}
function PickFromMappedResult(e, t, r) {
  const n = pick_from_mapped_result_FromMappedResult(e, t, r);
  return MappedResult(n);
}
function pick_FromIntersect(e, t) {
  return e.map((e) => PickResolve(e, t));
}
function pick_FromUnion(e, t) {
  return e.map((e) => PickResolve(e, t));
}
function pick_FromProperties(e, t) {
  const r = {};
  for (const n of t) if (n in e) r[n] = e[n];
  return r;
}
function PickResolve(e, t) {
  return IsIntersect(e)
    ? intersect_Intersect(pick_FromIntersect(e.allOf, t))
    : IsUnion(e)
      ? union_Union(pick_FromUnion(e.anyOf, t))
      : kind_IsObject(e)
        ? T(pick_FromProperties(e.properties, t))
        : T({});
}
function pick_Pick(e, t, r = {}) {
  if (IsMappedKey(t)) return PickFromMappedKey(e, t, r);
  if (IsMappedResult(e)) return PickFromMappedResult(e, t, r);
  const n = IsSchema(t) ? IndexPropertyKeys(t) : t;
  const o = Discard(e, [p, "$id", "required"]);
  const s = CloneType(PickResolve(e, n), r);
  return { ...o, ...s };
}
function pick_from_mapped_key_FromPropertyKey(e, t, r) {
  return { [t]: pick_Pick(e, [t], r) };
}
function pick_from_mapped_key_FromPropertyKeys(e, t, r) {
  return t.reduce((t, n) => ({ ...t, ...pick_from_mapped_key_FromPropertyKey(e, n, r) }), {});
}
function pick_from_mapped_key_FromMappedKey(e, t, r) {
  return pick_from_mapped_key_FromPropertyKeys(e, t.keys, r);
}
function PickFromMappedKey(e, t, r) {
  const n = pick_from_mapped_key_FromMappedKey(e, t, r);
  return MappedResult(n);
}
function readonly_optional_ReadonlyOptional(e) {
  return readonly_Readonly(optional_Optional(e));
}
function RecordCreateFromPattern(e, t, r) {
  return { ...r, [h]: "Record", type: "object", patternProperties: { [e]: CloneType(t) } };
}
function RecordCreateFromKeys(e, t, r) {
  const n = {};
  for (const r of e) n[r] = CloneType(t);
  return T(n, { ...r, [m]: "Record" });
}
function FromTemplateLiteralKey(e, t, r) {
  return IsTemplateLiteralFinite(e) ? RecordCreateFromKeys(IndexPropertyKeys(e), t, r) : RecordCreateFromPattern(e.pattern, t, r);
}
function FromUnionKey(e, t, r) {
  return RecordCreateFromKeys(IndexPropertyKeys(union_Union(e)), t, r);
}
function FromLiteralKey(e, t, r) {
  return RecordCreateFromKeys([e.toString()], t, r);
}
function FromRegExpKey(e, t, r) {
  return RecordCreateFromPattern(e.source, t, r);
}
function FromStringKey(e, t, r) {
  const n = value_IsUndefined(e.pattern) ? B : e.pattern;
  return RecordCreateFromPattern(n, t, r);
}
function FromIntegerKey(e, t, r) {
  return RecordCreateFromPattern(Q, t, r);
}
function FromNumberKey(e, t, r) {
  return RecordCreateFromPattern(Q, t, r);
}
function record_Record(e, t, r = {}) {
  return IsUnion(e)
    ? FromUnionKey(e.anyOf, t, r)
    : IsTemplateLiteral(e)
      ? FromTemplateLiteralKey(e, t, r)
      : IsLiteral(e)
        ? FromLiteralKey(e.const, t, r)
        : kind_IsInteger(e)
          ? FromIntegerKey(e, t, r)
          : kind_IsNumber(e)
            ? FromNumberKey(e, t, r)
            : kind_IsRegExp(e)
              ? FromRegExpKey(e, t, r)
              : kind_IsString(e)
                ? FromStringKey(e, t, r)
                : never_Never(r);
}
let K = 0;
function recursive_Recursive(e, t = {}) {
  if (value_IsUndefined(t.$id)) t.$id = `T${K++}`;
  const r = e({ [h]: "This", $ref: `${t.$id}` });
  r.$id = t.$id;
  return CloneType({ ...t, [m]: "Recursive", ...r });
}
function ref_Ref(e, t = {}) {
  if (value_IsString(e)) return { ...t, [h]: "Ref", $ref: e };
  if (value_IsUndefined(e.$id)) throw new Error("Reference target type must specify an $id");
  return { ...t, [h]: "Ref", $ref: e.$id };
}
function regexp_RegExp(e, t = {}) {
  const r = value_IsString(e) ? new globalThis.RegExp(e) : e;
  return { ...t, [h]: "RegExp", type: "RegExp", source: r.source, flags: r.flags };
}
function required_FromRest(e) {
  return e.map((e) => RequiredResolve(e));
}
function required_FromProperties(e) {
  const t = {};
  for (const r of globalThis.Object.getOwnPropertyNames(e)) t[r] = Discard(e[r], [g]);
  return t;
}
function RequiredResolve(e) {
  return IsIntersect(e)
    ? intersect_Intersect(required_FromRest(e.allOf))
    : IsUnion(e)
      ? union_Union(required_FromRest(e.anyOf))
      : kind_IsObject(e)
        ? T(required_FromProperties(e.properties))
        : T({});
}
function required_Required(e, t = {}) {
  if (IsMappedResult(e)) {
    return RequiredFromMappedResult(e, t);
  } else {
    const r = Discard(e, [p, "$id", "required"]);
    const n = CloneType(RequiredResolve(e), t);
    return { ...r, ...n };
  }
}
function required_from_mapped_result_FromProperties(e, t) {
  const r = {};
  for (const n of globalThis.Object.getOwnPropertyNames(e)) r[n] = required_Required(e[n], t);
  return r;
}
function required_from_mapped_result_FromMappedResult(e, t) {
  return required_from_mapped_result_FromProperties(e.properties, t);
}
function RequiredFromMappedResult(e, t) {
  const r = required_from_mapped_result_FromMappedResult(e, t);
  return MappedResult(r);
}
function RestResolve(e) {
  return IsIntersect(e) ? CloneRest(e.allOf) : IsUnion(e) ? CloneRest(e.anyOf) : IsTuple(e) ? CloneRest(e.items ?? []) : [];
}
function rest_Rest(e) {
  return CloneRest(RestResolve(e));
}
class TransformDecodeBuilder {
  schema;
  constructor(e) {
    this.schema = e;
  }
  Decode(e) {
    return new TransformEncodeBuilder(this.schema, e);
  }
}
class TransformEncodeBuilder {
  schema;
  decode;
  constructor(e, t) {
    this.schema = e;
    this.decode = t;
  }
  EncodeTransform(e, t) {
    const Encode = (r) => t[p].Encode(e(r));
    const Decode = (e) => this.decode(t[p].Decode(e));
    const r = { Encode: Encode, Decode: Decode };
    return { ...t, [p]: r };
  }
  EncodeSchema(e, t) {
    const r = { Decode: this.decode, Encode: e };
    return { ...t, [p]: r };
  }
  Encode(e) {
    const t = CloneType(this.schema);
    return IsTransform(t) ? this.EncodeTransform(e, t) : this.EncodeSchema(e, t);
  }
}
function transform_Transform(e) {
  return new TransformDecodeBuilder(e);
}
function void_Void(e = {}) {
  return { ...e, [h]: "Void", type: "void" };
}
class json_JsonTypeBuilder {
  Strict(e) {
    return Strict(e);
  }
  ReadonlyOptional(e) {
    return ReadonlyOptional(e);
  }
  Readonly(e, t) {
    return Readonly(e, t ?? true);
  }
  Optional(e, t) {
    return Optional(e, t ?? true);
  }
  Any(e = {}) {
    return Any(e);
  }
  Array(e, t = {}) {
    return Array(e, t);
  }
  Boolean(e = {}) {
    return Boolean(e);
  }
  Capitalize(e, t = {}) {
    return Capitalize(e, t);
  }
  Composite(e, t) {
    return Composite(e, t);
  }
  Const(e, t = {}) {
    return Const(e, t);
  }
  Deref(e, t) {
    return Deref(e, t);
  }
  Enum(e, t = {}) {
    return Enum(e, t);
  }
  Exclude(e, t, r = {}) {
    return Exclude(e, t, r);
  }
  Extends(e, t, r, n, o = {}) {
    return Extends(e, t, r, n, o);
  }
  Extract(e, t, r = {}) {
    return Extract(e, t, r);
  }
  Index(e, t, r = {}) {
    return Index(e, t, r);
  }
  Integer(e = {}) {
    return Integer(e);
  }
  Intersect(e, t = {}) {
    return Intersect(e, t);
  }
  KeyOf(e, t = {}) {
    return KeyOf(e, t);
  }
  Literal(e, t = {}) {
    return Literal(e, t);
  }
  Lowercase(e, t = {}) {
    return Lowercase(e, t);
  }
  Mapped(e, t, r = {}) {
    return Mapped(e, t, r);
  }
  Never(e = {}) {
    return Never(e);
  }
  Not(e, t) {
    return Not(e, t);
  }
  Null(e = {}) {
    return Null(e);
  }
  Number(e = {}) {
    return Number(e);
  }
  Object(e, t = {}) {
    return Object(e, t);
  }
  Omit(e, t, r = {}) {
    return Omit(e, t, r);
  }
  Partial(e, t = {}) {
    return Partial(e, t);
  }
  Pick(e, t, r = {}) {
    return Pick(e, t, r);
  }
  Record(e, t, r = {}) {
    return Record(e, t, r);
  }
  Recursive(e, t = {}) {
    return Recursive(e, t);
  }
  Ref(e, t = {}) {
    return Ref(e, t);
  }
  Required(e, t = {}) {
    return Required(e, t);
  }
  Rest(e) {
    return Rest(e);
  }
  String(e = {}) {
    return String(e);
  }
  TemplateLiteral(e, t = {}) {
    return TemplateLiteral(e, t);
  }
  Transform(e) {
    return Transform(e);
  }
  Tuple(e, t = {}) {
    return Tuple(e, t);
  }
  Uncapitalize(e, t = {}) {
    return Uncapitalize(e, t);
  }
  Union(e, t = {}) {
    return Union(e, t);
  }
  Unknown(e = {}) {
    return Unknown(e);
  }
  Unsafe(e = {}) {
    return Unsafe(e);
  }
  Uppercase(e, t = {}) {
    return Uppercase(e, t);
  }
}
function instance_type_InstanceType(e, t = {}) {
  return CloneType(e.returns, t);
}
function return_type_ReturnType(e, t = {}) {
  return CloneType(e.returns, t);
}
function strict_Strict(e) {
  return JSON.parse(JSON.stringify(e));
}
class JavaScriptTypeBuilder extends (null && JsonTypeBuilder) {
  AsyncIterator(e, t = {}) {
    return AsyncIterator(e, t);
  }
  Awaited(e, t = {}) {
    return Awaited(e, t);
  }
  BigInt(e = {}) {
    return BigInt(e);
  }
  ConstructorParameters(e, t = {}) {
    return ConstructorParameters(e, t);
  }
  Constructor(e, t, r) {
    return Constructor(e, t, r);
  }
  Date(e = {}) {
    return Date(e);
  }
  Function(e, t, r) {
    return FunctionType(e, t, r);
  }
  InstanceType(e, t = {}) {
    return InstanceType(e, t);
  }
  Iterator(e, t = {}) {
    return Iterator(e, t);
  }
  Parameters(e, t = {}) {
    return Parameters(e, t);
  }
  Promise(e, t = {}) {
    return Promise(e, t);
  }
  RegExp(e, t = {}) {
    return RegExp(e, t);
  }
  ReturnType(e, t = {}) {
    return ReturnType(e, t);
  }
  Symbol(e) {
    return Symbol(e);
  }
  Undefined(e = {}) {
    return Undefined(e);
  }
  Uint8Array(e = {}) {
    return Uint8Array(e);
  }
  Void(e = {}) {
    return Void(e);
  }
}
const q = o;
var J = __nccwpck_require__(70744);
var W = __nccwpck_require__.n(J);
var $ = __nccwpck_require__(80619);
function thresholdType(e) {
  return q
    .Transform(q.String(e))
    .Decode((e) => {
      const t = W()(e);
      if (t === undefined) {
        throw new TypeBoxError(`Invalid threshold value: [${e}]`);
      }
      return t;
    })
    .Encode((e) => {
      const t = W()(e, { long: true });
      if (t === undefined) {
        throw new TypeBoxError(`Invalid threshold value: [${e}]`);
      }
      return t;
    });
}
const z = ["pull_request.review_requested", "pull_request.ready_for_review", "pull_request_review_comment.created", "issue_comment.created", "push"];
function mapWebhookToEvent(e) {
  const t = new Map([
    ["pull_request.review_requested", "review_requested"],
    ["pull_request.ready_for_review", "ready_for_review"],
    ["pull_request_review_comment.created", "commented"],
    ["issue_comment.created", "commented"],
    ["push", "committed"],
  ]);
  return t.get(e);
}
const Z = q.Union(z.map((e) => q.Literal(e)));
const X = q.Object(
  {
    warning: thresholdType({ default: "3.5 days" }),
    watch: q.Object({ optOut: q.Array(q.String(), { default: [] }) }, { default: {} }),
    disqualification: thresholdType({ default: "7 days" }),
    eventWhitelist: q
      .Transform(q.Array(q.String(), { default: z }))
      .Decode((e) => {
        const t = Object.values(z);
        let r = [];
        for (const n of e) {
          if (!t.includes(n)) {
            throw new TypeBoxError(`Invalid event [${n}] (unknown event)`);
          }
          const e = mapWebhookToEvent(n);
          if (!e) {
            throw new TypeBoxError(`Invalid event [${n}] (unmapped event)`);
          }
          if (!r.includes(e)) {
            r.push(e);
          }
        }
        return r;
      })
      .Encode((e) =>
        e.map((e) => {
          const t = new Map([
            ["review_requested", "pull_request.review_requested"],
            ["ready_for_review", "pull_request.ready_for_review"],
            ["commented", "pull_request_review_comment.created"],
            ["commented", "issue_comment.created"],
            ["committed", "push"],
          ]);
          return t.get(e);
        })
      ),
  },
  { default: {} }
);
const ee = new $.StandardValidator(X);
const te = q.Object({});
const re = new $.StandardValidator(te);
function validateAndDecodeSchemas(e, t) {
  const r = [];
  const n = value_Default(te, t);
  if (!re.test(n)) {
    for (const e of re.errors(n)) {
      r.push(e);
    }
  }
  const o = value_Default(X, e);
  if (!ee.test(o)) {
    for (const e of ee.errors(o)) {
      r.push(e);
    }
  }
  if (r.length) {
    throw { errors: r };
  }
  try {
    const e = Decode(X, o);
    const r = Decode(te, t || {});
    return { decodedEnv: r, decodedSettings: e };
  } catch (e) {
    if (e instanceof TransformDecodeCheckError || e instanceof TransformDecodeError) {
      throw { errors: [e.error] };
    }
    throw e;
  }
}
async function returnDataToKernel(e, t, r, n = "return-data-to-ubiquity-os-kernel") {
  const o = new A.Octokit({ auth: e });
  return o.repos.createDispatchEvent({
    owner: i.context.repo.owner,
    repo: i.context.repo.repo,
    event_type: n,
    client_payload: { state_id: t, output: JSON.stringify(r) },
  });
}
(0, a.config)();
const ne = i.context.payload.inputs;
const { decodedSettings: oe } = validateAndDecodeSchemas(JSON.parse(ne.settings), process.env);
const se = { stateId: ne.stateId, eventName: ne.eventName, authToken: ne.authToken, ref: ne.ref, eventPayload: JSON.parse(ne.eventPayload), settings: oe };
const ie = se;
var ae = {
  reset: "[0m",
  bright: "[1m",
  dim: "[2m",
  underscore: "[4m",
  blink: "[5m",
  reverse: "[7m",
  hidden: "[8m",
  fgBlack: "[30m",
  fgRed: "[31m",
  fgGreen: "[32m",
  fgYellow: "[33m",
  fgBlue: "[34m",
  fgMagenta: "[35m",
  fgCyan: "[36m",
  fgWhite: "[37m",
  bgBlack: "[40m",
  bgRed: "[41m",
  bgGreen: "[42m",
  bgYellow: "[43m",
  bgBlue: "[44m",
  bgMagenta: "[45m",
  bgCyan: "[46m",
  bgWhite: "[47m",
};
var Ae = { FATAL: "fatal", ERROR: "error", INFO: "info", VERBOSE: "verbose", DEBUG: "debug" };
var ce = class {
  constructor() {
    this.ok = this.ok.bind(this);
    this.info = this.info.bind(this);
    this.error = this.error.bind(this);
    this.fatal = this.fatal.bind(this);
    this.debug = this.debug.bind(this);
    this.verbose = this.verbose.bind(this);
  }
  fatal(e, t) {
    this._logWithStack(Ae.FATAL, e, t);
  }
  error(e, t) {
    this._logWithStack(Ae.ERROR, e, t);
  }
  ok(e, t) {
    this._logWithStack("ok", e, t);
  }
  info(e, t) {
    this._logWithStack(Ae.INFO, e, t);
  }
  debug(e, t) {
    this._logWithStack(Ae.DEBUG, e, t);
  }
  verbose(e, t) {
    this._logWithStack(Ae.VERBOSE, e, t);
  }
  _logWithStack(e, t, r) {
    this._log(e, t);
    if (typeof r === "string") {
      this._log(e, r);
      return;
    }
    if (r) {
      const t = r;
      let n = t?.error?.stack || t?.stack;
      if (!n) {
        const e = new Error().stack?.split("\n");
        if (e) {
          e.splice(0, 4);
          n = e.filter((e) => e.includes(".ts:")).join("\n");
        }
      }
      const o = { ...t };
      delete o.message;
      delete o.name;
      delete o.stack;
      if (!this._isEmpty(o)) {
        this._log(e, o);
      }
      if (typeof n == "string") {
        const t = this._formatStackTrace(n, 1);
        const r = this._colorizeText(t, ae.dim);
        this._log(e, r);
      } else if (n) {
        const t = this._formatStackTrace(n.join("\n"), 1);
        const r = this._colorizeText(t, ae.dim);
        this._log(e, r);
      } else {
        throw new Error("Stack is null");
      }
    }
  }
  _colorizeText(e, t) {
    if (!t) {
      throw new Error(`Invalid color: ${t}`);
    }
    return t.concat(e).concat(ae.reset);
  }
  _formatStackTrace(e, t = 0, r = "") {
    const n = e.split("\n");
    for (let e = 0; e < t; e++) {
      n.shift();
    }
    return n.map((e) => `${r}${e.replace(/\s*at\s*/, "  ↳  ")}`).join("\n");
  }
  _isEmpty(e) {
    return !Reflect.ownKeys(e).some((t) => typeof e[String(t)] !== "function");
  }
  _log(e, t) {
    const r = { fatal: "×", ok: "✓", error: "⚠", info: "›", debug: "››", verbose: "💬" };
    const n = r[e];
    const o = typeof t === "string" ? t : JSON.stringify(t, null, 2);
    const s = o.split("\n");
    const i = s
      .map((e, t) => {
        const r = t === 0 ? `\t${n}` : `\t${" ".repeat(n.length)}`;
        return `${r} ${e}`;
      })
      .join("\n");
    const a = i;
    const A = {
      fatal: ["error", ae.fgRed],
      ok: ["log", ae.fgGreen],
      error: ["warn", ae.fgYellow],
      info: ["info", ae.dim],
      debug: ["debug", ae.fgMagenta],
      verbose: ["debug", ae.dim],
    };
    const c = console[A[e][0]];
    if (typeof c === "function" && a.length > 12) {
      c(this._colorizeText(a, A[e][1]));
    } else if (a.length <= 12) {
      return;
    } else {
      throw new Error(a);
    }
  }
};
var ue = class {
  logMessage;
  metadata;
  constructor(e, t) {
    this.logMessage = e;
    this.metadata = t;
  }
};
var le = class _Logs {
  _maxLevel = -1;
  static console;
  _log({ level: e, consoleLog: t, logMessage: r, metadata: n, type: o }) {
    if (this._getNumericLevel(e) <= this._maxLevel) {
      t(r, n);
    }
    return new ue({ raw: r, diff: this._diffColorCommentMessage(o, r), type: o, level: e }, n);
  }
  _addDiagnosticInformation(e) {
    if (!e) {
      e = {};
    } else if (typeof e !== "object") {
      e = { message: e };
    }
    const t = new Error().stack?.split("\n") || [];
    if (t.length > 3) {
      const r = t[3];
      const n = r.match(/at (\S+)/);
      if (n) {
        e.caller = n[1];
      }
    }
    return e;
  }
  ok(e, t) {
    t = this._addDiagnosticInformation(t);
    return this._log({ level: Ae.INFO, consoleLog: _Logs.console.ok, logMessage: e, metadata: t, type: "ok" });
  }
  info(e, t) {
    t = this._addDiagnosticInformation(t);
    return this._log({ level: Ae.INFO, consoleLog: _Logs.console.info, logMessage: e, metadata: t, type: "info" });
  }
  error(e, t) {
    t = this._addDiagnosticInformation(t);
    return this._log({ level: Ae.ERROR, consoleLog: _Logs.console.error, logMessage: e, metadata: t, type: "error" });
  }
  debug(e, t) {
    t = this._addDiagnosticInformation(t);
    return this._log({ level: Ae.DEBUG, consoleLog: _Logs.console.debug, logMessage: e, metadata: t, type: "debug" });
  }
  fatal(e, t) {
    if (!t) {
      t = _Logs.convertErrorsIntoObjects(new Error(e));
      const r = t.stack;
      r.splice(1, 1);
      t.stack = r;
    }
    if (t instanceof Error) {
      t = _Logs.convertErrorsIntoObjects(t);
      const e = t.stack;
      e.splice(1, 1);
      t.stack = e;
    }
    t = this._addDiagnosticInformation(t);
    return this._log({ level: Ae.FATAL, consoleLog: _Logs.console.fatal, logMessage: e, metadata: t, type: "fatal" });
  }
  verbose(e, t) {
    t = this._addDiagnosticInformation(t);
    return this._log({ level: Ae.VERBOSE, consoleLog: _Logs.console.verbose, logMessage: e, metadata: t, type: "verbose" });
  }
  constructor(e) {
    this._maxLevel = this._getNumericLevel(e);
    _Logs.console = new ce();
  }
  _diffColorCommentMessage(e, t) {
    const r = { fatal: "-", ok: "+", error: "!", info: "#", debug: "@@@@" };
    const n = r[e];
    if (n) {
      t = t
        .trim()
        .split("\n")
        .map((e) => `${n} ${e}`)
        .join("\n");
    } else if (e === "debug") {
      t = t
        .split("\n")
        .map((e) => `@@ ${e} @@`)
        .join("\n");
    } else {
      t = t
        .split("\n")
        .map((e) => `# ${e}`)
        .join("\n");
    }
    const o = "```diff";
    const s = "```";
    return [o, t, s].join("\n");
  }
  _getNumericLevel(e) {
    switch (e) {
      case Ae.FATAL:
        return 0;
      case Ae.ERROR:
        return 1;
      case Ae.INFO:
        return 2;
      case Ae.VERBOSE:
        return 4;
      case Ae.DEBUG:
        return 5;
      default:
        return -1;
    }
  }
  static convertErrorsIntoObjects(e) {
    if (e instanceof Error) {
      return { message: e.message, name: e.name, stack: e.stack ? e.stack.split("\n") : null };
    } else if (typeof e === "object" && e !== null) {
      const t = Object.keys(e);
      t.forEach((t) => {
        e[t] = this.convertErrorsIntoObjects(e[t]);
      });
    }
    return e;
  }
};
var pe = /\x1b\[\d+m|\s/g;
function cleanLogs(e) {
  const t = e.mock.calls.map((e) => e.map((e) => e?.toString()).join(" "));
  return t.flat().map((e) => cleanLogString(e));
}
function cleanLogString(e) {
  return e.replaceAll(pe, "").replaceAll(/\n/g, "").replaceAll(/\r/g, "").replaceAll(/\t/g, "").trim();
}
function cleanSpyLogs(e) {
  return cleanLogs(e);
}
async function getWatchedRepos(e) {
  const {
    config: {
      watch: { optOut: t },
    },
  } = e;
  const r = new Set();
  const n = e.payload.repository.owner?.login;
  if (!n) {
    throw new Error("No owner found in the payload");
  }
  const o = await getReposForOrg(e, n);
  o.forEach((e) => r.add(e.name.toLowerCase()));
  for (const e of t) {
    r.forEach((t) => (t.includes(e) ? r.delete(t) : null));
  }
  return Array.from(r)
    .map((e) => o.find((t) => t.name.toLowerCase() === e))
    .filter((e) => e !== undefined);
}
async function getReposForOrg(e, t) {
  const { octokit: r } = e;
  try {
    return await r.paginate(r.rest.repos.listForOrg, { org: t, per_page: 100 });
  } catch (e) {
    throw new Error(`Error getting repositories for org ${t}: ` + JSON.stringify(e));
  }
}
class LuxonError extends Error {}
class InvalidDateTimeError extends LuxonError {
  constructor(e) {
    super(`Invalid DateTime: ${e.toMessage()}`);
  }
}
class InvalidIntervalError extends LuxonError {
  constructor(e) {
    super(`Invalid Interval: ${e.toMessage()}`);
  }
}
class InvalidDurationError extends LuxonError {
  constructor(e) {
    super(`Invalid Duration: ${e.toMessage()}`);
  }
}
class ConflictingSpecificationError extends LuxonError {}
class InvalidUnitError extends LuxonError {
  constructor(e) {
    super(`Invalid unit ${e}`);
  }
}
class InvalidArgumentError extends LuxonError {}
class ZoneIsAbstractError extends LuxonError {
  constructor() {
    super("Zone is an abstract class");
  }
}
const de = "numeric",
  fe = "short",
  ge = "long";
const me = { year: de, month: de, day: de };
const he = { year: de, month: fe, day: de };
const Ee = { year: de, month: fe, day: de, weekday: fe };
const Ie = { year: de, month: ge, day: de };
const ye = { year: de, month: ge, day: de, weekday: ge };
const Ce = { hour: de, minute: de };
const be = { hour: de, minute: de, second: de };
const Qe = { hour: de, minute: de, second: de, timeZoneName: fe };
const Be = { hour: de, minute: de, second: de, timeZoneName: ge };
const Te = { hour: de, minute: de, hourCycle: "h23" };
const ve = { hour: de, minute: de, second: de, hourCycle: "h23" };
const we = { hour: de, minute: de, second: de, hourCycle: "h23", timeZoneName: fe };
const _e = { hour: de, minute: de, second: de, hourCycle: "h23", timeZoneName: ge };
const Re = { year: de, month: de, day: de, hour: de, minute: de };
const Oe = { year: de, month: de, day: de, hour: de, minute: de, second: de };
const Fe = { year: de, month: fe, day: de, hour: de, minute: de };
const De = { year: de, month: fe, day: de, hour: de, minute: de, second: de };
const ke = { year: de, month: fe, day: de, weekday: fe, hour: de, minute: de };
const Se = { year: de, month: ge, day: de, hour: de, minute: de, timeZoneName: fe };
const Ne = { year: de, month: ge, day: de, hour: de, minute: de, second: de, timeZoneName: fe };
const Pe = { year: de, month: ge, day: de, weekday: ge, hour: de, minute: de, timeZoneName: ge };
const Le = { year: de, month: ge, day: de, weekday: ge, hour: de, minute: de, second: de, timeZoneName: ge };
class Zone {
  get type() {
    throw new ZoneIsAbstractError();
  }
  get name() {
    throw new ZoneIsAbstractError();
  }
  get ianaName() {
    return this.name;
  }
  get isUniversal() {
    throw new ZoneIsAbstractError();
  }
  offsetName(e, t) {
    throw new ZoneIsAbstractError();
  }
  formatOffset(e, t) {
    throw new ZoneIsAbstractError();
  }
  offset(e) {
    throw new ZoneIsAbstractError();
  }
  equals(e) {
    throw new ZoneIsAbstractError();
  }
  get isValid() {
    throw new ZoneIsAbstractError();
  }
}
let Ue = null;
class SystemZone extends Zone {
  static get instance() {
    if (Ue === null) {
      Ue = new SystemZone();
    }
    return Ue;
  }
  get type() {
    return "system";
  }
  get name() {
    return new Intl.DateTimeFormat().resolvedOptions().timeZone;
  }
  get isUniversal() {
    return false;
  }
  offsetName(e, { format: t, locale: r }) {
    return parseZoneInfo(e, t, r);
  }
  formatOffset(e, t) {
    return formatOffset(this.offset(e), t);
  }
  offset(e) {
    return -new Date(e).getTimezoneOffset();
  }
  equals(e) {
    return e.type === "system";
  }
  get isValid() {
    return true;
  }
}
let Me = {};
function makeDTF(e) {
  if (!Me[e]) {
    Me[e] = new Intl.DateTimeFormat("en-US", {
      hour12: false,
      timeZone: e,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      era: "short",
    });
  }
  return Me[e];
}
const Ge = { year: 0, month: 1, day: 2, era: 3, hour: 4, minute: 5, second: 6 };
function hackyOffset(e, t) {
  const r = e.format(t).replace(/\u200E/g, ""),
    n = /(\d+)\/(\d+)\/(\d+) (AD|BC),? (\d+):(\d+):(\d+)/.exec(r),
    [, o, s, i, a, A, c, u] = n;
  return [i, o, s, a, A, c, u];
}
function partsOffset(e, t) {
  const r = e.formatToParts(t);
  const n = [];
  for (let e = 0; e < r.length; e++) {
    const { type: t, value: o } = r[e];
    const s = Ge[t];
    if (t === "era") {
      n[s] = o;
    } else if (!isUndefined(s)) {
      n[s] = parseInt(o, 10);
    }
  }
  return n;
}
let xe = {};
class IANAZone extends Zone {
  static create(e) {
    if (!xe[e]) {
      xe[e] = new IANAZone(e);
    }
    return xe[e];
  }
  static resetCache() {
    xe = {};
    Me = {};
  }
  static isValidSpecifier(e) {
    return this.isValidZone(e);
  }
  static isValidZone(e) {
    if (!e) {
      return false;
    }
    try {
      new Intl.DateTimeFormat("en-US", { timeZone: e }).format();
      return true;
    } catch (e) {
      return false;
    }
  }
  constructor(e) {
    super();
    this.zoneName = e;
    this.valid = IANAZone.isValidZone(e);
  }
  get type() {
    return "iana";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName(e, { format: t, locale: r }) {
    return parseZoneInfo(e, t, r, this.name);
  }
  formatOffset(e, t) {
    return formatOffset(this.offset(e), t);
  }
  offset(e) {
    const t = new Date(e);
    if (isNaN(t)) return NaN;
    const r = makeDTF(this.name);
    let [n, o, s, i, a, A, c] = r.formatToParts ? partsOffset(r, t) : hackyOffset(r, t);
    if (i === "BC") {
      n = -Math.abs(n) + 1;
    }
    const u = a === 24 ? 0 : a;
    const l = objToLocalTS({ year: n, month: o, day: s, hour: u, minute: A, second: c, millisecond: 0 });
    let p = +t;
    const d = p % 1e3;
    p -= d >= 0 ? d : 1e3 + d;
    return (l - p) / (60 * 1e3);
  }
  equals(e) {
    return e.type === "iana" && e.name === this.name;
  }
  get isValid() {
    return this.valid;
  }
}
let je = {};
function getCachedLF(e, t = {}) {
  const r = JSON.stringify([e, t]);
  let n = je[r];
  if (!n) {
    n = new Intl.ListFormat(e, t);
    je[r] = n;
  }
  return n;
}
let Ve = {};
function getCachedDTF(e, t = {}) {
  const r = JSON.stringify([e, t]);
  let n = Ve[r];
  if (!n) {
    n = new Intl.DateTimeFormat(e, t);
    Ve[r] = n;
  }
  return n;
}
let He = {};
function getCachedINF(e, t = {}) {
  const r = JSON.stringify([e, t]);
  let n = He[r];
  if (!n) {
    n = new Intl.NumberFormat(e, t);
    He[r] = n;
  }
  return n;
}
let Ye = {};
function getCachedRTF(e, t = {}) {
  const { base: r, ...n } = t;
  const o = JSON.stringify([e, n]);
  let s = Ye[o];
  if (!s) {
    s = new Intl.RelativeTimeFormat(e, t);
    Ye[o] = s;
  }
  return s;
}
let Ke = null;
function systemLocale() {
  if (Ke) {
    return Ke;
  } else {
    Ke = new Intl.DateTimeFormat().resolvedOptions().locale;
    return Ke;
  }
}
let qe = {};
function getCachedWeekInfo(e) {
  let t = qe[e];
  if (!t) {
    const r = new Intl.Locale(e);
    t = "getWeekInfo" in r ? r.getWeekInfo() : r.weekInfo;
    qe[e] = t;
  }
  return t;
}
function parseLocaleString(e) {
  const t = e.indexOf("-x-");
  if (t !== -1) {
    e = e.substring(0, t);
  }
  const r = e.indexOf("-u-");
  if (r === -1) {
    return [e];
  } else {
    let t;
    let n;
    try {
      t = getCachedDTF(e).resolvedOptions();
      n = e;
    } catch (o) {
      const s = e.substring(0, r);
      t = getCachedDTF(s).resolvedOptions();
      n = s;
    }
    const { numberingSystem: o, calendar: s } = t;
    return [n, o, s];
  }
}
function intlConfigString(e, t, r) {
  if (r || t) {
    if (!e.includes("-u-")) {
      e += "-u";
    }
    if (r) {
      e += `-ca-${r}`;
    }
    if (t) {
      e += `-nu-${t}`;
    }
    return e;
  } else {
    return e;
  }
}
function mapMonths(e) {
  const t = [];
  for (let r = 1; r <= 12; r++) {
    const n = DateTime.utc(2009, r, 1);
    t.push(e(n));
  }
  return t;
}
function mapWeekdays(e) {
  const t = [];
  for (let r = 1; r <= 7; r++) {
    const n = DateTime.utc(2016, 11, 13 + r);
    t.push(e(n));
  }
  return t;
}
function listStuff(e, t, r, n) {
  const o = e.listingMode();
  if (o === "error") {
    return null;
  } else if (o === "en") {
    return r(t);
  } else {
    return n(t);
  }
}
function supportsFastNumbers(e) {
  if (e.numberingSystem && e.numberingSystem !== "latn") {
    return false;
  } else {
    return (
      e.numberingSystem === "latn" || !e.locale || e.locale.startsWith("en") || new Intl.DateTimeFormat(e.intl).resolvedOptions().numberingSystem === "latn"
    );
  }
}
class PolyNumberFormatter {
  constructor(e, t, r) {
    this.padTo = r.padTo || 0;
    this.floor = r.floor || false;
    const { padTo: n, floor: o, ...s } = r;
    if (!t || Object.keys(s).length > 0) {
      const t = { useGrouping: false, ...r };
      if (r.padTo > 0) t.minimumIntegerDigits = r.padTo;
      this.inf = getCachedINF(e, t);
    }
  }
  format(e) {
    if (this.inf) {
      const t = this.floor ? Math.floor(e) : e;
      return this.inf.format(t);
    } else {
      const t = this.floor ? Math.floor(e) : roundTo(e, 3);
      return padStart(t, this.padTo);
    }
  }
}
class PolyDateFormatter {
  constructor(e, t, r) {
    this.opts = r;
    this.originalZone = undefined;
    let n = undefined;
    if (this.opts.timeZone) {
      this.dt = e;
    } else if (e.zone.type === "fixed") {
      const t = -1 * (e.offset / 60);
      const r = t >= 0 ? `Etc/GMT+${t}` : `Etc/GMT${t}`;
      if (e.offset !== 0 && IANAZone.create(r).valid) {
        n = r;
        this.dt = e;
      } else {
        n = "UTC";
        this.dt = e.offset === 0 ? e : e.setZone("UTC").plus({ minutes: e.offset });
        this.originalZone = e.zone;
      }
    } else if (e.zone.type === "system") {
      this.dt = e;
    } else if (e.zone.type === "iana") {
      this.dt = e;
      n = e.zone.name;
    } else {
      n = "UTC";
      this.dt = e.setZone("UTC").plus({ minutes: e.offset });
      this.originalZone = e.zone;
    }
    const o = { ...this.opts };
    o.timeZone = o.timeZone || n;
    this.dtf = getCachedDTF(t, o);
  }
  format() {
    if (this.originalZone) {
      return this.formatToParts()
        .map(({ value: e }) => e)
        .join("");
    }
    return this.dtf.format(this.dt.toJSDate());
  }
  formatToParts() {
    const e = this.dtf.formatToParts(this.dt.toJSDate());
    if (this.originalZone) {
      return e.map((e) => {
        if (e.type === "timeZoneName") {
          const t = this.originalZone.offsetName(this.dt.ts, { locale: this.dt.locale, format: this.opts.timeZoneName });
          return { ...e, value: t };
        } else {
          return e;
        }
      });
    }
    return e;
  }
  resolvedOptions() {
    return this.dtf.resolvedOptions();
  }
}
class PolyRelFormatter {
  constructor(e, t, r) {
    this.opts = { style: "long", ...r };
    if (!t && hasRelative()) {
      this.rtf = getCachedRTF(e, r);
    }
  }
  format(e, t) {
    if (this.rtf) {
      return this.rtf.format(e, t);
    } else {
      return formatRelativeTime(t, e, this.opts.numeric, this.opts.style !== "long");
    }
  }
  formatToParts(e, t) {
    if (this.rtf) {
      return this.rtf.formatToParts(e, t);
    } else {
      return [];
    }
  }
}
const Je = { firstDay: 1, minimalDays: 4, weekend: [6, 7] };
class Locale {
  static fromOpts(e) {
    return Locale.create(e.locale, e.numberingSystem, e.outputCalendar, e.weekSettings, e.defaultToEN);
  }
  static create(e, t, r, n, o = false) {
    const s = e || Settings.defaultLocale;
    const i = s || (o ? "en-US" : systemLocale());
    const a = t || Settings.defaultNumberingSystem;
    const A = r || Settings.defaultOutputCalendar;
    const c = validateWeekSettings(n) || Settings.defaultWeekSettings;
    return new Locale(i, a, A, c, s);
  }
  static resetCache() {
    Ke = null;
    Ve = {};
    He = {};
    Ye = {};
  }
  static fromObject({ locale: e, numberingSystem: t, outputCalendar: r, weekSettings: n } = {}) {
    return Locale.create(e, t, r, n);
  }
  constructor(e, t, r, n, o) {
    const [s, i, a] = parseLocaleString(e);
    this.locale = s;
    this.numberingSystem = t || i || null;
    this.outputCalendar = r || a || null;
    this.weekSettings = n;
    this.intl = intlConfigString(this.locale, this.numberingSystem, this.outputCalendar);
    this.weekdaysCache = { format: {}, standalone: {} };
    this.monthsCache = { format: {}, standalone: {} };
    this.meridiemCache = null;
    this.eraCache = {};
    this.specifiedLocale = o;
    this.fastNumbersCached = null;
  }
  get fastNumbers() {
    if (this.fastNumbersCached == null) {
      this.fastNumbersCached = supportsFastNumbers(this);
    }
    return this.fastNumbersCached;
  }
  listingMode() {
    const e = this.isEnglish();
    const t = (this.numberingSystem === null || this.numberingSystem === "latn") && (this.outputCalendar === null || this.outputCalendar === "gregory");
    return e && t ? "en" : "intl";
  }
  clone(e) {
    if (!e || Object.getOwnPropertyNames(e).length === 0) {
      return this;
    } else {
      return Locale.create(
        e.locale || this.specifiedLocale,
        e.numberingSystem || this.numberingSystem,
        e.outputCalendar || this.outputCalendar,
        validateWeekSettings(e.weekSettings) || this.weekSettings,
        e.defaultToEN || false
      );
    }
  }
  redefaultToEN(e = {}) {
    return this.clone({ ...e, defaultToEN: true });
  }
  redefaultToSystem(e = {}) {
    return this.clone({ ...e, defaultToEN: false });
  }
  months(e, t = false) {
    return listStuff(this, e, months, () => {
      const r = t ? { month: e, day: "numeric" } : { month: e },
        n = t ? "format" : "standalone";
      if (!this.monthsCache[n][e]) {
        this.monthsCache[n][e] = mapMonths((e) => this.extract(e, r, "month"));
      }
      return this.monthsCache[n][e];
    });
  }
  weekdays(e, t = false) {
    return listStuff(this, e, weekdays, () => {
      const r = t ? { weekday: e, year: "numeric", month: "long", day: "numeric" } : { weekday: e },
        n = t ? "format" : "standalone";
      if (!this.weekdaysCache[n][e]) {
        this.weekdaysCache[n][e] = mapWeekdays((e) => this.extract(e, r, "weekday"));
      }
      return this.weekdaysCache[n][e];
    });
  }
  meridiems() {
    return listStuff(
      this,
      undefined,
      () => lt,
      () => {
        if (!this.meridiemCache) {
          const e = { hour: "numeric", hourCycle: "h12" };
          this.meridiemCache = [DateTime.utc(2016, 11, 13, 9), DateTime.utc(2016, 11, 13, 19)].map((t) => this.extract(t, e, "dayperiod"));
        }
        return this.meridiemCache;
      }
    );
  }
  eras(e) {
    return listStuff(this, e, eras, () => {
      const t = { era: e };
      if (!this.eraCache[e]) {
        this.eraCache[e] = [DateTime.utc(-40, 1, 1), DateTime.utc(2017, 1, 1)].map((e) => this.extract(e, t, "era"));
      }
      return this.eraCache[e];
    });
  }
  extract(e, t, r) {
    const n = this.dtFormatter(e, t),
      o = n.formatToParts(),
      s = o.find((e) => e.type.toLowerCase() === r);
    return s ? s.value : null;
  }
  numberFormatter(e = {}) {
    return new PolyNumberFormatter(this.intl, e.forceSimple || this.fastNumbers, e);
  }
  dtFormatter(e, t = {}) {
    return new PolyDateFormatter(e, this.intl, t);
  }
  relFormatter(e = {}) {
    return new PolyRelFormatter(this.intl, this.isEnglish(), e);
  }
  listFormatter(e = {}) {
    return getCachedLF(this.intl, e);
  }
  isEnglish() {
    return this.locale === "en" || this.locale.toLowerCase() === "en-us" || new Intl.DateTimeFormat(this.intl).resolvedOptions().locale.startsWith("en-us");
  }
  getWeekSettings() {
    if (this.weekSettings) {
      return this.weekSettings;
    } else if (!hasLocaleWeekInfo()) {
      return Je;
    } else {
      return getCachedWeekInfo(this.locale);
    }
  }
  getStartOfWeek() {
    return this.getWeekSettings().firstDay;
  }
  getMinDaysInFirstWeek() {
    return this.getWeekSettings().minimalDays;
  }
  getWeekendDays() {
    return this.getWeekSettings().weekend;
  }
  equals(e) {
    return this.locale === e.locale && this.numberingSystem === e.numberingSystem && this.outputCalendar === e.outputCalendar;
  }
}
let We = null;
class FixedOffsetZone extends Zone {
  static get utcInstance() {
    if (We === null) {
      We = new FixedOffsetZone(0);
    }
    return We;
  }
  static instance(e) {
    return e === 0 ? FixedOffsetZone.utcInstance : new FixedOffsetZone(e);
  }
  static parseSpecifier(e) {
    if (e) {
      const t = e.match(/^utc(?:([+-]\d{1,2})(?::(\d{2}))?)?$/i);
      if (t) {
        return new FixedOffsetZone(signedOffset(t[1], t[2]));
      }
    }
    return null;
  }
  constructor(e) {
    super();
    this.fixed = e;
  }
  get type() {
    return "fixed";
  }
  get name() {
    return this.fixed === 0 ? "UTC" : `UTC${formatOffset(this.fixed, "narrow")}`;
  }
  get ianaName() {
    if (this.fixed === 0) {
      return "Etc/UTC";
    } else {
      return `Etc/GMT${formatOffset(-this.fixed, "narrow")}`;
    }
  }
  offsetName() {
    return this.name;
  }
  formatOffset(e, t) {
    return formatOffset(this.fixed, t);
  }
  get isUniversal() {
    return true;
  }
  offset() {
    return this.fixed;
  }
  equals(e) {
    return e.type === "fixed" && e.fixed === this.fixed;
  }
  get isValid() {
    return true;
  }
}
class InvalidZone extends Zone {
  constructor(e) {
    super();
    this.zoneName = e;
  }
  get type() {
    return "invalid";
  }
  get name() {
    return this.zoneName;
  }
  get isUniversal() {
    return false;
  }
  offsetName() {
    return null;
  }
  formatOffset() {
    return "";
  }
  offset() {
    return NaN;
  }
  equals() {
    return false;
  }
  get isValid() {
    return false;
  }
}
function normalizeZone(e, t) {
  let r;
  if (isUndefined(e) || e === null) {
    return t;
  } else if (e instanceof Zone) {
    return e;
  } else if (isString(e)) {
    const r = e.toLowerCase();
    if (r === "default") return t;
    else if (r === "local" || r === "system") return SystemZone.instance;
    else if (r === "utc" || r === "gmt") return FixedOffsetZone.utcInstance;
    else return FixedOffsetZone.parseSpecifier(r) || IANAZone.create(e);
  } else if (isNumber(e)) {
    return FixedOffsetZone.instance(e);
  } else if (typeof e === "object" && "offset" in e && typeof e.offset === "function") {
    return e;
  } else {
    return new InvalidZone(e);
  }
}
let now = () => Date.now(),
  $e = "system",
  ze = null,
  Ze = null,
  Xe = null,
  et = 60,
  tt,
  rt = null;
class Settings {
  static get now() {
    return now;
  }
  static set now(e) {
    now = e;
  }
  static set defaultZone(e) {
    $e = e;
  }
  static get defaultZone() {
    return normalizeZone($e, SystemZone.instance);
  }
  static get defaultLocale() {
    return ze;
  }
  static set defaultLocale(e) {
    ze = e;
  }
  static get defaultNumberingSystem() {
    return Ze;
  }
  static set defaultNumberingSystem(e) {
    Ze = e;
  }
  static get defaultOutputCalendar() {
    return Xe;
  }
  static set defaultOutputCalendar(e) {
    Xe = e;
  }
  static get defaultWeekSettings() {
    return rt;
  }
  static set defaultWeekSettings(e) {
    rt = validateWeekSettings(e);
  }
  static get twoDigitCutoffYear() {
    return et;
  }
  static set twoDigitCutoffYear(e) {
    et = e % 100;
  }
  static get throwOnInvalid() {
    return tt;
  }
  static set throwOnInvalid(e) {
    tt = e;
  }
  static resetCaches() {
    Locale.resetCache();
    IANAZone.resetCache();
  }
}
class Invalid {
  constructor(e, t) {
    this.reason = e;
    this.explanation = t;
  }
  toMessage() {
    if (this.explanation) {
      return `${this.reason}: ${this.explanation}`;
    } else {
      return this.reason;
    }
  }
}
const nt = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334],
  ot = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
function unitOutOfRange(e, t) {
  return new Invalid("unit out of range", `you specified ${t} (of type ${typeof t}) as a ${e}, which is invalid`);
}
function dayOfWeek(e, t, r) {
  const n = new Date(Date.UTC(e, t - 1, r));
  if (e < 100 && e >= 0) {
    n.setUTCFullYear(n.getUTCFullYear() - 1900);
  }
  const o = n.getUTCDay();
  return o === 0 ? 7 : o;
}
function computeOrdinal(e, t, r) {
  return r + (isLeapYear(e) ? ot : nt)[t - 1];
}
function uncomputeOrdinal(e, t) {
  const r = isLeapYear(e) ? ot : nt,
    n = r.findIndex((e) => e < t),
    o = t - r[n];
  return { month: n + 1, day: o };
}
function isoWeekdayToLocal(e, t) {
  return ((e - t + 7) % 7) + 1;
}
function gregorianToWeek(e, t = 4, r = 1) {
  const { year: n, month: o, day: s } = e,
    i = computeOrdinal(n, o, s),
    a = isoWeekdayToLocal(dayOfWeek(n, o, s), r);
  let A = Math.floor((i - a + 14 - t) / 7),
    c;
  if (A < 1) {
    c = n - 1;
    A = weeksInWeekYear(c, t, r);
  } else if (A > weeksInWeekYear(n, t, r)) {
    c = n + 1;
    A = 1;
  } else {
    c = n;
  }
  return { weekYear: c, weekNumber: A, weekday: a, ...timeObject(e) };
}
function weekToGregorian(e, t = 4, r = 1) {
  const { weekYear: n, weekNumber: o, weekday: s } = e,
    i = isoWeekdayToLocal(dayOfWeek(n, 1, t), r),
    a = daysInYear(n);
  let A = o * 7 + s - i - 7 + t,
    c;
  if (A < 1) {
    c = n - 1;
    A += daysInYear(c);
  } else if (A > a) {
    c = n + 1;
    A -= daysInYear(n);
  } else {
    c = n;
  }
  const { month: u, day: l } = uncomputeOrdinal(c, A);
  return { year: c, month: u, day: l, ...timeObject(e) };
}
function gregorianToOrdinal(e) {
  const { year: t, month: r, day: n } = e;
  const o = computeOrdinal(t, r, n);
  return { year: t, ordinal: o, ...timeObject(e) };
}
function ordinalToGregorian(e) {
  const { year: t, ordinal: r } = e;
  const { month: n, day: o } = uncomputeOrdinal(t, r);
  return { year: t, month: n, day: o, ...timeObject(e) };
}
function usesLocalWeekValues(e, t) {
  const r = !isUndefined(e.localWeekday) || !isUndefined(e.localWeekNumber) || !isUndefined(e.localWeekYear);
  if (r) {
    const r = !isUndefined(e.weekday) || !isUndefined(e.weekNumber) || !isUndefined(e.weekYear);
    if (r) {
      throw new ConflictingSpecificationError("Cannot mix locale-based week fields with ISO-based week fields");
    }
    if (!isUndefined(e.localWeekday)) e.weekday = e.localWeekday;
    if (!isUndefined(e.localWeekNumber)) e.weekNumber = e.localWeekNumber;
    if (!isUndefined(e.localWeekYear)) e.weekYear = e.localWeekYear;
    delete e.localWeekday;
    delete e.localWeekNumber;
    delete e.localWeekYear;
    return { minDaysInFirstWeek: t.getMinDaysInFirstWeek(), startOfWeek: t.getStartOfWeek() };
  } else {
    return { minDaysInFirstWeek: 4, startOfWeek: 1 };
  }
}
function hasInvalidWeekData(e, t = 4, r = 1) {
  const n = isInteger(e.weekYear),
    o = integerBetween(e.weekNumber, 1, weeksInWeekYear(e.weekYear, t, r)),
    s = integerBetween(e.weekday, 1, 7);
  if (!n) {
    return unitOutOfRange("weekYear", e.weekYear);
  } else if (!o) {
    return unitOutOfRange("week", e.weekNumber);
  } else if (!s) {
    return unitOutOfRange("weekday", e.weekday);
  } else return false;
}
function hasInvalidOrdinalData(e) {
  const t = isInteger(e.year),
    r = integerBetween(e.ordinal, 1, daysInYear(e.year));
  if (!t) {
    return unitOutOfRange("year", e.year);
  } else if (!r) {
    return unitOutOfRange("ordinal", e.ordinal);
  } else return false;
}
function hasInvalidGregorianData(e) {
  const t = isInteger(e.year),
    r = integerBetween(e.month, 1, 12),
    n = integerBetween(e.day, 1, daysInMonth(e.year, e.month));
  if (!t) {
    return unitOutOfRange("year", e.year);
  } else if (!r) {
    return unitOutOfRange("month", e.month);
  } else if (!n) {
    return unitOutOfRange("day", e.day);
  } else return false;
}
function hasInvalidTimeData(e) {
  const { hour: t, minute: r, second: n, millisecond: o } = e;
  const s = integerBetween(t, 0, 23) || (t === 24 && r === 0 && n === 0 && o === 0),
    i = integerBetween(r, 0, 59),
    a = integerBetween(n, 0, 59),
    A = integerBetween(o, 0, 999);
  if (!s) {
    return unitOutOfRange("hour", t);
  } else if (!i) {
    return unitOutOfRange("minute", r);
  } else if (!a) {
    return unitOutOfRange("second", n);
  } else if (!A) {
    return unitOutOfRange("millisecond", o);
  } else return false;
}
function isUndefined(e) {
  return typeof e === "undefined";
}
function isNumber(e) {
  return typeof e === "number";
}
function isInteger(e) {
  return typeof e === "number" && e % 1 === 0;
}
function isString(e) {
  return typeof e === "string";
}
function isDate(e) {
  return Object.prototype.toString.call(e) === "[object Date]";
}
function hasRelative() {
  try {
    return typeof Intl !== "undefined" && !!Intl.RelativeTimeFormat;
  } catch (e) {
    return false;
  }
}
function hasLocaleWeekInfo() {
  try {
    return typeof Intl !== "undefined" && !!Intl.Locale && ("weekInfo" in Intl.Locale.prototype || "getWeekInfo" in Intl.Locale.prototype);
  } catch (e) {
    return false;
  }
}
function maybeArray(e) {
  return Array.isArray(e) ? e : [e];
}
function bestBy(e, t, r) {
  if (e.length === 0) {
    return undefined;
  }
  return e.reduce((e, n) => {
    const o = [t(n), n];
    if (!e) {
      return o;
    } else if (r(e[0], o[0]) === e[0]) {
      return e;
    } else {
      return o;
    }
  }, null)[1];
}
function util_pick(e, t) {
  return t.reduce((t, r) => {
    t[r] = e[r];
    return t;
  }, {});
}
function util_hasOwnProperty(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function validateWeekSettings(e) {
  if (e == null) {
    return null;
  } else if (typeof e !== "object") {
    throw new InvalidArgumentError("Week settings must be an object");
  } else {
    if (
      !integerBetween(e.firstDay, 1, 7) ||
      !integerBetween(e.minimalDays, 1, 7) ||
      !Array.isArray(e.weekend) ||
      e.weekend.some((e) => !integerBetween(e, 1, 7))
    ) {
      throw new InvalidArgumentError("Invalid week settings");
    }
    return { firstDay: e.firstDay, minimalDays: e.minimalDays, weekend: Array.from(e.weekend) };
  }
}
function integerBetween(e, t, r) {
  return isInteger(e) && e >= t && e <= r;
}
function floorMod(e, t) {
  return e - t * Math.floor(e / t);
}
function padStart(e, t = 2) {
  const r = e < 0;
  let n;
  if (r) {
    n = "-" + ("" + -e).padStart(t, "0");
  } else {
    n = ("" + e).padStart(t, "0");
  }
  return n;
}
function parseInteger(e) {
  if (isUndefined(e) || e === null || e === "") {
    return undefined;
  } else {
    return parseInt(e, 10);
  }
}
function parseFloating(e) {
  if (isUndefined(e) || e === null || e === "") {
    return undefined;
  } else {
    return parseFloat(e);
  }
}
function parseMillis(e) {
  if (isUndefined(e) || e === null || e === "") {
    return undefined;
  } else {
    const t = parseFloat("0." + e) * 1e3;
    return Math.floor(t);
  }
}
function roundTo(e, t, r = false) {
  const n = 10 ** t,
    o = r ? Math.trunc : Math.round;
  return o(e * n) / n;
}
function isLeapYear(e) {
  return e % 4 === 0 && (e % 100 !== 0 || e % 400 === 0);
}
function daysInYear(e) {
  return isLeapYear(e) ? 366 : 365;
}
function daysInMonth(e, t) {
  const r = floorMod(t - 1, 12) + 1,
    n = e + (t - r) / 12;
  if (r === 2) {
    return isLeapYear(n) ? 29 : 28;
  } else {
    return [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][r - 1];
  }
}
function objToLocalTS(e) {
  let t = Date.UTC(e.year, e.month - 1, e.day, e.hour, e.minute, e.second, e.millisecond);
  if (e.year < 100 && e.year >= 0) {
    t = new Date(t);
    t.setUTCFullYear(e.year, e.month - 1, e.day);
  }
  return +t;
}
function firstWeekOffset(e, t, r) {
  const n = isoWeekdayToLocal(dayOfWeek(e, 1, t), r);
  return -n + t - 1;
}
function weeksInWeekYear(e, t = 4, r = 1) {
  const n = firstWeekOffset(e, t, r);
  const o = firstWeekOffset(e + 1, t, r);
  return (daysInYear(e) - n + o) / 7;
}
function untruncateYear(e) {
  if (e > 99) {
    return e;
  } else return e > Settings.twoDigitCutoffYear ? 1900 + e : 2e3 + e;
}
function parseZoneInfo(e, t, r, n = null) {
  const o = new Date(e),
    s = { hourCycle: "h23", year: "numeric", month: "2-digit", day: "2-digit", hour: "2-digit", minute: "2-digit" };
  if (n) {
    s.timeZone = n;
  }
  const i = { timeZoneName: t, ...s };
  const a = new Intl.DateTimeFormat(r, i).formatToParts(o).find((e) => e.type.toLowerCase() === "timezonename");
  return a ? a.value : null;
}
function signedOffset(e, t) {
  let r = parseInt(e, 10);
  if (Number.isNaN(r)) {
    r = 0;
  }
  const n = parseInt(t, 10) || 0,
    o = r < 0 || Object.is(r, -0) ? -n : n;
  return r * 60 + o;
}
function asNumber(e) {
  const t = Number(e);
  if (typeof e === "boolean" || e === "" || Number.isNaN(t)) throw new InvalidArgumentError(`Invalid unit value ${e}`);
  return t;
}
function normalizeObject(e, t) {
  const r = {};
  for (const n in e) {
    if (util_hasOwnProperty(e, n)) {
      const o = e[n];
      if (o === undefined || o === null) continue;
      r[t(n)] = asNumber(o);
    }
  }
  return r;
}
function formatOffset(e, t) {
  const r = Math.trunc(Math.abs(e / 60)),
    n = Math.trunc(Math.abs(e % 60)),
    o = e >= 0 ? "+" : "-";
  switch (t) {
    case "short":
      return `${o}${padStart(r, 2)}:${padStart(n, 2)}`;
    case "narrow":
      return `${o}${r}${n > 0 ? `:${n}` : ""}`;
    case "techie":
      return `${o}${padStart(r, 2)}${padStart(n, 2)}`;
    default:
      throw new RangeError(`Value format ${t} is out of range for property format`);
  }
}
function timeObject(e) {
  return util_pick(e, ["hour", "minute", "second", "millisecond"]);
}
function stringify(e) {
  return JSON.stringify(e, Object.keys(e).sort());
}
const st = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
const it = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const at = ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"];
function months(e) {
  switch (e) {
    case "narrow":
      return [...at];
    case "short":
      return [...it];
    case "long":
      return [...st];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"];
    case "2-digit":
      return ["01", "02", "03", "04", "05", "06", "07", "08", "09", "10", "11", "12"];
    default:
      return null;
  }
}
const At = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"];
const ct = ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"];
const ut = ["M", "T", "W", "T", "F", "S", "S"];
function weekdays(e) {
  switch (e) {
    case "narrow":
      return [...ut];
    case "short":
      return [...ct];
    case "long":
      return [...At];
    case "numeric":
      return ["1", "2", "3", "4", "5", "6", "7"];
    default:
      return null;
  }
}
const lt = ["AM", "PM"];
const pt = ["Before Christ", "Anno Domini"];
const dt = ["BC", "AD"];
const ft = ["B", "A"];
function eras(e) {
  switch (e) {
    case "narrow":
      return [...ft];
    case "short":
      return [...dt];
    case "long":
      return [...pt];
    default:
      return null;
  }
}
function meridiemForDateTime(e) {
  return lt[e.hour < 12 ? 0 : 1];
}
function weekdayForDateTime(e, t) {
  return weekdays(t)[e.weekday - 1];
}
function monthForDateTime(e, t) {
  return months(t)[e.month - 1];
}
function eraForDateTime(e, t) {
  return eras(t)[e.year < 0 ? 0 : 1];
}
function formatRelativeTime(e, t, r = "always", n = false) {
  const o = {
    years: ["year", "yr."],
    quarters: ["quarter", "qtr."],
    months: ["month", "mo."],
    weeks: ["week", "wk."],
    days: ["day", "day", "days"],
    hours: ["hour", "hr."],
    minutes: ["minute", "min."],
    seconds: ["second", "sec."],
  };
  const s = ["hours", "minutes", "seconds"].indexOf(e) === -1;
  if (r === "auto" && s) {
    const r = e === "days";
    switch (t) {
      case 1:
        return r ? "tomorrow" : `next ${o[e][0]}`;
      case -1:
        return r ? "yesterday" : `last ${o[e][0]}`;
      case 0:
        return r ? "today" : `this ${o[e][0]}`;
      default:
    }
  }
  const i = Object.is(t, -0) || t < 0,
    a = Math.abs(t),
    A = a === 1,
    c = o[e],
    u = n ? (A ? c[1] : c[2] || c[1]) : A ? o[e][0] : e;
  return i ? `${a} ${u} ago` : `in ${a} ${u}`;
}
function formatString(e) {
  const t = pick(e, ["weekday", "era", "year", "month", "day", "hour", "minute", "second", "timeZoneName", "hourCycle"]),
    r = stringify(t),
    n = "EEEE, LLLL d, yyyy, h:mm a";
  switch (r) {
    case stringify(Formats.DATE_SHORT):
      return "M/d/yyyy";
    case stringify(Formats.DATE_MED):
      return "LLL d, yyyy";
    case stringify(Formats.DATE_MED_WITH_WEEKDAY):
      return "EEE, LLL d, yyyy";
    case stringify(Formats.DATE_FULL):
      return "LLLL d, yyyy";
    case stringify(Formats.DATE_HUGE):
      return "EEEE, LLLL d, yyyy";
    case stringify(Formats.TIME_SIMPLE):
      return "h:mm a";
    case stringify(Formats.TIME_WITH_SECONDS):
      return "h:mm:ss a";
    case stringify(Formats.TIME_WITH_SHORT_OFFSET):
      return "h:mm a";
    case stringify(Formats.TIME_WITH_LONG_OFFSET):
      return "h:mm a";
    case stringify(Formats.TIME_24_SIMPLE):
      return "HH:mm";
    case stringify(Formats.TIME_24_WITH_SECONDS):
      return "HH:mm:ss";
    case stringify(Formats.TIME_24_WITH_SHORT_OFFSET):
      return "HH:mm";
    case stringify(Formats.TIME_24_WITH_LONG_OFFSET):
      return "HH:mm";
    case stringify(Formats.DATETIME_SHORT):
      return "M/d/yyyy, h:mm a";
    case stringify(Formats.DATETIME_MED):
      return "LLL d, yyyy, h:mm a";
    case stringify(Formats.DATETIME_FULL):
      return "LLLL d, yyyy, h:mm a";
    case stringify(Formats.DATETIME_HUGE):
      return n;
    case stringify(Formats.DATETIME_SHORT_WITH_SECONDS):
      return "M/d/yyyy, h:mm:ss a";
    case stringify(Formats.DATETIME_MED_WITH_SECONDS):
      return "LLL d, yyyy, h:mm:ss a";
    case stringify(Formats.DATETIME_MED_WITH_WEEKDAY):
      return "EEE, d LLL yyyy, h:mm a";
    case stringify(Formats.DATETIME_FULL_WITH_SECONDS):
      return "LLLL d, yyyy, h:mm:ss a";
    case stringify(Formats.DATETIME_HUGE_WITH_SECONDS):
      return "EEEE, LLLL d, yyyy, h:mm:ss a";
    default:
      return n;
  }
}
function stringifyTokens(e, t) {
  let r = "";
  for (const n of e) {
    if (n.literal) {
      r += n.val;
    } else {
      r += t(n.val);
    }
  }
  return r;
}
const gt = {
  D: me,
  DD: he,
  DDD: Ie,
  DDDD: ye,
  t: Ce,
  tt: be,
  ttt: Qe,
  tttt: Be,
  T: Te,
  TT: ve,
  TTT: we,
  TTTT: _e,
  f: Re,
  ff: Fe,
  fff: Se,
  ffff: Pe,
  F: Oe,
  FF: De,
  FFF: Ne,
  FFFF: Le,
};
class Formatter {
  static create(e, t = {}) {
    return new Formatter(e, t);
  }
  static parseFormat(e) {
    let t = null,
      r = "",
      n = false;
    const o = [];
    for (let s = 0; s < e.length; s++) {
      const i = e.charAt(s);
      if (i === "'") {
        if (r.length > 0) {
          o.push({ literal: n || /^\s+$/.test(r), val: r });
        }
        t = null;
        r = "";
        n = !n;
      } else if (n) {
        r += i;
      } else if (i === t) {
        r += i;
      } else {
        if (r.length > 0) {
          o.push({ literal: /^\s+$/.test(r), val: r });
        }
        r = i;
        t = i;
      }
    }
    if (r.length > 0) {
      o.push({ literal: n || /^\s+$/.test(r), val: r });
    }
    return o;
  }
  static macroTokenToFormatOpts(e) {
    return gt[e];
  }
  constructor(e, t) {
    this.opts = t;
    this.loc = e;
    this.systemLoc = null;
  }
  formatWithSystemDefault(e, t) {
    if (this.systemLoc === null) {
      this.systemLoc = this.loc.redefaultToSystem();
    }
    const r = this.systemLoc.dtFormatter(e, { ...this.opts, ...t });
    return r.format();
  }
  dtFormatter(e, t = {}) {
    return this.loc.dtFormatter(e, { ...this.opts, ...t });
  }
  formatDateTime(e, t) {
    return this.dtFormatter(e, t).format();
  }
  formatDateTimeParts(e, t) {
    return this.dtFormatter(e, t).formatToParts();
  }
  formatInterval(e, t) {
    const r = this.dtFormatter(e.start, t);
    return r.dtf.formatRange(e.start.toJSDate(), e.end.toJSDate());
  }
  resolvedOptions(e, t) {
    return this.dtFormatter(e, t).resolvedOptions();
  }
  num(e, t = 0) {
    if (this.opts.forceSimple) {
      return padStart(e, t);
    }
    const r = { ...this.opts };
    if (t > 0) {
      r.padTo = t;
    }
    return this.loc.numberFormatter(r).format(e);
  }
  formatDateTimeFromString(e, t) {
    const r = this.loc.listingMode() === "en",
      n = this.loc.outputCalendar && this.loc.outputCalendar !== "gregory",
      string = (t, r) => this.loc.extract(e, t, r),
      formatOffset = (t) => {
        if (e.isOffsetFixed && e.offset === 0 && t.allowZ) {
          return "Z";
        }
        return e.isValid ? e.zone.formatOffset(e.ts, t.format) : "";
      },
      meridiem = () => (r ? meridiemForDateTime(e) : string({ hour: "numeric", hourCycle: "h12" }, "dayperiod")),
      month = (t, n) => (r ? monthForDateTime(e, t) : string(n ? { month: t } : { month: t, day: "numeric" }, "month")),
      weekday = (t, n) => (r ? weekdayForDateTime(e, t) : string(n ? { weekday: t } : { weekday: t, month: "long", day: "numeric" }, "weekday")),
      maybeMacro = (t) => {
        const r = Formatter.macroTokenToFormatOpts(t);
        if (r) {
          return this.formatWithSystemDefault(e, r);
        } else {
          return t;
        }
      },
      era = (t) => (r ? eraForDateTime(e, t) : string({ era: t }, "era")),
      tokenToString = (t) => {
        switch (t) {
          case "S":
            return this.num(e.millisecond);
          case "u":
          case "SSS":
            return this.num(e.millisecond, 3);
          case "s":
            return this.num(e.second);
          case "ss":
            return this.num(e.second, 2);
          case "uu":
            return this.num(Math.floor(e.millisecond / 10), 2);
          case "uuu":
            return this.num(Math.floor(e.millisecond / 100));
          case "m":
            return this.num(e.minute);
          case "mm":
            return this.num(e.minute, 2);
          case "h":
            return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12);
          case "hh":
            return this.num(e.hour % 12 === 0 ? 12 : e.hour % 12, 2);
          case "H":
            return this.num(e.hour);
          case "HH":
            return this.num(e.hour, 2);
          case "Z":
            return formatOffset({ format: "narrow", allowZ: this.opts.allowZ });
          case "ZZ":
            return formatOffset({ format: "short", allowZ: this.opts.allowZ });
          case "ZZZ":
            return formatOffset({ format: "techie", allowZ: this.opts.allowZ });
          case "ZZZZ":
            return e.zone.offsetName(e.ts, { format: "short", locale: this.loc.locale });
          case "ZZZZZ":
            return e.zone.offsetName(e.ts, { format: "long", locale: this.loc.locale });
          case "z":
            return e.zoneName;
          case "a":
            return meridiem();
          case "d":
            return n ? string({ day: "numeric" }, "day") : this.num(e.day);
          case "dd":
            return n ? string({ day: "2-digit" }, "day") : this.num(e.day, 2);
          case "c":
            return this.num(e.weekday);
          case "ccc":
            return weekday("short", true);
          case "cccc":
            return weekday("long", true);
          case "ccccc":
            return weekday("narrow", true);
          case "E":
            return this.num(e.weekday);
          case "EEE":
            return weekday("short", false);
          case "EEEE":
            return weekday("long", false);
          case "EEEEE":
            return weekday("narrow", false);
          case "L":
            return n ? string({ month: "numeric", day: "numeric" }, "month") : this.num(e.month);
          case "LL":
            return n ? string({ month: "2-digit", day: "numeric" }, "month") : this.num(e.month, 2);
          case "LLL":
            return month("short", true);
          case "LLLL":
            return month("long", true);
          case "LLLLL":
            return month("narrow", true);
          case "M":
            return n ? string({ month: "numeric" }, "month") : this.num(e.month);
          case "MM":
            return n ? string({ month: "2-digit" }, "month") : this.num(e.month, 2);
          case "MMM":
            return month("short", false);
          case "MMMM":
            return month("long", false);
          case "MMMMM":
            return month("narrow", false);
          case "y":
            return n ? string({ year: "numeric" }, "year") : this.num(e.year);
          case "yy":
            return n ? string({ year: "2-digit" }, "year") : this.num(e.year.toString().slice(-2), 2);
          case "yyyy":
            return n ? string({ year: "numeric" }, "year") : this.num(e.year, 4);
          case "yyyyyy":
            return n ? string({ year: "numeric" }, "year") : this.num(e.year, 6);
          case "G":
            return era("short");
          case "GG":
            return era("long");
          case "GGGGG":
            return era("narrow");
          case "kk":
            return this.num(e.weekYear.toString().slice(-2), 2);
          case "kkkk":
            return this.num(e.weekYear, 4);
          case "W":
            return this.num(e.weekNumber);
          case "WW":
            return this.num(e.weekNumber, 2);
          case "n":
            return this.num(e.localWeekNumber);
          case "nn":
            return this.num(e.localWeekNumber, 2);
          case "ii":
            return this.num(e.localWeekYear.toString().slice(-2), 2);
          case "iiii":
            return this.num(e.localWeekYear, 4);
          case "o":
            return this.num(e.ordinal);
          case "ooo":
            return this.num(e.ordinal, 3);
          case "q":
            return this.num(e.quarter);
          case "qq":
            return this.num(e.quarter, 2);
          case "X":
            return this.num(Math.floor(e.ts / 1e3));
          case "x":
            return this.num(e.ts);
          default:
            return maybeMacro(t);
        }
      };
    return stringifyTokens(Formatter.parseFormat(t), tokenToString);
  }
  formatDurationFromString(e, t) {
    const tokenToField = (e) => {
        switch (e[0]) {
          case "S":
            return "millisecond";
          case "s":
            return "second";
          case "m":
            return "minute";
          case "h":
            return "hour";
          case "d":
            return "day";
          case "w":
            return "week";
          case "M":
            return "month";
          case "y":
            return "year";
          default:
            return null;
        }
      },
      tokenToString = (e) => (t) => {
        const r = tokenToField(t);
        if (r) {
          return this.num(e.get(r), t.length);
        } else {
          return t;
        }
      },
      r = Formatter.parseFormat(t),
      n = r.reduce((e, { literal: t, val: r }) => (t ? e : e.concat(r)), []),
      o = e.shiftTo(...n.map(tokenToField).filter((e) => e));
    return stringifyTokens(r, tokenToString(o));
  }
}
const mt = /[A-Za-z_+-]{1,256}(?::?\/[A-Za-z0-9_+-]{1,256}(?:\/[A-Za-z0-9_+-]{1,256})?)?/;
function combineRegexes(...e) {
  const t = e.reduce((e, t) => e + t.source, "");
  return RegExp(`^${t}$`);
}
function combineExtractors(...e) {
  return (t) =>
    e
      .reduce(
        ([e, r, n], o) => {
          const [s, i, a] = o(t, n);
          return [{ ...e, ...s }, i || r, a];
        },
        [{}, null, 1]
      )
      .slice(0, 2);
}
function parse(e, ...t) {
  if (e == null) {
    return [null, null];
  }
  for (const [r, n] of t) {
    const t = r.exec(e);
    if (t) {
      return n(t);
    }
  }
  return [null, null];
}
function simpleParse(...e) {
  return (t, r) => {
    const n = {};
    let o;
    for (o = 0; o < e.length; o++) {
      n[e[o]] = parseInteger(t[r + o]);
    }
    return [n, null, r + o];
  };
}
const ht = /(?:(Z)|([+-]\d\d)(?::?(\d\d))?)/;
const Et = `(?:${ht.source}?(?:\\[(${mt.source})\\])?)?`;
const It = /(\d\d)(?::?(\d\d)(?::?(\d\d)(?:[.,](\d{1,30}))?)?)?/;
const yt = RegExp(`${It.source}${Et}`);
const Ct = RegExp(`(?:T${yt.source})?`);
const bt = /([+-]\d{6}|\d{4})(?:-?(\d\d)(?:-?(\d\d))?)?/;
const Qt = /(\d{4})-?W(\d\d)(?:-?(\d))?/;
const Bt = /(\d{4})-?(\d{3})/;
const Tt = simpleParse("weekYear", "weekNumber", "weekDay");
const vt = simpleParse("year", "ordinal");
const wt = /(\d{4})-(\d\d)-(\d\d)/;
const _t = RegExp(`${It.source} ?(?:${ht.source}|(${mt.source}))?`);
const Rt = RegExp(`(?: ${_t.source})?`);
function regexParser_int(e, t, r) {
  const n = e[t];
  return isUndefined(n) ? r : parseInteger(n);
}
function extractISOYmd(e, t) {
  const r = { year: regexParser_int(e, t), month: regexParser_int(e, t + 1, 1), day: regexParser_int(e, t + 2, 1) };
  return [r, null, t + 3];
}
function extractISOTime(e, t) {
  const r = {
    hours: regexParser_int(e, t, 0),
    minutes: regexParser_int(e, t + 1, 0),
    seconds: regexParser_int(e, t + 2, 0),
    milliseconds: parseMillis(e[t + 3]),
  };
  return [r, null, t + 4];
}
function extractISOOffset(e, t) {
  const r = !e[t] && !e[t + 1],
    n = signedOffset(e[t + 1], e[t + 2]),
    o = r ? null : FixedOffsetZone.instance(n);
  return [{}, o, t + 3];
}
function extractIANAZone(e, t) {
  const r = e[t] ? IANAZone.create(e[t]) : null;
  return [{}, r, t + 1];
}
const Ot = RegExp(`^T?${It.source}$`);
const Ft =
  /^-?P(?:(?:(-?\d{1,20}(?:\.\d{1,20})?)Y)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20}(?:\.\d{1,20})?)W)?(?:(-?\d{1,20}(?:\.\d{1,20})?)D)?(?:T(?:(-?\d{1,20}(?:\.\d{1,20})?)H)?(?:(-?\d{1,20}(?:\.\d{1,20})?)M)?(?:(-?\d{1,20})(?:[.,](-?\d{1,20}))?S)?)?)$/;
function extractISODuration(e) {
  const [t, r, n, o, s, i, a, A, c] = e;
  const u = t[0] === "-";
  const l = A && A[0] === "-";
  const maybeNegate = (e, t = false) => (e !== undefined && (t || (e && u)) ? -e : e);
  return [
    {
      years: maybeNegate(parseFloating(r)),
      months: maybeNegate(parseFloating(n)),
      weeks: maybeNegate(parseFloating(o)),
      days: maybeNegate(parseFloating(s)),
      hours: maybeNegate(parseFloating(i)),
      minutes: maybeNegate(parseFloating(a)),
      seconds: maybeNegate(parseFloating(A), A === "-0"),
      milliseconds: maybeNegate(parseMillis(c), l),
    },
  ];
}
const Dt = { GMT: 0, EDT: -4 * 60, EST: -5 * 60, CDT: -5 * 60, CST: -6 * 60, MDT: -6 * 60, MST: -7 * 60, PDT: -7 * 60, PST: -8 * 60 };
function fromStrings(e, t, r, n, o, s, i) {
  const a = {
    year: t.length === 2 ? untruncateYear(parseInteger(t)) : parseInteger(t),
    month: it.indexOf(r) + 1,
    day: parseInteger(n),
    hour: parseInteger(o),
    minute: parseInteger(s),
  };
  if (i) a.second = parseInteger(i);
  if (e) {
    a.weekday = e.length > 3 ? At.indexOf(e) + 1 : ct.indexOf(e) + 1;
  }
  return a;
}
const kt =
  /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|(?:([+-]\d\d)(\d\d)))$/;
function extractRFC2822(e) {
  const [, t, r, n, o, s, i, a, A, c, u, l] = e,
    p = fromStrings(t, o, n, r, s, i, a);
  let d;
  if (A) {
    d = Dt[A];
  } else if (c) {
    d = 0;
  } else {
    d = signedOffset(u, l);
  }
  return [p, new FixedOffsetZone(d)];
}
function preprocessRFC2822(e) {
  return e
    .replace(/\([^()]*\)|[\n\t]/g, " ")
    .replace(/(\s\s+)/g, " ")
    .trim();
}
const St = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d\d) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d\d):(\d\d):(\d\d) GMT$/,
  Nt = /^(Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d\d)-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d\d) (\d\d):(\d\d):(\d\d) GMT$/,
  Pt = /^(Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( \d|\d\d) (\d\d):(\d\d):(\d\d) (\d{4})$/;
function extractRFC1123Or850(e) {
  const [, t, r, n, o, s, i, a] = e,
    A = fromStrings(t, o, n, r, s, i, a);
  return [A, FixedOffsetZone.utcInstance];
}
function extractASCII(e) {
  const [, t, r, n, o, s, i, a] = e,
    A = fromStrings(t, a, r, n, o, s, i);
  return [A, FixedOffsetZone.utcInstance];
}
const Lt = combineRegexes(bt, Ct);
const Ut = combineRegexes(Qt, Ct);
const Mt = combineRegexes(Bt, Ct);
const Gt = combineRegexes(yt);
const xt = combineExtractors(extractISOYmd, extractISOTime, extractISOOffset, extractIANAZone);
const jt = combineExtractors(Tt, extractISOTime, extractISOOffset, extractIANAZone);
const Vt = combineExtractors(vt, extractISOTime, extractISOOffset, extractIANAZone);
const Ht = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseISODate(e) {
  return parse(e, [Lt, xt], [Ut, jt], [Mt, Vt], [Gt, Ht]);
}
function parseRFC2822Date(e) {
  return parse(preprocessRFC2822(e), [kt, extractRFC2822]);
}
function parseHTTPDate(e) {
  return parse(e, [St, extractRFC1123Or850], [Nt, extractRFC1123Or850], [Pt, extractASCII]);
}
function parseISODuration(e) {
  return parse(e, [Ft, extractISODuration]);
}
const Yt = combineExtractors(extractISOTime);
function parseISOTimeOnly(e) {
  return parse(e, [Ot, Yt]);
}
const Kt = combineRegexes(wt, Rt);
const qt = combineRegexes(_t);
const Jt = combineExtractors(extractISOTime, extractISOOffset, extractIANAZone);
function parseSQL(e) {
  return parse(e, [Kt, xt], [qt, Jt]);
}
const Wt = "Invalid Duration";
const $t = {
    weeks: { days: 7, hours: 7 * 24, minutes: 7 * 24 * 60, seconds: 7 * 24 * 60 * 60, milliseconds: 7 * 24 * 60 * 60 * 1e3 },
    days: { hours: 24, minutes: 24 * 60, seconds: 24 * 60 * 60, milliseconds: 24 * 60 * 60 * 1e3 },
    hours: { minutes: 60, seconds: 60 * 60, milliseconds: 60 * 60 * 1e3 },
    minutes: { seconds: 60, milliseconds: 60 * 1e3 },
    seconds: { milliseconds: 1e3 },
  },
  zt = {
    years: {
      quarters: 4,
      months: 12,
      weeks: 52,
      days: 365,
      hours: 365 * 24,
      minutes: 365 * 24 * 60,
      seconds: 365 * 24 * 60 * 60,
      milliseconds: 365 * 24 * 60 * 60 * 1e3,
    },
    quarters: { months: 3, weeks: 13, days: 91, hours: 91 * 24, minutes: 91 * 24 * 60, seconds: 91 * 24 * 60 * 60, milliseconds: 91 * 24 * 60 * 60 * 1e3 },
    months: { weeks: 4, days: 30, hours: 30 * 24, minutes: 30 * 24 * 60, seconds: 30 * 24 * 60 * 60, milliseconds: 30 * 24 * 60 * 60 * 1e3 },
    ...$t,
  },
  Zt = 146097 / 400,
  Xt = 146097 / 4800,
  er = {
    years: {
      quarters: 4,
      months: 12,
      weeks: Zt / 7,
      days: Zt,
      hours: Zt * 24,
      minutes: Zt * 24 * 60,
      seconds: Zt * 24 * 60 * 60,
      milliseconds: Zt * 24 * 60 * 60 * 1e3,
    },
    quarters: {
      months: 3,
      weeks: Zt / 28,
      days: Zt / 4,
      hours: (Zt * 24) / 4,
      minutes: (Zt * 24 * 60) / 4,
      seconds: (Zt * 24 * 60 * 60) / 4,
      milliseconds: (Zt * 24 * 60 * 60 * 1e3) / 4,
    },
    months: { weeks: Xt / 7, days: Xt, hours: Xt * 24, minutes: Xt * 24 * 60, seconds: Xt * 24 * 60 * 60, milliseconds: Xt * 24 * 60 * 60 * 1e3 },
    ...$t,
  };
const tr = ["years", "quarters", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds"];
const rr = tr.slice(0).reverse();
function clone(e, t, r = false) {
  const n = {
    values: r ? t.values : { ...e.values, ...(t.values || {}) },
    loc: e.loc.clone(t.loc),
    conversionAccuracy: t.conversionAccuracy || e.conversionAccuracy,
    matrix: t.matrix || e.matrix,
  };
  return new Duration(n);
}
function durationToMillis(e, t) {
  let r = t.milliseconds ?? 0;
  for (const n of rr.slice(1)) {
    if (t[n]) {
      r += t[n] * e[n]["milliseconds"];
    }
  }
  return r;
}
function normalizeValues(e, t) {
  const r = durationToMillis(e, t) < 0 ? -1 : 1;
  tr.reduceRight((n, o) => {
    if (!isUndefined(t[o])) {
      if (n) {
        const s = t[n] * r;
        const i = e[o][n];
        const a = Math.floor(s / i);
        t[o] += a * r;
        t[n] -= a * i * r;
      }
      return o;
    } else {
      return n;
    }
  }, null);
  tr.reduce((r, n) => {
    if (!isUndefined(t[n])) {
      if (r) {
        const o = t[r] % 1;
        t[r] -= o;
        t[n] += o * e[r][n];
      }
      return n;
    } else {
      return r;
    }
  }, null);
}
function removeZeroes(e) {
  const t = {};
  for (const [r, n] of Object.entries(e)) {
    if (n !== 0) {
      t[r] = n;
    }
  }
  return t;
}
class Duration {
  constructor(e) {
    const t = e.conversionAccuracy === "longterm" || false;
    let r = t ? er : zt;
    if (e.matrix) {
      r = e.matrix;
    }
    this.values = e.values;
    this.loc = e.loc || Locale.create();
    this.conversionAccuracy = t ? "longterm" : "casual";
    this.invalid = e.invalid || null;
    this.matrix = r;
    this.isLuxonDuration = true;
  }
  static fromMillis(e, t) {
    return Duration.fromObject({ milliseconds: e }, t);
  }
  static fromObject(e, t = {}) {
    if (e == null || typeof e !== "object") {
      throw new InvalidArgumentError(`Duration.fromObject: argument expected to be an object, got ${e === null ? "null" : typeof e}`);
    }
    return new Duration({
      values: normalizeObject(e, Duration.normalizeUnit),
      loc: Locale.fromObject(t),
      conversionAccuracy: t.conversionAccuracy,
      matrix: t.matrix,
    });
  }
  static fromDurationLike(e) {
    if (isNumber(e)) {
      return Duration.fromMillis(e);
    } else if (Duration.isDuration(e)) {
      return e;
    } else if (typeof e === "object") {
      return Duration.fromObject(e);
    } else {
      throw new InvalidArgumentError(`Unknown duration argument ${e} of type ${typeof e}`);
    }
  }
  static fromISO(e, t) {
    const [r] = parseISODuration(e);
    if (r) {
      return Duration.fromObject(r, t);
    } else {
      return Duration.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
    }
  }
  static fromISOTime(e, t) {
    const [r] = parseISOTimeOnly(e);
    if (r) {
      return Duration.fromObject(r, t);
    } else {
      return Duration.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
    }
  }
  static invalid(e, t = null) {
    if (!e) {
      throw new InvalidArgumentError("need to specify a reason the Duration is invalid");
    }
    const r = e instanceof Invalid ? e : new Invalid(e, t);
    if (Settings.throwOnInvalid) {
      throw new InvalidDurationError(r);
    } else {
      return new Duration({ invalid: r });
    }
  }
  static normalizeUnit(e) {
    const t = {
      year: "years",
      years: "years",
      quarter: "quarters",
      quarters: "quarters",
      month: "months",
      months: "months",
      week: "weeks",
      weeks: "weeks",
      day: "days",
      days: "days",
      hour: "hours",
      hours: "hours",
      minute: "minutes",
      minutes: "minutes",
      second: "seconds",
      seconds: "seconds",
      millisecond: "milliseconds",
      milliseconds: "milliseconds",
    }[e ? e.toLowerCase() : e];
    if (!t) throw new InvalidUnitError(e);
    return t;
  }
  static isDuration(e) {
    return (e && e.isLuxonDuration) || false;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  toFormat(e, t = {}) {
    const r = { ...t, floor: t.round !== false && t.floor !== false };
    return this.isValid ? Formatter.create(this.loc, r).formatDurationFromString(this, e) : Wt;
  }
  toHuman(e = {}) {
    if (!this.isValid) return Wt;
    const t = tr
      .map((t) => {
        const r = this.values[t];
        if (isUndefined(r)) {
          return null;
        }
        return this.loc.numberFormatter({ style: "unit", unitDisplay: "long", ...e, unit: t.slice(0, -1) }).format(r);
      })
      .filter((e) => e);
    return this.loc.listFormatter({ type: "conjunction", style: e.listStyle || "narrow", ...e }).format(t);
  }
  toObject() {
    if (!this.isValid) return {};
    return { ...this.values };
  }
  toISO() {
    if (!this.isValid) return null;
    let e = "P";
    if (this.years !== 0) e += this.years + "Y";
    if (this.months !== 0 || this.quarters !== 0) e += this.months + this.quarters * 3 + "M";
    if (this.weeks !== 0) e += this.weeks + "W";
    if (this.days !== 0) e += this.days + "D";
    if (this.hours !== 0 || this.minutes !== 0 || this.seconds !== 0 || this.milliseconds !== 0) e += "T";
    if (this.hours !== 0) e += this.hours + "H";
    if (this.minutes !== 0) e += this.minutes + "M";
    if (this.seconds !== 0 || this.milliseconds !== 0) e += roundTo(this.seconds + this.milliseconds / 1e3, 3) + "S";
    if (e === "P") e += "T0S";
    return e;
  }
  toISOTime(e = {}) {
    if (!this.isValid) return null;
    const t = this.toMillis();
    if (t < 0 || t >= 864e5) return null;
    e = { suppressMilliseconds: false, suppressSeconds: false, includePrefix: false, format: "extended", ...e, includeOffset: false };
    const r = DateTime.fromMillis(t, { zone: "UTC" });
    return r.toISOTime(e);
  }
  toJSON() {
    return this.toISO();
  }
  toString() {
    return this.toISO();
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Duration { values: ${JSON.stringify(this.values)} }`;
    } else {
      return `Duration { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  toMillis() {
    if (!this.isValid) return NaN;
    return durationToMillis(this.matrix, this.values);
  }
  valueOf() {
    return this.toMillis();
  }
  plus(e) {
    if (!this.isValid) return this;
    const t = Duration.fromDurationLike(e),
      r = {};
    for (const e of tr) {
      if (util_hasOwnProperty(t.values, e) || util_hasOwnProperty(this.values, e)) {
        r[e] = t.get(e) + this.get(e);
      }
    }
    return clone(this, { values: r }, true);
  }
  minus(e) {
    if (!this.isValid) return this;
    const t = Duration.fromDurationLike(e);
    return this.plus(t.negate());
  }
  mapUnits(e) {
    if (!this.isValid) return this;
    const t = {};
    for (const r of Object.keys(this.values)) {
      t[r] = asNumber(e(this.values[r], r));
    }
    return clone(this, { values: t }, true);
  }
  get(e) {
    return this[Duration.normalizeUnit(e)];
  }
  set(e) {
    if (!this.isValid) return this;
    const t = { ...this.values, ...normalizeObject(e, Duration.normalizeUnit) };
    return clone(this, { values: t });
  }
  reconfigure({ locale: e, numberingSystem: t, conversionAccuracy: r, matrix: n } = {}) {
    const o = this.loc.clone({ locale: e, numberingSystem: t });
    const s = { loc: o, matrix: n, conversionAccuracy: r };
    return clone(this, s);
  }
  as(e) {
    return this.isValid ? this.shiftTo(e).get(e) : NaN;
  }
  normalize() {
    if (!this.isValid) return this;
    const e = this.toObject();
    normalizeValues(this.matrix, e);
    return clone(this, { values: e }, true);
  }
  rescale() {
    if (!this.isValid) return this;
    const e = removeZeroes(this.normalize().shiftToAll().toObject());
    return clone(this, { values: e }, true);
  }
  shiftTo(...e) {
    if (!this.isValid) return this;
    if (e.length === 0) {
      return this;
    }
    e = e.map((e) => Duration.normalizeUnit(e));
    const t = {},
      r = {},
      n = this.toObject();
    let o;
    for (const s of tr) {
      if (e.indexOf(s) >= 0) {
        o = s;
        let e = 0;
        for (const t in r) {
          e += this.matrix[t][s] * r[t];
          r[t] = 0;
        }
        if (isNumber(n[s])) {
          e += n[s];
        }
        const i = Math.trunc(e);
        t[s] = i;
        r[s] = (e * 1e3 - i * 1e3) / 1e3;
      } else if (isNumber(n[s])) {
        r[s] = n[s];
      }
    }
    for (const e in r) {
      if (r[e] !== 0) {
        t[o] += e === o ? r[e] : r[e] / this.matrix[o][e];
      }
    }
    normalizeValues(this.matrix, t);
    return clone(this, { values: t }, true);
  }
  shiftToAll() {
    if (!this.isValid) return this;
    return this.shiftTo("years", "months", "weeks", "days", "hours", "minutes", "seconds", "milliseconds");
  }
  negate() {
    if (!this.isValid) return this;
    const e = {};
    for (const t of Object.keys(this.values)) {
      e[t] = this.values[t] === 0 ? 0 : -this.values[t];
    }
    return clone(this, { values: e }, true);
  }
  get years() {
    return this.isValid ? this.values.years || 0 : NaN;
  }
  get quarters() {
    return this.isValid ? this.values.quarters || 0 : NaN;
  }
  get months() {
    return this.isValid ? this.values.months || 0 : NaN;
  }
  get weeks() {
    return this.isValid ? this.values.weeks || 0 : NaN;
  }
  get days() {
    return this.isValid ? this.values.days || 0 : NaN;
  }
  get hours() {
    return this.isValid ? this.values.hours || 0 : NaN;
  }
  get minutes() {
    return this.isValid ? this.values.minutes || 0 : NaN;
  }
  get seconds() {
    return this.isValid ? this.values.seconds || 0 : NaN;
  }
  get milliseconds() {
    return this.isValid ? this.values.milliseconds || 0 : NaN;
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  equals(e) {
    if (!this.isValid || !e.isValid) {
      return false;
    }
    if (!this.loc.equals(e.loc)) {
      return false;
    }
    function eq(e, t) {
      if (e === undefined || e === 0) return t === undefined || t === 0;
      return e === t;
    }
    for (const t of tr) {
      if (!eq(this.values[t], e.values[t])) {
        return false;
      }
    }
    return true;
  }
}
const nr = "Invalid Interval";
function validateStartEnd(e, t) {
  if (!e || !e.isValid) {
    return Interval.invalid("missing or invalid start");
  } else if (!t || !t.isValid) {
    return Interval.invalid("missing or invalid end");
  } else if (t < e) {
    return Interval.invalid("end before start", `The end of an interval must be after its start, but you had start=${e.toISO()} and end=${t.toISO()}`);
  } else {
    return null;
  }
}
class Interval {
  constructor(e) {
    this.s = e.start;
    this.e = e.end;
    this.invalid = e.invalid || null;
    this.isLuxonInterval = true;
  }
  static invalid(e, t = null) {
    if (!e) {
      throw new InvalidArgumentError("need to specify a reason the Interval is invalid");
    }
    const r = e instanceof Invalid ? e : new Invalid(e, t);
    if (Settings.throwOnInvalid) {
      throw new InvalidIntervalError(r);
    } else {
      return new Interval({ invalid: r });
    }
  }
  static fromDateTimes(e, t) {
    const r = friendlyDateTime(e),
      n = friendlyDateTime(t);
    const o = validateStartEnd(r, n);
    if (o == null) {
      return new Interval({ start: r, end: n });
    } else {
      return o;
    }
  }
  static after(e, t) {
    const r = Duration.fromDurationLike(t),
      n = friendlyDateTime(e);
    return Interval.fromDateTimes(n, n.plus(r));
  }
  static before(e, t) {
    const r = Duration.fromDurationLike(t),
      n = friendlyDateTime(e);
    return Interval.fromDateTimes(n.minus(r), n);
  }
  static fromISO(e, t) {
    const [r, n] = (e || "").split("/", 2);
    if (r && n) {
      let e, o;
      try {
        e = DateTime.fromISO(r, t);
        o = e.isValid;
      } catch (n) {
        o = false;
      }
      let s, i;
      try {
        s = DateTime.fromISO(n, t);
        i = s.isValid;
      } catch (n) {
        i = false;
      }
      if (o && i) {
        return Interval.fromDateTimes(e, s);
      }
      if (o) {
        const r = Duration.fromISO(n, t);
        if (r.isValid) {
          return Interval.after(e, r);
        }
      } else if (i) {
        const e = Duration.fromISO(r, t);
        if (e.isValid) {
          return Interval.before(s, e);
        }
      }
    }
    return Interval.invalid("unparsable", `the input "${e}" can't be parsed as ISO 8601`);
  }
  static isInterval(e) {
    return (e && e.isLuxonInterval) || false;
  }
  get start() {
    return this.isValid ? this.s : null;
  }
  get end() {
    return this.isValid ? this.e : null;
  }
  get isValid() {
    return this.invalidReason === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  length(e = "milliseconds") {
    return this.isValid ? this.toDuration(...[e]).get(e) : NaN;
  }
  count(e = "milliseconds", t) {
    if (!this.isValid) return NaN;
    const r = this.start.startOf(e, t);
    let n;
    if (t?.useLocaleWeeks) {
      n = this.end.reconfigure({ locale: r.locale });
    } else {
      n = this.end;
    }
    n = n.startOf(e, t);
    return Math.floor(n.diff(r, e).get(e)) + (n.valueOf() !== this.end.valueOf());
  }
  hasSame(e) {
    return this.isValid ? this.isEmpty() || this.e.minus(1).hasSame(this.s, e) : false;
  }
  isEmpty() {
    return this.s.valueOf() === this.e.valueOf();
  }
  isAfter(e) {
    if (!this.isValid) return false;
    return this.s > e;
  }
  isBefore(e) {
    if (!this.isValid) return false;
    return this.e <= e;
  }
  contains(e) {
    if (!this.isValid) return false;
    return this.s <= e && this.e > e;
  }
  set({ start: e, end: t } = {}) {
    if (!this.isValid) return this;
    return Interval.fromDateTimes(e || this.s, t || this.e);
  }
  splitAt(...e) {
    if (!this.isValid) return [];
    const t = e
        .map(friendlyDateTime)
        .filter((e) => this.contains(e))
        .sort((e, t) => e.toMillis() - t.toMillis()),
      r = [];
    let { s: n } = this,
      o = 0;
    while (n < this.e) {
      const e = t[o] || this.e,
        s = +e > +this.e ? this.e : e;
      r.push(Interval.fromDateTimes(n, s));
      n = s;
      o += 1;
    }
    return r;
  }
  splitBy(e) {
    const t = Duration.fromDurationLike(e);
    if (!this.isValid || !t.isValid || t.as("milliseconds") === 0) {
      return [];
    }
    let { s: r } = this,
      n = 1,
      o;
    const s = [];
    while (r < this.e) {
      const e = this.start.plus(t.mapUnits((e) => e * n));
      o = +e > +this.e ? this.e : e;
      s.push(Interval.fromDateTimes(r, o));
      r = o;
      n += 1;
    }
    return s;
  }
  divideEqually(e) {
    if (!this.isValid) return [];
    return this.splitBy(this.length() / e).slice(0, e);
  }
  overlaps(e) {
    return this.e > e.s && this.s < e.e;
  }
  abutsStart(e) {
    if (!this.isValid) return false;
    return +this.e === +e.s;
  }
  abutsEnd(e) {
    if (!this.isValid) return false;
    return +e.e === +this.s;
  }
  engulfs(e) {
    if (!this.isValid) return false;
    return this.s <= e.s && this.e >= e.e;
  }
  equals(e) {
    if (!this.isValid || !e.isValid) {
      return false;
    }
    return this.s.equals(e.s) && this.e.equals(e.e);
  }
  intersection(e) {
    if (!this.isValid) return this;
    const t = this.s > e.s ? this.s : e.s,
      r = this.e < e.e ? this.e : e.e;
    if (t >= r) {
      return null;
    } else {
      return Interval.fromDateTimes(t, r);
    }
  }
  union(e) {
    if (!this.isValid) return this;
    const t = this.s < e.s ? this.s : e.s,
      r = this.e > e.e ? this.e : e.e;
    return Interval.fromDateTimes(t, r);
  }
  static merge(e) {
    const [t, r] = e
      .sort((e, t) => e.s - t.s)
      .reduce(
        ([e, t], r) => {
          if (!t) {
            return [e, r];
          } else if (t.overlaps(r) || t.abutsStart(r)) {
            return [e, t.union(r)];
          } else {
            return [e.concat([t]), r];
          }
        },
        [[], null]
      );
    if (r) {
      t.push(r);
    }
    return t;
  }
  static xor(e) {
    let t = null,
      r = 0;
    const n = [],
      o = e.map((e) => [
        { time: e.s, type: "s" },
        { time: e.e, type: "e" },
      ]),
      s = Array.prototype.concat(...o),
      i = s.sort((e, t) => e.time - t.time);
    for (const e of i) {
      r += e.type === "s" ? 1 : -1;
      if (r === 1) {
        t = e.time;
      } else {
        if (t && +t !== +e.time) {
          n.push(Interval.fromDateTimes(t, e.time));
        }
        t = null;
      }
    }
    return Interval.merge(n);
  }
  difference(...e) {
    return Interval.xor([this].concat(e))
      .map((e) => this.intersection(e))
      .filter((e) => e && !e.isEmpty());
  }
  toString() {
    if (!this.isValid) return nr;
    return `[${this.s.toISO()} – ${this.e.toISO()})`;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `Interval { start: ${this.s.toISO()}, end: ${this.e.toISO()} }`;
    } else {
      return `Interval { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  toLocaleString(e = me, t = {}) {
    return this.isValid ? Formatter.create(this.s.loc.clone(t), e).formatInterval(this) : nr;
  }
  toISO(e) {
    if (!this.isValid) return nr;
    return `${this.s.toISO(e)}/${this.e.toISO(e)}`;
  }
  toISODate() {
    if (!this.isValid) return nr;
    return `${this.s.toISODate()}/${this.e.toISODate()}`;
  }
  toISOTime(e) {
    if (!this.isValid) return nr;
    return `${this.s.toISOTime(e)}/${this.e.toISOTime(e)}`;
  }
  toFormat(e, { separator: t = " – " } = {}) {
    if (!this.isValid) return nr;
    return `${this.s.toFormat(e)}${t}${this.e.toFormat(e)}`;
  }
  toDuration(e, t) {
    if (!this.isValid) {
      return Duration.invalid(this.invalidReason);
    }
    return this.e.diff(this.s, e, t);
  }
  mapEndpoints(e) {
    return Interval.fromDateTimes(e(this.s), e(this.e));
  }
}
class Info {
  static hasDST(e = Settings.defaultZone) {
    const t = DateTime.now().setZone(e).set({ month: 12 });
    return !e.isUniversal && t.offset !== t.set({ month: 6 }).offset;
  }
  static isValidIANAZone(e) {
    return IANAZone.isValidZone(e);
  }
  static normalizeZone(e) {
    return normalizeZone(e, Settings.defaultZone);
  }
  static getStartOfWeek({ locale: e = null, locObj: t = null } = {}) {
    return (t || Locale.create(e)).getStartOfWeek();
  }
  static getMinimumDaysInFirstWeek({ locale: e = null, locObj: t = null } = {}) {
    return (t || Locale.create(e)).getMinDaysInFirstWeek();
  }
  static getWeekendWeekdays({ locale: e = null, locObj: t = null } = {}) {
    return (t || Locale.create(e)).getWeekendDays().slice();
  }
  static months(e = "long", { locale: t = null, numberingSystem: r = null, locObj: n = null, outputCalendar: o = "gregory" } = {}) {
    return (n || Locale.create(t, r, o)).months(e);
  }
  static monthsFormat(e = "long", { locale: t = null, numberingSystem: r = null, locObj: n = null, outputCalendar: o = "gregory" } = {}) {
    return (n || Locale.create(t, r, o)).months(e, true);
  }
  static weekdays(e = "long", { locale: t = null, numberingSystem: r = null, locObj: n = null } = {}) {
    return (n || Locale.create(t, r, null)).weekdays(e);
  }
  static weekdaysFormat(e = "long", { locale: t = null, numberingSystem: r = null, locObj: n = null } = {}) {
    return (n || Locale.create(t, r, null)).weekdays(e, true);
  }
  static meridiems({ locale: e = null } = {}) {
    return Locale.create(e).meridiems();
  }
  static eras(e = "short", { locale: t = null } = {}) {
    return Locale.create(t, null, "gregory").eras(e);
  }
  static features() {
    return { relative: hasRelative(), localeWeek: hasLocaleWeekInfo() };
  }
}
function dayDiff(e, t) {
  const utcDayStart = (e) => e.toUTC(0, { keepLocalTime: true }).startOf("day").valueOf(),
    r = utcDayStart(t) - utcDayStart(e);
  return Math.floor(Duration.fromMillis(r).as("days"));
}
function highOrderDiffs(e, t, r) {
  const n = [
    ["years", (e, t) => t.year - e.year],
    ["quarters", (e, t) => t.quarter - e.quarter + (t.year - e.year) * 4],
    ["months", (e, t) => t.month - e.month + (t.year - e.year) * 12],
    [
      "weeks",
      (e, t) => {
        const r = dayDiff(e, t);
        return (r - (r % 7)) / 7;
      },
    ],
    ["days", dayDiff],
  ];
  const o = {};
  const s = e;
  let i, a;
  for (const [A, c] of n) {
    if (r.indexOf(A) >= 0) {
      i = A;
      o[A] = c(e, t);
      a = s.plus(o);
      if (a > t) {
        o[A]--;
        e = s.plus(o);
        if (e > t) {
          a = e;
          o[A]--;
          e = s.plus(o);
        }
      } else {
        e = a;
      }
    }
  }
  return [e, o, a, i];
}
function diff(e, t, r, n) {
  let [o, s, i, a] = highOrderDiffs(e, t, r);
  const A = t - o;
  const c = r.filter((e) => ["hours", "minutes", "seconds", "milliseconds"].indexOf(e) >= 0);
  if (c.length === 0) {
    if (i < t) {
      i = o.plus({ [a]: 1 });
    }
    if (i !== o) {
      s[a] = (s[a] || 0) + A / (i - o);
    }
  }
  const u = Duration.fromObject(s, n);
  if (c.length > 0) {
    return Duration.fromMillis(A, n)
      .shiftTo(...c)
      .plus(u);
  } else {
    return u;
  }
}
const or = {
  arab: "[٠-٩]",
  arabext: "[۰-۹]",
  bali: "[᭐-᭙]",
  beng: "[০-৯]",
  deva: "[०-९]",
  fullwide: "[０-９]",
  gujr: "[૦-૯]",
  hanidec: "[〇|一|二|三|四|五|六|七|八|九]",
  khmr: "[០-៩]",
  knda: "[೦-೯]",
  laoo: "[໐-໙]",
  limb: "[᥆-᥏]",
  mlym: "[൦-൯]",
  mong: "[᠐-᠙]",
  mymr: "[၀-၉]",
  orya: "[୦-୯]",
  tamldec: "[௦-௯]",
  telu: "[౦-౯]",
  thai: "[๐-๙]",
  tibt: "[༠-༩]",
  latn: "\\d",
};
const sr = {
  arab: [1632, 1641],
  arabext: [1776, 1785],
  bali: [6992, 7001],
  beng: [2534, 2543],
  deva: [2406, 2415],
  fullwide: [65296, 65303],
  gujr: [2790, 2799],
  khmr: [6112, 6121],
  knda: [3302, 3311],
  laoo: [3792, 3801],
  limb: [6470, 6479],
  mlym: [3430, 3439],
  mong: [6160, 6169],
  mymr: [4160, 4169],
  orya: [2918, 2927],
  tamldec: [3046, 3055],
  telu: [3174, 3183],
  thai: [3664, 3673],
  tibt: [3872, 3881],
};
const ir = or.hanidec.replace(/[\[|\]]/g, "").split("");
function parseDigits(e) {
  let t = parseInt(e, 10);
  if (isNaN(t)) {
    t = "";
    for (let r = 0; r < e.length; r++) {
      const n = e.charCodeAt(r);
      if (e[r].search(or.hanidec) !== -1) {
        t += ir.indexOf(e[r]);
      } else {
        for (const e in sr) {
          const [r, o] = sr[e];
          if (n >= r && n <= o) {
            t += n - r;
          }
        }
      }
    }
    return parseInt(t, 10);
  } else {
    return t;
  }
}
function digitRegex({ numberingSystem: e }, t = "") {
  return new RegExp(`${or[e || "latn"]}${t}`);
}
const ar = "missing Intl.DateTimeFormat.formatToParts support";
function intUnit(e, t = (e) => e) {
  return { regex: e, deser: ([e]) => t(parseDigits(e)) };
}
const Ar = String.fromCharCode(160);
const cr = `[ ${Ar}]`;
const ur = new RegExp(cr, "g");
function fixListRegex(e) {
  return e.replace(/\./g, "\\.?").replace(ur, cr);
}
function stripInsensitivities(e) {
  return e.replace(/\./g, "").replace(ur, " ").toLowerCase();
}
function oneOf(e, t) {
  if (e === null) {
    return null;
  } else {
    return { regex: RegExp(e.map(fixListRegex).join("|")), deser: ([r]) => e.findIndex((e) => stripInsensitivities(r) === stripInsensitivities(e)) + t };
  }
}
function offset(e, t) {
  return { regex: e, deser: ([, e, t]) => signedOffset(e, t), groups: t };
}
function simple(e) {
  return { regex: e, deser: ([e]) => e };
}
function escapeToken(e) {
  return e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
}
function unitForToken(e, t) {
  const r = digitRegex(t),
    n = digitRegex(t, "{2}"),
    o = digitRegex(t, "{3}"),
    s = digitRegex(t, "{4}"),
    i = digitRegex(t, "{6}"),
    a = digitRegex(t, "{1,2}"),
    A = digitRegex(t, "{1,3}"),
    c = digitRegex(t, "{1,6}"),
    u = digitRegex(t, "{1,9}"),
    l = digitRegex(t, "{2,4}"),
    p = digitRegex(t, "{4,6}"),
    literal = (e) => ({ regex: RegExp(escapeToken(e.val)), deser: ([e]) => e, literal: true }),
    unitate = (d) => {
      if (e.literal) {
        return literal(d);
      }
      switch (d.val) {
        case "G":
          return oneOf(t.eras("short"), 0);
        case "GG":
          return oneOf(t.eras("long"), 0);
        case "y":
          return intUnit(c);
        case "yy":
          return intUnit(l, untruncateYear);
        case "yyyy":
          return intUnit(s);
        case "yyyyy":
          return intUnit(p);
        case "yyyyyy":
          return intUnit(i);
        case "M":
          return intUnit(a);
        case "MM":
          return intUnit(n);
        case "MMM":
          return oneOf(t.months("short", true), 1);
        case "MMMM":
          return oneOf(t.months("long", true), 1);
        case "L":
          return intUnit(a);
        case "LL":
          return intUnit(n);
        case "LLL":
          return oneOf(t.months("short", false), 1);
        case "LLLL":
          return oneOf(t.months("long", false), 1);
        case "d":
          return intUnit(a);
        case "dd":
          return intUnit(n);
        case "o":
          return intUnit(A);
        case "ooo":
          return intUnit(o);
        case "HH":
          return intUnit(n);
        case "H":
          return intUnit(a);
        case "hh":
          return intUnit(n);
        case "h":
          return intUnit(a);
        case "mm":
          return intUnit(n);
        case "m":
          return intUnit(a);
        case "q":
          return intUnit(a);
        case "qq":
          return intUnit(n);
        case "s":
          return intUnit(a);
        case "ss":
          return intUnit(n);
        case "S":
          return intUnit(A);
        case "SSS":
          return intUnit(o);
        case "u":
          return simple(u);
        case "uu":
          return simple(a);
        case "uuu":
          return intUnit(r);
        case "a":
          return oneOf(t.meridiems(), 0);
        case "kkkk":
          return intUnit(s);
        case "kk":
          return intUnit(l, untruncateYear);
        case "W":
          return intUnit(a);
        case "WW":
          return intUnit(n);
        case "E":
        case "c":
          return intUnit(r);
        case "EEE":
          return oneOf(t.weekdays("short", false), 1);
        case "EEEE":
          return oneOf(t.weekdays("long", false), 1);
        case "ccc":
          return oneOf(t.weekdays("short", true), 1);
        case "cccc":
          return oneOf(t.weekdays("long", true), 1);
        case "Z":
        case "ZZ":
          return offset(new RegExp(`([+-]${a.source})(?::(${n.source}))?`), 2);
        case "ZZZ":
          return offset(new RegExp(`([+-]${a.source})(${n.source})?`), 2);
        case "z":
          return simple(/[a-z_+-/]{1,256}?/i);
        case " ":
          return simple(/[^\S\n\r]/);
        default:
          return literal(d);
      }
    };
  const d = unitate(e) || { invalidReason: ar };
  d.token = e;
  return d;
}
const lr = {
  year: { "2-digit": "yy", numeric: "yyyyy" },
  month: { numeric: "M", "2-digit": "MM", short: "MMM", long: "MMMM" },
  day: { numeric: "d", "2-digit": "dd" },
  weekday: { short: "EEE", long: "EEEE" },
  dayperiod: "a",
  dayPeriod: "a",
  hour12: { numeric: "h", "2-digit": "hh" },
  hour24: { numeric: "H", "2-digit": "HH" },
  minute: { numeric: "m", "2-digit": "mm" },
  second: { numeric: "s", "2-digit": "ss" },
  timeZoneName: { long: "ZZZZZ", short: "ZZZ" },
};
function tokenForPart(e, t, r) {
  const { type: n, value: o } = e;
  if (n === "literal") {
    const e = /^\s+$/.test(o);
    return { literal: !e, val: e ? " " : o };
  }
  const s = t[n];
  let i = n;
  if (n === "hour") {
    if (t.hour12 != null) {
      i = t.hour12 ? "hour12" : "hour24";
    } else if (t.hourCycle != null) {
      if (t.hourCycle === "h11" || t.hourCycle === "h12") {
        i = "hour12";
      } else {
        i = "hour24";
      }
    } else {
      i = r.hour12 ? "hour12" : "hour24";
    }
  }
  let a = lr[i];
  if (typeof a === "object") {
    a = a[s];
  }
  if (a) {
    return { literal: false, val: a };
  }
  return undefined;
}
function buildRegex(e) {
  const t = e.map((e) => e.regex).reduce((e, t) => `${e}(${t.source})`, "");
  return [`^${t}$`, e];
}
function match(e, t, r) {
  const n = e.match(t);
  if (n) {
    const e = {};
    let t = 1;
    for (const o in r) {
      if (util_hasOwnProperty(r, o)) {
        const s = r[o],
          i = s.groups ? s.groups + 1 : 1;
        if (!s.literal && s.token) {
          e[s.token.val[0]] = s.deser(n.slice(t, t + i));
        }
        t += i;
      }
    }
    return [n, e];
  } else {
    return [n, {}];
  }
}
function dateTimeFromMatches(e) {
  const toField = (e) => {
    switch (e) {
      case "S":
        return "millisecond";
      case "s":
        return "second";
      case "m":
        return "minute";
      case "h":
      case "H":
        return "hour";
      case "d":
        return "day";
      case "o":
        return "ordinal";
      case "L":
      case "M":
        return "month";
      case "y":
        return "year";
      case "E":
      case "c":
        return "weekday";
      case "W":
        return "weekNumber";
      case "k":
        return "weekYear";
      case "q":
        return "quarter";
      default:
        return null;
    }
  };
  let t = null;
  let r;
  if (!isUndefined(e.z)) {
    t = IANAZone.create(e.z);
  }
  if (!isUndefined(e.Z)) {
    if (!t) {
      t = new FixedOffsetZone(e.Z);
    }
    r = e.Z;
  }
  if (!isUndefined(e.q)) {
    e.M = (e.q - 1) * 3 + 1;
  }
  if (!isUndefined(e.h)) {
    if (e.h < 12 && e.a === 1) {
      e.h += 12;
    } else if (e.h === 12 && e.a === 0) {
      e.h = 0;
    }
  }
  if (e.G === 0 && e.y) {
    e.y = -e.y;
  }
  if (!isUndefined(e.u)) {
    e.S = parseMillis(e.u);
  }
  const n = Object.keys(e).reduce((t, r) => {
    const n = toField(r);
    if (n) {
      t[n] = e[r];
    }
    return t;
  }, {});
  return [n, t, r];
}
let pr = null;
function getDummyDateTime() {
  if (!pr) {
    pr = DateTime.fromMillis(1555555555555);
  }
  return pr;
}
function maybeExpandMacroToken(e, t) {
  if (e.literal) {
    return e;
  }
  const r = Formatter.macroTokenToFormatOpts(e.val);
  const n = formatOptsToTokens(r, t);
  if (n == null || n.includes(undefined)) {
    return e;
  }
  return n;
}
function expandMacroTokens(e, t) {
  return Array.prototype.concat(...e.map((e) => maybeExpandMacroToken(e, t)));
}
function explainFromTokens(e, t, r) {
  const n = expandMacroTokens(Formatter.parseFormat(r), e),
    o = n.map((t) => unitForToken(t, e)),
    s = o.find((e) => e.invalidReason);
  if (s) {
    return { input: t, tokens: n, invalidReason: s.invalidReason };
  } else {
    const [e, r] = buildRegex(o),
      s = RegExp(e, "i"),
      [i, a] = match(t, s, r),
      [A, c, u] = a ? dateTimeFromMatches(a) : [null, null, undefined];
    if (util_hasOwnProperty(a, "a") && util_hasOwnProperty(a, "H")) {
      throw new ConflictingSpecificationError("Can't include meridiem when specifying 24-hour format");
    }
    return { input: t, tokens: n, regex: s, rawMatches: i, matches: a, result: A, zone: c, specificOffset: u };
  }
}
function parseFromTokens(e, t, r) {
  const { result: n, zone: o, specificOffset: s, invalidReason: i } = explainFromTokens(e, t, r);
  return [n, o, s, i];
}
function formatOptsToTokens(e, t) {
  if (!e) {
    return null;
  }
  const r = Formatter.create(t, e);
  const n = r.dtFormatter(getDummyDateTime());
  const o = n.formatToParts();
  const s = n.resolvedOptions();
  return o.map((t) => tokenForPart(t, e, s));
}
const dr = "Invalid DateTime";
const fr = 864e13;
function unsupportedZone(e) {
  return new Invalid("unsupported zone", `the zone "${e.name}" is not supported`);
}
function possiblyCachedWeekData(e) {
  if (e.weekData === null) {
    e.weekData = gregorianToWeek(e.c);
  }
  return e.weekData;
}
function possiblyCachedLocalWeekData(e) {
  if (e.localWeekData === null) {
    e.localWeekData = gregorianToWeek(e.c, e.loc.getMinDaysInFirstWeek(), e.loc.getStartOfWeek());
  }
  return e.localWeekData;
}
function datetime_clone(e, t) {
  const r = { ts: e.ts, zone: e.zone, c: e.c, o: e.o, loc: e.loc, invalid: e.invalid };
  return new DateTime({ ...r, ...t, old: r });
}
function fixOffset(e, t, r) {
  let n = e - t * 60 * 1e3;
  const o = r.offset(n);
  if (t === o) {
    return [n, t];
  }
  n -= (o - t) * 60 * 1e3;
  const s = r.offset(n);
  if (o === s) {
    return [n, o];
  }
  return [e - Math.min(o, s) * 60 * 1e3, Math.max(o, s)];
}
function tsToObj(e, t) {
  e += t * 60 * 1e3;
  const r = new Date(e);
  return {
    year: r.getUTCFullYear(),
    month: r.getUTCMonth() + 1,
    day: r.getUTCDate(),
    hour: r.getUTCHours(),
    minute: r.getUTCMinutes(),
    second: r.getUTCSeconds(),
    millisecond: r.getUTCMilliseconds(),
  };
}
function objToTS(e, t, r) {
  return fixOffset(objToLocalTS(e), t, r);
}
function adjustTime(e, t) {
  const r = e.o,
    n = e.c.year + Math.trunc(t.years),
    o = e.c.month + Math.trunc(t.months) + Math.trunc(t.quarters) * 3,
    s = { ...e.c, year: n, month: o, day: Math.min(e.c.day, daysInMonth(n, o)) + Math.trunc(t.days) + Math.trunc(t.weeks) * 7 },
    i = Duration.fromObject({
      years: t.years - Math.trunc(t.years),
      quarters: t.quarters - Math.trunc(t.quarters),
      months: t.months - Math.trunc(t.months),
      weeks: t.weeks - Math.trunc(t.weeks),
      days: t.days - Math.trunc(t.days),
      hours: t.hours,
      minutes: t.minutes,
      seconds: t.seconds,
      milliseconds: t.milliseconds,
    }).as("milliseconds"),
    a = objToLocalTS(s);
  let [A, c] = fixOffset(a, r, e.zone);
  if (i !== 0) {
    A += i;
    c = e.zone.offset(A);
  }
  return { ts: A, o: c };
}
function parseDataToDateTime(e, t, r, n, o, s) {
  const { setZone: i, zone: a } = r;
  if ((e && Object.keys(e).length !== 0) || t) {
    const n = t || a,
      o = DateTime.fromObject(e, { ...r, zone: n, specificOffset: s });
    return i ? o : o.setZone(a);
  } else {
    return DateTime.invalid(new Invalid("unparsable", `the input "${o}" can't be parsed as ${n}`));
  }
}
function toTechFormat(e, t, r = true) {
  return e.isValid ? Formatter.create(Locale.create("en-US"), { allowZ: r, forceSimple: true }).formatDateTimeFromString(e, t) : null;
}
function toISODate(e, t) {
  const r = e.c.year > 9999 || e.c.year < 0;
  let n = "";
  if (r && e.c.year >= 0) n += "+";
  n += padStart(e.c.year, r ? 6 : 4);
  if (t) {
    n += "-";
    n += padStart(e.c.month);
    n += "-";
    n += padStart(e.c.day);
  } else {
    n += padStart(e.c.month);
    n += padStart(e.c.day);
  }
  return n;
}
function toISOTime(e, t, r, n, o, s) {
  let i = padStart(e.c.hour);
  if (t) {
    i += ":";
    i += padStart(e.c.minute);
    if (e.c.millisecond !== 0 || e.c.second !== 0 || !r) {
      i += ":";
    }
  } else {
    i += padStart(e.c.minute);
  }
  if (e.c.millisecond !== 0 || e.c.second !== 0 || !r) {
    i += padStart(e.c.second);
    if (e.c.millisecond !== 0 || !n) {
      i += ".";
      i += padStart(e.c.millisecond, 3);
    }
  }
  if (o) {
    if (e.isOffsetFixed && e.offset === 0 && !s) {
      i += "Z";
    } else if (e.o < 0) {
      i += "-";
      i += padStart(Math.trunc(-e.o / 60));
      i += ":";
      i += padStart(Math.trunc(-e.o % 60));
    } else {
      i += "+";
      i += padStart(Math.trunc(e.o / 60));
      i += ":";
      i += padStart(Math.trunc(e.o % 60));
    }
  }
  if (s) {
    i += "[" + e.zone.ianaName + "]";
  }
  return i;
}
const gr = { month: 1, day: 1, hour: 0, minute: 0, second: 0, millisecond: 0 },
  mr = { weekNumber: 1, weekday: 1, hour: 0, minute: 0, second: 0, millisecond: 0 },
  hr = { ordinal: 1, hour: 0, minute: 0, second: 0, millisecond: 0 };
const Er = ["year", "month", "day", "hour", "minute", "second", "millisecond"],
  Ir = ["weekYear", "weekNumber", "weekday", "hour", "minute", "second", "millisecond"],
  yr = ["year", "ordinal", "hour", "minute", "second", "millisecond"];
function normalizeUnit(e) {
  const t = {
    year: "year",
    years: "year",
    month: "month",
    months: "month",
    day: "day",
    days: "day",
    hour: "hour",
    hours: "hour",
    minute: "minute",
    minutes: "minute",
    quarter: "quarter",
    quarters: "quarter",
    second: "second",
    seconds: "second",
    millisecond: "millisecond",
    milliseconds: "millisecond",
    weekday: "weekday",
    weekdays: "weekday",
    weeknumber: "weekNumber",
    weeksnumber: "weekNumber",
    weeknumbers: "weekNumber",
    weekyear: "weekYear",
    weekyears: "weekYear",
    ordinal: "ordinal",
  }[e.toLowerCase()];
  if (!t) throw new InvalidUnitError(e);
  return t;
}
function normalizeUnitWithLocalWeeks(e) {
  switch (e.toLowerCase()) {
    case "localweekday":
    case "localweekdays":
      return "localWeekday";
    case "localweeknumber":
    case "localweeknumbers":
      return "localWeekNumber";
    case "localweekyear":
    case "localweekyears":
      return "localWeekYear";
    default:
      return normalizeUnit(e);
  }
}
function quickDT(e, t) {
  const r = normalizeZone(t.zone, Settings.defaultZone),
    n = Locale.fromObject(t),
    o = Settings.now();
  let s, i;
  if (!isUndefined(e.year)) {
    for (const t of Er) {
      if (isUndefined(e[t])) {
        e[t] = gr[t];
      }
    }
    const t = hasInvalidGregorianData(e) || hasInvalidTimeData(e);
    if (t) {
      return DateTime.invalid(t);
    }
    const n = r.offset(o);
    [s, i] = objToTS(e, n, r);
  } else {
    s = o;
  }
  return new DateTime({ ts: s, zone: r, loc: n, o: i });
}
function diffRelative(e, t, r) {
  const n = isUndefined(r.round) ? true : r.round,
    format = (e, o) => {
      e = roundTo(e, n || r.calendary ? 0 : 2, true);
      const s = t.loc.clone(r).relFormatter(r);
      return s.format(e, o);
    },
    differ = (n) => {
      if (r.calendary) {
        if (!t.hasSame(e, n)) {
          return t.startOf(n).diff(e.startOf(n), n).get(n);
        } else return 0;
      } else {
        return t.diff(e, n).get(n);
      }
    };
  if (r.unit) {
    return format(differ(r.unit), r.unit);
  }
  for (const e of r.units) {
    const t = differ(e);
    if (Math.abs(t) >= 1) {
      return format(t, e);
    }
  }
  return format(e > t ? -0 : 0, r.units[r.units.length - 1]);
}
function lastOpts(e) {
  let t = {},
    r;
  if (e.length > 0 && typeof e[e.length - 1] === "object") {
    t = e[e.length - 1];
    r = Array.from(e).slice(0, e.length - 1);
  } else {
    r = Array.from(e);
  }
  return [t, r];
}
class DateTime {
  constructor(e) {
    const t = e.zone || Settings.defaultZone;
    let r = e.invalid || (Number.isNaN(e.ts) ? new Invalid("invalid input") : null) || (!t.isValid ? unsupportedZone(t) : null);
    this.ts = isUndefined(e.ts) ? Settings.now() : e.ts;
    let n = null,
      o = null;
    if (!r) {
      const s = e.old && e.old.ts === this.ts && e.old.zone.equals(t);
      if (s) {
        [n, o] = [e.old.c, e.old.o];
      } else {
        const e = t.offset(this.ts);
        n = tsToObj(this.ts, e);
        r = Number.isNaN(n.year) ? new Invalid("invalid input") : null;
        n = r ? null : n;
        o = r ? null : e;
      }
    }
    this._zone = t;
    this.loc = e.loc || Locale.create();
    this.invalid = r;
    this.weekData = null;
    this.localWeekData = null;
    this.c = n;
    this.o = o;
    this.isLuxonDateTime = true;
  }
  static now() {
    return new DateTime({});
  }
  static local() {
    const [e, t] = lastOpts(arguments),
      [r, n, o, s, i, a, A] = t;
    return quickDT({ year: r, month: n, day: o, hour: s, minute: i, second: a, millisecond: A }, e);
  }
  static utc() {
    const [e, t] = lastOpts(arguments),
      [r, n, o, s, i, a, A] = t;
    e.zone = FixedOffsetZone.utcInstance;
    return quickDT({ year: r, month: n, day: o, hour: s, minute: i, second: a, millisecond: A }, e);
  }
  static fromJSDate(e, t = {}) {
    const r = isDate(e) ? e.valueOf() : NaN;
    if (Number.isNaN(r)) {
      return DateTime.invalid("invalid input");
    }
    const n = normalizeZone(t.zone, Settings.defaultZone);
    if (!n.isValid) {
      return DateTime.invalid(unsupportedZone(n));
    }
    return new DateTime({ ts: r, zone: n, loc: Locale.fromObject(t) });
  }
  static fromMillis(e, t = {}) {
    if (!isNumber(e)) {
      throw new InvalidArgumentError(`fromMillis requires a numerical input, but received a ${typeof e} with value ${e}`);
    } else if (e < -fr || e > fr) {
      return DateTime.invalid("Timestamp out of range");
    } else {
      return new DateTime({ ts: e, zone: normalizeZone(t.zone, Settings.defaultZone), loc: Locale.fromObject(t) });
    }
  }
  static fromSeconds(e, t = {}) {
    if (!isNumber(e)) {
      throw new InvalidArgumentError("fromSeconds requires a numerical input");
    } else {
      return new DateTime({ ts: e * 1e3, zone: normalizeZone(t.zone, Settings.defaultZone), loc: Locale.fromObject(t) });
    }
  }
  static fromObject(e, t = {}) {
    e = e || {};
    const r = normalizeZone(t.zone, Settings.defaultZone);
    if (!r.isValid) {
      return DateTime.invalid(unsupportedZone(r));
    }
    const n = Locale.fromObject(t);
    const o = normalizeObject(e, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek: s, startOfWeek: i } = usesLocalWeekValues(o, n);
    const a = Settings.now(),
      A = !isUndefined(t.specificOffset) ? t.specificOffset : r.offset(a),
      c = !isUndefined(o.ordinal),
      u = !isUndefined(o.year),
      l = !isUndefined(o.month) || !isUndefined(o.day),
      p = u || l,
      d = o.weekYear || o.weekNumber;
    if ((p || c) && d) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (l && c) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    const g = d || (o.weekday && !p);
    let m,
      h,
      E = tsToObj(a, A);
    if (g) {
      m = Ir;
      h = mr;
      E = gregorianToWeek(E, s, i);
    } else if (c) {
      m = yr;
      h = hr;
      E = gregorianToOrdinal(E);
    } else {
      m = Er;
      h = gr;
    }
    let I = false;
    for (const e of m) {
      const t = o[e];
      if (!isUndefined(t)) {
        I = true;
      } else if (I) {
        o[e] = h[e];
      } else {
        o[e] = E[e];
      }
    }
    const y = g ? hasInvalidWeekData(o, s, i) : c ? hasInvalidOrdinalData(o) : hasInvalidGregorianData(o),
      C = y || hasInvalidTimeData(o);
    if (C) {
      return DateTime.invalid(C);
    }
    const b = g ? weekToGregorian(o, s, i) : c ? ordinalToGregorian(o) : o,
      [Q, B] = objToTS(b, A, r),
      T = new DateTime({ ts: Q, zone: r, o: B, loc: n });
    if (o.weekday && p && e.weekday !== T.weekday) {
      return DateTime.invalid("mismatched weekday", `you can't specify both a weekday of ${o.weekday} and a date of ${T.toISO()}`);
    }
    return T;
  }
  static fromISO(e, t = {}) {
    const [r, n] = parseISODate(e);
    return parseDataToDateTime(r, n, t, "ISO 8601", e);
  }
  static fromRFC2822(e, t = {}) {
    const [r, n] = parseRFC2822Date(e);
    return parseDataToDateTime(r, n, t, "RFC 2822", e);
  }
  static fromHTTP(e, t = {}) {
    const [r, n] = parseHTTPDate(e);
    return parseDataToDateTime(r, n, t, "HTTP", t);
  }
  static fromFormat(e, t, r = {}) {
    if (isUndefined(e) || isUndefined(t)) {
      throw new InvalidArgumentError("fromFormat requires an input string and a format");
    }
    const { locale: n = null, numberingSystem: o = null } = r,
      s = Locale.fromOpts({ locale: n, numberingSystem: o, defaultToEN: true }),
      [i, a, A, c] = parseFromTokens(s, e, t);
    if (c) {
      return DateTime.invalid(c);
    } else {
      return parseDataToDateTime(i, a, r, `format ${t}`, e, A);
    }
  }
  static fromString(e, t, r = {}) {
    return DateTime.fromFormat(e, t, r);
  }
  static fromSQL(e, t = {}) {
    const [r, n] = parseSQL(e);
    return parseDataToDateTime(r, n, t, "SQL", e);
  }
  static invalid(e, t = null) {
    if (!e) {
      throw new InvalidArgumentError("need to specify a reason the DateTime is invalid");
    }
    const r = e instanceof Invalid ? e : new Invalid(e, t);
    if (Settings.throwOnInvalid) {
      throw new InvalidDateTimeError(r);
    } else {
      return new DateTime({ invalid: r });
    }
  }
  static isDateTime(e) {
    return (e && e.isLuxonDateTime) || false;
  }
  static parseFormatForOpts(e, t = {}) {
    const r = formatOptsToTokens(e, Locale.fromObject(t));
    return !r ? null : r.map((e) => (e ? e.val : null)).join("");
  }
  static expandFormat(e, t = {}) {
    const r = expandMacroTokens(Formatter.parseFormat(e), Locale.fromObject(t));
    return r.map((e) => e.val).join("");
  }
  get(e) {
    return this[e];
  }
  get isValid() {
    return this.invalid === null;
  }
  get invalidReason() {
    return this.invalid ? this.invalid.reason : null;
  }
  get invalidExplanation() {
    return this.invalid ? this.invalid.explanation : null;
  }
  get locale() {
    return this.isValid ? this.loc.locale : null;
  }
  get numberingSystem() {
    return this.isValid ? this.loc.numberingSystem : null;
  }
  get outputCalendar() {
    return this.isValid ? this.loc.outputCalendar : null;
  }
  get zone() {
    return this._zone;
  }
  get zoneName() {
    return this.isValid ? this.zone.name : null;
  }
  get year() {
    return this.isValid ? this.c.year : NaN;
  }
  get quarter() {
    return this.isValid ? Math.ceil(this.c.month / 3) : NaN;
  }
  get month() {
    return this.isValid ? this.c.month : NaN;
  }
  get day() {
    return this.isValid ? this.c.day : NaN;
  }
  get hour() {
    return this.isValid ? this.c.hour : NaN;
  }
  get minute() {
    return this.isValid ? this.c.minute : NaN;
  }
  get second() {
    return this.isValid ? this.c.second : NaN;
  }
  get millisecond() {
    return this.isValid ? this.c.millisecond : NaN;
  }
  get weekYear() {
    return this.isValid ? possiblyCachedWeekData(this).weekYear : NaN;
  }
  get weekNumber() {
    return this.isValid ? possiblyCachedWeekData(this).weekNumber : NaN;
  }
  get weekday() {
    return this.isValid ? possiblyCachedWeekData(this).weekday : NaN;
  }
  get isWeekend() {
    return this.isValid && this.loc.getWeekendDays().includes(this.weekday);
  }
  get localWeekday() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekday : NaN;
  }
  get localWeekNumber() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekNumber : NaN;
  }
  get localWeekYear() {
    return this.isValid ? possiblyCachedLocalWeekData(this).weekYear : NaN;
  }
  get ordinal() {
    return this.isValid ? gregorianToOrdinal(this.c).ordinal : NaN;
  }
  get monthShort() {
    return this.isValid ? Info.months("short", { locObj: this.loc })[this.month - 1] : null;
  }
  get monthLong() {
    return this.isValid ? Info.months("long", { locObj: this.loc })[this.month - 1] : null;
  }
  get weekdayShort() {
    return this.isValid ? Info.weekdays("short", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get weekdayLong() {
    return this.isValid ? Info.weekdays("long", { locObj: this.loc })[this.weekday - 1] : null;
  }
  get offset() {
    return this.isValid ? +this.o : NaN;
  }
  get offsetNameShort() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, { format: "short", locale: this.locale });
    } else {
      return null;
    }
  }
  get offsetNameLong() {
    if (this.isValid) {
      return this.zone.offsetName(this.ts, { format: "long", locale: this.locale });
    } else {
      return null;
    }
  }
  get isOffsetFixed() {
    return this.isValid ? this.zone.isUniversal : null;
  }
  get isInDST() {
    if (this.isOffsetFixed) {
      return false;
    } else {
      return this.offset > this.set({ month: 1, day: 1 }).offset || this.offset > this.set({ month: 5 }).offset;
    }
  }
  getPossibleOffsets() {
    if (!this.isValid || this.isOffsetFixed) {
      return [this];
    }
    const e = 864e5;
    const t = 6e4;
    const r = objToLocalTS(this.c);
    const n = this.zone.offset(r - e);
    const o = this.zone.offset(r + e);
    const s = this.zone.offset(r - n * t);
    const i = this.zone.offset(r - o * t);
    if (s === i) {
      return [this];
    }
    const a = r - s * t;
    const A = r - i * t;
    const c = tsToObj(a, s);
    const u = tsToObj(A, i);
    if (c.hour === u.hour && c.minute === u.minute && c.second === u.second && c.millisecond === u.millisecond) {
      return [datetime_clone(this, { ts: a }), datetime_clone(this, { ts: A })];
    }
    return [this];
  }
  get isInLeapYear() {
    return isLeapYear(this.year);
  }
  get daysInMonth() {
    return daysInMonth(this.year, this.month);
  }
  get daysInYear() {
    return this.isValid ? daysInYear(this.year) : NaN;
  }
  get weeksInWeekYear() {
    return this.isValid ? weeksInWeekYear(this.weekYear) : NaN;
  }
  get weeksInLocalWeekYear() {
    return this.isValid ? weeksInWeekYear(this.localWeekYear, this.loc.getMinDaysInFirstWeek(), this.loc.getStartOfWeek()) : NaN;
  }
  resolvedLocaleOptions(e = {}) {
    const { locale: t, numberingSystem: r, calendar: n } = Formatter.create(this.loc.clone(e), e).resolvedOptions(this);
    return { locale: t, numberingSystem: r, outputCalendar: n };
  }
  toUTC(e = 0, t = {}) {
    return this.setZone(FixedOffsetZone.instance(e), t);
  }
  toLocal() {
    return this.setZone(Settings.defaultZone);
  }
  setZone(e, { keepLocalTime: t = false, keepCalendarTime: r = false } = {}) {
    e = normalizeZone(e, Settings.defaultZone);
    if (e.equals(this.zone)) {
      return this;
    } else if (!e.isValid) {
      return DateTime.invalid(unsupportedZone(e));
    } else {
      let n = this.ts;
      if (t || r) {
        const t = e.offset(this.ts);
        const r = this.toObject();
        [n] = objToTS(r, t, e);
      }
      return datetime_clone(this, { ts: n, zone: e });
    }
  }
  reconfigure({ locale: e, numberingSystem: t, outputCalendar: r } = {}) {
    const n = this.loc.clone({ locale: e, numberingSystem: t, outputCalendar: r });
    return datetime_clone(this, { loc: n });
  }
  setLocale(e) {
    return this.reconfigure({ locale: e });
  }
  set(e) {
    if (!this.isValid) return this;
    const t = normalizeObject(e, normalizeUnitWithLocalWeeks);
    const { minDaysInFirstWeek: r, startOfWeek: n } = usesLocalWeekValues(t, this.loc);
    const o = !isUndefined(t.weekYear) || !isUndefined(t.weekNumber) || !isUndefined(t.weekday),
      s = !isUndefined(t.ordinal),
      i = !isUndefined(t.year),
      a = !isUndefined(t.month) || !isUndefined(t.day),
      A = i || a,
      c = t.weekYear || t.weekNumber;
    if ((A || s) && c) {
      throw new ConflictingSpecificationError("Can't mix weekYear/weekNumber units with year/month/day or ordinals");
    }
    if (a && s) {
      throw new ConflictingSpecificationError("Can't mix ordinal dates with month/day");
    }
    let u;
    if (o) {
      u = weekToGregorian({ ...gregorianToWeek(this.c, r, n), ...t }, r, n);
    } else if (!isUndefined(t.ordinal)) {
      u = ordinalToGregorian({ ...gregorianToOrdinal(this.c), ...t });
    } else {
      u = { ...this.toObject(), ...t };
      if (isUndefined(t.day)) {
        u.day = Math.min(daysInMonth(u.year, u.month), u.day);
      }
    }
    const [l, p] = objToTS(u, this.o, this.zone);
    return datetime_clone(this, { ts: l, o: p });
  }
  plus(e) {
    if (!this.isValid) return this;
    const t = Duration.fromDurationLike(e);
    return datetime_clone(this, adjustTime(this, t));
  }
  minus(e) {
    if (!this.isValid) return this;
    const t = Duration.fromDurationLike(e).negate();
    return datetime_clone(this, adjustTime(this, t));
  }
  startOf(e, { useLocaleWeeks: t = false } = {}) {
    if (!this.isValid) return this;
    const r = {},
      n = Duration.normalizeUnit(e);
    switch (n) {
      case "years":
        r.month = 1;
      case "quarters":
      case "months":
        r.day = 1;
      case "weeks":
      case "days":
        r.hour = 0;
      case "hours":
        r.minute = 0;
      case "minutes":
        r.second = 0;
      case "seconds":
        r.millisecond = 0;
        break;
      case "milliseconds":
        break;
    }
    if (n === "weeks") {
      if (t) {
        const e = this.loc.getStartOfWeek();
        const { weekday: t } = this;
        if (t < e) {
          r.weekNumber = this.weekNumber - 1;
        }
        r.weekday = e;
      } else {
        r.weekday = 1;
      }
    }
    if (n === "quarters") {
      const e = Math.ceil(this.month / 3);
      r.month = (e - 1) * 3 + 1;
    }
    return this.set(r);
  }
  endOf(e, t) {
    return this.isValid
      ? this.plus({ [e]: 1 })
          .startOf(e, t)
          .minus(1)
      : this;
  }
  toFormat(e, t = {}) {
    return this.isValid ? Formatter.create(this.loc.redefaultToEN(t)).formatDateTimeFromString(this, e) : dr;
  }
  toLocaleString(e = me, t = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(t), e).formatDateTime(this) : dr;
  }
  toLocaleParts(e = {}) {
    return this.isValid ? Formatter.create(this.loc.clone(e), e).formatDateTimeParts(this) : [];
  }
  toISO({ format: e = "extended", suppressSeconds: t = false, suppressMilliseconds: r = false, includeOffset: n = true, extendedZone: o = false } = {}) {
    if (!this.isValid) {
      return null;
    }
    const s = e === "extended";
    let i = toISODate(this, s);
    i += "T";
    i += toISOTime(this, s, t, r, n, o);
    return i;
  }
  toISODate({ format: e = "extended" } = {}) {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, e === "extended");
  }
  toISOWeekDate() {
    return toTechFormat(this, "kkkk-'W'WW-c");
  }
  toISOTime({
    suppressMilliseconds: e = false,
    suppressSeconds: t = false,
    includeOffset: r = true,
    includePrefix: n = false,
    extendedZone: o = false,
    format: s = "extended",
  } = {}) {
    if (!this.isValid) {
      return null;
    }
    let i = n ? "T" : "";
    return i + toISOTime(this, s === "extended", t, e, r, o);
  }
  toRFC2822() {
    return toTechFormat(this, "EEE, dd LLL yyyy HH:mm:ss ZZZ", false);
  }
  toHTTP() {
    return toTechFormat(this.toUTC(), "EEE, dd LLL yyyy HH:mm:ss 'GMT'");
  }
  toSQLDate() {
    if (!this.isValid) {
      return null;
    }
    return toISODate(this, true);
  }
  toSQLTime({ includeOffset: e = true, includeZone: t = false, includeOffsetSpace: r = true } = {}) {
    let n = "HH:mm:ss.SSS";
    if (t || e) {
      if (r) {
        n += " ";
      }
      if (t) {
        n += "z";
      } else if (e) {
        n += "ZZ";
      }
    }
    return toTechFormat(this, n, true);
  }
  toSQL(e = {}) {
    if (!this.isValid) {
      return null;
    }
    return `${this.toSQLDate()} ${this.toSQLTime(e)}`;
  }
  toString() {
    return this.isValid ? this.toISO() : dr;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    if (this.isValid) {
      return `DateTime { ts: ${this.toISO()}, zone: ${this.zone.name}, locale: ${this.locale} }`;
    } else {
      return `DateTime { Invalid, reason: ${this.invalidReason} }`;
    }
  }
  valueOf() {
    return this.toMillis();
  }
  toMillis() {
    return this.isValid ? this.ts : NaN;
  }
  toSeconds() {
    return this.isValid ? this.ts / 1e3 : NaN;
  }
  toUnixInteger() {
    return this.isValid ? Math.floor(this.ts / 1e3) : NaN;
  }
  toJSON() {
    return this.toISO();
  }
  toBSON() {
    return this.toJSDate();
  }
  toObject(e = {}) {
    if (!this.isValid) return {};
    const t = { ...this.c };
    if (e.includeConfig) {
      t.outputCalendar = this.outputCalendar;
      t.numberingSystem = this.loc.numberingSystem;
      t.locale = this.loc.locale;
    }
    return t;
  }
  toJSDate() {
    return new Date(this.isValid ? this.ts : NaN);
  }
  diff(e, t = "milliseconds", r = {}) {
    if (!this.isValid || !e.isValid) {
      return Duration.invalid("created by diffing an invalid DateTime");
    }
    const n = { locale: this.locale, numberingSystem: this.numberingSystem, ...r };
    const o = maybeArray(t).map(Duration.normalizeUnit),
      s = e.valueOf() > this.valueOf(),
      i = s ? this : e,
      a = s ? e : this,
      A = diff(i, a, o, n);
    return s ? A.negate() : A;
  }
  diffNow(e = "milliseconds", t = {}) {
    return this.diff(DateTime.now(), e, t);
  }
  until(e) {
    return this.isValid ? Interval.fromDateTimes(this, e) : this;
  }
  hasSame(e, t, r) {
    if (!this.isValid) return false;
    const n = e.valueOf();
    const o = this.setZone(e.zone, { keepLocalTime: true });
    return o.startOf(t, r) <= n && n <= o.endOf(t, r);
  }
  equals(e) {
    return this.isValid && e.isValid && this.valueOf() === e.valueOf() && this.zone.equals(e.zone) && this.loc.equals(e.loc);
  }
  toRelative(e = {}) {
    if (!this.isValid) return null;
    const t = e.base || DateTime.fromObject({}, { zone: this.zone }),
      r = e.padding ? (this < t ? -e.padding : e.padding) : 0;
    let n = ["years", "months", "days", "hours", "minutes", "seconds"];
    let o = e.unit;
    if (Array.isArray(e.unit)) {
      n = e.unit;
      o = undefined;
    }
    return diffRelative(t, this.plus(r), { ...e, numeric: "always", units: n, unit: o });
  }
  toRelativeCalendar(e = {}) {
    if (!this.isValid) return null;
    return diffRelative(e.base || DateTime.fromObject({}, { zone: this.zone }), this, {
      ...e,
      numeric: "auto",
      units: ["years", "months", "days"],
      calendary: true,
    });
  }
  static min(...e) {
    if (!e.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("min requires all arguments be DateTimes");
    }
    return bestBy(e, (e) => e.valueOf(), Math.min);
  }
  static max(...e) {
    if (!e.every(DateTime.isDateTime)) {
      throw new InvalidArgumentError("max requires all arguments be DateTimes");
    }
    return bestBy(e, (e) => e.valueOf(), Math.max);
  }
  static fromFormatExplain(e, t, r = {}) {
    const { locale: n = null, numberingSystem: o = null } = r,
      s = Locale.fromOpts({ locale: n, numberingSystem: o, defaultToEN: true });
    return explainFromTokens(s, e, t);
  }
  static fromStringExplain(e, t, r = {}) {
    return DateTime.fromFormatExplain(e, t, r);
  }
  static get DATE_SHORT() {
    return me;
  }
  static get DATE_MED() {
    return he;
  }
  static get DATE_MED_WITH_WEEKDAY() {
    return Ee;
  }
  static get DATE_FULL() {
    return Ie;
  }
  static get DATE_HUGE() {
    return ye;
  }
  static get TIME_SIMPLE() {
    return Ce;
  }
  static get TIME_WITH_SECONDS() {
    return be;
  }
  static get TIME_WITH_SHORT_OFFSET() {
    return Qe;
  }
  static get TIME_WITH_LONG_OFFSET() {
    return Be;
  }
  static get TIME_24_SIMPLE() {
    return Te;
  }
  static get TIME_24_WITH_SECONDS() {
    return ve;
  }
  static get TIME_24_WITH_SHORT_OFFSET() {
    return we;
  }
  static get TIME_24_WITH_LONG_OFFSET() {
    return _e;
  }
  static get DATETIME_SHORT() {
    return Re;
  }
  static get DATETIME_SHORT_WITH_SECONDS() {
    return Oe;
  }
  static get DATETIME_MED() {
    return Fe;
  }
  static get DATETIME_MED_WITH_SECONDS() {
    return De;
  }
  static get DATETIME_MED_WITH_WEEKDAY() {
    return ke;
  }
  static get DATETIME_FULL() {
    return Se;
  }
  static get DATETIME_FULL_WITH_SECONDS() {
    return Ne;
  }
  static get DATETIME_HUGE() {
    return Pe;
  }
  static get DATETIME_HUGE_WITH_SECONDS() {
    return Le;
  }
}
function friendlyDateTime(e) {
  if (DateTime.isDateTime(e)) {
    return e;
  } else if (e && e.valueOf && isNumber(e.valueOf())) {
    return DateTime.fromJSDate(e);
  } else if (e && typeof e === "object") {
    return DateTime.fromObject(e);
  } else {
    throw new InvalidArgumentError(`Unknown datetime argument: ${e}, of type ${typeof e}`);
  }
}
const Cr = "3.4.4";
function parseIssueUrl(e) {
  const t = new URL(e).pathname.split("/");
  if (t.length !== 5) {
    throw new Error(`[parseGitHubUrl] Invalid url: [${e}]`);
  }
  return { owner: t[1], repo: t[2], issue_number: Number(t[4]) };
}
function createStructuredMetadata(e, t) {
  let r, n;
  if (t) {
    r = t.logMessage;
    n = t.metadata;
  }
  const o = JSON.stringify(n, null, 2);
  const s = new Error().stack?.split("\n")[2] ?? "";
  const i = s.match(/at (\S+)/)?.[1] ?? "";
  const a = `\x3c!-- Ubiquity - ${e} - ${i} - ${n?.revision}`;
  let A;
  const c = ["```json", o, "```"].join("\n");
  const u = [a, o, "--\x3e"].join("\n");
  if (r?.type === "fatal") {
    A = [c, u].join("\n");
  } else {
    A = u;
  }
  return A;
}
async function unassignUserFromIssue(e, t) {
  const { logger: r, config: n } = e;
  if (n.disqualification <= 0) {
    r.info("The unassign threshold is <= 0, won't unassign users.");
  } else {
    r.info(`Passed the deadline on ${t.html_url} and no activity is detected, removing assignees.`);
    await removeAllAssignees(e, t);
  }
}
async function remindAssigneesForIssue(e, t) {
  const { logger: r, config: n } = e;
  if (n.warning <= 0) {
    r.info("The reminder threshold is <= 0, won't send any reminder.");
  } else {
    r.info(`Passed the reminder threshold on ${t.html_url}, sending a reminder.`);
    await remindAssignees(e, t);
  }
}
async function remindAssignees(e, t) {
  const { octokit: r, logger: n } = e;
  const { repo: o, owner: s, issue_number: i } = parseIssueUrl(t.html_url);
  if (!t?.assignees?.length) {
    n.error(`Missing Assignees from ${t.html_url}`);
    return false;
  }
  const a = t.assignees
    .map((e) => e?.login)
    .filter((e) => !!e)
    .join(", @");
  const A = n.info(`@${a}, this task has been idle for a while. Please provide an update.\n\n`, { taskAssignees: t.assignees.map((e) => e?.id) });
  const c = createStructuredMetadata("Followup", A);
  await r.rest.issues.createComment({ owner: s, repo: o, issue_number: i, body: [A.logMessage.raw, c].join("\n") });
  return true;
}
async function removeAllAssignees(e, t) {
  const { octokit: r, logger: n } = e;
  const { repo: o, owner: s, issue_number: i } = parseIssueUrl(t.html_url);
  if (!t?.assignees?.length) {
    n.error(`Missing Assignees from ${t.html_url}`);
    return false;
  }
  const a = t.assignees.map((e) => e?.login).filter((e) => !!e);
  await r.rest.issues.removeAssignees({ owner: s, repo: o, issue_number: i, assignees: a });
  return true;
}
const br = e(import.meta.url)("node:fs");
var Qr = __nccwpck_require__(28422);
var Br = __nccwpck_require__(31970);
const Tr = validateQuery;
const vr = (0, Qr.buildClientSchema)(JSON.parse((0, br.readFileSync)(__nccwpck_require__.ab + "schema.json", "utf8")));
function validateQuery(e) {
  return (0, Qr.validate)(vr, Br(e));
}
const wr = `\n  query collectLinkedPullRequests($owner: String!, $repo: String!, $issue_number: Int!) {\n    repository(owner: $owner, name: $repo) {\n      issue(number: $issue_number) {\n        closedByPullRequestsReferences(first: 100, includeClosedPrs: true) {\n          edges {\n            node {\n              url\n              title\n              body\n              state\n              number\n              author {\n                login\n                ... on User {\n                  id: databaseId\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n`;
const _r = Tr(wr);
if (_r.length > 1) {
  throw new Error(`Invalid query: ${_r.join(", ")}`);
}
async function collectLinkedPullRequests(e, t) {
  const { owner: r, repo: n, issue_number: o } = t;
  const s = await e.octokit.graphql(wr, { owner: r, repo: n, issue_number: o });
  return s.repository.issue.closedByPullRequestsReferences.edges.map((e) => e.node);
}
async function getAssigneesActivityForIssue(e, t, r) {
  const n = parseIssueUrl(t.html_url);
  const o = await e.octokit.paginate(e.octokit.rest.issues.listEventsForTimeline, {
    owner: n.owner,
    repo: n.repo,
    issue_number: n.issue_number,
    per_page: 100,
  });
  const s = await collectLinkedPullRequests(e, n);
  for (const t of s) {
    const { owner: r, repo: n, issue_number: s } = parseIssueUrl(t.url || "");
    const i = await e.octokit.paginate(e.octokit.rest.issues.listEventsForTimeline, { owner: r, repo: n, issue_number: s, per_page: 100 });
    o.push(...i);
  }
  return filterEvents(o, r);
}
function filterEvents(e, t) {
  const r = new Map();
  let n = [];
  for (const o of e) {
    let e = null;
    let s = null;
    let i = null;
    let a = o.event;
    if ("actor" in o && o.actor) {
      s = o.actor.login.toLowerCase();
      if (!r.has(s)) {
        r.set(s, o.actor.id);
      }
      e = r.get(s);
      i = o.created_at;
    } else if (o.event === "committed") {
      const e = "author" in o ? o.author : null;
      const t = "committer" in o ? o.committer : null;
      if (e || t) {
        n.push({ event: a, created_at: i });
        continue;
      }
    }
    if (e && t.includes(e)) {
      n.push({ event: a, created_at: i });
    }
  }
  return n.sort((e, t) => {
    if (!e.created_at || !t.created_at) {
      return 0;
    }
    return DateTime.fromISO(t.created_at).toMillis() - DateTime.fromISO(e.created_at).toMillis();
  });
}
async function getDeadlineWithThreshold(e, t, r) {
  const {
    logger: n,
    config: { disqualification: o, warning: s, eventWhitelist: i },
  } = e;
  const a = r.assignees?.map((e) => e.id) || [];
  if (a.length && t.taskAssignees?.some((e) => !a.includes(e))) {
    n.info(`Assignees mismatch found for ${r.html_url}`, { metadata: t, assigneeIds: a });
  }
  const A = DateTime.fromISO(t.startPlusLabelDuration || r.created_at);
  if (!A.isValid) {
    n.error(`Invalid deadline date found on ${r.html_url}`);
    return false;
  }
  const c = (await getAssigneesActivityForIssue(e, r, a)).filter((e) => {
    if (!e.created_at) {
      return false;
    }
    return DateTime.fromISO(e.created_at) >= A;
  });
  const u = c.filter((e) => {
    if (!e.event) {
      return false;
    }
    return i.includes(e.event);
  });
  let l = A.plus({ milliseconds: o });
  let p = A.plus({ milliseconds: s });
  if (u?.length) {
    const e = u[0].created_at ? DateTime.fromISO(u[0].created_at) : A;
    if (!e.isValid) {
      n.error(`Invalid date found on last activity for ${r.html_url}`);
      return false;
    }
    l = e.plus({ milliseconds: o });
    p = e.plus({ milliseconds: s });
  }
  return { deadlineWithThreshold: l, reminderWithThreshold: p };
}
async function getTaskAssignmentDetails(e, t, r) {
  const { logger: n, octokit: o } = e;
  const s = await o.paginate(o.rest.issues.listEvents, { owner: t.owner.login, repo: t.name, issue_number: r.number });
  const i = s.filter((e) => e.event === "assigned").sort((e, t) => DateTime.fromISO(t.created_at).toMillis() - DateTime.fromISO(e.created_at).toMillis());
  const a = i.find((e) => e.actor?.type === "User");
  const A = i.find((e) => e.actor?.type === "Bot");
  let c = a || A;
  if (a && A && DateTime.fromISO(a.created_at) > DateTime.fromISO(A.created_at)) {
    c = a;
  } else {
    c = A;
  }
  const u = {
    startPlusLabelDuration: DateTime.fromISO(r.created_at).toISO() || "",
    taskAssignees: r.assignees ? r.assignees.map((e) => e.id) : r.assignee ? [r.assignee.id] : [],
  };
  if (!u.taskAssignees?.length) {
    n.error(`Missing Assignees from ${r.html_url}`);
    return false;
  }
  const l = parseTimeLabel(r.labels);
  if (l === 0) {
  } else if (l < 0 || !l) {
    n.error(`Invalid deadline found on ${r.html_url}`);
    return false;
  }
  u.startPlusLabelDuration =
    DateTime.fromISO(c?.created_at || r.created_at)
      .plus({ milliseconds: l })
      .toISO() || "";
  return u;
}
function parseTimeLabel(e) {
  let t = 0;
  for (const r of e) {
    let e = "";
    if (typeof r === "string") {
      e = r;
    } else {
      e = r.name || "";
    }
    if (e.startsWith("Time:")) {
      const r = e.match(/Time: <(\d+) (\w+)/i);
      if (!r) {
        return 0;
      }
      const [n, o, s] = r;
      t = W()(`${o} ${s}`);
    }
    if (t) {
      break;
    }
  }
  return t;
}
async function updateTaskReminder(e, t, r) {
  const { logger: n } = e;
  let o, s;
  const i = DateTime.now();
  const a = await getTaskAssignmentDetails(e, t, r);
  if (a) {
    const t = await getDeadlineWithThreshold(e, a, r);
    if (t) {
      o = t.deadlineWithThreshold;
      s = t.reminderWithThreshold;
      n.info(`Handling metadata and deadline for ${r.html_url}`, {
        initialDeadline: DateTime.fromISO(a.startPlusLabelDuration).toLocaleString(DateTime.DATETIME_MED),
        now: i.toLocaleString(DateTime.DATETIME_MED),
        reminderWithThreshold: s.toLocaleString(DateTime.DATETIME_MED),
        deadlineWithThreshold: o.toLocaleString(DateTime.DATETIME_MED),
      });
    }
  }
  if (!o || !s) {
    n.error(`Failed to handle metadata or deadline for ${r.html_url}`);
    return false;
  }
  if (i >= o) {
    await unassignUserFromIssue(e, r);
  } else if (i >= s) {
    await remindAssigneesForIssue(e, r);
  } else {
    n.info(`Nothing to do for ${r.html_url}, still within due-time.`);
  }
}
async function watchUserActivity(e) {
  const { logger: t } = e;
  const r = await getWatchedRepos(e);
  if (!r?.length) {
    t.info("No watched repos have been found, no work to do.");
    return false;
  }
  for (const t of r) {
    await updateReminders(e, t);
  }
  return true;
}
async function updateReminders(e, t) {
  const { logger: r, octokit: n, payload: o } = e;
  const s = o.repository.owner?.login;
  if (!s) {
    throw new Error("No owner found in the payload");
  }
  const i = await n.paginate(n.rest.issues.listForRepo, { owner: s, repo: t.name, per_page: 100, state: "open" });
  for (const n of i) {
    if (n.draft || n.pull_request || n.locked || n.state !== "open") {
      continue;
    }
    if (n.assignees?.length || n.assignee) {
      r.debug(`Checking assigned issue: ${n.html_url}`);
      await updateTaskReminder(e, t, n);
    }
  }
}
async function run(e) {
  const t = new A.Octokit({ auth: e.authToken });
  const r = { eventName: e.eventName, payload: e.eventPayload, config: e.settings, octokit: t, logger: new le("verbose") };
  r.logger.debug("Will run with the following configuration:", { configuration: r.config });
  await runPlugin(r);
  return returnDataToKernel(process.env.GITHUB_TOKEN, e.stateId, {});
}
async function runPlugin(e) {
  return await watchUserActivity(e);
}
run(ie)
  .then((e) => s?.setOutput("result", e))
  .catch((e) => {
    console.error("Failed to run user-activity-watcher:", e);
    s?.setFailed(e.toString());
  });
